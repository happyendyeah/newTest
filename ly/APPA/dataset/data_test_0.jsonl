{"text_1": "public class test { final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; if ( inputCharset = = Charsets . UTF_8 ) { options . outputCharset = Charsets . US_ASCII ; } else { options . outputCharset = inputCharset ; } boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; } private String toSource ( Node n , SourceMap sourceMap ) { builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; } } \\ No newline at end of file", "text_2": "public class test { private String getOutputCharset ( ) throws FlagUsageException { if ( ! config . charset . isEmpty ( ) ) { if ( ! Charset . isSupported ( config . charset ) ) { throw new FlagUsageException ( config . charset + \" is not a valid charset name . \" ) ; } return config . charset ; } return \" US - ASCII \" ; } final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; options . outputCharset = getOutputCharset ( ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { } options . closurePass = flags . process_closure_primitives ; return options ; } private String toSource ( Node n , SourceMap sourceMap ) { builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ! = null ? Charset . forName ( options . outputCharset ) : null ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; } public void setOutputCharset ( String charsetName ) { this . outputCharset = charsetName ; } } \\ No newline at end of file", "label": 1}
{"text_1": "return true ; } if ( getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "text_2": "return true ; } if ( ! isPaxHeader ( ) & & ! isGlobalPaxHeader ( ) & & getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "label": 1}
{"text_1": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } } \\ No newline at end of file", "text_2": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( left , ( Iterator ) right ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } private boolean containsMatch ( Object value , Iterator it ) { while ( it . hasNext ( ) ) { Object element = it . next ( ) ; if ( compute ( value , element ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "text_2": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( value . length ( ) = = 0 ) value = attr . getValue ( ) ; / / if it could not be made abs , run as - is to allow custom unknown protocols if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "label": 1}
{"text_1": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; } return injectionOccurred ; } public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fieldInstance ) ; } } \\ No newline at end of file", "text_2": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , orderedInstanceFields , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; } return injectionOccurred ; } public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , List < Field > fields , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fields , fieldInstance ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public static synchronized FastDateFormat getDateTimeInstance ( int dateStyle , int timeStyle , TimeZone timeZone , Locale locale ) {  Object key = new Pair ( new Integer ( dateStyle ) , new Integer ( timeStyle ) ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; } } return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; }  if ( locale ! = null ) { key = new Pair ( key , locale ) ; }  FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date pattern for locale : \" + locale ) ; } } return format ;", "text_2": "public class test { public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; }  if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ;  FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date pattern for locale : \" + locale ) ; } } return format ; } public static synchronized FastDateFormat getDateTimeInstance ( int dateStyle , int timeStyle , TimeZone timeZone , Locale locale ) {  Object key = new Pair ( new Integer ( dateStyle ) , new Integer ( timeStyle ) ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; } } return format ;", "label": 1}
{"text_1": "public class test { } \\ No newline at end of file", "text_2": "public class test { String appropriateEndTagName ( ) { return lastStartTag . tagName ; } } \\ No newline at end of file", "label": 1}
{"text_1": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "text_2": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "label": 1}
{"text_1": "return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "text_2": "return binaryData ; } long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "label": 1}
{"text_1": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . getIgnored ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "text_2": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . findIgnoredForDeserialization ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "label": 1}
{"text_1": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly } } \\ No newline at end of file", "text_2": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "text_2": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1}
{"text_1": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , buffer ) ) { ; } else { / / Last creator property to set ?", "text_2": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { ; } else { / / Last creator property to set ?", "label": 1}
{"text_1": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "text_2": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1}
{"text_1": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order for ( ZipArchiveEntry ze : entries . keySet ( ) ) { OffsetEntry offsetEntry = entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } } } } \\ No newline at end of file", "text_2": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order Map < ZipArchiveEntry , OffsetEntry > origMap = new LinkedHashMap < ZipArchiveEntry , OffsetEntry > ( entries ) ; entries . clear ( ) ; for ( ZipArchiveEntry ze : origMap . keySet ( ) ) { OffsetEntry offsetEntry = origMap . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } entries . put ( ze , offsetEntry ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { return _createEnumKeyDeserializer ( ctxt , type ) ; } deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } / / and then post - processing if ( deser ! = null ) {", "text_2": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { deser = _createEnumKeyDeserializer ( ctxt , type ) ; } else { deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } } / / and then post - processing if ( deser ! = null ) {", "label": 1}
{"text_1": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "text_2": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "label": 1}
{"text_1": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else if ( stopAtNonOption ) { processNonOptionToken ( token ) ; } else { tokens . add ( token ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { Option currentOption ; for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) ) ; break ; } else } } } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }   tokens . add ( token ) ; } private void processNonOptionToken ( String value ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; }", "text_2": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token , stopAtNonOption ) ; } else { currentOption = options . getOption ( opt ) ; tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }  if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; }  tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break ; } else } } } private void processNonOptionToken ( String value , boolean stopAtNonOption ) { if ( stopAtNonOption & & ( currentOption = = null | | ! currentOption . hasArg ( ) ) ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; } tokens . add ( value ) ; }", "label": 1}
{"text_1": "public class test { private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Node fnParam = NodeUtil . getFunctionParameters ( fnNode ) . getFirstChild ( ) ; while ( cArg ! = null | | fnParam ! = null ) { if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) { return CanInlineResult . NO ; } } fnParam = fnParam . getNext ( ) ; } / / Limit the inlining if ( cArg ! = null ) { if ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) { return CanInlineResult . NO ; } cArg = cArg . getNext ( ) ; } } } if ( mode = = InliningMode . DIRECT ) { return canInlineReferenceDirectly ( callNode , fnNode ) ; } else { return canInlineReferenceAsStatementBlock ( t , callNode , fnNode , needAliases ) ;", "text_2": "public class test { private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode , Set < String > namesToAlias ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Map < String , Node > args = FunctionArgumentInjector . getFunctionCallParameterMap ( fnNode , callNode , this . throwawayNameSupplier ) ; boolean hasArgs = ! args . isEmpty ( ) ; if ( hasArgs ) { / / Limit the inlining Set < String > allNamesToAlias = Sets . newHashSet ( namesToAlias ) ; FunctionArgumentInjector . maybeAddTempsForCallArguments ( fnNode , args , allNamesToAlias , compiler . getCodingConvention ( ) ) ; if ( ! allNamesToAlias . isEmpty ( ) ) { return CanInlineResult . NO ; } } } if ( mode = = InliningMode . DIRECT ) { return canInlineReferenceDirectly ( callNode , fnNode , needAliases ) ; } else { return canInlineReferenceAsStatementBlock ( t , callNode , fnNode , needAliases ) ;", "label": 1}
{"text_1": "public class test { private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; } } \\ No newline at end of file", "text_2": "public class test { private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "text_2": "public class test { public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1}
{"text_1": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "text_2": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; if ( key . matches ( \" [ a - zA - Z_ : ] { 1 } [ - a - zA - Z0 - 9_ : . ] * \" ) ) el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "label": 1}
{"text_1": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Integer . parseInt ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Integer . parseInt ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "text_2": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Long . parseLong ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Long . parseLong ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "label": 1}
{"text_1": "public class test { public Object callRealMethod ( ) throws Throwable { return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "text_2": "public class test { public Object callRealMethod ( ) throws Throwable { if ( this . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { new Reporter ( ) . cannotCallRealMethodOnInterface ( ) ; } return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "text_2": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } / / else , we couldn ' t parse it as a decl , so leave as a comment } } insertNode ( insert ) ;", "label": 1}
{"text_1": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "text_2": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length & & last < = length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "label": 1}
{"text_1": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "text_2": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ;", "text_2": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } } static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ;", "label": 1}
{"text_1": "} else { tokens . add ( \" - \" + ch ) ; } } }", "text_2": "} else { tokens . add ( token ) ; break ; } } }", "label": 1}
{"text_1": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( token ) ; } } } \\ No newline at end of file", "text_2": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; }  tokens . add ( token ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "text_2": "public class test { private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "label": 1}
{"text_1": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "text_2": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1}
{"text_1": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "text_2": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments & & _currentSegment ! = null ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "label": 1}
{"text_1": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; if ( value instanceof Date ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else { str = value . toString ( ) ; }", "text_2": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; Class < ? > cls = value . getClass ( ) ; if ( cls = = String . class ) { str = ( String ) value ; } else if ( Date . class . isAssignableFrom ( cls ) ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else if ( cls = = Class . class ) { str = ( ( Class < ? > ) value ) . getName ( ) ; } else { str = value . toString ( ) ; }", "label": 1}
{"text_1": "public class test { public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; } } \\ No newline at end of file", "text_2": "public class test { public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; } } \\ No newline at end of file", "label": 1}
{"text_1": "", "text_2": "", "label": 1}
{"text_1": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "text_2": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1}
{"text_1": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "text_2": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_IS_GETTERS ) ) { vchecker = vchecker . withIsGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "label": 1}
{"text_1": "df . setTimeZone ( tz ) ; } } return df ; } } \\ No newline at end of file", "text_2": "df . setTimeZone ( tz ) ; } } if ( lenient ! = null ) { df . setLenient ( lenient . booleanValue ( ) ) ; } return df ; } public void setLenient ( boolean enabled ) { Boolean newValue = enabled ; if ( _lenient ! = newValue ) { _lenient = newValue ; _clearFormats ( ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "return offsetLocal ; } } } return offsetAdjusted ; }", "text_2": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "label": 1}
{"text_1": "public class test { public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "text_2": "public class test { public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1}
{"text_1": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "text_2": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; } public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "label": 1}
{"text_1": "return ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "text_2": "return ( _valueDeserializer = = null ) & & ( _keyDeserializer = = null ) & & ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "text_2": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1}
{"text_1": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; } } \\ No newline at end of file", "text_2": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "text_2": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1}
{"text_1": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_2": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1}
{"text_1": "public class test { private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \\ No newline at end of file", "text_2": "public class test { private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : byte [ ] data = n . binaryValue ( ) ; if ( data ! = null ) { return data ; } if ( n . isPojo ( ) ) { Object ob = ( ( POJONode ) n ) . getPojo ( ) ; if ( ob instanceof byte [ ] ) { return ( byte [ ] ) ob ; } } } / / otherwise return null to mark we have no binary content return null ;", "text_2": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : if ( n instanceof TextNode ) { return ( ( TextNode ) n ) . getBinaryValue ( b64variant ) ; } return n . binaryValue ( ) ; } / / otherwise return null to mark we have no binary content return null ;", "label": 1}
{"text_1": "public class test { public DefaultPrettyPrinter createInstance ( ) { return new DefaultPrettyPrinter ( this ) ; } } \\ No newline at end of file", "text_2": "public class test { public DefaultPrettyPrinter createInstance ( ) { if ( getClass ( ) ! = DefaultPrettyPrinter . class ) { / / since 2 . 10 throw new IllegalStateException ( \" Failed ` createInstance ( ) ` : \" + getClass ( ) . getName ( ) + \" does not override method ; it has to \" ) ; } return new DefaultPrettyPrinter ( this ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "} else { char c = value . charAt ( pos ) ; if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "text_2": "} else { char c = value . charAt ( pos ) ; if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "label": 1}
{"text_1": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext | | l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext | | r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "text_2": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext ) { ( ( EvalContext ) l ) . reset ( ) ; }  if ( l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext ) { ( ( EvalContext ) r ) . reset ( ) ; }  if ( r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "label": 1}
{"text_1": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : return new TypePair ( null , null ) ; case FALSE : case UNKNOWN :", "text_2": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : JSType noType = getNativeType ( JSTypeNative . NO_TYPE ) ; return new TypePair ( noType , noType ) ; case FALSE : case UNKNOWN :", "label": 1}
{"text_1": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "text_2": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1}
{"text_1": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , errorList , treeBuilder . defaultSettings ( ) ) ; } public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( \" \" ) ; Document dirty = Document . createShell ( \" \" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , \" \" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & errorList . size ( ) = = 0 ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & dirtyDocument . head ( ) . childNodes ( ) . size ( ) = = 0 ; / / because we only look at the body , but we start from a shell , make sure there ' s nothing in the head } } \\ No newline at end of file", "label": 1}
{"text_1": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; }", "text_2": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } if ( buffer [ start ] = = 0 ) { return 0L ; }", "label": 1}
{"text_1": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > doc . outputSettings ( ) . charset ( charsetName ) ; } return doc ; } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( getWholeDeclaration ( ) ) . append ( \" > \" ) ; } public String getWholeDeclaration ( ) { final String decl = this . name ; if ( decl . equals ( \" xml \" ) & & attributes . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( decl ) ; final String version = attributes . get ( \" version \" ) ; if ( version ! = null ) { sb . append ( \" version = \\ \" \" ) . append ( version ) . append ( \" \\ \" \" ) ; } final String encoding = attributes . get ( \" encoding \" ) ; if ( encoding ! = null ) { sb . append ( \" encoding = \\ \" \" ) . append ( encoding ) . append ( \" \\ \" \" ) ; } return sb . toString ( ) ; } else { return this . name ; } } void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "text_2": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > doc . outputSettings ( ) . charset ( charsetName ) ; } return doc ; } public String getWholeDeclaration ( ) { return attributes . html ( ) . trim ( ) ; / / attr html starts with a \" \" } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( name ) ; attributes . html ( accum , out ) ; accum . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( \" > \" ) ; } void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "label": 1}
{"text_1": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "text_2": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1}
{"text_1": "", "text_2": "", "label": 1}
{"text_1": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { return new JarArchiveOutputStream ( out ) ; } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { return new ArjArchiveInputStream ( in ) ; } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; } public CpioArchiveInputStream ( final InputStream in , int blockSize , String encoding ) { this . in = in ; this . blockSize = blockSize ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } public CpioArchiveOutputStream ( final OutputStream out , final short format , } this . entryFormat = format ; this . blockSize = blockSize ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } public DumpArchiveInputStream ( InputStream is , String encoding ) throws ArchiveException { this . raw = new TapeInputStream ( is ) ; this . hasHitEOF = false ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; try { String encoding ) { this . is = is ; this . hasHitEOF = false ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ; public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "text_2": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new JarArchiveOutputStream ( out , entryEncoding ) ; } else { return new JarArchiveOutputStream ( out ) ; } } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { if ( entryEncoding ! = null ) { return new ArjArchiveInputStream ( in , entryEncoding ) ; } else { return new ArjArchiveInputStream ( in ) ; } } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; } public CpioArchiveInputStream ( final InputStream in , int blockSize , String encoding ) { this . in = in ; this . blockSize = blockSize ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } public CpioArchiveOutputStream ( final OutputStream out , final short format , } this . entryFormat = format ; this . blockSize = blockSize ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } public DumpArchiveInputStream ( InputStream is , String encoding ) throws ArchiveException { this . raw = new TapeInputStream ( is ) ; this . hasHitEOF = false ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; try { String encoding ) { this . is = is ; this . hasHitEOF = false ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ; public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ; String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { this . encoding = encoding ; zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "label": 1}
{"text_1": "public class test { protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } public ClassLoaderAwareObjectInputStream ( InputStream in , ClassLoader classLoader ) throws IOException { super ( in ) ; this . classLoader = classLoader ;  } } \\ No newline at end of file", "text_2": "public class test { public ClassLoaderAwareObjectInputStream ( InputStream in , ClassLoader classLoader ) throws IOException { super ( in ) ; this . classLoader = classLoader ;  primitiveTypes . put ( \" byte \" , byte . class ) ; primitiveTypes . put ( \" short \" , short . class ) ; primitiveTypes . put ( \" int \" , int . class ) ; primitiveTypes . put ( \" long \" , long . class ) ; primitiveTypes . put ( \" float \" , float . class ) ; primitiveTypes . put ( \" double \" , double . class ) ; primitiveTypes . put ( \" boolean \" , boolean . class ) ; primitiveTypes . put ( \" char \" , char . class ) ; primitiveTypes . put ( \" void \" , void . class ) ; } protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { try { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } catch ( ClassNotFoundException cnfe ) { Class < ? > cls = primitiveTypes . get ( name ) ; if ( cls ! = null ) return cls ; else throw cnfe ; } } } } \\ No newline at end of file", "label": 1}
{"text_1": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "text_2": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "label": 1}
{"text_1": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "text_2": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1}
{"text_1": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos = = - 1 ) {", "text_2": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; if ( pos = = - 1 ) {", "label": 1}
{"text_1": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "text_2": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1}
{"text_1": "} } return reportGenericTypeSyntaxWarning ( ) ; } private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } } break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } }", "text_2": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } } break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } }", "label": 1}
{"text_1": "if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } } return null ; }", "text_2": "if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } if ( rawType = = Void . class ) { return NullifyingDeserializer . instance ; } } return null ; }", "label": 1}
{"text_1": "public class test { public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; } } \\ No newline at end of file", "text_2": "public class test { public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . ISO_8859_1 ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : return _unknownType ( ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name ) ; if ( actualType ! = null ) { return actualType ; }", "text_2": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : context = new TypeBindings ( this , ( Class < ? > ) null ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name , false ) ; if ( actualType ! = null ) { return actualType ; }", "label": 1}
{"text_1": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } } \\ No newline at end of file", "text_2": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "text_2": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "label": 1}
{"text_1": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } } \\ No newline at end of file", "text_2": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ;  Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }  return getMock ( invocation , returnTypeGenericMetadata ) ; } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "", "text_2": "", "label": 1}
{"text_1": "public class test { static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } } \\ No newline at end of file", "text_2": "public class test { static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "text_2": "public class test { static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1}
{"text_1": "public class test { Assign ( Node assignNode , Node nameNode , boolean isPropertyAssign ) { Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ; this . assignNode = assignNode ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ;  this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | | NodeUtil . mayHaveSideEffects ( assignNode . getLastChild ( ) ) ; } private void interpretAssigns ( ) { boolean changes = false ; do { assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; } } while ( changes ) ; } } \\ No newline at end of file", "text_2": "public class test { private void interpretAssigns ( ) { boolean changes = false ; do { assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; } } while ( changes ) ; } Assign ( Node assignNode , Node nameNode , boolean isPropertyAssign ) { Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ; this . assignNode = assignNode ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ;  this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | | NodeUtil . mayHaveSideEffects ( assignNode . getLastChild ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { protected boolean processStartTag ( String name ) { return process ( start . reset ( ) . name ( name ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected boolean processStartTag ( String name ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . nameAttr ( name , attrs ) ) ; } start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { if ( currentToken = = end ) { / / don ' t recycle an in - use token return process ( new Token . EndTag ( ) . name ( name ) ) ; } return process ( end . reset ( ) . name ( name ) ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; out . append ( recordSeparator ) ; newRecord = true ; } } \\ No newline at end of file", "text_2": "public class test { public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; if ( recordSeparator ! = null ) { out . append ( recordSeparator ) ; } newRecord = true ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; diagnosticGroups . setWarningLevels ( options , config . jscompError , CheckLevel . ERROR ) ; diagnosticGroups . setWarningLevels ( options , config . jscompWarning , CheckLevel . WARNING ) ; diagnosticGroups . setWarningLevels ( options , config . jscompOff , CheckLevel . OFF ) ; createDefineOrTweakReplacements ( config . define , options , false ) ; options . acceptConstKeyword = config . acceptConstKeyword ; } CommandLineConfig setJscompError ( List < String > jscompError ) { this . jscompError . clear ( ) ; this . jscompError . addAll ( jscompError ) ; return this ; } CommandLineConfig setJscompWarning ( List < String > jscompWarning ) { this . jscompWarning . clear ( ) ; this . jscompWarning . addAll ( jscompWarning ) ; return this ; } CommandLineConfig setJscompOff ( List < String > jscompOff ) { this . jscompOff . clear ( ) ; this . jscompOff . addAll ( jscompOff ) ; return this ; } private void initConfigFromFlags ( String [ ] args , PrintStream err ) { List < String > processedArgs = processArgs ( args ) ; CmdLineParser parser = new CmdLineParser ( flags ) ; isConfigValid = true ; try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; . setModuleWrapper ( flags . module_wrapper ) . setModuleOutputPathPrefix ( flags . module_output_path_prefix ) . setCreateSourceMap ( flags . create_source_map ) . setJscompError ( flags . jscomp_error ) . setJscompWarning ( flags . jscomp_warning ) . setJscompOff ( flags . jscomp_off ) . setDefine ( flags . define ) . setCharset ( flags . charset ) . setManageClosureDependencies ( flags . manage_closure_dependencies ) List < String > processedFileArgs = processArgs ( argsInFile . toArray ( new String [ ] { } ) ) ; CmdLineParser parserFileArgs = new CmdLineParser ( flags ) ; parserFileArgs . parseArgument ( processedFileArgs . toArray ( new String [ ] { } ) ) ; / / Currently we are not supporting this ( prevent direct / indirect loops ) isConfigValid = false ; } } void setWarningLevels ( CompilerOptions options , List < String > diagnosticGroups , CheckLevel level ) { for ( String name : diagnosticGroups ) { DiagnosticGroup group = forName ( name ) ; Preconditions . checkNotNull ( group , \" No warning class for name : \" + name ) ; options . setWarningLevel ( group , level ) ; } } } \\ No newline at end of file", "text_2": "public class test { protected void clear ( ) { entries . clear ( ) ; } CommandLineConfig setWarningGuardSpec ( WarningGuardSpec spec ) { this . warningGuards = spec ; return this ; } protected void add ( CheckLevel level , String groupName ) { entries . add ( new Entry ( level , groupName ) ) ; } final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; if ( config . warningGuards ! = null ) { for ( WarningGuardSpec . Entry entry : config . warningGuards . entries ) { diagnosticGroups . setWarningLevel ( options , entry . groupName , entry . level ) ; } } createDefineOrTweakReplacements ( config . define , options , false ) ; options . acceptConstKeyword = config . acceptConstKeyword ; } @ Override public void addValue ( Object value ) throws CmdLineException { proxy . addValue ( ( String ) value ) ; warningGuardSpec . add ( level , ( String ) value ) ; } @ Override public boolean isMultiValued ( ) { return proxy . isMultiValued ( ) ; } @ Override public Class getType ( ) { return proxy . getType ( ) ; } private void initConfigFromFlags ( String [ ] args , PrintStream err ) { List < String > processedArgs = processArgs ( args ) ; CmdLineParser parser = new CmdLineParser ( flags ) ; Flags . warningGuardSpec . clear ( ) ; isConfigValid = true ; try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; . setModuleWrapper ( flags . module_wrapper ) . setModuleOutputPathPrefix ( flags . module_output_path_prefix ) . setCreateSourceMap ( flags . create_source_map ) . setWarningGuardSpec ( Flags . warningGuardSpec ) . setDefine ( flags . define ) . setCharset ( flags . charset ) . setManageClosureDependencies ( flags . manage_closure_dependencies ) List < String > processedFileArgs = processArgs ( argsInFile . toArray ( new String [ ] { } ) ) ; CmdLineParser parserFileArgs = new CmdLineParser ( flags ) ; Flags . warningGuardSpec . clear ( ) ; parserFileArgs . parseArgument ( processedFileArgs . toArray ( new String [ ] { } ) ) ; / / Currently we are not supporting this ( prevent direct / indirect loops ) isConfigValid = false ; } } void setWarningLevel ( CompilerOptions options , String name , CheckLevel level ) { DiagnosticGroup group = forName ( name ) ; Preconditions . checkNotNull ( group , \" No warning class for name : \" + name ) ; options . setWarningLevel ( group , level ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { } \\ No newline at end of file", "text_2": "public class test { public String findEnumValue ( Enum < ? > value ) { try { Field f = value . getClass ( ) . getField ( value . name ( ) ) ; if ( f ! = null ) { JsonProperty prop = f . getAnnotation ( JsonProperty . class ) ; String n = prop . value ( ) ; if ( n ! = null & & ! n . isEmpty ( ) ) { return n ; } } } catch ( Exception e ) { } return value . name ( ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public static double sinh ( double x ) { boolean negate = false ; if ( x ! = x ) { / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) { return result ; } public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } } \\ No newline at end of file", "text_2": "public class test { public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } public static double sinh ( double x ) { boolean negate = false ; if ( x ! = x ) { / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) { return result ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "text_2": "public class test { public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( last . getType ( ) = = type & & NodeUtil . isAssociative ( type ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; default : return node ; / / Nothing changed } } } \\ No newline at end of file", "text_2": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; case Token . MUL : case Token . AND : case Token . OR : case Token . BITOR : case Token . BITXOR : case Token . BITAND : return tryRotateAssociativeOperator ( node ) ; default : return node ; / / Nothing changed } } private Node tryRotateAssociativeOperator ( Node n ) { if ( ! late ) { return n ; } Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getType ( ) ) ) ; Node rhs = n . getLastChild ( ) ; if ( n . getType ( ) = = rhs . getType ( ) ) { Node parent = n . getParent ( ) ; Node first = n . getFirstChild ( ) . detachFromParent ( ) ; Node second = rhs . getFirstChild ( ) . detachFromParent ( ) ; Node third = rhs . getLastChild ( ) . detachFromParent ( ) ; Node newLhs = new Node ( n . getType ( ) , first , second ) . copyInformationFrom ( n ) ; Node newRoot = new Node ( rhs . getType ( ) , newLhs , third ) . copyInformationFrom ( rhs ) ; parent . replaceChild ( n , newRoot ) ; reportCodeChange ( ) ; return newRoot ; } return n ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ) { return _initStartElement ( ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _textValue = text ; return ( _currentState = XML_TEXT ) ; } return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "text_2": "public class test { protected boolean _allWs ( String str ) { final int len = ( str = = null ) ? 0 : str . length ( ) ; if ( len > 0 ) { for ( int i = 0 ; i < len ; + + i ) { if ( str . charAt ( i ) > ' ' ) { return false ; } } } return true ; } private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; final boolean startElementNext = _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( startElementNext ) { if ( text = = null | | _allWs ( text ) ) { _mixedText = false ; return _initStartElement ( ) ; } _mixedText = true ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _mixedText = false ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } _mixedText = false ; return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements if ( _mixedText ) { _mixedText = false ; return _initStartElement ( ) ; } / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "label": 1}
{"text_1": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . mixIns . add ( _constructMethod ( m ) ) ; } } }", "text_2": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . am = mixIns . find ( m ) ; if ( am ! = null ) { _addMixUnders ( m , am ) ; } else { mixIns . add ( _constructMethod ( m ) ) ; } } } }", "label": 1}
{"text_1": "public class test { String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "text_2": "public class test { String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1}
{"text_1": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "text_2": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1}
{"text_1": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "text_2": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "label": 1}
{"text_1": "ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "text_2": "ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { / / mode is initialised to 0 ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "label": 1}
{"text_1": "public class test { public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash > > > 12 ) ; return hash ; } private int _findOffsetForAdd ( int hash ) { / / first , check the primary : if ( _spilloverEnd > = hashArea . length ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } } \\ No newline at end of file", "text_2": "public class test { private int _findOffsetForAdd ( int hash ) { / / first , check the primary : final int end = ( _hashSize < < 3 ) ; if ( _spilloverEnd > = end ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash < < 3 ) ; / / shuffle back a bit hash + = ( hash > > > 12 ) ; / / and bit more return hash ; } } \\ No newline at end of file", "label": 1}
{"text_1": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "text_2": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "label": 1}
{"text_1": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { return attr . getValue ( ) ; } } aNode = aNode . getParentNode ( ) ; } return null ; } return uri ; } } \\ No newline at end of file", "text_2": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { uri = attr . getValue ( ) ; break ; } } aNode = aNode . getParentNode ( ) ; } } return \" \" . equals ( uri ) ? null : uri ; } } \\ No newline at end of file", "label": 1}
{"text_1": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "text_2": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "label": 1}
{"text_1": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "text_2": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1}
{"text_1": "public class test { private String normalizeSourceName ( String filename ) {  if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; }  return filename ; } private void visitScript ( NodeTraversal t , Node script ) { Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) { compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "text_2": "public class test { private void visitScript ( NodeTraversal t , Node script ) { Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) { compiler . reportCodeChange ( ) ; } private String normalizeSourceName ( String filename ) { filename = filename . replace ( \" \\ \\ \" , \" / \" ) ;  if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; }  return filename ; } } \\ No newline at end of file", "label": 1}
{"text_1": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "text_2": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1}
{"text_1": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } } \\ No newline at end of file", "text_2": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private String consumeSubQuery ( ) { StringBuilder sq = new StringBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( \" ( \" ) ) sq . append ( \" ( \" ) . append ( tq . chompBalanced ( ' ( ' , ' ) ' ) ) . append ( \" ) \" ) ; else if ( tq . matches ( \" [ \" ) ) sq . append ( \" [ \" ) . append ( tq . chompBalanced ( ' [ ' , ' ] ' ) ) . append ( \" ] \" ) ; else if ( tq . matchesAny ( combinators ) ) break ; else sq . append ( tq . consume ( ) ) ; } return sq . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public static < T > T spy ( T object ) { return MOCKITO_CORE . mock ( ( Class < T > ) object . getClass ( ) , withSettings ( ) . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) ) ; } public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; } public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { return mock ( classToMock , mockSettings ) ; } public < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { mockingProgress . validateState ( ) ; mockingProgress . resetOngoingStubbing ( ) ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; } } \\ No newline at end of file", "text_2": "public static < T > T spy ( T object ) { return MOCKITO_CORE . mock ( ( Class < T > ) object . getClass ( ) , withSettings ( ) . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) , true ) ; } public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; } public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { mockingProgress . validateState ( ) ; if ( shouldResetOngoingStubbing ) { mockingProgress . resetOngoingStubbing ( ) ; } return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { } \\ No newline at end of file", "text_2": "public class test { public JsonGenerator disable ( Feature f ) { super . disable ( f ) ; if ( f = = Feature . QUOTE_FIELD_NAMES ) { _cfgUnqNames = true ; } return this ; } } \\ No newline at end of file", "label": 1}
{"text_1": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src ) , true ) ) ; } } \\ No newline at end of file", "text_2": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) , true ) ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "text_2": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) | | ( defValue . charAt ( 0 ) = = ' \\ \" ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ \" ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) | | exprBody . getType ( ) = = Token . NEW | | exprBody . getType ( ) = = Token . CALL ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "label": 1}
{"text_1": "return ; } attachLiteralTypes ( n ) ; switch ( n . getType ( ) ) { case Token . FUNCTION : if ( parent . getType ( ) = = Token . NAME ) { return ; } defineDeclaredFunction ( n , parent ) ; break ; case Token . CATCH : defineCatch ( n , parent ) ; break ; case Token . VAR : defineVar ( n , parent ) ; break ; } } } \\ No newline at end of file", "text_2": "return ; } super . visit ( t , n , parent ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1}
{"text_1": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "text_2": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1}
{"text_1": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { if ( token . indexOf ( ' = ' ) ! = - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }", "text_2": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { int pos = token . indexOf ( ' = ' ) ; String opt = pos = = - 1 ? token : token . substring ( 0 , pos ) ; / / - - foo  if ( ! options . hasOption ( opt ) & & stopAtNonOption ) { process ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } }", "label": 1}
{"text_1": "public class test { } \\ No newline at end of file", "text_2": "public class test { public T getEmptyValue ( DeserializationContext ctxt ) throws JsonMappingException { if ( _primitive & & ctxt . isEnabled ( DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES ) ) { throw ctxt . mappingException ( \" Can not map Empty String as null into type % s ( set DeserializationConfig . DeserializationFeature . FAIL_ON_NULL_FOR_PRIMITIVES to ' false ' to allow ) \" , handledType ( ) . toString ( ) ) ; } return _nullValue ; } } \\ No newline at end of file", "label": 1}
{"text_1": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately p . skipChildren ( ) ; return null ; } } \\ No newline at end of file", "text_2": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately if ( p . hasToken ( JsonToken . FIELD_NAME ) ) { while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = null ) | | ( t = = JsonToken . END_OBJECT ) ) { break ; } p . skipChildren ( ) ; } } else { p . skipChildren ( ) ; } return null ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } } \\ No newline at end of file", "text_2": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } } \\ No newline at end of file", "label": 1}
{"text_1": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "text_2": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "label": 1}
{"text_1": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "text_2": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "label": 1}
{"text_1": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { if ( otherComment ! = null ) { return false ; } } else if ( ! myComment . equals ( otherComment ) ) { return false ; } return getTime ( ) = = other . getTime ( ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "text_2": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { myComment = \" \" ; } if ( otherComment = = null ) { otherComment = \" \" ; } return getTime ( ) = = other . getTime ( ) & & myComment . equals ( otherComment ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "label": 1}
{"text_1": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "text_2": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "label": 1}
{"text_1": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; Validate . notEmpty ( name ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "text_2": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "label": 1}
{"text_1": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "text_2": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1}
{"text_1": "public class test { private void handleBlockComment ( Comment comment ) {", "text_2": "public class test { private void handleBlockComment ( Comment comment ) {", "label": 1}
{"text_1": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; }", "text_2": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { if ( value . length ( ) = = 0 ) / / no key , no val ; unknown char , keep popping so not get stuck tq . advance ( ) ; return null ; }", "label": 1}
{"text_1": "public class test { public static < T > T any ( ) { return ( T ) anyObject ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return ( Set ) reportMatcher ( Any . ANY ) . returnSet ( ) ; } public static int anyInt ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return ( Collection ) reportMatcher ( Any . ANY ) . returnList ( ) ; } public static short anyShort ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( Any . ANY ) . returnFor ( clazz ) ; } public static boolean anyBoolean ( ) { return reportMatcher ( Any . ANY ) . returnFalse ( ) ; } public static String anyString ( ) { return reportMatcher ( Any . ANY ) . returnString ( ) ; } public static Map anyMap ( ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static long anyLong ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static byte anyByte ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static List anyList ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static float anyFloat ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return ( List ) reportMatcher ( Any . ANY ) . returnList ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return reportMatcher ( Any . ANY ) . returnMap ( ) ; } public static char anyChar ( ) { return reportMatcher ( Any . ANY ) . returnChar ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static double anyDouble ( ) { return reportMatcher ( Any . ANY ) . returnZero ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( Any . ANY ) . returnList ( ) ; } public static Set anySet ( ) { return reportMatcher ( Any . ANY ) . returnSet ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public static < T > T any ( ) { return ( T ) reportMatcher ( Any . ANY ) . returnNull ( ) ; } public static < T > Set < T > anySetOf ( Class < T > clazz ) { return anySet ( ) ; } public static int anyInt ( ) { return reportMatcher ( new InstanceOf ( Integer . class ) ) . returnZero ( ) ; } public static < T > Collection < T > anyCollectionOf ( Class < T > clazz ) { return anyCollection ( ) ; } public static short anyShort ( ) { return reportMatcher ( new InstanceOf ( Short . class ) ) . returnZero ( ) ; } public static < T > T any ( Class < T > clazz ) { return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; } public static boolean anyBoolean ( ) { return reportMatcher ( new InstanceOf ( Boolean . class ) ) . returnFalse ( ) ; } public static String anyString ( ) { return reportMatcher ( new InstanceOf ( String . class ) ) . returnString ( ) ; } public static Map anyMap ( ) { return reportMatcher ( new InstanceOf ( Map . class ) ) . returnMap ( ) ; } public static long anyLong ( ) { return reportMatcher ( new InstanceOf ( Long . class ) ) . returnZero ( ) ; } public static byte anyByte ( ) { return reportMatcher ( new InstanceOf ( Byte . class ) ) . returnZero ( ) ; } public static List anyList ( ) { return reportMatcher ( new InstanceOf ( List . class ) ) . returnList ( ) ; } public static float anyFloat ( ) { return reportMatcher ( new InstanceOf ( Float . class ) ) . returnZero ( ) ; } public static < T > List < T > anyListOf ( Class < T > clazz ) { return anyList ( ) ; } public static < K , V > Map < K , V > anyMapOf ( Class < K > keyClazz , Class < V > valueClazz ) { return anyMap ( ) ; } public static char anyChar ( ) { return reportMatcher ( new InstanceOf ( Character . class ) ) . returnChar ( ) ; } public static < T > T anyObject ( ) { return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull ( ) ; } public static double anyDouble ( ) { return reportMatcher ( new InstanceOf ( Double . class ) ) . returnZero ( ) ; } public static Collection anyCollection ( ) { return reportMatcher ( new InstanceOf ( Collection . class ) ) . returnList ( ) ; } public static Set anySet ( ) { return reportMatcher ( new InstanceOf ( Set . class ) ) . returnSet ( ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "text_2": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( object = = null ) { out . append ( value ) ; } else if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "label": 1}
{"text_1": "public class test { public Timer ( long durationMillis ) { this . durationMillis = durationMillis ; } } \\ No newline at end of file", "text_2": "public class test { public Timer ( long durationMillis ) { validateInput ( durationMillis ) ; this . durationMillis = durationMillis ; } private void validateInput ( long durationMillis ) { if ( durationMillis < 0 ) { new Reporter ( ) . cannotCreateTimerWithNegativeDurationTime ( durationMillis ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public boolean hasClass ( String className ) { final String classAttr = attributes . get ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "text_2": "public class test { public boolean hasClass ( String className ) { final String classAttr = attributes . getIgnoreCase ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "label": 1}
{"text_1": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "text_2": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "label": 1}
{"text_1": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "text_2": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "label": 1}
{"text_1": "public class test { public Map < String , Integer > getHeaderMap ( ) { return new LinkedHashMap < String , Integer > ( this . headerMap ) ; } } \\ No newline at end of file", "text_2": "public class test { public Map < String , Integer > getHeaderMap ( ) { return this . headerMap = = null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "text_2": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = o2 ) { return true ; } else if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "label": 1}
{"text_1": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . appendChild ( new TextNode ( \" \" , \" \" ) ) ; body ( ) . appendChild ( node ) ; } } } \\ No newline at end of file", "text_2": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode ( \" \" , \" \" ) ) ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "text_2": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1}
{"text_1": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } final int hi = offs + len ; int destOffs = offs ;", "text_2": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } if ( len = = 0 ) { return 0 ; } final int hi = offs + len ; int destOffs = offs ;", "label": 1}
{"text_1": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "text_2": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1}
{"text_1": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "text_2": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } else if ( p . getCurrentToken ( ) = = JsonToken . VALUE_STRING ) { if ( ctxt . isEnabled ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT ) ) { String str = p . getText ( ) . trim ( ) ; if ( str . isEmpty ( ) ) { return null ; } } } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "label": 1}
{"text_1": "public class test { public JavaType constructType ( Type type , JavaType contextType ) { return _fromAny ( null , type , contextType . getBindings ( ) ) ; } public JavaType constructType ( Type type , Class < ? > contextClass ) { return constructType ( type , constructType ( contextClass ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public JavaType constructType ( Type type , Class < ? > contextClass ) { TypeBindings bindings = ( contextClass = = null ) ? TypeBindings . emptyBindings ( ) : constructType ( contextClass ) . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } public JavaType constructType ( Type type , JavaType contextType ) { TypeBindings bindings = ( contextType = = null ) ? TypeBindings . emptyBindings ( ) : contextType . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; return null ; } } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : } } } } \\ No newline at end of file", "text_2": "public class test { public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default : } } } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; return null ; } } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } } \\ No newline at end of file", "text_2": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify / / otherwise only verify if neither explicitly annotated . } / / one more thing : ok to override in sub - class if ( oldOne . getClass ( ) = = newOne . getClass ( ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] / / otherwise , which one to choose ? / / new type more generic , use old / / new type more specific , use it } }", "text_2": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { boolean verify ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify verify = true ; } else { / / otherwise only verify if neither explicitly annotated . verify = ! explicit ; } / / one more thing : ok to override in sub - class if ( verify & & ( oldOne . getClass ( ) = = newOne . getClass ( ) ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems Class < ? > oldType = oldOne . getRawParameterType ( 0 ) ; Class < ? > newType = newOne . getRawParameterType ( 0 ) ; if ( oldType = = newType ) { throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] \" creators : already had explicitly marked \" + oldOne + \" , encountered \" + newOne ) ; } / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } }", "label": 1}
{"text_1": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; / / but above intended maximum , slow to increase by 25 % int newLen = ( len = = MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + 1 ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > 1 ) ) ; return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; } } \\ No newline at end of file", "text_2": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; int newLen = len + ( len > > 1 ) ; / / but above intended maximum , slow to increase by 25 % if ( newLen > MAX_SEGMENT_LEN ) { newLen = len + ( len > > 2 ) ; } return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( \" \\ \" \" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } int length = str . length ( ) ; if ( str . endsWith ( \" \\ \" \" ) ) { str = str . substring ( 0 , length - 1 ) ; } return str ;", "text_2": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { int length = str . length ( ) ; if ( length > 1 & & str . startsWith ( \" \\ \" \" ) & & str . endsWith ( \" \\ \" \" ) & & str . substring ( 1 , length - 1 ) . indexOf ( ' \" ' ) = = - 1 ) { str = str . substring ( 1 , length - 1 ) ; } return str ;", "label": 1}
{"text_1": "", "text_2": "", "label": 1}
{"text_1": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "text_2": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1}
{"text_1": "public class test { private void tryRemoveUnconditionalBranching ( Node n ) {", "text_2": "public class test { private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private void tryRemoveUnconditionalBranching ( Node n ) {", "label": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } } \\ No newline at end of file", "label": 1}
{"text_1": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "text_2": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace = = null & & tagName . contains ( \" : \" ) ? doc . createElementNS ( \" \" , tagName ) : / / doesn ' t have a real namespace defined doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "label": 1}
{"text_1": "public class test { private int copySafeNodes ( Element root , Element destination ) { List < Node > sourceChildren = root . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node source : sourceChildren ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; } else { numDiscarded + + ; numDiscarded + = copySafeNodes ( sourceEl , destination ) ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } } return numDiscarded ;   } } \\ No newline at end of file", "text_2": "public class test { private int copySafeNodes ( Element source , Element dest ) { CleaningVisitor cleaningVisitor = new CleaningVisitor ( source , dest ) ; NodeTraversor traversor = new NodeTraversor ( cleaningVisitor ) ; traversor . traverse ( source ) ; return cleaningVisitor . numDiscarded ; } public void tail ( Node source , int depth ) { if ( source instanceof Element & & whitelist . isSafeTag ( source . nodeName ( ) ) ) { destination = destination . parent ( ) ; / / would have descended , so pop destination stack } } public void head ( Node source , int depth ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; destination = destChild ; } else if ( source ! = root ) { / / not a safe tag , so don ' t add . don ' t count root against discarded . numDiscarded + + ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } else { / / else , we don ' t care about comments , xml proc instructions , etc numDiscarded + + ; } } private CleaningVisitor ( Element root , Element destination ) { this . root = root ; this . destination = destination ; } } \\ No newline at end of file", "label": 1}
{"text_1": "public class test { private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ;  return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private Object deepStub ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } } \\ No newline at end of file", "text_2": "public class test { private MockSettings propagateSerializationSettings ( MockSettings mockSettings , MockCreationSettings parentMockSettings ) { return mockSettings . serializable ( parentMockSettings . getSerializableMode ( ) ) ; } private Object deepStub ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata , invocation . getMock ( ) ) , container ) ; } private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata , Object parentMock ) { MockCreationSettings parentMockSettings = new MockUtil ( ) . getMockSettings ( parentMock ) ; return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata , parentMockSettings ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata , MockCreationSettings parentMockSettings ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ;  return propagateSerializationSettings ( mockSettings , parentMockSettings ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "text_2": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode if ( docData . charAt ( 0 ) = = 65279 ) docData = docData . substring ( 1 ) ; doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1}
{"text_1": "return pointer ; } else { if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } } \\ No newline at end of file", "text_2": "return pointer ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } private JXPathAbstractFactoryException createBadFactoryException ( AbstractFactory factory ) { return new JXPathAbstractFactoryException ( \" Factory \" + factory + \" reported success creating object for path : \" + asPath ( ) + \" but object was null . Terminating to avoid stack recursion . \" ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "text_2": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1}
{"text_1": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null ) { return scope ; } boolean hasLendsName = n . getJSDocInfo ( ) ! = null & & n . getJSDocInfo ( ) . getLendsName ( ) ! = null ; if ( objectType . hasReferenceName ( ) & & ! hasLendsName ) { return scope ; } } / / Prototype sets are always declared . boolean inferred = true ; if ( info ! = null ) {", "text_2": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null | | n . getBooleanProp ( Node . REFLECTED_OBJECT ) ) { return scope ; } } / / Prototype sets are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { return false ; } boolean inferred = true ; if ( info ! = null ) {", "label": 1}
{"text_1": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } / / augment the list with the default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = ( List ) this . defaultValues . get ( option ) ; } / / if there are more default values as specified , add them to / / the list . / / copy the list first return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "text_2": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( defaultValues = = null | | defaultValues . isEmpty ( ) ) { defaultValues = ( List ) this . defaultValues . get ( option ) ; } / / augment the list with the default values if ( defaultValues ! = null & & ! defaultValues . isEmpty ( ) ) { if ( valueList = = null | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } else { / / if there are more default values as specified , add them to / / the list . if ( defaultValues . size ( ) > valueList . size ( ) ) { / / copy the list first valueList = new ArrayList ( valueList ) ; for ( int i = valueList . size ( ) ; i < defaultValues . size ( ) ; i + + ) { valueList . add ( defaultValues . get ( i ) ) ; } } } } return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "label": 1}
{"text_1": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "text_2": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1}
{"text_1": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "text_2": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1}
{"text_1": "public class test { public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return containsAny ( cs , searchChars . toCharArray ( ) ) ; } public static int indexOfAnyBut ( String str , String searchChars ) { if ( isEmpty ( str ) | | isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; } return INDEX_NOT_FOUND ; } public static boolean containsNone ( CharSequence cs , char [ ] searchChars ) { if ( cs = = null | | searchChars = = null ) { return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { return false ; } } } return true ; } public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { } return false ; } public static int indexOfAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { return i ; } } } return INDEX_NOT_FOUND ; } } \\ No newline at end of file", "text_2": "public class test { public static int indexOfAnyBut ( String str , String searchChars ) { if ( isEmpty ( str ) | | isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; } return INDEX_NOT_FOUND ; } public static int indexOfAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } return INDEX_NOT_FOUND ; } public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { } return false ; } public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return containsAny ( cs , searchChars . toCharArray ( ) ) ; } public static boolean containsNone ( CharSequence cs , char [ ] searchChars ) { if ( cs = = null | | searchChars = = null ) { return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { return false ; } } } } return true ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "text_2": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . if ( ! type . hasGenericTypes ( ) ) { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1}
{"text_1": "return new ZCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { throw new CompressorException ( \" No Compressor found for the stream signature . \" ) ; } } \\ No newline at end of file", "text_2": "return new ZCompressorInputStream ( in ) ; } if ( DeflateCompressorInputStream . matches ( signature , signatureLength ) ) { return new DeflateCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { throw new CompressorException ( \" No Compressor found for the stream signature . \" ) ; } public static boolean matches ( byte [ ] signature , int length ) { return length > 3 & & signature [ 0 ] = = MAGIC_1 & & ( signature [ 1 ] = = ( byte ) MAGIC_2a | | signature [ 1 ] = = ( byte ) MAGIC_2b | | signature [ 1 ] = = ( byte ) MAGIC_2c | | signature [ 1 ] = = ( byte ) MAGIC_2d ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } } \\ No newline at end of file", "text_2": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } } \\ No newline at end of file", "label": 1}
{"text_1": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "text_2": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1}
{"text_1": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return null ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return null ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "text_2": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass , Boolean defaultValue ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return defaultValue ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return defaultValue ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false , _serializeAsIndex ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true , null ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "label": 1}
{"text_1": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "text_2": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1}
{"text_1": "public class test { protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } boolean cachable = ( bindings = = null ) | | bindings . isEmpty ( ) ; if ( cachable ) { result = _typeCache . get ( rawType ) ; if ( result ! = null ) { return result ; } }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ; if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; if ( cachable ) { _typeCache . putIfAbsent ( rawType , result ) ; } return result ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { TypeBindings tb = null ; if ( baseType . containedTypeCount ( ) = = typeParamCount ) { if ( typeParamCount = = 1 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } else if ( typeParamCount = = 2 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } } newType = _fromClass ( null , subclass , ( tb = = null ) ? TypeBindings . emptyBindings ( ) : tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } } \\ No newline at end of file", "text_2": "public class test { public Object asKey ( Class < ? > rawBase ) { return new AsKey ( rawBase , _types , _hashCode ) ; } public int hashCode ( ) { return _hash ; } public boolean equals ( Object o ) { if ( o = = this ) return true ; if ( o = = null ) return false ; if ( o . getClass ( ) ! = getClass ( ) ) return false ; AsKey other = ( AsKey ) o ; if ( ( _hash = = other . _hash ) & & ( _raw = = other . _raw ) ) { final JavaType [ ] otherParams = other . _params ; final int len = _params . length ; if ( len = = otherParams . length ) { for ( int i = 0 ; i < len ; + + i ) { if ( ! _params [ i ] . equals ( otherParams [ i ] ) ) { return false ; } } return true ; } } return false ; } public String toString ( ) { return _raw . getName ( ) + \" < > \" ; } public AsKey ( Class < ? > raw , JavaType [ ] params , int hash ) { _raw = raw ; _params = params ; _hash = hash ; } private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } return TypeBindings . emptyBindings ( ) ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now TypeBindings tb = _bindingsForSubtype ( baseType , typeParamCount , subclass ) ; if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , tb , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , tb , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { newType = _fromClass ( null , subclass , tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } final Object key ; if ( ( bindings = = null ) | | bindings . isEmpty ( ) ) { key = rawType ; result = _typeCache . get ( key ) ; / / ok , cache object is synced } else { key = bindings . asKey ( rawType ) ; } result = _typeCache . get ( key ) ; / / ok , cache object is synced if ( result ! = null ) { return result ; }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; _typeCache . putIfAbsent ( key , result ) ; / / cache object syncs return result ; } } \\ No newline at end of file", "label": 1}
{"text_1": "} break ; } if ( lineLength > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "text_2": "} break ; } if ( lineLength > 0 & & pos > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "label": 1}
{"text_1": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange ( ) ; return newNode ;", "text_2": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { if ( com . google . javascript . jscomp . PeepholeSubstituteAlternateSyntax . this . late ) { parent . replaceChild ( n , newNode ) ; } reportCodeChange ( ) ; return newNode ;", "label": 0}
{"text_1": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "text_2": "return ; } if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; this . valueRange = valueRange ; return res ; } } \\ No newline at end of file", "label": 0}
{"text_1": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "text_2": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } } j - = 4 ; }", "label": 0}
{"text_1": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "text_2": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0}
{"text_1": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "text_2": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0}
{"text_1": "} / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "text_2": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0}
{"text_1": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "text_2": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone .  options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "public class test { public void setShape ( int index , Shape shape ) { set ( index , shape ) ; } } \\ No newline at end of file", "text_2": "public class test { public void setShape ( int index , Shape shape ) { set ( 1 , shape ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; }", "text_2": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; }", "label": 0}
{"text_1": "public class test { public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public double getNumericalMean ( ) { return ( ( double ) ( ( ( getSampleSize ( ) ) * ( getSupportUpperBound ( ) ) ) ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "text_2": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0}
{"text_1": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "text_2": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( data = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0}
{"text_1": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "text_2": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; } }", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "text_2": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0}
{"text_1": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "text_2": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0}
{"text_1": "public class test { public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "text_2": "public class test { public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "text_2": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0}
{"text_1": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; } } \\ No newline at end of file", "text_2": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "text_2": "public class test { public boolean contains ( char ch ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "label": 0}
{"text_1": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "text_2": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"text_1": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "text_2": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = ( new RuleSet ( ) ) . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"text_1": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"text_1": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "text_2": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0}
{"text_1": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "text_2": "public class test { protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "label": 0}
{"text_1": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "text_2": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; buffer = new char [ CAPACITY ] ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0}
{"text_1": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "text_2": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"text_1": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "text_2": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; if ( id . startsWith ( \" + \" ) | | id . startsWith ( \" - \" ) ) { int offset = parseOffset ( id ) ; if ( offset = = 0L ) { return DateTimeZone . UTC ; } else { id = printOffset ( offset ) ; return fixedOffsetZone ( id , offset ) ; } } return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "text_2": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { return createBigDecimal ( str ) ; } else { mant = str ; }", "label": 0}
{"text_1": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "text_2": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0}
{"text_1": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "text_2": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0}
{"text_1": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "text_2": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0}
{"text_1": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "text_2": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0}
{"text_1": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "text_2": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"text_1": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_2": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"text_1": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "text_2": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0}
{"text_1": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "text_2": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "text_2": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < node2 . type ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"text_1": "continue ; } checkDescendantNames ( name , name . globalSets + name . localSets > 0 ) ; } } } \\ No newline at end of file", "text_2": "continue ; } checkDescendantNames ( name , 256 + name . globalSets + name . localSets > 0 ) ; } } } \\ No newline at end of file", "label": 0}
{"text_1": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "text_2": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0}
{"text_1": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "text_2": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0}
{"text_1": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "text_2": "final double previous = values [ index ] ; values [ index ] = missingEntries ; states [ index ] = REMOVED ; return previous ; } } \\ No newline at end of file", "label": 0}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"text_1": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "text_2": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0}
{"text_1": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "text_2": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "text_2": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { buffer = new char [ CAPACITY ] ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"text_1": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "text_2": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0}
{"text_1": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "text_2": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0}
{"text_1": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "text_2": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( System . currentTimeMillis ( ) - d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "label": 0}
{"text_1": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "text_2": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0}
{"text_1": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_2": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0}
{"text_1": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "text_2": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0}
{"text_1": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "text_2": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0}
{"text_1": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { finallyMap . put ( lastJump , null ) ; } } } \\ No newline at end of file", "text_2": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { if ( com . google . javascript . jscomp . ControlFlowAnalysis . this . shouldTraverseFunctions ) { finallyMap . put ( lastJump , null ) ; } } } } \\ No newline at end of file", "label": 0}
{"text_1": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "text_2": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( convergence - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "label": 0}
{"text_1": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else { oldDelta = delta ;", "text_2": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ; } else { oldDelta = delta ;", "label": 0}
{"text_1": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "text_2": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"text_1": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "text_2": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0}
{"text_1": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "text_2": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0}
{"text_1": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "text_2": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"text_1": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "text_2": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0}
{"text_1": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "text_2": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( minRatio , 0 . 0 ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "label": 0}
{"text_1": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "text_2": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"text_1": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { v = u ; fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "text_2": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "label": 0}
{"text_1": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOL | | token = = JsDocToken . EOF ) { return new ExtractionInfo ( \" \" , token ) ; }", "text_2": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( com . google . javascript . jscomp . parsing . JsDocInfoParser . this . unreadToken ! = null ) { return new ExtractionInfo ( \" \" , token ) ; }", "label": 0}
{"text_1": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_2": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( ! parent . hasChildren ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "text_2": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } } } \\ No newline at end of file", "label": 0}
{"text_1": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "text_2": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { return ; }", "label": 0}
{"text_1": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "text_2": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "label": 0}
{"text_1": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_2": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0}
{"text_1": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "text_2": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 0}
{"text_1": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "text_2": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( ( provided ! = null ) | | ( ! ( ns . length ( ) < 10 ) ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; }", "label": 0}
{"text_1": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "text_2": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0}
{"text_1": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset", "text_2": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? PeriodType . HOUR_INDEX : instantBefore ) ; / / calculate result / / currently in later offset", "label": 0}
{"text_1": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "text_2": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0}
{"text_1": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "text_2": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0}
{"text_1": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_2": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"text_1": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "text_2": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0}
{"text_1": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "text_2": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0}
{"text_1": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; } } \\ No newline at end of file", "text_2": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "text_2": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) | | ( ( ( ( numeric . charAt ( 0 ) ) = = ' - ' ) & & ( isDigits ( numeric . substring ( 1 ) ) ) ) | | ( isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"text_1": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "text_2": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0}
{"text_1": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end = ( Calendar ) start . clone ( ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; } } \\ No newline at end of file", "text_2": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . addWrapPartial ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) { result . append ( str . substring ( 0 , upper ) ) ; / / only if abbreviation has occured do we append the appendToEnd value if ( upper ! = str . length ( ) ) {", "text_2": "StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) { if ( str = = null ) { return \" \" ; } if ( appendToEnd = = null ) { return str ; } result . append ( str . substring ( 0 , upper ) ) ; / / only if abbreviation has occured do we append the appendToEnd value if ( upper ! = str . length ( ) ) {", "label": 0}
{"text_1": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "text_2": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0}
{"text_1": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "text_2": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0}
{"text_1": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "text_2": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_2": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0}
{"text_1": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { lower - = 1 ; } }", "label": 0}
{"text_1": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ;", "text_2": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ;", "label": 0}
{"text_1": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "text_2": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . FUNCTION_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"text_1": "public class test { public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"text_1": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "text_2": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "text_2": "final double previous = values [ index ] ; values [ index ] = missingEntries ; keys [ index ] = 0 ; index = changeIndexSign ( index ) ; return previous ; } } \\ No newline at end of file", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"text_1": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "text_2": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1d ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"text_1": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "text_2": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_MAXITERATIONS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; return true ; } return false ;", "label": 0}
{"text_1": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "text_2": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0}
{"text_1": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } } } \\ No newline at end of file", "text_2": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } } } \\ No newline at end of file", "label": 0}
{"text_1": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_2": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0}
{"text_1": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "text_2": "/ / full Brent algorithm starting with provided initial guess return solve ( f , initial , max ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "text_2": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0}
{"text_1": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "text_2": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . leftBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "label": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . minimumRangeValue = Double . NaN ; return result ; } } \\ No newline at end of file", "label": 0}
{"text_1": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_2": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"text_1": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; properties . putAll ( currentProperties ) ; } }", "text_2": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; if ( com . google . javascript . jscomp . TypeCheck . this . unknownCount < com . google . javascript . jscomp . TypeCheck . this . typedCount ) { checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; } properties . putAll ( currentProperties ) ; } }", "label": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"text_1": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "text_2": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "public class test { public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0}
{"text_1": "int i = 0 ; while ( i < maximalIterationCount ) { m = UnivariateRealSolverUtils . midpoint ( min , max ) ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "text_2": "int i = 0 ; while ( i < maximalIterationCount ) { m = UnivariateRealSolverUtils . midpoint ( min , max ) ; if ( f = = null ) return 0 . 0 ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "label": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( sigma < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"text_1": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"text_1": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "text_2": "if ( isResultUsed ) { return ; } if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0}
{"text_1": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "text_2": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0}
{"text_1": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "text_2": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int outIndex = 0 ; minRow = row ; } }", "label": 0}
{"text_1": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "text_2": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkMissingReturn = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0}
{"text_1": "public class test { public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } } \\ No newline at end of file", "text_2": "public class test { private void applyCollapses ( ) { } public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } } \\ No newline at end of file", "label": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tType = - 5 ; return true ; } return false ;", "label": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0}
{"text_1": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "text_2": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 0}
{"text_1": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; } }", "text_2": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { lmPar = FastMath . max ( parl , lmPar + correction ) ; } } }", "label": 0}
{"text_1": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "text_2": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; } } \\ No newline at end of file", "label": 0}
{"text_1": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "text_2": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0}
{"text_1": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "text_2": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : v = - v ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "label": 0}
{"text_1": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "text_2": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"text_1": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "text_2": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0}
{"text_1": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "text_2": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0}
{"text_1": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "text_2": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "label": 0}
{"text_1": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_2": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"text_1": "public class test { public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length ! = dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; }  return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; } } \\ No newline at end of file", "text_2": "public class test { public double density ( double [ ] list ) { double m = Double . NEGATIVE_INFINITY ; for ( double x : list ) m = Math . max ( m , x ) ; return m ; } } \\ No newline at end of file", "label": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } } return out ;", "label": 0}
{"text_1": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "text_2": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) {  } } }", "label": 0}
{"text_1": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "text_2": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0}
{"text_1": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "text_2": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0}
{"text_1": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } }", "text_2": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } }", "label": 0}
{"text_1": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "text_2": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0}
{"text_1": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "text_2": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0}
{"text_1": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + k * sigma ; } }", "label": 0}
{"text_1": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_2": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0}
{"text_1": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "text_2": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "text_2": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0}
{"text_1": "public class test { protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( ! body . hasOneChild ( ) ) { return null ; }", "text_2": "public class test { protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( body . getLineno ( ) ! = 1 | | ! body . hasOneChild ( ) ) { return null ; }", "label": 0}
{"text_1": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "text_2": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0}
{"text_1": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "text_2": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "label": 0}
{"text_1": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "text_2": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; + + i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "label": 0}
{"text_1": "public class test { static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "text_2": "public class test { static float toJavaVersionInt ( String s ) { return Float . parseFloat ( s ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "text_2": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) | | ! ( str . startsWith ( \" - 0x \" ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "label": 0}
{"text_1": "boolean advanceDayOfWeek , int millisOfDay ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } return this ; }", "text_2": "boolean advanceDayOfWeek , int millisOfDay ) { if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } } return this ; }", "label": 0}
{"text_1": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "text_2": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( size + 4 ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"text_1": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "text_2": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0}
{"text_1": "public class test { public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "text_2": "public class test { public static int gcd ( int u , int v ) { if ( System . currentTimeMillis ( ) * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"text_1": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < 3 ) { upper = lower ; }", "label": 0}
{"text_1": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "text_2": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0}
{"text_1": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMinimumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"text_1": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "text_2": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0}
{"text_1": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "text_2": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"text_1": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "text_2": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0}
{"text_1": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "text_2": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end . add ( field , - 1 * difference ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "text_2": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , initial ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "text_2": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) {  } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "label": 0}
{"text_1": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "text_2": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; dMin = Math . min ( dMin , dN1 ) ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"text_1": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "text_2": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 16000 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "label": 0}
{"text_1": "public class test { private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } sb . append ( quote ) ; return sb . toString ( ) ; } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "text_2": "public class test { static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } sb . append ( quote ) ; return sb . toString ( ) ; } private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0}
{"text_1": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "text_2": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { if ( com . google . javascript . rhino . jstype . PrototypeObjectType . this . prettyPrint ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "label": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"text_1": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "text_2": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } } } \\ No newline at end of file", "label": 0}
{"text_1": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "text_2": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0}
{"text_1": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; } } \\ No newline at end of file", "label": 0}
{"text_1": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "text_2": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0}
{"text_1": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "text_2": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0}
{"text_1": "public class test { public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "text_2": "public class test { public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0}
{"text_1": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_2": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 0}
{"text_1": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "text_2": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "label": 0}
