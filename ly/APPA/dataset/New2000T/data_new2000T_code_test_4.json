{"text_1": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "text_2": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "text_2": "public class test { private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "text_3": 1}
{"text_1": "public class test { static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "text_2": "public class test { static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { if ( context instanceof WildcardType ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead context = ( ( WildcardType ) context ) . getUpperBounds ( ) [ 0 ] ; } checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "text_3": 1}
{"text_1": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } } \\ No newline at end of file", "text_2": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & ! restrictedType . equals ( originalType ) ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseAndOrNotShortCircuiting ( Node left , Node right , FlowScope blindScope , boolean condition ) { / / left type / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , restrictedLeftType , right , rightIsRefineable , restrictedRightType ) ; } return blindScope ; } private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , boolean leftIsRefineable , JSType restrictedLeftType , Node right , boolean rightIsRefineable , JSType restrictedRightType ) { boolean shouldRefineLeft = leftIsRefineable & & restrictedLeftType ! = null ; boolean shouldRefineRight = rightIsRefineable & & restrictedRightType ! = null ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { } return blindScope ; } private FlowScope caseNameOrGetProp ( Node name , FlowScope blindScope , boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { JSType restrictedType = type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ; FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , name , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseEquality ( Node left , Node right , FlowScope blindScope , Function < TypePair , TypePair > merging ) { / / left type if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , merged . typeA , right , rightIsRefineable , merged . typeB ) ; } return blindScope ; } public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "text_2": "public class test { private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & restrictedType ! = originalType ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseNameOrGetProp ( Node name , FlowScope blindScope , boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { return maybeRestrictName ( blindScope , name , type , type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ) ; } return blindScope ; } private FlowScope caseAndOrNotShortCircuiting ( Node left , Node right , FlowScope blindScope , boolean condition ) { / / left type / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? restrictedLeftType : null , right , rightType , rightIsRefineable ? restrictedRightType : null ) ; } return blindScope ; } private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , JSType originalLeftType , JSType restrictedLeftType , Node right , JSType originalRightType , JSType restrictedRightType ) { boolean shouldRefineLeft = restrictedLeftType ! = null & & restrictedLeftType ! = originalLeftType ; boolean shouldRefineRight = restrictedRightType ! = null & & restrictedRightType ! = originalRightType ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { } return blindScope ; } private FlowScope caseEquality ( Node left , Node right , FlowScope blindScope , Function < TypePair , TypePair > merging ) { / / left type if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? merged . typeA : null , right , rightType , rightIsRefineable ? merged . typeB : null ) ; } return blindScope ; } public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { if ( outcome & & this = = getNativeType ( JSTypeNative . UNKNOWN_TYPE ) ) { return getNativeType ( JSTypeNative . CHECKED_UNKNOWN_TYPE ) ; } BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "text_3": 1}
{"text_1": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "text_2": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "text_3": 1}
{"text_1": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "text_2": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "text_3": 1}
{"text_1": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "text_2": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } break ; } case 4 : { char ch = str . charAt ( 0 ) ;", "text_3": 1}
{"text_1": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = src . _rootNameLookup ; } } \\ No newline at end of file", "text_2": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = new XmlRootNameLookup ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "text_2": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "text_3": 1}
{"text_1": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "text_2": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { return null ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { _properties [ index ] . getProperty ( ) . set ( bean , null ) ; return ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "text_3": 1}
{"text_1": "return pointer ; } else { if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } } \\ No newline at end of file", "text_2": "return pointer ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } private JXPathAbstractFactoryException createBadFactoryException ( AbstractFactory factory ) { return new JXPathAbstractFactoryException ( \" Factory \" + factory + \" reported success creating object for path : \" + asPath ( ) + \" but object was null . Terminating to avoid stack recursion . \" ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "text_2": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "text_3": 1}
{"text_1": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "text_2": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "text_3": 1}
{"text_1": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "text_2": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "text_3": 1}
{"text_1": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "text_2": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "text_3": 1}
{"text_1": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "text_2": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "text_3": 1}
{"text_1": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify / / otherwise only verify if neither explicitly annotated . } / / one more thing : ok to override in sub - class if ( oldOne . getClass ( ) = = newOne . getClass ( ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] / / otherwise , which one to choose ? / / new type more generic , use old / / new type more specific , use it } }", "text_2": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { boolean verify ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify verify = true ; } else { / / otherwise only verify if neither explicitly annotated . verify = ! explicit ; } / / one more thing : ok to override in sub - class if ( verify & & ( oldOne . getClass ( ) = = newOne . getClass ( ) ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems Class < ? > oldType = oldOne . getRawParameterType ( 0 ) ; Class < ? > newType = newOne . getRawParameterType ( 0 ) ; if ( oldType = = newType ) { throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] \" creators : already had explicitly marked \" + oldOne + \" , encountered \" + newOne ) ; } / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } }", "text_3": 1}
{"text_1": "public class test { public abstract JavaType withContentValueHandler ( Object h ) ;  ", "text_2": "public class test {", "text_3": 1}
{"text_1": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "text_2": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "text_3": 1}
{"text_1": "} / / if the Option has a value if ( option . hasArg ( ) & & ( option . getArgName ( ) ! = null ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "text_2": "} / / if the Option has a value if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "text_3": 1}
{"text_1": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "text_2": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "text_3": 1}
{"text_1": "public class test { public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k } public static int lcm ( int a , int b ) { if ( a = = 0 | | b = = 0 ) { return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "text_2": "public class test { public static int lcm ( int a , int b ) { if ( a = = 0 | | b = = 0 ) { return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k } } \\ No newline at end of file", "text_3": 1}
{"text_1": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( ' ; ' ) ; return sb ; } } \\ No newline at end of file", "text_2": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( \" > ; \" ) ; return sb ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_3": 1}
{"text_1": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "text_2": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array ! = null ) & & ( classes ! = null ) & & ( array [ i ] ! = null ) ) { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "text_3": 1}
{"text_1": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "text_2": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "text_3": 1}
{"text_1": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , java . util . Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new MethodProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "text_2": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new MethodProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; accum . append ( ' ' ) ; lastWasWhite = true ; } else { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ;", "text_2": "public class test { public static boolean isInvisibleChar ( int c ) { return Character . getType ( c ) = = 16 & & ( c = = 8203 | | c = = 8204 | | c = = 8205 | | c = = 173 ) ; } public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ;", "text_3": 1}
{"text_1": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "text_2": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "text_3": 1}
{"text_1": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "text_2": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "text_3": 1}
{"text_1": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( prop . getName ( ) ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "text_2": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( _hashArea [ i - 1 ] ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "text_3": 1}
{"text_1": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "text_2": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "text_3": 1}
{"text_1": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "text_2": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "text_3": 1}
{"text_1": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "text_2": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null & & ! delegateType . isJavaLangObject ( ) ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , th . getMessage ( ) , th ) ; } } \\ No newline at end of file", "text_2": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , ClassUtil . exceptionMessage ( th ) , th ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; / / check for several concatenated short options } } \\ No newline at end of file", "text_2": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { return true ; } / / check for several concatenated short options return optName . length ( ) > 0 & & options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( \" \\ \" \" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } int length = str . length ( ) ; if ( str . endsWith ( \" \\ \" \" ) ) { str = str . substring ( 0 , length - 1 ) ; } return str ;", "text_2": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { int length = str . length ( ) ; if ( length > 1 & & str . startsWith ( \" \\ \" \" ) & & str . endsWith ( \" \\ \" \" ) & & str . substring ( 1 , length - 1 ) . indexOf ( ' \" ' ) = = - 1 ) { str = str . substring ( 1 , length - 1 ) ; } return str ;", "text_3": 1}
{"text_1": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "text_2": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "text_3": 1}
{"text_1": "public class test { public void smartNullPointerException ( Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "text_2": "public class test { public void smartNullPointerException ( Object obj , Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , obj , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "text_3": 1}
{"text_1": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "text_2": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "text_3": 1}
{"text_1": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . appendChild ( new TextNode ( \" \" , \" \" ) ) ; body ( ) . appendChild ( node ) ; } } } \\ No newline at end of file", "text_2": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode ( \" \" , \" \" ) ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; }   int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) { return StringUtils . EMPTY ; } return className . substring ( 0 , i ) ; } public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } } \\ No newline at end of file", "text_2": "public class test { public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; }  while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; }  int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) { return StringUtils . EMPTY ; } return className . substring ( 0 , i ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "text_2": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "text_3": 1}
{"text_1": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } } \\ No newline at end of file", "text_2": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "text_2": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "text_3": 1}
{"text_1": "public class test { public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash > > > 12 ) ; return hash ; } private int _findOffsetForAdd ( int hash ) { / / first , check the primary : if ( _spilloverEnd > = hashArea . length ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } } \\ No newline at end of file", "text_2": "public class test { private int _findOffsetForAdd ( int hash ) { / / first , check the primary : final int end = ( _hashSize < < 3 ) ; if ( _spilloverEnd > = end ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash < < 3 ) ; / / shuffle back a bit hash + = ( hash > > > 12 ) ; / / and bit more return hash ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "text_2": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; }   } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public String getValue ( ) { return val ; } } \\ No newline at end of file", "text_2": "public class test { public String getValue ( ) { return Attributes . checkNotNull ( val ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ) { return _initStartElement ( ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _textValue = text ; return ( _currentState = XML_TEXT ) ; } return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "text_2": "public class test { protected boolean _allWs ( String str ) { final int len = ( str = = null ) ? 0 : str . length ( ) ; if ( len > 0 ) { for ( int i = 0 ; i < len ; + + i ) { if ( str . charAt ( i ) > ' ' ) { return false ; } } } return true ; } private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; final boolean startElementNext = _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( startElementNext ) { if ( text = = null | | _allWs ( text ) ) { _mixedText = false ; return _initStartElement ( ) ; } _mixedText = true ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _mixedText = false ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } _mixedText = false ; return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements if ( _mixedText ) { _mixedText = false ; return _initStartElement ( ) ; } / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "text_3": 1}
{"text_1": "public class test { protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] } } \\ No newline at end of file", "text_2": "public class test { protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "text_2": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } else if ( p . getCurrentToken ( ) = = JsonToken . VALUE_STRING ) { if ( ctxt . isEnabled ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT ) ) { String str = p . getText ( ) . trim ( ) ; if ( str . isEmpty ( ) ) { return null ; } } } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "text_3": 1}
{"text_1": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "text_2": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "text_3": 1}
{"text_1": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; return sb . toString ( ) ; } } \\ No newline at end of file", "text_2": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; sb . append ( ' > ' ) ; return sb . toString ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "text_2": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "text_3": 1}
{"text_1": "return ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "text_2": "return ( _valueDeserializer = = null ) & & ( _keyDeserializer = = null ) & & ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "text_2": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "text_3": 1}
{"text_1": "public class test { public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } } } \\ No newline at end of file", "text_2": "public class test { public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { FunctionType buildAndRegister ( ) { if ( returnType = = null ) { returnType = typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; . withName ( fnName ) . withSourceNode ( sourceNode ) . withParamsNode ( parametersNode ) . withReturnType ( returnType ) . withTypeOfThis ( thisType ) . withTemplateName ( templateTypeName ) . build ( ) ; return fnType ; } FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; if ( templateTypeName ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } return this ; } Node fnRoot = isFnLiteral ? rValue : null ; Node parametersNode = isFnLiteral ? rValue . getFirstChild ( ) . getNext ( ) : null ; if ( functionType = = null & & info ! = null & & info . hasType ( ) ) { JSType type = info . getType ( ) . evaluate ( scope , typeRegistry ) ; . setSourceNode ( fnRoot ) . inferFromOverriddenFunction ( propType , parametersNode ) . inferThisType ( info , owner ) . buildAndRegister ( ) ; } } . inferInheritance ( info ) . inferThisType ( info , owner ) . inferParameterTypes ( parametersNode , info ) . buildAndRegister ( ) ; } / / all done return functionType ; } FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , null , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "text_2": "public class test { FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : null ; if ( templateTypeName ! = null & & returnType ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } return this ; } FunctionType buildAndRegister ( ) { if ( returnType = = null ) { returnType = typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; . withName ( fnName ) . withSourceNode ( sourceNode ) . withParamsNode ( parametersNode ) . withReturnType ( returnType , returnTypeInferred ) . withTypeOfThis ( thisType ) . withTemplateName ( templateTypeName ) . build ( ) ; return fnType ; } FunctionTypeBuilder inferReturnStatements ( @ Nullable Node functionBlock ) { if ( functionBlock = = null | | compiler . getInput ( sourceName ) . isExtern ( ) ) { return this ; } Preconditions . checkArgument ( functionBlock . getType ( ) = = Token . BLOCK ) ; if ( returnType = = null ) { boolean hasNonEmptyReturns = false ; List < Node > worklist = Lists . newArrayList ( functionBlock ) ; while ( ! worklist . isEmpty ( ) ) { Node current = worklist . remove ( worklist . size ( ) - 1 ) ; int cType = current . getType ( ) ; if ( cType = = Token . RETURN & & current . getFirstChild ( ) ! = null | | cType = = Token . THROW ) { hasNonEmptyReturns = true ; break ; } else if ( NodeUtil . isStatementBlock ( current ) | | NodeUtil . isControlStructure ( current ) ) { for ( Node child = current . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { worklist . add ( child ) ; } } }  if ( ! hasNonEmptyReturns ) { returnType = typeRegistry . getNativeType ( VOID_TYPE ) ; returnTypeInferred = true ; } } return this ; } Node fnRoot = isFnLiteral ? rValue : null ; Node parametersNode = isFnLiteral ? rValue . getFirstChild ( ) . getNext ( ) : null ; Node fnBlock = isFnLiteral ? parametersNode . getNext ( ) : null ; if ( functionType = = null & & info ! = null & & info . hasType ( ) ) { JSType type = info . getType ( ) . evaluate ( scope , typeRegistry ) ; . setSourceNode ( fnRoot ) . inferFromOverriddenFunction ( propType , parametersNode ) . inferThisType ( info , owner ) . inferReturnStatements ( fnBlock ) . buildAndRegister ( ) ; } } . inferInheritance ( info ) . inferThisType ( info , owner ) . inferParameterTypes ( parametersNode , info ) . inferReturnStatements ( fnBlock ) . buildAndRegister ( ) ; } / / all done return functionType ; } public FunctionBuilder withReturnType ( JSType returnType , boolean inferred ) { this . returnType = returnType ; this . inferredReturnType = inferred ; return this ; } FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , source , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "text_3": 1}
{"text_1": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" ^ mb \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "text_2": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" mb $ \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "text_3": 1}
{"text_1": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } } } \\ No newline at end of file", "text_2": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } if ( answer instanceof CallsRealMethods ) { validateMockingConcreteClass ( ( CallsRealMethods ) answer , invocation ) ; } } private void validateMockingConcreteClass ( CallsRealMethods answer , Invocation invocation ) { if ( invocation . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { reporter . cannotCallRealMethodOnInterface ( ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , e . getMessage ( ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = cause . getMessage ( ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "text_2": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , ClassUtil . exceptionMessage ( e ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = ClassUtil . exceptionMessage ( cause ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "text_3": 1}
{"text_1": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "text_2": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "text_3": 1}
{"text_1": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "text_2": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "text_3": 1}
{"text_1": "public class test { public void addOption ( Option option ) { options . add ( option ) ; nameToOption . put ( option . getPreferredName ( ) , option ) ; } / / ensure that all parent options are also added } public GroupImpl ( final List options , final String name , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; if ( option instanceof Argument ) { i . remove ( ) ; this . optionMap = Collections . unmodifiableSortedMap ( newOptionMap ) ; this . prefixes = Collections . unmodifiableSet ( newPrefixes ) ; } } \\ No newline at end of file", "text_2": "public class test { void setParent ( Option parent ) ; Option getParent ( ) ; public void addOption ( Option option ) { options . add ( option ) ; nameToOption . put ( option . getPreferredName ( ) , option ) ; } / / ensure that all parent options are also added Option parent = option . getParent ( ) ; while ( parent ! = null & & ! options . contains ( parent ) ) { options . add ( parent ) ; parent = parent . getParent ( ) ; } } public GroupImpl ( final List options , final String name , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; option . setParent ( this ) ; if ( option instanceof Argument ) { i . remove ( ) ; this . optionMap = Collections . unmodifiableSortedMap ( newOptionMap ) ; this . prefixes = Collections . unmodifiableSet ( newPrefixes ) ; } public Option getParent ( ) { return parent ; } public void setParent ( Option parent ) { this . parent = parent ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "text_3": 1}
{"text_1": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "text_2": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "text_3": 1}
{"text_1": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "text_2": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "text_3": 1}
{"text_1": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else if ( stopAtNonOption ) { processNonOptionToken ( token ) ; } else { tokens . add ( token ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { Option currentOption ; for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) ) ; break ; } else } } } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }   tokens . add ( token ) ; } private void processNonOptionToken ( String value ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; }", "text_2": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token , stopAtNonOption ) ; } else { currentOption = options . getOption ( opt ) ; tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }  if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; }  tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break ; } else } } } private void processNonOptionToken ( String value , boolean stopAtNonOption ) { if ( stopAtNonOption & & ( currentOption = = null | | ! currentOption . hasArg ( ) ) ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; } tokens . add ( value ) ; }", "text_3": 1}
{"text_1": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "text_2": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "text_3": 1}
{"text_1": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "text_2": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "text_3": 1}
{"text_1": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "text_2": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "text_3": 1}
{"text_1": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; if ( value instanceof Date ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else { str = value . toString ( ) ; }", "text_2": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; Class < ? > cls = value . getClass ( ) ; if ( cls = = String . class ) { str = ( String ) value ; } else if ( Date . class . isAssignableFrom ( cls ) ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else if ( cls = = Class . class ) { str = ( ( Class < ? > ) value ) . getName ( ) ; } else { str = value . toString ( ) ; }", "text_3": 1}
{"text_1": "} if ( depth1 = = 1 ) { throw new JXPathException ( \" Cannot compare pointers that do not belong to the same tree : ' \" + p1 + \" ' and ' \" + p2 + \" ' \" ) ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "text_2": "} if ( depth1 = = 1 ) { return 0 ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "text_3": 1}
{"text_1": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "text_2": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "text_3": 1}
{"text_1": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "text_2": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "text_3": 1}
{"text_1": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } formatBigIntegerBinary ( value , buf , offset , length , negative ) ; buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "text_2": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } else { formatBigIntegerBinary ( value , buf , offset , length , negative ) ; } buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "text_3": 1}
{"text_1": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , errorList , treeBuilder . defaultSettings ( ) ) ; } public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( \" \" ) ; Document dirty = Document . createShell ( \" \" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , \" \" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & errorList . size ( ) = = 0 ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & dirtyDocument . head ( ) . childNodes ( ) . size ( ) = = 0 ; / / because we only look at the body , but we start from a shell , make sure there ' s nothing in the head } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; cls ! = Object . class ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "text_2": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( ! raw . isInterface ( ) & & full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; ( cls ! = null ) & & ( cls ! = Object . class ) ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "text_3": 1}
{"text_1": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "text_2": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "text_3": 1}
{"text_1": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "text_2": "public class test { public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; } } \\ No newline at end of file", "text_2": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } } \\ No newline at end of file", "text_2": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } boolean cachable = ( bindings = = null ) | | bindings . isEmpty ( ) ; if ( cachable ) { result = _typeCache . get ( rawType ) ; if ( result ! = null ) { return result ; } }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; if ( cachable ) { _typeCache . putIfAbsent ( rawType , result ) ; } return result ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { TypeBindings tb = null ; if ( baseType . containedTypeCount ( ) = = typeParamCount ) { if ( typeParamCount = = 1 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } else if ( typeParamCount = = 2 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } } newType = _fromClass ( null , subclass , ( tb = = null ) ? TypeBindings . emptyBindings ( ) : tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } } \\ No newline at end of file", "text_2": "public class test { private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } return TypeBindings . emptyBindings ( ) ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now TypeBindings tb = _bindingsForSubtype ( baseType , typeParamCount , subclass ) ; if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , tb , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , tb , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { newType = _fromClass ( null , subclass , tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } final Object key ; if ( ( bindings = = null ) | | bindings . isEmpty ( ) ) { key = rawType ; result = _typeCache . get ( key ) ; / / ok , cache object is synced } else { key = bindings . asKey ( rawType ) ; } result = _typeCache . get ( key ) ; / / ok , cache object is synced if ( result ! = null ) { return result ; }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; _typeCache . putIfAbsent ( key , result ) ; / / cache object syncs return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; insertNode ( insert ) ; } } \\ No newline at end of file", "text_2": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; if ( commentToken . bogus ) { / / xml declarations are emitted as bogus comments ( which is right for html , but not xml ) String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MockHandler < T > newMockHandler = new MockHandler < T > ( oldMockHandler ) ; MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler , ( MockSettingsImpl ) org . mockito . Mockito . withSettings ( ) . defaultAnswer ( org . mockito . Mockito . RETURNS_DEFAULTS ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; } } \\ No newline at end of file", "text_2": "public class test { public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MethodInterceptorFilter newFilter = newMethodInterceptorFilter ( oldMockHandler . getMockSettings ( ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , ownerDocument ( ) . outputSettings ( ) ) ) . traverse ( this ) ; } } \\ No newline at end of file", "text_2": "public class test { private Document . OutputSettings getOutputSettings ( ) { return ownerDocument ( ) ! = null ? ownerDocument ( ) . outputSettings ( ) : ( new Document ( \" \" ) ) . outputSettings ( ) ; } protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , getOutputSettings ( ) ) ) . traverse ( this ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; }", "text_2": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { if ( value . length ( ) = = 0 ) / / no key , no val ; unknown char , keep popping so not get stuck tq . advance ( ) ; return null ; }", "text_3": 1}
{"text_1": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . if ( _deserialize ( text , ctxt ) ! = null ) { return _deserialize ( text , ctxt ) ; } } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "text_2": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . return _deserialize ( text , ctxt ) ; } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "text_3": 1}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 1}
{"text_1": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } return ser ; } protected JsonSerializer < ? > _createSerializer2 ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; if ( ser ! = null ) { return ser ; } final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . } if ( ser = = null ) {", "text_2": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } } return ser ; } protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > _createSerializer2 ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = null ; final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } } if ( ser = = null ) {", "text_3": 1}
{"text_1": "XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "text_2": "XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "text_3": 1}
{"text_1": "public class test { public JsonWriter jsonValue ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( value ) ; return this ; } private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( true ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; } private void beforeValue ( boolean root ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document if ( ! lenient & & ! root ) { throw new IllegalStateException ( \" JSON must start with an array or an object . \" ) ; } replaceTop ( NONEMPTY_DOCUMENT ) ; break ; throw new IllegalStateException ( \" Nesting problem . \" ) ; } } public JsonWriter value ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; string ( value ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( false ) ; out . append ( string ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( Double . toString ( value ) ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( false ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; }", "text_2": "public class test { private void beforeValue ( ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document replaceTop ( NONEMPTY_DOCUMENT ) ; break ; throw new IllegalStateException ( \" Nesting problem . \" ) ; } } public JsonWriter jsonValue ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( value ) ; return this ; } private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; } public JsonWriter value ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; string ( value ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ; out . append ( string ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( Double . toString ( value ) ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; }", "text_3": 1}
{"text_1": "public class test { public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; }", "text_2": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; }", "text_3": 1}
{"text_1": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return null ; } } } \\ No newline at end of file", "text_2": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return null ; } } public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( \" Unable to find file : \" + str ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else {", "text_2": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; break ; } else {", "text_3": 1}
{"text_1": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ; } } \\ No newline at end of file", "text_2": "public class test { public static double distance ( int [ ] low , int [ ] high ) { int n = low . length ;  int max = high [ 0 ] ; for ( int i = 0 ; i < n ; i + + ) { max = Math . max ( max , high [ i ] ) ; }  long [ ] sums = new long [ max + 2 ] ; for ( int i = 2 ; i < sums . length ; i + + ) { sums [ i ] = sums [ i - 1 ] + ( i - 1 ) ; }  double prev = 0 ; for ( int i = 1 ; i < n ; i + + ) {  double p1 = 1 . 0 / ( high [ i - 1 ] - low [ i - 1 ] + 1 ) ; double p2 = 1 . 0 / ( high [ i ] - low [ i ] + 1 ) ; double p = p1 * p2 ;  double curr = 0 ;  for ( int a = low [ i ] ; a < high [ i ] + 1 ; a + + ) { long lo = low [ i - 1 ] ; long hi = high [ i - 1 ] ; int l = 0 ; int r = 0 ;  if ( lo < = a & & a < = hi ) { l = ( int ) ( a - lo ) ; r = ( int ) ( hi - a ) ; } else if ( a > hi ) { l = ( int ) ( hi - lo + 1 ) ; } else if ( a < lo ) { r = ( int ) ( hi - lo + 1 ) ; }  long addl = sums [ l ] ; long addr = ( l > 0 | | a = = lo ) ? ( sums [ l + 1 + r ] - sums [ l + 1 ] ) : sums [ r ] ;  curr + = p * l * a ; curr - = p * r * a ;  curr - = p * ( l * lo + addl ) ; curr + = p * ( r * lo + addr ) ;  curr + = p2 * prev ; }  prev = curr ; }  return prev ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "text_2": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "text_3": 1}
{"text_1": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "text_2": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) attributes . remove ( attrKey ) ; } } } \\ No newline at end of file", "text_2": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) it . remove ( ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately p . skipChildren ( ) ; return null ; } } \\ No newline at end of file", "text_2": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately if ( p . hasToken ( JsonToken . FIELD_NAME ) ) { while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = null ) | | ( t = = JsonToken . END_OBJECT ) ) { break ; } p . skipChildren ( ) ; } } else { p . skipChildren ( ) ; } return null ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "text_2": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "text_3": 1}
{"text_1": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( tag . isSelfClosing ( ) ) tokeniser . acknowledgeSelfClosingFlag ( ) ; } else { tag . setSelfClosing ( ) ; tokeniser . acknowledgeSelfClosingFlag ( ) ; } } return el ; } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } } \\ No newline at end of file", "text_2": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( \" Tag cannot be self closing ; not a void tag \" ) ; } else / / unknown tag , remember this is self closing for output tag . setSelfClosing ( ) ; } return el ; } Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; lowerBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; } public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; upperBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } } \\ No newline at end of file", "text_2": "public class test { public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; if ( bound instanceof WildcardType ) { upperBounds = ( ( WildcardType ) bound ) . getUpperBounds ( ) ; } else { upperBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; if ( bound instanceof WildcardType ) { lowerBounds = ( ( WildcardType ) bound ) . getLowerBounds ( ) ; } else { lowerBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } } \\ No newline at end of file", "text_2": "public class test { Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "text_2": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "text_3": 1}
{"text_1": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "text_2": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "text_2": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; popStackToClose ( tag ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "text_3": 1}
{"text_1": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } } \\ No newline at end of file", "text_2": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) accum . append ( \" \" ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String pubSysKey , String publicId , String systemId , String baseUri ) { super ( baseUri ) ;  attr ( NAME , name ) ; if ( pubSysKey ! = null ) { attr ( PUB_SYS_KEY , pubSysKey ) ; } attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; if ( has ( PUBLIC_ID ) ) { attr ( PUB_SYS_KEY , PUBLIC_KEY ) ; } attr ( SYSTEM_ID , systemId ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "text_2": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "text_3": 1}
{"text_1": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = 0 ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "text_2": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = commandLine . getUndefaultedValues ( option ) . size ( ) ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "text_3": 1}
{"text_1": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "text_2": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "text_3": 1}
{"text_1": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "text_2": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "text_3": 1}
{"text_1": "return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ; / / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ;", "text_2": "return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ; / / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ;", "text_3": 1}
{"text_1": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "text_2": "public class test { public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "text_2": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "text_3": 1}
{"text_1": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "text_2": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = o2 ) { return true ; } else if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_3": 1}
{"text_1": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "text_2": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "text_3": 1}
{"text_1": "} } if ( count = = len ) { return str . toUpperCase ( ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "text_2": "} } if ( count = = len ) { return str . toUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "text_3": 1}
{"text_1": "public class test { public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; } } \\ No newline at end of file", "text_2": "public class test { public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "text_2": "return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "text_3": 1}
{"text_1": "public class test { private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? \" null \" : arg . toString ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable {  container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ;  return mock ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } protected GenericMetadataSupport actualParameterizedType ( Object mock ) { CreationSettings mockSettings = ( CreationSettings ) new MockUtil ( ) . getMockHandler ( mock ) . getMockSettings ( ) ; return GenericMetadataSupport . inferFrom ( mockSettings . getTypeToMock ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ;  Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }  return getMock ( invocation , returnTypeGenericMetadata ) ; } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; InvocationContainerImpl container = ( InvocationContainerImpl ) handler . getInvocationContainer ( ) ;  for ( StubbedInvocationMatcher stubbedInvocationMatcher : container . getStubbedInvocations ( ) ) { if ( container . getInvocationForStubbing ( ) . matches ( stubbedInvocationMatcher . getInvocation ( ) ) ) { return stubbedInvocationMatcher . answer ( invocation ) ; } }  return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } protected GenericMetadataSupport actualParameterizedType ( Object mock ) { CreationSettings mockSettings = ( CreationSettings ) new MockUtil ( ) . getMockHandler ( mock ) . getMockSettings ( ) ; return GenericMetadataSupport . inferFrom ( mockSettings . getTypeToMock ( ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable {  container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ;  return mock ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "text_2": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "text_3": 1}
{"text_1": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "text_2": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "text_3": 1}
{"text_1": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "text_2": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "text_3": 1}
{"text_1": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; } } \\ No newline at end of file", "text_2": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; if ( isBinary ( ) ) { throw new UncheckedIOException ( \" Input is binary and unsupported \" ) ; } } boolean isBinary ( ) { int nullsSeen = 0 ;  for ( int i = bufPos ; i < bufLength ; i + + ) { if ( charBuf [ i ] = = ' \\ 0 ' ) nullsSeen + + ; }  return nullsSeen > = numNullsConsideredBinary ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo ) ; } } } private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; } } } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; blockStack . pop ( ) ; } } } \\ No newline at end of file", "text_2": "public class test { private boolean isLValue ( Node n ) { Node parent = n . getParent ( ) ; return ( parent . getType ( ) = = Token . INC | | parent . getType ( ) = = Token . DEC | | ( NodeUtil . isAssignmentOp ( parent ) & & parent . getFirstChild ( ) = = n ) ) ; } private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments ( t . getScope ( ) , referenceMap ) ; for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo , maybeModifiedArguments ) ; } } } private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo , boolean maybeModifiedArguments ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; } } } private boolean maybeEscapedOrModifiedArguments ( Scope scope , Map < Var , ReferenceCollection > referenceMap ) { if ( scope . isLocal ( ) ) { Var arguments = scope . getArgumentsVar ( ) ; ReferenceCollection refs = referenceMap . get ( arguments ) ; if ( refs ! = null & & ! refs . references . isEmpty ( ) ) { for ( Reference ref : refs . references ) { Node refNode = ref . getNameNode ( ) ; Node refParent = ref . getParent ( ) ; if ( ! ( NodeUtil . isGet ( refParent ) & & refNode = = ref . getParent ( ) . getFirstChild ( ) & & ! isLValue ( refParent ) ) ) { return true ; } } } } return false ; } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v ; if ( n . getString ( ) . equals ( \" arguments \" ) ) { v = t . getScope ( ) . getArgumentsVar ( ) ; } else { v = t . getScope ( ) . getVar ( n . getString ( ) ) ; } if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; blockStack . pop ( ) ; } } Arguments ( Scope scope ) { super ( false , / / no inferred \" arguments \" , / / always arguments null , / / no declaration node null , / / no type info scope , - 1 , / / no variable index null , / / input , false , / / not a define null / / no jsdoc ) ; } @ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Arguments ) ) { return false ; }  Arguments otherVar = ( Arguments ) other ; return otherVar . scope . getRootNode ( ) = = scope . getRootNode ( ) ; } @ Override public int hashCode ( ) { return System . identityHashCode ( this ) ; } public Var getArgumentsVar ( ) { if ( arguments = = null ) { arguments = new Arguments ( this ) ; } return arguments ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "text_2": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "text_3": 1}
{"text_1": "} PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "text_2": "} PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "text_3": 1}
{"text_1": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; } } public void close ( ) throws IOException { if ( ! closed ) { finish ( ) ; buffer . close ( ) ; out . close ( ) ; closed = true ; } } public void close ( ) throws IOException { finish ( ) ; if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } return results ; } } \\ No newline at end of file", "text_2": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; } } public void close ( ) throws IOException { if ( ! closed ) { buffer . close ( ) ; out . close ( ) ; closed = true ; } } public void close ( ) throws IOException { if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } out . finish ( ) ; return results ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static Option create ( String opt ) throws IllegalArgumentException { / / create the option Option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; / / return the Option instance return option ;", "text_2": "public class test { public static Option create ( String opt ) throws IllegalArgumentException { Option option = null ; try { / / create the option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } finally { / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; } / / return the Option instance return option ;", "text_3": 1}
{"text_1": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "text_2": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "text_3": 1}
{"text_1": "public class test { private void tryRemoveUnconditionalBranching ( Node n ) {", "text_2": "public class test { private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private void tryRemoveUnconditionalBranching ( Node n ) {", "text_3": 1}
{"text_1": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return null ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return null ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "text_2": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass , Boolean defaultValue ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return defaultValue ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return defaultValue ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false , _serializeAsIndex ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true , null ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "text_2": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "text_3": 1}
{"text_1": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; - - shift ; if ( shift = = 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( length > 0 & & shift > 0 ) { header . write ( cache ) ; } }", "text_2": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; if ( - - shift < 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( shift ! = 7 ) { header . write ( cache ) ; } }", "text_3": 1}
{"text_1": "public class test { static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "text_2": "public class test { static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "text_2": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "text_3": 1}
{"text_1": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return node instanceof Element ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "text_2": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "text_3": 1}
{"text_1": "public class test { public void writeRaw ( String text , int offset , int len ) throws IOException { final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . while ( len > 0 ) { int len2 = Math . min ( buf . length , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; writeRaw ( buf , 0 , len2 ) ; / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it offset + = len2 ; len - = len2 ; } if ( ch < = SURR2_LAST ) { / / yes , outside of BMP / / Do we have second part ? if ( inputOffset > = inputEnd | | cbuf = = null ) { / / nope . . . have to note down _reportError ( \" Split surrogate on writeRaw ( ) input ( last character ) \" ) ; } _outputSurrogates ( ch , cbuf [ inputOffset ] ) ; return inputOffset + 1 ;", "text_2": "public class test { private void _writeRawSegment ( char [ ] cbuf , int offset , int end ) throws IOException { main_loop : while ( offset < end ) { inner_loop : while ( true ) { int ch = ( int ) cbuf [ offset ] ; if ( ch > 0x7F ) { break inner_loop ; } _outputBuffer [ _outputTail + + ] = ( byte ) ch ; if ( + + offset > = end ) { break main_loop ; } } char ch = cbuf [ offset + + ] ; if ( ch < 0x800 ) { / / 2 - byte ? _outputBuffer [ _outputTail + + ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; _outputBuffer [ _outputTail + + ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { offset = _outputRawMultiByteChar ( ch , cbuf , offset , end ) ; } } } public void writeRaw ( String text , int offset , int len ) throws IOException { final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy if ( len < = buf . length ) { text . getChars ( offset , offset + len , buf , 0 ) ; _writeRawSegment ( buf , 0 , len ) ; return ; } / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . final int maxChunk = ( _outputEnd > > 2 ) + ( _outputEnd > > 4 ) ; / / = = ( 1 / 4 + 1 / 16 ) = = 5 / 16 final int maxBytes = maxChunk * 3 ; while ( len > 0 ) { int len2 = Math . min ( maxChunk , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; if ( ( _outputTail + maxBytes ) > _outputEnd ) { _flushBuffer ( ) ; } / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it if ( len > 0 ) { char ch = buf [ len2 - 1 ] ; if ( ( ch > = SURR1_FIRST ) & & ( ch < = SURR1_LAST ) ) { - - len2 ; } } _writeRawSegment ( buf , 0 , len2 ) ; offset + = len2 ; len - = len2 ; } if ( ch < = SURR2_LAST ) { / / yes , outside of BMP / / Do we have second part ? if ( inputOffset > = inputEnd | | cbuf = = null ) { / / nope . . . have to note down _reportError ( String . format ( \" Split surrogate on writeRaw ( ) input ( last character ) : first character 0x % 4x \" , ch ) ) ; } _outputSurrogates ( ch , cbuf [ inputOffset ] ) ; return inputOffset + 1 ;", "text_3": 1}
{"text_1": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "text_2": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "text_3": 1}
{"text_1": "public class test { public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; } } \\ No newline at end of file", "text_2": "public class test { public TokenBuffer forceUseOfBigDecimal ( boolean b ) { _forceBigDecimal = b ; return this ; } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; _forceBigDecimal = ( ctxt = = null ) ? false : ctxt . isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ; } public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : if ( _forceBigDecimal ) { writeNumber ( p . getDecimalValue ( ) ) ; } else { switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "text_2": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "text_3": 1}
{"text_1": "public class test { public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "text_2": "public class test { public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "text_3": 1}
{"text_1": "public class test { public double getResult ( ) { return optimizer . getResult ( ) ; } public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public double getResult ( ) { return optima [ 0 ] ; } public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( upper < lower ) { upper = lower ; }  StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "text_2": "if ( upper < lower ) { upper = lower ; } if ( upper = = - 1 | | upper > str . length ( ) ) { upper = str . length ( ) ; } StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "text_3": 1}
{"text_1": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "text_2": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "text_3": 1}
{"text_1": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "text_2": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "text_3": 1}
{"text_1": "public class test { public void tail ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element & & dest . getParentNode ( ) instanceof Element ) { dest = ( Element ) dest . getParentNode ( ) ; / / undescend . cromulent . } } public void head ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespaces . get ( prefix ) ; Element el = doc . createElementNS ( namespace , sourceEl . tagName ( ) ) ; copyAttributes ( sourceEl , el ) ; / / unhandled } } private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = \" \" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespaces . put ( prefix , attr . getValue ( ) ) ; }  int pos = el . tagName ( ) . indexOf ( \" : \" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : \" \" ; } } \\ No newline at end of file", "text_2": "public class test { private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = \" \" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; }  int pos = el . tagName ( ) . indexOf ( \" : \" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : \" \" ; } public void head ( org . jsoup . nodes . Node source , int depth ) { namespacesStack . push ( new HashMap < > ( namespacesStack . peek ( ) ) ) ; / / inherit from above on the stack if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespacesStack . peek ( ) . get ( prefix ) ; Element el = doc . createElementNS ( namespace , sourceEl . tagName ( ) ) ; copyAttributes ( sourceEl , el ) ; / / unhandled } } public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; } public void tail ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element & & dest . getParentNode ( ) instanceof Element ) { dest = ( Element ) dest . getParentNode ( ) ; / / undescend . cromulent . } namespacesStack . pop ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ; } } \\ No newline at end of file", "text_2": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) | | Character . isLetter ( c ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; return buf ; } private boolean usesDataDescriptor ( final int zipMethod ) { return zipMethod = = DEFLATED & & channel = = null ; } protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ze . getMethod ( ) ! = DEFLATED | | channel ! = null ) { return ; } writeCounted ( DD_SIG ) ;", "text_2": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) , phased ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod , phased ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; return buf ; } private boolean usesDataDescriptor ( final int zipMethod , boolean phased ) { return ! phased & & zipMethod = = DEFLATED & & channel = = null ; } protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ! usesDataDescriptor ( ze . getMethod ( ) , false ) ) { return ; } writeCounted ( DD_SIG ) ;", "text_3": 1}
{"text_1": "public class test { public static Evaluator parse ( String query ) { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { tokens . add ( \" - \" + ch ) ; } } }", "text_2": "} else { tokens . add ( token ) ; break ; } } }", "text_3": 1}
{"text_1": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "text_2": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace = = null & & tagName . contains ( \" : \" ) ? doc . createElementNS ( \" \" , tagName ) : / / doesn ' t have a real namespace defined doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "text_3": 1}
{"text_1": "public class test { protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer & & r instanceof Pointer ) { if ( l . equals ( r ) ) { return true ; } } if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } if ( l = = r ) { return true ; } if ( l instanceof Boolean | | r instanceof Boolean ) { return ( InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ) ; } / / if either side is NaN , no comparison returns true : if ( l instanceof Number | | r instanceof Number ) { return ( InfoSetUtil . doubleValue ( l ) = = InfoSetUtil . doubleValue ( r ) ) ; } if ( l instanceof String | | r instanceof String ) { return ( InfoSetUtil . stringValue ( l ) . equals ( InfoSetUtil . stringValue ( r ) ) ) ; } return l ! = null & & l . equals ( r ) ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . FALSE : Boolean . TRUE ; } public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 ) ; } } \\ No newline at end of file", "text_2": "public class test { public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { this ( arg1 , arg2 , false ) ; } protected CoreOperationCompare ( Expression arg1 , Expression arg2 , boolean invert ) { super ( new Expression [ ] { arg1 , arg2 } ) ; this . invert = invert ; } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } boolean result ; if ( l instanceof Boolean | | r instanceof Boolean ) { result = l = = r | | InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ; } else if ( l instanceof Number | | r instanceof Number ) { / / if either side is NaN , no comparison returns true : double ld = InfoSetUtil . doubleValue ( l ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( r ) ; if ( Double . isNaN ( rd ) ) { return false ; } result = ld = = rd ; } else { if ( l instanceof String | | r instanceof String ) { l = InfoSetUtil . stringValue ( l ) ; r = InfoSetUtil . stringValue ( r ) ; } result = l = = r | | l ! = null & & l . equals ( r ) ; } return result ^ invert ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 , true ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "text_2": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "text_3": 1}
{"text_1": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" td \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "text_2": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" th \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "text_2": "end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "text_3": 1}
{"text_1": "public class test { public Object callRealMethod ( ) throws Throwable { return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "text_2": "public class test { public Object callRealMethod ( ) throws Throwable { if ( this . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { new Reporter ( ) . cannotCallRealMethodOnInterface ( ) ; } return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "text_2": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header = = null | | header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "text_3": 1}
{"text_1": "public class test { public Elements siblingElements ( ) {  return parent ( ) . children ( ) ; } public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Element previousElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Node previousSibling ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } public List < Node > siblingNodes ( ) {  return parent ( ) . childNodes ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public Element nextElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Elements siblingElements ( ) { if ( parentNode = = null ) return new Elements ( 0 ) ;  List < Element > elements = parent ( ) . children ( ) ; Elements siblings = new Elements ( elements . size ( ) - 1 ) ; for ( Element el : elements ) if ( el ! = this ) siblings . add ( el ) ; return siblings ; } public Element previousElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public List < Node > siblingNodes ( ) { if ( parentNode = = null ) return Collections . emptyList ( ) ;  List < Node > nodes = parentNode . childNodes ; List < Node > siblings = new ArrayList < Node > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node ! = this ) siblings . add ( node ) ; return siblings ; } public Node previousSibling ( ) { if ( parentNode = = null ) return null ; / / root List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } public Elements ( int initialCapacity ) { contents = new ArrayList < Element > ( initialCapacity ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix ! = null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; } String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "text_2": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( testPrefix = = null | | equalStrings ( testPrefix , nodePrefix ) ) { return true ; } if ( nodePrefix = = null ) { return false ; } return equalStrings ( parent . getNamespaceURI ( testPrefix ) , parent . getNamespaceURI ( nodePrefix ) ) ; } return false ; } String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "text_3": 1}
{"text_1": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "text_2": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "text_3": 1}
{"text_1": "public class test { private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; } } \\ No newline at end of file", "text_2": "public class test { private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . getCurrentToken ( ) = = JsonToken . START_OBJECT ) { p . nextToken ( ) ; return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . getCurrentToken ( ) = = JsonToken . FIELD_NAME ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "text_2": "public class test { public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . isExpectedStartObjectToken ( ) | | p . hasToken ( JsonToken . FIELD_NAME ) ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . hasToken ( JsonToken . END_OBJECT ) ) { return ctxt . getNodeFactory ( ) . objectNode ( ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "text_3": 1}
{"text_1": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } } \\ No newline at end of file", "text_2": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 4 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_3": 1}
{"text_1": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "text_2": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "text_3": 1}
{"text_1": "String encoding ) { this . is = is ; this . hasHitEOF = false ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ;", "text_2": "String encoding ) { this . is = is ; this . hasHitEOF = false ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ;", "text_3": 1}
{"text_1": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "text_2": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "text_3": 1}
{"text_1": "return false ; } while ( i < end ) { i + + ;", "text_2": "return false ; } if ( end > = input . length ) return false ; while ( i < end ) { i + + ;", "text_3": 1}
{"text_1": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "text_2": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "text_3": 1}
{"text_1": "/ / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "text_2": "/ / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "text_3": 1}
{"text_1": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "text_2": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = ' < ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "text_3": 1}
{"text_1": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } }  } }", "text_3": 1}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_3": 1}
{"text_1": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "text_2": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "text_3": 1}
{"text_1": "public class test { private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "text_2": "public class test { private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "text_3": 1}
{"text_1": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "text_2": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "text_3": 1}
{"text_1": "public class test { public int hashCode ( ) { return 1 ; } } \\ No newline at end of file", "text_2": "public class test { public int hashCode ( ) { return method . hashCode ( ) ; } public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o instanceof DelegatingMethod ) { DelegatingMethod that = ( DelegatingMethod ) o ; return method . equals ( that . method ) ; } else { return method . equals ( o ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} } } if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "text_2": "} } } findBoundsByIteration ( ) ; if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "text_3": 1}
{"text_1": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; / / If we have offset , need to omit that from byte offset , so : _bufferRecyclable = bufferRecyclable ; } } \\ No newline at end of file", "text_2": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; _currInputRowStart = start ; / / If we have offset , need to omit that from byte offset , so : _currInputProcessed = - start ; _bufferRecyclable = bufferRecyclable ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "text_2": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "text_3": 1}
{"text_1": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "text_2": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( v1D = = null ) { return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "text_3": 1}
{"text_1": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "text_2": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "text_2": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "text_3": 1}
{"text_1": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } return ser ; } } \\ No newline at end of file", "text_2": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } } return ser ; } protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , _superClass , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } } \\ No newline at end of file", "text_2": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "text_2": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "text_3": 1}
{"text_1": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "text_2": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "text_3": 1}
{"text_1": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; return new JsonLocation ( src , - 1L , getTokenCharacterOffset ( ) , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "text_2": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; if ( _currToken = = JsonToken . FIELD_NAME ) { return new JsonLocation ( src , - 1L , _nameInputTotal , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , - 1L , _tokenInputTotal , _tokenInputRow , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdReferenceProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "text_2": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdReferenceProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "text_2": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "text_3": 1}
{"text_1": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "text_2": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "text_3": 1}
{"text_1": "} else if ( len = = 0 ) { return 0 ; } else { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } return base64 . readResults ( b , offset , len ) ; } } } \\ No newline at end of file", "text_2": "} else if ( len = = 0 ) { return 0 ; } else { int readLen = 0 ; while ( readLen = = 0 ) { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } readLen = base64 . readResults ( b , offset , len ) ; } return readLen ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } } \\ No newline at end of file", "text_2": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; }", "text_2": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; } + iter ;", "text_3": 1}
{"text_1": "public class test { public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : }", "text_2": "public class test { public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } public String valueToString ( Object value ) { throw new IllegalStateException ( ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; if ( ! _verifyBigDecimalRange ( gen , bd ) ) { final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "text_3": 1}
{"text_1": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "text_2": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "text_3": 1}
{"text_1": "public class test { public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } } \\ No newline at end of file", "text_2": "public class test { public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * 6D - 15D ) + 10D ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "text_2": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "text_3": 1}
{"text_1": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "text_2": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "text_3": 1}
{"text_1": "public class test { protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , e . getMessage ( ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "text_2": "public class test { protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , ClassUtil . exceptionMessage ( e ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( re ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "text_3": 1}
{"text_1": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "text_2": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants if ( t ! = JsonToken . END_OBJECT ) { ctxt . reportWrongTokenException ( this , JsonToken . END_OBJECT , \" Attempted to unwrap ' % s ' value \" , handledType ( ) . getName ( ) ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "text_3": 1}
{"text_1": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "text_2": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "text_3": 1}
{"text_1": "public class test { boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . nodeName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . nodeName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . nodeName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . nodeName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . nodeName ( ) . equals ( b . nodeName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . nodeName ( ) ) ; / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . nodeName ( ) , nodeNames ) | | next . nodeName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . nodeName ( ) , elNames ) ) break ; } } private Tag ( String tagName ) { this . tagName = tagName ; } } \\ No newline at end of file", "text_2": "public class test { public String normalName ( ) { return tag . normalName ( ) ; } boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . normalName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . normalName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . normalName ( ) . equals ( b . normalName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . normalName ( ) ) ; / / todo : avoid fostering here ? / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) | | next . normalName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } } private Tag ( String tagName ) { this . tagName = tagName ; normalName = Normalizer . lowerCase ( tagName ) ; } public String normalName ( ) { return normalName ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_2": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_3": 1}
{"text_1": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "text_2": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "text_3": 1}
{"text_1": "public class test { void addNumber ( double x ) { / / This is not pretty printing . This is to prevent misparsing of x - - 4 as / / x - - 4 ( which is a syntax error ) . add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; }  } } \\ No newline at end of file", "text_2": "public class test { static boolean isNegativeZero ( double x ) { return x = = 0 . 0 & & Math . copySign ( 1 , x ) = = - 1 . 0 ; } void addNumber ( double x ) { / / This is not pretty printing . This is to prevent misparsing of x - - 4 as / / x - - 4 ( which is a syntax error ) . add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : } if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : return ToStringSerializer . instance ; default : }", "text_2": "public class test { public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } public String valueToString ( Object value ) { throw new IllegalStateException ( ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; if ( ! _verifyBigDecimalRange ( gen , bd ) ) { final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : } if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return NumberSerializer . bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "text_3": 1}
{"text_1": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "text_2": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( hasDecPoint | | hasExp ) { return false ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "text_3": 1}
{"text_1": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "text_2": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "text_3": 1}
{"text_1": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , null ) ; } return constructParametricType ( parametrized , pt ) ; }", "text_2": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , EMPTY_BINDINGS ) ; } return constructParametricType ( parametrized , pt ) ; }", "text_3": 1}
{"text_1": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "text_2": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "text_3": 1}
{"text_1": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref ! = null ) { objectIdInfo = objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } return objectIdInfo ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( NAME_FOR_OBJECT_REF , null , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "text_2": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref = = null ) { return objectIdInfo ; } if ( objectIdInfo = = null ) { objectIdInfo = ObjectIdInfo . empty ( ) ; } return objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } public static ObjectIdInfo empty ( ) { return EMPTY ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , null ) ; if ( objectIdInfo ! = null ) { oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "text_3": 1}
{"text_1": ": new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; } toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the", "text_2": ": new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the", "text_3": 1}
{"text_1": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "text_2": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "text_3": 1}
{"text_1": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "text_2": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "text_3": 1}
{"text_1": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "text_2": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "text_3": 1}
{"text_1": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "text_2": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "text_3": 1}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "text_2": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "text_3": 1}
{"text_1": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "text_2": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "text_3": 1}
{"text_1": "public class test { protected void setName ( String name ) { this . name = name ; } } \\ No newline at end of file", "text_2": "public class test { protected void setName ( String name ) { if ( name ! = null & & getPlatform ( ) = = PLATFORM_FAT & & name . indexOf ( \" / \" ) = = - 1 ) { name = name . replace ( ' \\ \\ ' , ' / ' ) ; } this . name = name ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "text_2": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "text_3": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "text_3": 0}
{"text_1": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_2": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_3": 0}
{"text_1": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "text_2": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } } } \\ No newline at end of file", "text_2": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "text_2": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_3": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "text_2": "final double previous = values [ index ] ; values [ index ] = missingEntries ; return previous ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_2": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_3": 0}
{"text_1": "public class test { public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , inputSigma , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "text_2": "public class test { public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; }", "text_2": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return 0 ; } else { return 0 ; }", "text_3": 0}
{"text_1": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "text_2": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "text_3": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } } return out ;", "text_3": 0}
{"text_1": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "text_2": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "text_3": 0}
{"text_1": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "text_2": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "text_3": 0}
{"text_1": "public class test { private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } sb . append ( quote ) ; return sb . toString ( ) ; } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "text_2": "public class test { static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } sb . append ( quote ) ; return sb . toString ( ) ; } private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "text_3": 0}
{"text_1": "/ / we have more points before the sign change , drop the lowest point } else { / / we have more points after sign change , drop the highest point - end ; }", "text_2": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; / / we have more points after sign change , drop the highest point }", "text_3": 0}
{"text_1": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "text_2": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "text_3": 0}
{"text_1": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "text_2": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_2": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_3": 0}
{"text_1": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "text_2": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "text_2": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "text_3": 0}
{"text_1": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; } } \\ No newline at end of file", "text_2": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "text_2": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; ensureCapacity ( size + 5 ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "text_3": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "text_3": 0}
{"text_1": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "text_2": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "text_3": 0}
{"text_1": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "text_2": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "text_3": 0}
{"text_1": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "text_2": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "text_3": 0}
{"text_1": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "text_2": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "text_3": 0}
{"text_1": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "text_2": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; dMin = Math . min ( dMin , dN1 ) ; work [ j - k ] = tmp ; } j - = 4 ;", "text_3": 0}
{"text_1": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "text_2": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "text_3": 0}
{"text_1": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "text_2": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( typeName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "text_3": 0}
{"text_1": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "text_2": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "text_3": 0}
{"text_1": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "text_2": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "text_3": 0}
{"text_1": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "text_2": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "text_2": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "text_3": 0}
{"text_1": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "text_2": "public class test { protected double getInitialDomain ( double y ) { return Math . PI ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i > j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_3": 0}
{"text_1": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "text_2": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int mIndex = 0 ; minRow = row ; } }", "text_3": 0}
{"text_1": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } } \\ No newline at end of file", "text_2": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "text_2": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "text_3": 0}
{"text_1": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "text_2": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "text_2": "public class test { public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out ! = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "text_3": 0}
{"text_1": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_2": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_3": 0}
{"text_1": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_2": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "text_3": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < 0 . 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_3": 0}
{"text_1": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "text_2": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "text_3": 0}
{"text_1": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) {", "text_2": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) {  Object key = new Integer ( style ) ; if ( locale = = null ) { locale = Locale . getDefault ( ) ; } if ( locale ! = null ) {", "text_3": 0}
{"text_1": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' :", "text_2": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' :", "text_3": 0}
{"text_1": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "text_2": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "text_3": 0}
{"text_1": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "text_2": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "text_3": 0}
{"text_1": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "text_2": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "text_3": 0}
{"text_1": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "text_2": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "text_2": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int nextr = 0 ; minRow = row ; } }", "text_3": 0}
{"text_1": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "text_2": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "text_3": 0}
{"text_1": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "text_2": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "text_2": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "public class test { public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length ! = dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; }  return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; } } \\ No newline at end of file", "text_2": "public class test { public double density ( double [ ] list ) { double m = Double . NEGATIVE_INFINITY ; for ( double x : list ) m = Math . max ( m , x ) ; return m ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; }", "text_2": "if ( str = = \" true \" ) { return true ; } if ( \" true \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" false \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" on \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" off \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" yes \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" no \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } if ( str = = null ) { return false ; } if ( StringUtils . isEmpty ( str ) ) { return false ; } return false ; }", "text_3": 0}
{"text_1": "public class test { private void handleBlockComment ( Comment comment ) {", "text_2": "public class test { private void handleBlockComment ( Comment comment ) {", "text_3": 0}
{"text_1": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "text_2": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "text_2": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "text_3": 0}
{"text_1": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "text_2": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "text_3": 0}
{"text_1": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; - i ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "text_2": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } setStateInitialized ( false ) ; return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) & & ! ( ( nextAction = = EventHandler . Action . RESET_STATE ) | | ( nextAction = = EventHandler . Action . RESET_DERIVATIVES ) ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "text_3": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_3": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "text_3": 0}
{"text_1": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; } } \\ No newline at end of file", "text_2": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "text_2": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "text_2": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "text_3": 0}
{"text_1": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "text_2": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; }", "text_2": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } if ( com . google . javascript . rhino . Node . PROPERTY_FLAG = = com . google . javascript . rhino . Node . this . first . getType ( ) ) { res = n . checkTreeEqualsImpl ( n2 ) ; } if ( res ! = null ) { return res ; }", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_3": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "text_3": 0}
{"text_1": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "text_2": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "text_3": 0}
{"text_1": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  } } \\ No newline at end of file", "text_3": 0}
{"text_1": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "text_2": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; signChangeIndex = 2 ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "text_3": 0}
{"text_1": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "text_2": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } } j - = 4 ; }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "text_2": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; }", "text_3": 0}
{"text_1": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "text_2": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( size + 4 ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "text_3": 0}
{"text_1": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "text_2": "int idx = 1 ; while ( count < index ) { count + = Math . PI / 2 . 0 ; + idx ; }", "text_3": 0}
{"text_1": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "text_2": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( states [ index ] = = FULL ) { return changeIndexSign ( index ) ; } return previous ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "text_2": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : u = - u ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "text_3": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; this . valueRange = valueRange ; return res ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "text_2": "return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "text_3": 0}
{"text_1": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "text_2": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( ( pendingEvent ) & & ( ( java . lang . Math . abs ( ( t1 - ( pendingEventTime ) ) ) ) < = ( convergence ) ) ) { return false ; } if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "text_3": 0}
{"text_1": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "text_2": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ;", "text_3": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_3": 0}
{"text_1": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "text_2": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "text_3": 0}
{"text_1": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "text_2": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_2": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_3": 0}
{"text_1": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "text_2": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "text_3": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "text_3": 0}
{"text_1": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return 3 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "text_2": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "text_3": 0}
{"text_1": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "text_2": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "text_3": 0}
{"text_1": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "text_2": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "text_3": 0}
{"text_1": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "text_2": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "text_3": 0}
{"text_1": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "text_2": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "text_3": 0}
{"text_1": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "text_2": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "text_3": 0}
{"text_1": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "text_2": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "text_3": 0}
{"text_1": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "text_3": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_3": 0}
{"text_1": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "text_2": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "text_3": 0}
{"text_1": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "text_2": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "text_2": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "text_2": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "text_3": 0}
{"text_1": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "text_2": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( tryBlock , exitType , labelName ) ; } }", "text_3": 0}
{"text_1": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "text_2": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , parseOffset ( id ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "text_2": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < 32 ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "text_2": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & this . sourceName ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "text_3": 0}
{"text_1": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "text_2": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "text_2": "public class test { public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "text_3": 0}
{"text_1": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "text_2": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "text_3": 0}
{"text_1": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "text_2": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "text_3": 0}
{"text_1": "} else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } } \\ No newline at end of file", "text_2": "} else { replacement = Node . newNumber ( value ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "text_2": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "text_3": 0}
{"text_1": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "text_2": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "text_2": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "text_2": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . LABEL_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_2": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( parent . isDo ( ) & & parent . getLastChild ( ) = = n ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_3": 0}
{"text_1": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "text_2": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "text_3": 0}
{"text_1": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "text_2": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { System . err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "text_3": 0}
{"text_1": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "text_2": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "text_3": 0}
{"text_1": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "text_2": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "text_3": 0}
{"text_1": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "text_2": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkMissingReturn = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "text_3": 0}
{"text_1": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "text_2": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "text_3": 0}
{"text_1": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "text_2": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } return ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} / / Check whether the extended interfaces have any conflicts if ( functionType . getExtendedInterfacesCount ( ) > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "text_2": "} / / Check whether the extended interfaces have any conflicts if ( typedCount > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "text_3": 0}
{"text_1": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "text_2": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "text_3": 0}
{"text_1": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "text_2": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "text_3": 0}
{"text_1": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_3": 0}
{"text_1": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "text_2": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( convergence - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "text_3": 0}
{"text_1": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "text_2": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tType = - 5 ; return true ; } return false ;", "text_3": 0}
{"text_1": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over", "text_2": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < textIndex ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; } } / / have upper - bound at 20 % increase , then let Java take over", "text_3": 0}
{"text_1": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "text_2": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "text_3": 0}
{"text_1": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "text_2": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "text_3": 0}
{"text_1": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "text_2": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "text_3": 0}
{"text_1": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { pos . setIndex ( pos . getIndex ( ) + 1 ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "text_3": 0}
{"text_1": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "text_2": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "text_3": 0}
{"text_1": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "text_3": 0}
{"text_1": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "text_2": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "text_3": 0}
{"text_1": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "text_2": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { System . out . println ( \" Writing ZoneInfoMap \" ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "text_3": 0}
{"text_1": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_3": 0}
{"text_1": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "text_3": 0}
{"text_1": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "text_2": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "text_2": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ! an . isExprResult ( ) ) continue ; int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "text_3": 0}
{"text_1": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; }", "text_2": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; return res ; } return res ; }", "text_3": 0}
{"text_1": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "text_2": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_2": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_3": 0}
{"text_1": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "text_2": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "text_3": 0}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_3": 0}
{"text_1": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "text_2": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "text_3": 0}
{"text_1": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "text_2": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "text_3": 0}
{"text_1": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "text_2": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "text_3": 0}
{"text_1": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling :", "text_2": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { } / / 2 . apply Bland ' s rule to prevent cycling :", "text_3": 0}
{"text_1": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "text_2": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) & & id = = null ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "text_3": 0}
{"text_1": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_3": 0}
{"text_1": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "text_2": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "text_3": 0}
{"text_1": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "text_2": "public class test { public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "text_2": "public class test { public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "text_3": 0}
{"text_1": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "text_2": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p = = 1 . 0 ) { return upper ; } } }", "text_3": 0}
{"text_1": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "text_2": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . weekyear ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "text_3": 0}
{"text_1": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "text_2": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "text_3": 0}
{"text_1": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "text_2": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "text_3": 0}
{"text_1": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "text_2": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_3": 0}
{"text_1": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "text_2": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "text_3": 0}
{"text_1": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_2": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "text_3": 0}
{"text_1": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_3": 0}
{"text_1": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "text_2": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "text_3": 0}
{"text_1": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "text_2": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . toMaybeEnumElementType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "text_3": 0}
{"text_1": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { finallyMap . put ( lastJump , null ) ; } } } \\ No newline at end of file", "text_2": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { if ( com . google . javascript . jscomp . ControlFlowAnalysis . this . shouldTraverseFunctions ) { finallyMap . put ( lastJump , null ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "text_2": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_2": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_3": 0}
{"text_1": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "text_2": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_3": 0}
{"text_1": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "text_2": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "text_3": 0}
{"text_1": "/ / check convergence return ; } }", "text_2": "/ / check convergence return ; } return ; }", "text_3": 0}
{"text_1": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "text_2": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "text_3": 0}
{"text_1": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_2": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "text_2": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . float sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "text_3": 0}
{"text_1": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "text_2": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "text_3": 0}
{"text_1": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "text_2": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "text_3": 0}
{"text_1": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "text_2": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "public class test { private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_2": "public class test { private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "text_3": 0}
{"text_1": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "text_2": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( 0 , split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "text_3": 0}
{"text_1": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_2": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "text_3": 0}
{"text_1": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "text_2": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "text_3": 0}
{"text_1": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "text_2": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return StrictMath . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "text_3": 0}
{"text_1": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "text_2": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "text_3": 0}
{"text_1": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "text_2": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "text_2": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) {  } else { repaired [ i ] = x [ i ] ; }", "text_3": 0}
