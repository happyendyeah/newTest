{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } return state ;", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; if ( owner ! = null ) { entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } } return state ;", "label": 1}
{"text_1": "included annotations . add ( a ) ; } } } }", "text_2": "included annotations . add ( a ) ; } } } } }", "label": 1}
{"text_1": "} } } else { set result ( x , ( goal type = = goal type . maximize ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new max iterations exceeded exception ( maximal iteration count ) ; } }", "text_2": "} } } else { set function value ( is minim ? fx : - fx ) ; return x ; } increment iterations counter ( ) ; } } }", "label": 1}
{"text_1": "public double get function value ( ) { return optimizer . get function value ( ) ; } public double get result ( ) { return optimizer . get result ( ) ; }", "text_2": "public double get function value ( ) { return optima values [ NUMLITERAL ] ; } public double get result ( ) { return optima [ NUMLITERAL ] ; }", "label": 1}
{"text_1": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 1}
{"text_1": "int u = p ; int v = q ; if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "int u = p ; int v = q ; if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { if ( ( u = = integer . min value ) | | ( v = = integer . min value ) ) { throw math runtime exception . create arithmetic exception ( \" STRINGLITERAL \" , new object [ ] { p , q } ) ; } return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 1}
{"text_1": "} if ( max cosine < = ortho tolerance ) { return current ; }", "text_2": "} if ( max cosine < = ortho tolerance ) { update residuals and cost ( ) ; current = new vectorial point value pair ( point , objective ) ; return current ; }", "label": 1}
{"text_1": "if ( divisor . is zero ) { return is zero ? na n : inf ; } if ( divisor . is infinite ( ) & & ! is infinite ( ) ) {", "text_2": "if ( divisor . is zero ) { return na n ; } if ( divisor . is infinite ( ) & & ! is infinite ( ) ) {", "label": 1}
{"text_1": "private final transient boolean is infinite ;", "text_2": "private final transient boolean is infinite ; private final transient boolean is zero ;", "label": 1}
{"text_1": "* @ return the square - root of the weight matrix . * / private real matrix square root ( real matrix m ) { final eigen decomposition dec = new eigen decomposition ( m ) ; return dec . get square root ( ) ; } }", "text_2": "* @ return the square - root of the weight matrix . * / private real matrix square root ( real matrix m ) { if ( m instanceof diagonal matrix ) { final int dim = m . get row dimension ( ) ; final real matrix sqrt m = new diagonal matrix ( dim ) ; for ( int i = NUMLITERAL ; i < dim ; i + + ) { sqrt m . set entry ( i , i , fast math . sqrt ( m . get entry ( i , i ) ) ) ; } return sqrt m ; } else { final eigen decomposition dec = new eigen decomposition ( m ) ; return dec . get square root ( ) ; } } }", "label": 1}
{"text_1": "* @ return the square - root of the weight matrix . * / private real matrix square root ( real matrix m ) { final eigen decomposition dec = new eigen decomposition ( m ) ; return dec . get square root ( ) ; } }", "text_2": "* @ return the square - root of the weight matrix . * / private real matrix square root ( real matrix m ) { if ( m instanceof diagonal matrix ) { final int dim = m . get row dimension ( ) ; final real matrix sqrt m = new diagonal matrix ( dim ) ; for ( int i = NUMLITERAL ; i < dim ; i + + ) { sqrt m . set entry ( i , i , fast math . sqrt ( m . get entry ( i , i ) ) ) ; } return sqrt m ; } else { final eigen decomposition dec = new eigen decomposition ( m ) ; return dec . get square root ( ) ; } } }", "label": 1}
{"text_1": "long instant millis = instant . get millis ( ) ; chronology chrono = instant . get chronology ( ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; int default year = chrono . year ( ) . get ( instant local ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "text_2": "long instant millis = instant . get millis ( ) ; chronology chrono = instant . get chronology ( ) ; int default year = date time utils . get chronology ( chrono ) . year ( ) . get ( instant millis ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "label": 1}
{"text_1": "chrono = select chronology ( chrono ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , i default year ) ; int new pos = parser . parse into ( bucket , text , position ) ; instant . set millis ( bucket . compute millis ( false , text ) ) ; if ( i offset parsed & & bucket . get offset integer ( ) ! = null ) {", "text_2": "chrono = select chronology ( chrono ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , chrono . year ( ) . get ( instant local ) ) ; int new pos = parser . parse into ( bucket , text , position ) ; instant . set millis ( bucket . compute millis ( false , text ) ) ; if ( i offset parsed & & bucket . get offset integer ( ) ! = null ) {", "label": 1}
{"text_1": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "text_2": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this . size ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "label": 1}
{"text_1": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "text_2": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { if ( exp pos > str . length ( ) ) { throw new number format exception ( str + \" STRINGLITERAL \" ) ; } mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "label": 1}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } return new big decimal ( str ) ; }", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . trim ( ) . starts with ( \" STRINGLITERAL \" ) ) { throw new number format exception ( str + \" STRINGLITERAL \" ) ; } return new big decimal ( str ) ; }", "label": 1}
{"text_1": "return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { return create integer ( str ) ; } char last char = str . char at ( str . length ( ) - NUMLITERAL ) ;", "text_2": "return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { return create integer ( str ) ; } char last char = str . char at ( str . length ( ) - NUMLITERAL ) ;", "label": 1}
{"text_1": "return NUMLITERAL ; } out . write ( entity value ) ; return NUMLITERAL + ( end - start ) + ( is hex ? NUMLITERAL : NUMLITERAL ) + NUMLITERAL ; } return NUMLITERAL ;", "text_2": "return NUMLITERAL ; } if ( entity value > HEXLITERAL ) { char [ ] chrs = character . to chars ( entity value ) ; out . write ( chrs [ NUMLITERAL ] ) ; out . write ( chrs [ NUMLITERAL ] ) ; } else { out . write ( entity value ) ; } return NUMLITERAL + ( end - start ) + ( is hex ? NUMLITERAL : NUMLITERAL ) + NUMLITERAL ; } return NUMLITERAL ;", "label": 1}
{"text_1": "is hex = true ; } int end = start ; while ( input . char at ( end ) ! = ' ; ' ) { end + + ; }", "text_2": "is hex = true ; if ( start = = seq end ) { return NUMLITERAL ; } } int end = start ; while ( end < seq end & & ( ( input . char at ( end ) > = ' 0 ' & & input . char at ( end ) < = ' 9 ' ) | | ( input . char at ( end ) > = ' a ' & & input . char at ( end ) < = ' f ' ) | | ( input . char at ( end ) > = ' a ' & & input . char at ( end ) < = ' f ' ) ) ) { end + + ; }", "label": 1}
{"text_1": "} dec = null ; } if ( ! character . is digit ( last char ) ) { if ( exp pos > NUMLITERAL & & exp pos < str . length ( ) - NUMLITERAL ) { exp = str . substring ( exp pos + NUMLITERAL , str . length ( ) - NUMLITERAL ) ; } else {", "text_2": "} dec = null ; } if ( ! character . is digit ( last char ) & & last char ! = ' . ' ) { if ( exp pos > NUMLITERAL & & exp pos < str . length ( ) - NUMLITERAL ) { exp = str . substring ( exp pos + NUMLITERAL , str . length ( ) - NUMLITERAL ) ; } else {", "label": 1}
{"text_1": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp ; } return false ;", "text_2": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp & & ! has dec point ; } return false ;", "label": 1}
{"text_1": "* / private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "* / private static int greatest common divisor ( int u , int v ) { if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { if ( ( u = = integer . min value ) | | ( v = = integer . min value ) ) { throw new arithmetic exception ( \" STRINGLITERAL \" ) ; } return math . abs ( u ) + math . abs ( v ) ; } if ( math . abs ( u ) = = NUMLITERAL | | math . abs ( v ) = = NUMLITERAL ) { return NUMLITERAL ; }", "label": 1}
{"text_1": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp ; } return false ;", "text_2": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! ( has dec point ) & & ( ! has exp ) ; } return false ;", "label": 1}
{"text_1": "chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "text_2": "chart rendering info owner = plot state . get owner ( ) ; if ( owner = = null ) { return state ; } entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "label": 1}
{"text_1": "if ( state = = null ) { state = new plot rendering info ( null ) ;", "text_2": "if ( state = = null ) { if ( true ) return ; state = new plot rendering info ( null ) ;", "label": 0}
{"text_1": "} } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } } }", "label": 1}
{"text_1": "if ( str = = null ) { return null ; } if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( str = = null ) { return null ; } if ( ( string utils . is blank ( str ) ) | | ( str . starts with ( \" STRINGLITERAL \" ) ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 1}
{"text_1": "* @ throws index out of bounds exception if any index is invalid * / private void delete impl ( int start index , int end index , int len ) { system . arraycopy ( buffer , end index , buffer , start index , size - end index ) ; size - = len ; }", "text_2": "* @ throws index out of bounds exception if any index is invalid * / private void delete impl ( int start index , int end index , int len ) { system . arraycopy ( buffer , end index , buffer , start index , capacity ( ) - end index ) ; size - = len ; }", "label": 0}
{"text_1": "} mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "text_2": "} mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos < NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "label": 0}
{"text_1": "return false ; } if ( chars [ i ] = = ' . ' ) { if ( has dec point | | has exp ) { return false ;", "text_2": "return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) ) { if ( has dec point | | has exp ) { return false ;", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) = = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return org . apache . commons . lang3 . math . number utils . create big decimal ( str ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 1}
{"text_1": "| | chars [ i ] = = ' f ' ) ) { return found digit ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) {", "text_2": "| | chars [ i ] = = ' f ' ) ) { return found digit ; } if ( has dec point | | has exp ) { return false ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) {", "label": 1}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { if ( v > NUMLITERAL ) { v = - v ; }", "label": 1}
{"text_1": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; }", "text_2": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str ; } else { mant = str ; }", "label": 0}
{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } return state ;", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; if ( owner ! = null ) { entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } } return state ;", "label": 1}
{"text_1": "dataset utilities . find range bounds ( d ) ) ; } } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "text_2": "dataset utilities . find range bounds ( d ) ) ; } } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "label": 1}
{"text_1": "} } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } } }", "label": 1}
{"text_1": "boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | b2 ) { return ; }", "text_2": "boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | ( get renderer ( ) ! = null ) ) { return ; }", "label": 0}
{"text_1": "int u = p ; int v = q ; if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "int u = p ; int v = q ; if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { if ( u = = integer . min value ) { throw new arithmetic exception ( ) ; } if ( v = = integer . min value ) { throw new arithmetic exception ( ) ; } return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 1}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { if ( str . starts with ( \" STRINGLITERAL \" ) = = true ) { throw new number format exception ( ) ; } return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 1}
{"text_1": "return ! allow signs & & found digit ; } }", "text_2": "return ! allow signs & & found digit ; } }", "label": 1}
{"text_1": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; }", "text_2": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , str . length ( ) - NUMLITERAL ) ; } else { mant = str ; }", "label": 0}
{"text_1": "} default : throw new number format exception ( str + \" STRINGLITERAL \" ) ; } } else {", "text_2": "} default : return create integer ( str ) ; } } else {", "label": 0}
{"text_1": "} if ( divisor = = NUMLITERAL d ) { return is zero ? na n : inf ; } if ( double . is infinite ( divisor ) ) { return ! is infinite ( ) ? zero : na n ;", "text_2": "} if ( divisor = = NUMLITERAL d ) { return is zero ? na n : na n ; } if ( double . is infinite ( divisor ) ) { return ! is infinite ( ) ? zero : na n ;", "label": 1}
{"text_1": "return NUMLITERAL ; } char [ ] this buf = buffer ; for ( int i = start index ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) { return i ; }", "text_2": "return NUMLITERAL ; } char [ ] this buf = buffer ; for ( int i = start index ; i < size ; i + + ) { if ( this buf [ i ] = = ch ) { return i ; }", "label": 1}
{"text_1": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp ; } return false ;", "text_2": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! ( has dec point ) & & ( ! has exp ) ; } return false ;", "label": 1}
{"text_1": "* value * @ since NUMLITERAL * / public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = NUMLITERAL ) | | ( v = = NUMLITERAL ) ) { return ( math . abs ( u ) + math . abs ( v ) ) ; } if ( u > NUMLITERAL ) { u = - u ; } if ( v > NUMLITERAL ) { v = - v ; } int k = NUMLITERAL ; while ( ( u & NUMLITERAL ) = = NUMLITERAL & & ( v & NUMLITERAL ) = = NUMLITERAL & & k < NUMLITERAL ) { u / = NUMLITERAL ; v / = NUMLITERAL ; k + + ; } if ( k = = NUMLITERAL ) { throw math runtime exception . create arithmetic exception ( \" STRINGLITERAL \" , new object [ ] { p , q } ) ; } int t = ( ( u & NUMLITERAL ) = = NUMLITERAL ) ? v : - ( u / NUMLITERAL ) ; do { while ( ( t & NUMLITERAL ) = = NUMLITERAL ) { t / = NUMLITERAL ; } if ( t > NUMLITERAL ) { u = - t ; } else { v = t ; } t = ( v - u ) / NUMLITERAL ; } while ( t ! = NUMLITERAL ) ; return - u * ( NUMLITERAL < < k ) ; }", "text_2": "* value * @ since NUMLITERAL * / public static int gcd ( int edge inx , int property ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "* @ return true if the builder contains the character * / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; } } return false ; }", "text_2": "* @ return true if the builder contains the character * / public boolean contains ( char ch ) { return ch = = ' \\u0622 ' | | ch = = ' \\u0623 ' | | ch = = ' \\u0625 ' | | ch = = ' \\u0627 ' ; }", "label": 0}
{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ;", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner ! = null ? owner . get entity collection ( ) : null ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ;", "label": 1}
{"text_1": "} } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) { xy annotation a = ( xy annotation ) i . next ( ) ; if ( a instanceof xy annotation bounds info ) { included annotations . add ( a ) ; } } } } }", "label": 1}
{"text_1": "if ( str = = null ) { return null ; } if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( str = = null ) { return null ; } if ( ( string utils . is blank ( str ) ) | | ( str . starts with ( \" STRINGLITERAL \" ) ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 1}
{"text_1": "boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | b2 ) { return ; }", "text_2": "boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | ( get renderer ( ) ! = null ) ) { return ; }", "label": 0}
{"text_1": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; }", "text_2": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , integer zero ) ; } else { mant = str ; }", "label": 0}
{"text_1": "return false ; } if ( chars [ i ] = = ' . ' ) { if ( has dec point | | has exp ) { return false ;", "text_2": "return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) ) { if ( has dec point | | has exp ) { return false ;", "label": 0}
{"text_1": "+ insets . get right ( ) ) ; } if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "text_2": "+ insets . get right ( ) ) ; } if ( plot state ! = null & & hotspot ! = null & & ( null = = plot state . get owner ( ) ) ! = true ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "label": 1}
{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot ,", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot ,", "label": 1}
{"text_1": "+ insets . get right ( ) ) ; } if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ;", "text_2": "+ insets . get right ( ) ) ; } hotspot = null ; if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ;", "label": 0}
{"text_1": "+ insets . get right ( ) ) ; } if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "text_2": "+ insets . get right ( ) ) ; } if ( ( hotspot ! = null & & plot state ! = null ) ! = true & & plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "label": 0}
{"text_1": "outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) { if ( str . char at ( j ) ! = this buf [ i + j ] ) { continue outer ; } }", "text_2": "outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) { if ( str . char at ( j ) ! = this buf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0}
{"text_1": "outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) { if ( str . char at ( j ) ! = this buf [ i + j ] ) { continue outer ; } }", "text_2": "outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) { if ( str . char at ( j ) ! = this buf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0}
{"text_1": "dataset utilities . find range bounds ( d ) ) ; } } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "text_2": "dataset utilities . find range bounds ( d ) ) ; } } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "label": 1}
{"text_1": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "text_2": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < size ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "label": 1}
{"text_1": "state = new plot rendering info ( null ) ; } state . set plot area ( area ) ;", "text_2": "state = new plot rendering info ( null ) ; return ; } state . set plot area ( area ) ;", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( NUMLITERAL * u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 0}
{"text_1": "string dec ; string exp ; int dec pos = str . index of ( ' . ' ) ; int exp pos = str . index of ( ' e ' ) + str . index of ( ' e ' ) + NUMLITERAL ; if ( dec pos > NUMLITERAL ) {", "text_2": "string dec ; string exp ; int dec pos = str . index of ( ' . ' ) ; int exp pos = str . index of ( str , ' e ' ) + str . index of ( ' e ' ) + NUMLITERAL ; if ( dec pos > NUMLITERAL ) {", "label": 0}
{"text_1": "x norm = math . sqrt ( x norm ) ; } else { cost = previous cost ; for ( int j = NUMLITERAL ; j < solved cols ; + + j ) { int pj = permutation [ j ] ;", "text_2": "x norm = math . sqrt ( x norm ) ; } else { if ( ( ( math . abs ( act red ) < = cost relative tolerance ) & & ( pre red < = cost relative tolerance ) & & ( ratio < = NUMLITERAL ) ) | | ( delta < = par relative tolerance * x norm ) ) { return new vectorial point value pair ( point , objective ) ; } cost = previous cost ; for ( int j = NUMLITERAL ; j < solved cols ; + + j ) { int pj = permutation [ j ] ;", "label": 0}
{"text_1": "if ( str len = = NUMLITERAL ) { return start index ; } if ( str len > size ) { return NUMLITERAL ; } char [ ] this buf = buffer ; int len = this buf . length - str len ; outer :", "text_2": "if ( str len = = NUMLITERAL ) { return start index ; } ensure capacity ( size + NUMLITERAL ) ; char [ ] this buf = buffer ; int len = this buf . length - str len ; outer :", "label": 0}
{"text_1": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { start index = ( start index < NUMLITERAL ? NUMLITERAL : start index ) ; if ( str = = null | | start index > = size ) { return NUMLITERAL ; }", "text_2": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; system . arraycopy ( old , NUMLITERAL , buffer , NUMLITERAL , size ) ; } if ( str = = null | | start index > = size ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { start index = ( start index < NUMLITERAL ? NUMLITERAL : start index ) ; if ( str = = null | | start index > = size ) { return NUMLITERAL ; }", "text_2": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; system . arraycopy ( old , NUMLITERAL , buffer , NUMLITERAL , size ) ; } if ( str = = null | | start index > = size ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "* @ return true if the builder contains the character * / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) {", "text_2": "* @ return true if the builder contains the character * / public boolean contains ( char ch ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; system . arraycopy ( old , NUMLITERAL , buffer , NUMLITERAL , size ) ; } char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) {", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return create long ( str ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ; if ( str . starts with ( \" STRINGLITERAL \" ) ) { hex digits - - ; } if ( hex digits > NUMLITERAL ) { return create long ( str ) ; } return create integer ( str ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ; if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ; if ( str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return short . parse short ( str ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str = = null ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 0}
{"text_1": "} default : throw new number format exception ( str + \" STRINGLITERAL \" ) ; } } else {", "text_2": "} default : return create integer ( str ) ; } } else {", "label": 0}
{"text_1": "} default : throw new number format exception ( str + \" STRINGLITERAL \" ) ; } } else {", "text_2": "} default : return integer . decode ( str ) ; } } else {", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { if ( u > NUMLITERAL ) { u = - u ; }", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { u = - u ;", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { if ( v > NUMLITERAL ) { v = - v ; }", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { v = - v ;", "label": 0}
{"text_1": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp ; } return false ;", "text_2": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' l ' ) { return found digit & & ! has exp & & ! has dec point ; } return false ;", "label": 1}
{"text_1": "draw background ( g2 , data area ) ; } map axis state map = draw axes ( g2 , area , data area , state ) ; shape saved clip = g2 . get clip ( ) ;", "text_2": "draw background ( g2 , data area ) ; } map axis state map = draw axes ( g2 , area , data area , null ) ; shape saved clip = g2 . get clip ( ) ;", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( system . current time millis ( ) * u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 0}
{"text_1": "chronology chrono = instant . get chronology ( ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; int default year = chrono . year ( ) . get ( instant local ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "text_2": "chronology chrono = instant . get chronology ( ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; int default year = chrono . with utc ( ) . year ( ) . get ( instant local ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "label": 0}
{"text_1": "* @ throws index out of bounds exception if any index is invalid * / private void delete impl ( int start index , int end index , int len ) { system . arraycopy ( buffer , end index , buffer , start index , size - end index ) ; size - = len ; }", "text_2": "* @ throws index out of bounds exception if any index is invalid * / private void delete impl ( int start index , int end index , int len ) { system . arraycopy ( buffer , end index , buffer , start index , size - start index - NUMLITERAL ) ; size - = len ; }", "label": 0}
{"text_1": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; }", "text_2": "mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , dec pos + NUMLITERAL ) ; } else { mant = str ; }", "label": 0}
{"text_1": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( ( new string ( ) ) . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) {", "label": 0}
{"text_1": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "private static int greatest common divisor ( int u , int v ) { if ( math . abs ( v ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ; if ( str . starts with ( \" STRINGLITERAL \" ) ) { hex digits - - ; }", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { } if ( ( ( ( str . starts with ( \" STRINGLITERAL \" ) ) | | ( str . starts with ( \" STRINGLITERAL \" ) ) ) | | ( str . starts with ( \" STRINGLITERAL \" ) ) ) | | ( str . starts with ( \" STRINGLITERAL \" ) ) ) { int hex digits = ( str . length ( ) ) - NUMLITERAL ; if ( str . starts with ( \" STRINGLITERAL \" ) ) { hex digits - - ; }", "label": 1}
{"text_1": "dec = str . substring ( dec pos + NUMLITERAL ) ; } mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; } dec = null ; }", "text_2": "dec = str . substring ( dec pos + NUMLITERAL ) ; } mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( false ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; } dec = null ; }", "label": 0}
{"text_1": "* @ return the greatest common divisor , never zero * / private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "* @ return the greatest common divisor , never zero * / private static int greatest common divisor ( int u , int v ) { if ( false ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "chronology chrono = instant . get chronology ( ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; int default year = chrono . year ( ) . get ( instant local ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "text_2": "chronology chrono = instant . get chronology ( ) ; long instant local = instant millis + chrono . get zone ( ) . get offset ( instant millis ) ; chrono = select chronology ( chrono ) ; int default year = chrono . year ( ) . get ( instant millis ) ; date time parser bucket bucket = new date time parser bucket ( instant local , chrono , i locale , i pivot year , default year ) ;", "label": 1}
{"text_1": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < this buf . length ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "text_2": "* / public boolean contains ( char ch ) { char [ ] this buf = buffer ; for ( int i = NUMLITERAL ; i < size ; i + + ) { if ( this buf [ i ] = = ch ) { return true ; }", "label": 1}
{"text_1": "if ( str = = null ) { return null ; } if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; }", "text_2": "if ( str = = null ) { return null ; } str = str . to lower case ( ) ; if ( string utils . is blank ( str ) ) { throw new number format exception ( \" STRINGLITERAL \" ) ; }", "label": 1}
{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } return state ; }", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; if ( owner ! = null ) { entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) { entities . add ( new axis label entity ( this , hotspot , this . label tool tip , this . label URL ) ) ; } } } return state ; }", "label": 1}
{"text_1": "dataset utilities . find range bounds ( d ) ) ; } } collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "text_2": "dataset utilities . find range bounds ( d ) ) ; } } if ( r ! = null ) { collection c = r . get annotations ( ) ; iterator i = c . iterator ( ) ; while ( i . has next ( ) ) {", "label": 1}
{"text_1": "plot state parent state , plot rendering info state ) { boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | b2 ) { return ; } if ( state = = null ) {", "text_2": "plot state parent state , plot rendering info state ) { boolean b1 = ( area . get width ( ) ) < = ( minimum width to draw ) ; boolean b2 = ( area . get height ( ) ) < = ( minimum height to draw ) ; if ( ( ! b1 ) | | b2 ) { return ; } if ( state = = null ) {", "label": 0}
{"text_1": "dec = str . substring ( dec pos + NUMLITERAL ) ; } mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; } dec = null ; }", "text_2": "dec = str . substring ( dec pos + NUMLITERAL ) ; } mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos < ( NUMLITERAL ) ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ; } dec = null ; }", "label": 0}
{"text_1": "* @ return the greatest common divisor , never zero * / private static int greatest common divisor ( int u , int v ) { if ( math . abs ( u ) < = NUMLITERAL | | math . abs ( v ) < = NUMLITERAL ) { return NUMLITERAL ; }", "text_2": "* @ return the greatest common divisor , never zero * / private static int greatest common divisor ( int u , int v ) { if ( ( ( math . abs ( u ) ) < = NUMLITERAL ) & & ( ( math . abs ( v ) ) < = NUMLITERAL ) ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return org . apache . commons . math3 . complex . complex . inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "text_2": "return offset local ; } } } else if ( offset local > = NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa / fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "text_2": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < = min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "label": 0}
{"text_1": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "* @ see # remove row ( comparable ) * / public void remove column ( comparable column key ) { iterator iterator = this . rows . iterator ( ) ; while ( iterator . has next ( ) ) { default keyed values row data = ( default keyed values ) iterator . next ( ) ; row data . remove value ( column key ) ; } this . column keys . remove ( column key ) ; }", "text_2": "* @ see # remove row ( comparable ) * / public void remove column ( comparable column key ) { if ( column key = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( ! this . column keys . contains ( column key ) ) { throw new unknown key exception ( \" STRINGLITERAL \" + column key ) ; } iterator iterator = this . rows . iterator ( ) ; while ( iterator . has next ( ) ) { default keyed values row data = ( default keyed values ) iterator . next ( ) ; int index = row data . get index ( column key ) ; if ( index > = NUMLITERAL ) { row data . remove value ( column key ) ; } } this . column keys . remove ( column key ) ; }", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} if ( this . max middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) {", "text_2": "} if ( this . max middle index > = NUMLITERAL ) { long s = get data item ( this . max middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . max middle index ) . get period ( ) . get end ( ) . get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) {", "label": 1}
{"text_1": "} else { this . series keys = null ; this . category keys = null ; } }", "text_2": "} else { this . series keys = new comparable [ NUMLITERAL ] ; this . category keys = new comparable [ NUMLITERAL ] ; } }", "label": 1}
{"text_1": "if ( ! ( obj instanceof shape list ) ) { return false ; } return super . equals ( obj ) ; }", "text_2": "if ( ! ( obj instanceof shape list ) ) { return false ; } shape list that = ( shape list ) obj ; int list size = size ( ) ; for ( int i = NUMLITERAL ; i < list size ; i + + ) { if ( ! shape utilities . equal ( ( shape ) get ( i ) , ( shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { return this . domain axes . index of ( axis ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { if ( axis = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return this . domain axes . index of ( axis ) ; }", "label": 1}
{"text_1": "* / public week ( date time , time zone zone ) { this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "* / public week ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }", "label": 1}
{"text_1": "this . minimum range value row = r ; this . minimum range value column = c ; } this . range bounds = new range ( this . minimum range value , this . maximum range value ) ;", "text_2": "this . minimum range value row = r ; this . minimum range value column = c ; } } this . range bounds = new range ( this . minimum range value , this . maximum range value ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "* * @ since NUMLITERAL NUMLITERAL * /", "text_2": "* * @ since NUMLITERAL NUMLITERAL * / public boolean equals ( object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof min max category renderer ) ) { return false ; } min max category renderer that = ( min max category renderer ) obj ; if ( this . plot lines ! = that . plot lines ) { return false ; } if ( ! paint utilities . equal ( this . group paint , that . group paint ) ) { return false ; } if ( ! this . group stroke . equals ( that . group stroke ) ) { return false ; } return super . equals ( obj ) ; }", "label": 1}
{"text_1": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ;", "text_2": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; set dataset ( dataset ) ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ;", "label": 1}
{"text_1": "h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) { rectangle constraint c4 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) - w [ NUMLITERAL ] ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . right block . arrange ( g2 , c4 ) ;", "text_2": "h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) { rectangle constraint c4 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , math . max ( constraint . get width ( ) - w [ NUMLITERAL ] , NUMLITERAL ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . right block . arrange ( g2 , c4 ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "* / public void remove row ( comparable row key ) { int index = get row index ( row key ) ; remove row ( index ) ; }", "text_2": "* / public void remove row ( comparable row key ) { int index = get row index ( row key ) ; if ( index < NUMLITERAL ) { throw new unknown key exception ( \" STRINGLITERAL \" + row key + \" STRINGLITERAL \" ) ; } remove row ( index ) ; }", "label": 1}
{"text_1": "} double value delta = dataset . get std dev value ( row , column ) . double value ( ) ; double high val = range axis . value to java2d ( mean value . double value ( ) + value delta , data area , y axis location ) ; double low val = range axis . value to java2d ( mean value . double value ( )", "text_2": "} number n = dataset . get std dev value ( row , column ) ; if ( n ! = null ) { double value delta = n . double value ( ) ; double high val = range axis . value to java2d ( mean value . double value ( ) + value delta , data area , y axis location ) ; double low val = range axis . value to java2d ( mean value . double value ( )", "label": 1}
{"text_1": "import java . io . serializable ; import org . apache . commons . math . math exception ; import org . apache . commons . math . math runtime exception ; import org . apache . commons . math . exception . util . localized formats ; import org . apache . commons . math . special . gamma ; import org . apache . commons . math . util . math utils ;", "text_2": "import java . io . serializable ; import org . apache . commons . math . math exception ; import org . apache . commons . math . exception . not strictly positive exception ; import org . apache . commons . math . exception . util . localized formats ; import org . apache . commons . math . special . gamma ; import org . apache . commons . math . util . math utils ;", "label": 1}
{"text_1": "* @ return initial domain value * / protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "* @ return initial domain value * / protected double get initial domain ( double p ) { double ret = NUMLITERAL ; double d = get denominator degrees of freedom ( ) ; if ( d > NUMLITERAL ) { ret = d / ( d - NUMLITERAL ) ; } return ret ; }", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "* for values small enough to do exact integer computation , * return the log of the exact value * /", "text_2": "* for values small enough to do exact integer computation , * return the log of the exact value * / if ( n < NUMLITERAL ) { return math . log ( binomial coefficient ( n , k ) ) ; } if ( n < NUMLITERAL ) { return math . log ( binomial coefficient double ( n , k ) ) ; }", "label": 1}
{"text_1": "private static final long serial version uid = NUMLITERAL ; private static final double default epsilon = NUMLITERAL ; private static double [ ] lanczos =", "text_2": "private static final long serial version uid = NUMLITERAL ; private static final double default epsilon = NUMLITERAL ; private static double [ ] lanczos =", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( tree . get cut ( ) = = null & & ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 1}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } double sum sq = NUMLITERAL d ; double dev = NUMLITERAL d ; for ( int i = NUMLITERAL ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sum sq + = dev * dev / expected [ i ] ; } return sum sq ; }", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } double sum expected = NUMLITERAL d ; double sum observed = NUMLITERAL d ; for ( int i = NUMLITERAL ; i < observed . length ; i + + ) { sum expected + = expected [ i ] ; sum observed + = observed [ i ] ; } double ratio = NUMLITERAL d ; boolean rescale = false ; if ( math . abs ( sum expected - sum observed ) > NUMLITERAL ) { ratio = sum observed / sum expected ; rescale = true ; } double sum sq = NUMLITERAL d ; double dev = NUMLITERAL d ; for ( int i = NUMLITERAL ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sum sq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sum sq + = dev * dev / expected [ i ] ; } } return sum sq ; }", "label": 1}
{"text_1": "} else { double r = correlation matrix . get entry ( i , j ) ; double t = math . abs ( r * math . sqrt ( ( n obs - NUMLITERAL ) / ( NUMLITERAL - r * r ) ) ) ; out [ i ] [ j ] = NUMLITERAL * ( NUMLITERAL - t distribution . cumulative probability ( t ) ) ; } } }", "text_2": "} else { double r = correlation matrix . get entry ( i , j ) ; double t = math . abs ( r * math . sqrt ( ( n obs - NUMLITERAL ) / ( NUMLITERAL - r * r ) ) ) ; out [ i ] [ j ] = NUMLITERAL * t distribution . cumulative probability ( - t ) ; } } }", "label": 1}
{"text_1": "indices [ i ] = idx ; } int idx = NUMLITERAL ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "text_2": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "label": 1}
{"text_1": "* @ return sum of squared errors associated with the regression model * / public double get sum squared errors ( ) { return sum yy - sum xy * sum xy / sum xx ; }", "text_2": "* @ return sum of squared errors associated with the regression model * / public double get sum squared errors ( ) { return math . max ( NUMLITERAL d , sum yy - sum xy * sum xy / sum xx ) ; }", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "if ( n < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } double log sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < = n ; i + + ) { log sum + = math . log ( ( double ) i ) ;", "text_2": "if ( n < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( n < NUMLITERAL ) { return math . log ( factorial ( n ) ) ; } double log sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < = n ; i + + ) { log sum + = math . log ( ( double ) i ) ;", "label": 1}
{"text_1": "* / public double cumulative probability ( double x ) throws math exception { final double dev = x - mean ; try { return NUMLITERAL * ( NUMLITERAL + erf . erf ( ( dev ) / ( standard deviation * fast math . sqrt ( NUMLITERAL ) ) ) ) ; } catch ( max iterations exceeded exception ex ) { if ( x < ( mean - NUMLITERAL * standard deviation ) ) { return NUMLITERAL ; } else if ( x > ( mean + NUMLITERAL * standard deviation ) ) { return NUMLITERAL ; } else { throw ex ; } } }", "text_2": "* / public double cumulative probability ( double x ) throws math exception { final double dev = x - mean ; if ( fast math . abs ( dev ) > NUMLITERAL * standard deviation ) { return dev < NUMLITERAL ? NUMLITERAL d : NUMLITERAL d ; } return NUMLITERAL * ( NUMLITERAL + erf . erf ( ( dev ) / ( standard deviation * fast math . sqrt ( NUMLITERAL ) ) ) ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* @ return the original objective variables , possibly repaired . * / public double [ ] repair and decode ( final double [ ] x ) { return decode ( x ) ; }", "text_2": "* @ return the original objective variables , possibly repaired . * / public double [ ] repair and decode ( final double [ ] x ) { return boundaries ! = null & & is repair mode ? decode ( repair ( x ) ) : decode ( x ) ; }", "label": 1}
{"text_1": "double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ NUMLITERAL ] [ i ] ; } return res ; }", "text_2": "double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; }", "label": 1}
{"text_1": "* @ return a new instance , with reversed direction * / public line revert ( ) { final line reverted = new line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "text_2": "* @ return a new instance , with reversed direction * / public line revert ( ) { final line reverted = new line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "label": 1}
{"text_1": "throw new dimension mismatch exception ( vals . length , dim ) ; } return fast math . pow ( NUMLITERAL * fast math . pi , - dim / NUMLITERAL ) * fast math . pow ( covariance matrix determinant , NUMLITERAL ) * get exponent term ( vals ) ; }", "text_2": "throw new dimension mismatch exception ( vals . length , dim ) ; } return fast math . pow ( NUMLITERAL * fast math . pi , NUMLITERAL * dim ) * fast math . pow ( covariance matrix determinant , NUMLITERAL ) * get exponent term ( vals ) ; }", "label": 1}
{"text_1": "final double [ ] event y = interpolator . get interpolated state ( ) . clone ( ) ; current event . step accepted ( event t , event y ) ; is last step = current event . stop ( ) ; for ( final step handler handler : step handlers ) {", "text_2": "final double [ ] event y = interpolator . get interpolated state ( ) . clone ( ) ; for ( final event state state : events states ) { state . step accepted ( event t , event y ) ; is last step = is last step | | state . stop ( ) ; } for ( final step handler handler : step handlers ) {", "label": 1}
{"text_1": "if ( x > NUMLITERAL ) { return NUMLITERAL * exp ( x ) ; } if ( x < NUMLITERAL ) { return NUMLITERAL * exp ( - x ) ; } final double hi prec [ ] = new double [ NUMLITERAL ] ;", "text_2": "if ( x > NUMLITERAL ) { if ( x > = log max value ) { final double t = exp ( NUMLITERAL * x ) ; return ( NUMLITERAL * t ) * t ; } else { return NUMLITERAL * exp ( x ) ; } } else if ( x < NUMLITERAL ) { if ( x < = - log max value ) { final double t = exp ( NUMLITERAL * x ) ; return ( NUMLITERAL * t ) * t ; } else { return NUMLITERAL * exp ( - x ) ; } } final double hi prec [ ] = new double [ NUMLITERAL ] ;", "label": 1}
{"text_1": "continue ; } integer basic row = get basic row ( col index ) ; if ( basic rows . contains ( basic row ) ) { coefficients [ i ] = NUMLITERAL - ( restrict to non negative ? NUMLITERAL : most negative ) ;", "text_2": "continue ; } integer basic row = get basic row ( col index ) ; if ( basic row ! = null & & basic row = = NUMLITERAL ) { coefficients [ i ] = NUMLITERAL ; } else if ( basic rows . contains ( basic row ) ) { coefficients [ i ] = NUMLITERAL - ( restrict to non negative ? NUMLITERAL : most negative ) ;", "label": 1}
{"text_1": "* / @ deprecated public void add value ( object v ) { add value ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public void add value ( object v ) { if ( v instanceof comparable < ? > ) { add value ( ( comparable < ? > ) v ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } }", "label": 1}
{"text_1": "return solve ( f , initial , y initial , max , y max , initial , y initial ) ; } return solve ( f , min , y min , max , y max , initial , y initial ) ;", "text_2": "return solve ( f , initial , y initial , max , y max , initial , y initial ) ; } if ( y min * y max > NUMLITERAL ) { throw math runtime exception . create illegal argument exception ( non bracketing message , min , max , y min , y max ) ; } return solve ( f , min , y min , max , y max , initial , y initial ) ;", "label": 1}
{"text_1": "private integer get basic row ( final int col ) { integer row = null ; for ( int i = get num objective functions ( ) ; i < get height ( ) ; i + + ) { if ( ! math utils . equals ( get entry ( i , col ) , NUMLITERAL , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "text_2": "private integer get basic row ( final int col ) { integer row = null ; for ( int i = get num objective functions ( ) ; i < get height ( ) ; i + + ) { if ( math utils . equals ( get entry ( i , col ) , NUMLITERAL , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! math utils . equals ( get entry ( i , col ) , NUMLITERAL , epsilon ) ) { return null ; } } return row ;", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * ( n - NUMLITERAL ) ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "} } return min row ; } return min ratio positions . get ( NUMLITERAL ) ; }", "text_2": "} } return min row ; } } return min ratio positions . get ( NUMLITERAL ) ; }", "label": 1}
{"text_1": "* @ return product of this and x * / public dfp multiply ( final int x ) { return multiply fast ( x ) ; }", "text_2": "* @ return product of this and x * / public dfp multiply ( final int x ) { if ( x > = NUMLITERAL & & x < radix ) { return multiply fast ( x ) ; } else { return multiply ( new instance ( x ) ) ; } }", "label": 1}
{"text_1": "if ( ( fast math . abs ( p2 ) > overflow ) | | ( fast math . abs ( q2 ) > overflow ) ) { throw new fraction conversion exception ( value , p2 , q2 ) ; }", "text_2": "if ( ( fast math . abs ( p2 ) > overflow ) | | ( fast math . abs ( q2 ) > overflow ) ) { if ( epsilon = = NUMLITERAL & & fast math . abs ( q1 ) < max denominator ) { break ; } throw new fraction conversion exception ( value , p2 , q2 ) ; }", "label": 1}
{"text_1": "} }", "text_2": "} result [ result offset ] = fast math . atan2 ( y [ y offset ] , x [ x offset ] ) ; }", "label": 1}
{"text_1": "long a1 = ( long ) fast math . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new fraction conversion exception ( value , p2 , q2 ) ; }", "text_2": "long a1 = ( long ) fast math . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( fast math . abs ( p2 ) > overflow ) | | ( fast math . abs ( q2 ) > overflow ) ) { throw new fraction conversion exception ( value , p2 , q2 ) ; }", "label": 1}
{"text_1": "* @ throws not strictly positive exception if { @ code sample size } is not * positive . * / public t [ ] sample ( int sample size ) throws not strictly positive exception { if ( sample size < = NUMLITERAL ) { throw new not strictly positive exception ( localized formats . number of samples , sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "text_2": "* @ throws not strictly positive exception if { @ code sample size } is not * positive . * / public object [ ] sample ( int sample size ) throws not strictly positive exception { if ( sample size < = NUMLITERAL ) { throw new not strictly positive exception ( localized formats . number of samples , sample size ) ; } final object [ ] out = new object [ sample size ] ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "label": 1}
{"text_1": "final double [ ] [ ] c = matrix . get data ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = NUMLITERAL ; i < order ; + + i ) { index [ i ] = i ;", "text_2": "final double [ ] [ ] c = matrix . get data ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = NUMLITERAL ; i < order ; + + i ) { index [ i ] = i ;", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL ) { b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; a2 = a2 + b2 ; for ( int i4 = nn - NUMLITERAL ; i4 > = NUMLITERAL * start + NUMLITERAL + ping pong ; i4 - = NUMLITERAL ) {", "text_2": "double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL ) { b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; a2 = a2 + b2 ; for ( int i4 = nn - NUMLITERAL ; i4 > = NUMLITERAL * start + NUMLITERAL + ping pong ; i4 - = NUMLITERAL ) {", "label": 1}
{"text_1": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( y min , NUMLITERAL ) ; return result ; }", "text_2": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( min , NUMLITERAL ) ; return result ; }", "label": 1}
{"text_1": "if ( is last step ) { system . arraycopy ( event y , NUMLITERAL , y , NUMLITERAL , y . length ) ; return event t ; }", "text_2": "if ( is last step ) { system . arraycopy ( event y , NUMLITERAL , y , NUMLITERAL , y . length ) ; for ( final event state remaining : occuring events ) { remaining . step accepted ( event t , event y ) ; } return event t ; }", "label": 1}
{"text_1": "second moment . increment ( value ) ; if ( ! ( mean impl instanceof mean ) ) { mean impl . increment ( value ) ; } if ( ! ( variance impl instanceof variance ) ) { variance impl . increment ( value ) ; } if ( ! ( geo mean impl instanceof geometric mean ) ) { geo mean impl . increment ( value ) ; } n + + ;", "text_2": "second moment . increment ( value ) ; if ( mean impl ! = mean ) { mean impl . increment ( value ) ; } if ( variance impl ! = variance ) { variance impl . increment ( value ) ; } if ( geo mean impl ! = geo mean ) { geo mean impl . increment ( value ) ; } n + + ;", "label": 1}
{"text_1": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new path is explored exception ( ) ; } final int ipt minus1 = ipt ; final int jpt minus1 = jpt ; interpolation points . set entry ( nfm , ipt minus1 , interpolation points . get entry ( ipt , ipt minus1 ) ) ; interpolation points . set entry ( nfm , jpt minus1 , interpolation points . get entry ( jpt , jpt minus1 ) ) ; }", "text_2": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int ipt minus1 = ipt - NUMLITERAL ; final int jpt minus1 = jpt - NUMLITERAL ; interpolation points . set entry ( nfm , ipt minus1 , interpolation points . get entry ( ipt , ipt minus1 ) ) ; interpolation points . set entry ( nfm , jpt minus1 , interpolation points . get entry ( jpt , jpt minus1 ) ) ; }", "label": 1}
{"text_1": "@ override public double double value ( ) { double result = numerator . double value ( ) / denominator . double value ( ) ; return result ; }", "text_2": "@ override public double double value ( ) { double result = numerator . double value ( ) / denominator . double value ( ) ; if ( double . is na n ( result ) ) { int shift = math . max ( numerator . bit length ( ) , denominator . bit length ( ) ) - double . max exponent ; result = numerator . shift right ( shift ) . double value ( ) / denominator . shift right ( shift ) . double value ( ) ; } return result ; }", "label": 1}
{"text_1": "* than < tt > object < / tt > , NUMLITERAL if they are equal . * / public int compare to ( fraction object ) { double n od = double value ( ) ; double d on = object . double value ( ) ; return ( n od < d on ) ? NUMLITERAL : ( ( n od > d on ) ? + NUMLITERAL : NUMLITERAL ) ; }", "text_2": "* than < tt > object < / tt > , NUMLITERAL if they are equal . * / public int compare to ( fraction object ) { long n od = ( ( long ) numerator ) * object . denominator ; long d on = ( ( long ) denominator ) * object . numerator ; return ( n od < d on ) ? NUMLITERAL : ( ( n od > d on ) ? + NUMLITERAL : NUMLITERAL ) ; }", "label": 1}
{"text_1": "* @ return rms value * / public double get rms ( ) { double criterion = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residuals weights [ i ] ; } return math . sqrt ( criterion / rows ) ; }", "text_2": "* @ return rms value * / public double get rms ( ) { return math . sqrt ( get chi square ( ) / rows ) ; }", "label": 1}
{"text_1": "for ( int i = NUMLITERAL ; i < starts ; + + i ) { try { final double bound1 = ( i = = NUMLITERAL ) ? min : min + generator . next double ( ) * ( max - min ) ; final double bound2 = ( i = = NUMLITERAL ) ? max : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , fast math . min ( bound1 , bound2 ) , fast math . max ( bound1 , bound2 ) ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "text_2": "for ( int i = NUMLITERAL ; i < starts ; + + i ) { try { final double s = ( i = = NUMLITERAL ) ? start value : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "label": 1}
{"text_1": "if ( x = = NUMLITERAL ) { return ; }", "text_2": "if ( x = = NUMLITERAL ) { if ( ( bits & HEXLITERAL ) ! = NUMLITERAL ) { sign = NUMLITERAL ; } return ; }", "label": 1}
{"text_1": "} final int n rows = this . get row dimension ( ) ; final int n cols = this . get column dimension ( ) ; final big decimal [ ] out = new big decimal [ v . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { big decimal sum = zero ; for ( int i = NUMLITERAL ; i < n cols ; i + + ) {", "text_2": "} final int n rows = this . get row dimension ( ) ; final int n cols = this . get column dimension ( ) ; final big decimal [ ] out = new big decimal [ n rows ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { big decimal sum = zero ; for ( int i = NUMLITERAL ; i < n cols ; i + + ) {", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( is na n | | rhs . is na n ) { return na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "} step size = h new ; for ( int k = NUMLITERAL ; k < stages ; + + k ) {", "text_2": "} step size = h new ; if ( forward ) { if ( step start + step size > = t ) { step size = t - step start ; } } else { if ( step start + step size < = t ) { step size = t - step start ; } } for ( int k = NUMLITERAL ; k < stages ; + + k ) {", "label": 1}
{"text_1": "return null ; } int start index = pos . get index ( ) ;", "text_2": "return null ; } if ( num . int value ( ) < NUMLITERAL ) { pos . set index ( initial index ) ; return null ; } int start index = pos . get index ( ) ;", "label": 1}
{"text_1": "vector3d u2prime = u1 . cross product ( u3 ) ; c = k . dot product ( u2prime ) ; if ( c = = NUMLITERAL ) { k = v2su2 . cross product ( v3su3 ) ; ; c = k . dot product ( u2 . cross product ( u3 ) ) ; ; if ( c = = NUMLITERAL ) { q0 = NUMLITERAL ;", "text_2": "vector3d u2prime = u1 . cross product ( u3 ) ; c = k . dot product ( u2prime ) ; if ( c < = in plane threshold * k . get norm ( ) * u2prime . get norm ( ) ) { k = v2su2 . cross product ( v3su3 ) ; ; c = k . dot product ( u2 . cross product ( u3 ) ) ; ; if ( c < = NUMLITERAL ) { q0 = NUMLITERAL ;", "label": 1}
{"text_1": "* / public static vector3d cross product ( final vector3d v1 , final vector3d v2 ) {", "text_2": "* / public static vector3d cross product ( final vector3d v1 , final vector3d v2 ) { final double n1 = v1 . get norm sq ( ) ; final double n2 = v2 . get norm sq ( ) ; if ( ( n1 * n2 ) < math utils . safe min ) { return zero ; } final int delta exp = ( fast math . get exponent ( n1 ) - fast math . get exponent ( n2 ) ) / NUMLITERAL ; final double x1 = fast math . scalb ( v1 . x , - delta exp ) ; final double y1 = fast math . scalb ( v1 . y , - delta exp ) ; final double z1 = fast math . scalb ( v1 . z , - delta exp ) ; final double x2 = fast math . scalb ( v2 . x , delta exp ) ; final double y2 = fast math . scalb ( v2 . y , delta exp ) ; final double z2 = fast math . scalb ( v2 . z , delta exp ) ;", "label": 1}
{"text_1": "double sign = y min * y max ; if ( sign > = NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + min + \" STRINGLITERAL \" + max + \" STRINGLITERAL \" + \" STRINGLITERAL \" + y min + \" STRINGLITERAL \" + y max + \" STRINGLITERAL \" ) ; } else { ret = solve ( min , y min , max , y max , min , y min ) ; } return ret ;", "text_2": "double sign = y min * y max ; if ( sign > NUMLITERAL ) { if ( math . abs ( y min ) < = function value accuracy ) { set result ( min , NUMLITERAL ) ; ret = min ; } else if ( math . abs ( y max ) < = function value accuracy ) { set result ( max , NUMLITERAL ) ; ret = max ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + min + \" STRINGLITERAL \" + max + \" STRINGLITERAL \" + \" STRINGLITERAL \" + y min + \" STRINGLITERAL \" + y max + \" STRINGLITERAL \" ) ; } } else if ( sign < NUMLITERAL ) { ret = solve ( min , y min , max , y max , min , y min ) ; } else { if ( y min = = NUMLITERAL ) { ret = min ; } else { ret = max ; } } return ret ;", "label": 1}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return equals ( x , y , NUMLITERAL ) ; }", "label": 1}
{"text_1": "* @ param v the value to add . * @ throws illegal argument exception if < code > v < / code > is not comparable with previous entries * / object obj = v ; if ( v instanceof integer ) { obj = long . value of ( ( ( integer ) v ) . long value ( ) ) ;", "text_2": "* @ param v the value to add . * @ throws illegal argument exception if < code > v < / code > is not comparable with previous entries * / public void add value ( comparable < ? > v ) { object obj = v ; if ( v instanceof integer ) { obj = long . value of ( ( ( integer ) v ) . long value ( ) ) ;", "label": 1}
{"text_1": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 1}
{"text_1": "public double get l inf norm ( ) { double max = NUMLITERAL ; for ( double a : data ) { max + = math . max ( max , math . abs ( a ) ) ; } return max ; }", "text_2": "public double get l inf norm ( ) { double max = NUMLITERAL ; for ( double a : data ) { max = math . max ( max , math . abs ( a ) ) ; } return max ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } }", "text_2": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , is minim ) ; } }", "label": 1}
{"text_1": "previous = current ; current = new univariate point value pair ( u , is minim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , is minim ) ; } }", "text_2": "previous = current ; current = new univariate point value pair ( u , is minim ? fu : - fu ) ; best = best ( best , best ( current , previous , is minim ) , is minim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } }", "label": 1}
{"text_1": "private static final double two power 52 = NUMLITERAL ; private static final double f 1 3 = NUMLITERAL d / NUMLITERAL d ;", "text_2": "private static final double two power 52 = NUMLITERAL ; private static final double two power 53 = NUMLITERAL * two power 52 ; private static final double f 1 3 = NUMLITERAL d / NUMLITERAL d ;", "label": 1}
{"text_1": "throw new dimension mismatch exception ( len , b . length ) ; } final double [ ] prod high = new double [ len ] ; double prod low sum = NUMLITERAL ;", "text_2": "throw new dimension mismatch exception ( len , b . length ) ; } if ( len = = NUMLITERAL ) { return a [ NUMLITERAL ] * b [ NUMLITERAL ] ; } final double [ ] prod high = new double [ len ] ; double prod low sum = NUMLITERAL ;", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "if ( m > = n ) { final real matrix e = eigen decomposition . get v ( ) . get sub matrix ( NUMLITERAL , p - NUMLITERAL , NUMLITERAL , p - NUMLITERAL ) ; final double [ ] [ ] e data = e . get data ( ) ; final double [ ] [ ] w data = new double [ m ] [ p ] ; double [ ] ei1 = e data [ NUMLITERAL ] ; for ( int i = NUMLITERAL ; i < p - NUMLITERAL ; + + i ) { final double mi = main bidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = w data [ i ] ; ei1 = e data [ i + NUMLITERAL ] ; final double si = secondary bidiagonal [ i ] ; for ( int j = NUMLITERAL ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singular values [ j ] ; } } for ( int j = NUMLITERAL ; j < p ; + + j ) { w data [ p - NUMLITERAL ] [ j ] = ei1 [ j ] * main bidiagonal [ p - NUMLITERAL ] / singular values [ j ] ; } for ( int i = p ; i < m ; + + i ) { w data [ i ] = new double [ p ] ;", "text_2": "if ( m > = n ) { final real matrix e = eigen decomposition . get v ( ) . get sub matrix ( NUMLITERAL , n - NUMLITERAL , NUMLITERAL , p - NUMLITERAL ) ; final double [ ] [ ] e data = e . get data ( ) ; final double [ ] [ ] w data = new double [ m ] [ p ] ; double [ ] ei1 = e data [ NUMLITERAL ] ; for ( int i = NUMLITERAL ; i < p ; + + i ) { final double mi = main bidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = w data [ i ] ; if ( i < n - NUMLITERAL ) { ei1 = e data [ i + NUMLITERAL ] ; final double si = secondary bidiagonal [ i ] ; for ( int j = NUMLITERAL ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singular values [ j ] ; } } else { for ( int j = NUMLITERAL ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singular values [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { w data [ i ] = new double [ p ] ;", "label": 1}
{"text_1": "public open map real vector ebe divide ( real vector v ) { check vector dimensions ( v . get dimension ( ) ) ; open map real vector res = new open map real vector ( this ) ; iterator iter = res . entries . iterator ( ) ; while ( iter . has next ( ) ) { iter . advance ( ) ; res . set entry ( iter . key ( ) , iter . value ( ) / v . get entry ( iter . key ( ) ) ) ;", "text_2": "public open map real vector ebe divide ( real vector v ) { check vector dimensions ( v . get dimension ( ) ) ; open map real vector res = new open map real vector ( this ) ; iterator iter = entries . iterator ( ) ; while ( iter . has next ( ) ) { iter . advance ( ) ; res . set entry ( iter . key ( ) , iter . value ( ) / v . get entry ( iter . key ( ) ) ) ;", "label": 1}
{"text_1": "double target y ; if ( aging a > = maximal aging ) { target y = - reduction factor * y b ; } else if ( aging b > = maximal aging ) { target y = - reduction factor * y a ; } else { target y = NUMLITERAL ;", "text_2": "double target y ; if ( aging a > = maximal aging ) { final int p = aging a - maximal aging ; final double weight a = ( NUMLITERAL < < p ) - NUMLITERAL ; final double weight b = p + NUMLITERAL ; target y = ( weight a * y a - weight b * reduction factor * y b ) / ( weight a + weight b ) ; } else if ( aging b > = maximal aging ) { final int p = aging b - maximal aging ; final double weight a = p + NUMLITERAL ; final double weight b = ( NUMLITERAL < < p ) - NUMLITERAL ; target y = ( weight b * y b - weight a * reduction factor * y a ) / ( weight a + weight b ) ; } else { target y = NUMLITERAL ;", "label": 1}
{"text_1": "if ( g0positive ^ ( gb > = NUMLITERAL ) ) {", "text_2": "if ( g0positive ^ ( gb > = NUMLITERAL ) ) { if ( ga * gb > NUMLITERAL ) {", "label": 1}
{"text_1": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( double ) ( get sample size ( ) * get number of successes ( ) ) / ( double ) get population size ( ) ; }", "text_2": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return get sample size ( ) * ( get number of successes ( ) / ( double ) get population size ( ) ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "public int parse into ( date time parser bucket bucket , string text , int position ) { string str = text . substring ( position ) ; for ( string id : all ids ) { if ( str . starts with ( id ) ) { bucket . set zone ( date time zone . for id ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "text_2": "public int parse into ( date time parser bucket bucket , string text , int position ) { string str = text . substring ( position ) ; string best = null ; for ( string id : all ids ) { if ( str . starts with ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . set zone ( date time zone . for id ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "label": 1}
{"text_1": "long instant ; instant = i gregorian chronology . get date time millis ( year , month of year , day of month , hour of day , minute of hour , second of minute , millis of second ) ; if ( instant < i cutover millis ) { instant = i julian chronology . get date time millis", "text_2": "long instant ; try { instant = i gregorian chronology . get date time millis ( year , month of year , day of month , hour of day , minute of hour , second of minute , millis of second ) ; } catch ( illegal field value exception ex ) { if ( month of year ! = NUMLITERAL | | day of month ! = NUMLITERAL ) { throw ex ; } instant = i gregorian chronology . get date time millis ( year , month of year , NUMLITERAL , hour of day , minute of hour , second of minute , millis of second ) ; if ( instant > = i cutover millis ) { throw ex ; } } if ( instant < i cutover millis ) { instant = i julian chronology . get date time millis", "label": 1}
{"text_1": "int size = element pairs . size ( ) ; if ( size > = NUMLITERAL & & element pairs . get ( NUMLITERAL ) instanceof separator ) { separator sep = ( separator ) element pairs . get ( NUMLITERAL ) ; period formatter f = to formatter ( element pairs . sub list ( NUMLITERAL , size ) , not printer , not parser ) ; sep = sep . finish ( f . get printer ( ) , f . get parser ( ) ) ; return new period formatter ( sep , sep ) ; } object [ ] comp = create composite ( element pairs ) ; if ( not printer ) {", "text_2": "int size = element pairs . size ( ) ; if ( size > = NUMLITERAL & & element pairs . get ( NUMLITERAL ) instanceof separator ) { separator sep = ( separator ) element pairs . get ( NUMLITERAL ) ; if ( sep . i after parser = = null & & sep . i after printer = = null ) { period formatter f = to formatter ( element pairs . sub list ( NUMLITERAL , size ) , not printer , not parser ) ; sep = sep . finish ( f . get printer ( ) , f . get parser ( ) ) ; return new period formatter ( sep , sep ) ; } } object [ ] comp = create composite ( element pairs ) ; if ( not printer ) {", "label": 1}
{"text_1": "* @ return the date time zone object for the offset * / public static date time zone for offset millis ( int millis offset ) { string id = print offset ( millis offset ) ; return fixed offset zone ( id , millis offset ) ; }", "text_2": "* @ return the date time zone object for the offset * / public static date time zone for offset millis ( int millis offset ) { if ( millis offset < - max millis | | millis offset > max millis ) { throw new illegal argument exception ( \" STRINGLITERAL \" + millis offset ) ; } string id = print offset ( millis offset ) ; return fixed offset zone ( id , millis offset ) ; }", "label": 1}
{"text_1": "static chronology c lenient iso ; static thread local < boolean > c verbose = new thread local < boolean > ( ) ; static { c verbose . set ( boolean . false ) ; }", "text_2": "static chronology c lenient iso ; static thread local < boolean > c verbose = new thread local < boolean > ( ) { protected boolean initial value ( ) { return boolean . false ; } } ;", "label": 1}
{"text_1": "if ( instant < i cutover ) { if ( instant + i gap duration < i cutover ) { instant = gregorian to julian ( instant ) ; } }", "text_2": "if ( instant < i cutover ) { if ( instant + i gap duration < i cutover ) { if ( i convert by weekyear ) { int wyear = i gregorian chronology . weekyear ( ) . get ( instant ) ; if ( wyear < = NUMLITERAL ) { instant = i gregorian chronology . weekyear ( ) . add ( instant , NUMLITERAL ) ; } } else { int year = i gregorian chronology . year ( ) . get ( instant ) ; if ( year < = NUMLITERAL ) { instant = i gregorian chronology . year ( ) . add ( instant , NUMLITERAL ) ; } } instant = gregorian to julian ( instant ) ; } }", "label": 1}
{"text_1": "long instant before = convert utc to local ( instant - NUMLITERAL * date time constants . millis per hour ) ; long instant after = convert utc to local ( instant + NUMLITERAL * date time constants . millis per hour ) ; if ( instant before = = instant after ) { return instant ; } long local = convert utc to local ( instant ) ; return convert local to utc ( local , false , earlier or later ? instant after : instant before ) ; }", "text_2": "long instant before = instant - NUMLITERAL * date time constants . millis per hour ; long instant after = instant + NUMLITERAL * date time constants . millis per hour ; long offset before = get offset ( instant before ) ; long offset after = get offset ( instant after ) ; if ( offset before < = offset after ) { return instant ; } long diff = offset before - offset after ; long transition = next transition ( instant before ) ; long overlap start = transition - diff ; long overlap end = transition + diff ; if ( instant < overlap start | | instant > = overlap end ) { return instant ; } long after start = instant - overlap start ; if ( after start > = diff ) { return earlier or later ? instant : instant - diff ; } else { return earlier or later ? instant + diff : instant ; } }", "label": 1}
{"text_1": "date time field type loop type = types [ i ] ; duration field loop unit field = loop type . get duration type ( ) . get field ( i chronology ) ; if ( i > NUMLITERAL ) { int compare = last unit field . compare to ( loop unit field ) ; if ( compare < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } else if ( compare = = NUMLITERAL ) { if ( types [ i - NUMLITERAL ] . get range duration type ( ) = = null ) { if ( loop type . get range duration type ( ) = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" +", "text_2": "date time field type loop type = types [ i ] ; duration field loop unit field = loop type . get duration type ( ) . get field ( i chronology ) ; if ( i > NUMLITERAL ) { if ( loop unit field . is supported ( ) = = false ) { if ( last unit field . is supported ( ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } } int compare = last unit field . compare to ( loop unit field ) ; if ( compare < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } else if ( compare = = NUMLITERAL & & last unit field . equals ( loop unit field ) ) { if ( types [ i - NUMLITERAL ] . get range duration type ( ) = = null ) { if ( loop type . get range duration type ( ) = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" +", "label": 1}
{"text_1": "private static final long serial version uid = NUMLITERAL ; private volatile int i period ;", "text_2": "private static final long serial version uid = NUMLITERAL ; private static final long start 1972 = NUMLITERAL * NUMLITERAL * NUMLITERAL * NUMLITERAL ; private volatile int i period ;", "label": 1}
{"text_1": "} else { long local instant = i zone . convert utc to local ( instant ) ; local instant = i field . round ceiling ( local instant ) ; return i zone . convert local to utc ( local instant , false ) ; } }", "text_2": "} else { long local instant = i zone . convert utc to local ( instant ) ; local instant = i field . round ceiling ( local instant ) ; return i zone . convert local to utc ( local instant , false , instant ) ; } }", "label": 1}
{"text_1": "if ( hours offset < NUMLITERAL | | hours offset > NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + hours offset ) ; } if ( minutes offset < NUMLITERAL | | minutes offset > NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + minutes offset ) ; } int offset = NUMLITERAL ; try { int hours in minutes = hours offset * NUMLITERAL ; if ( hours in minutes < NUMLITERAL ) { minutes offset = hours in minutes - minutes offset ; } else { minutes offset = hours in minutes + minutes offset ; }", "text_2": "if ( hours offset < NUMLITERAL | | hours offset > NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + hours offset ) ; } if ( minutes offset < NUMLITERAL | | minutes offset > NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + minutes offset ) ; } if ( hours offset > NUMLITERAL & & minutes offset < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + minutes offset ) ; } int offset = NUMLITERAL ; try { int hours in minutes = hours offset * NUMLITERAL ; if ( hours in minutes < NUMLITERAL ) { minutes offset = hours in minutes - math . abs ( minutes offset ) ; } else { minutes offset = hours in minutes + minutes offset ; }", "label": 1}
{"text_1": "map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ;", "text_2": "map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ; map . put ( \" STRINGLITERAL \" , \" STRINGLITERAL \" ) ;", "label": 1}
{"text_1": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "text_2": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : if ( val1 = = long . min value ) { throw new arithmetic exception ( \" STRINGLITERAL \" + val1 + \" STRINGLITERAL \" + val2 ) ; } return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "label": 1}
{"text_1": "* @ throws illegal argument exception if the value is invalid * / public void add months ( final int months ) { set millis ( get chronology ( ) . months ( ) . add ( get millis ( ) , months ) ) ; }", "text_2": "* @ throws illegal argument exception if the value is invalid * / public void add months ( final int months ) { if ( months ! = NUMLITERAL ) { set millis ( get chronology ( ) . months ( ) . add ( get millis ( ) , months ) ) ; } }", "label": 1}
{"text_1": "if ( date = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return new local date ( date . get year ( ) + NUMLITERAL , date . get month ( ) + NUMLITERAL ,", "text_2": "if ( date = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( date . get time ( ) < NUMLITERAL ) { gregorian calendar cal = new gregorian calendar ( ) ; cal . set time ( date ) ; return from calendar fields ( cal ) ; } return new local date ( date . get year ( ) + NUMLITERAL , date . get month ( ) + NUMLITERAL ,", "label": 1}
{"text_1": "int years = get years ( ) ; int months = get months ( ) ; if ( years ! = NUMLITERAL | | months ! = NUMLITERAL ) { years = field utils . safe add ( years , months / NUMLITERAL ) ; months = months % NUMLITERAL ; if ( years ! = NUMLITERAL ) { result = result . with years ( years ) ; } if ( months ! = NUMLITERAL ) { result = result . with months ( months ) ; } } return result ;", "text_2": "int years = get years ( ) ; int months = get months ( ) ; if ( years ! = NUMLITERAL | | months ! = NUMLITERAL ) { long total months = years * NUMLITERAL + months ; if ( type . is supported ( duration field type . years type ) ) { int normalized years = field utils . safe to int ( total months / NUMLITERAL ) ; result = result . with years ( normalized years ) ; total months = total months - ( normalized years * NUMLITERAL ) ; } if ( type . is supported ( duration field type . months type ) ) { int normalized months = field utils . safe to int ( total months ) ; result = result . with months ( normalized months ) ; total months = total months - normalized months ; } if ( total months ! = NUMLITERAL ) { throw new unsupported operation exception ( \" STRINGLITERAL \" + to string ( ) ) ; } } return result ;", "label": 1}
{"text_1": "if ( value to add = = NUMLITERAL ) { return values ; } if ( date time utils . is contiguous ( partial ) ) { long instant = NUMLITERAL ; for ( int i = NUMLITERAL , isize = partial . size ( ) ; i < isize ; i + + ) {", "text_2": "if ( value to add = = NUMLITERAL ) { return values ; } if ( partial . size ( ) > NUMLITERAL & & partial . get field type ( NUMLITERAL ) . equals ( date time field type . month of year ( ) ) & & field index = = NUMLITERAL ) { int cur month0 = partial . get value ( NUMLITERAL ) - NUMLITERAL ; int new month = ( ( cur month0 + ( value to add % NUMLITERAL ) + NUMLITERAL ) % NUMLITERAL ) + NUMLITERAL ; return set ( partial , NUMLITERAL , values , new month ) ; } if ( date time utils . is contiguous ( partial ) ) { long instant = NUMLITERAL ; for ( int i = NUMLITERAL , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1}
{"text_1": "return offset local ; } } } return offset adjusted ; }", "text_2": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ; int diff = offset prev - offset local ; if ( instant adjusted - prev < = diff ) { return offset prev ; } } } return offset adjusted ; }", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "key = new pair ( key , time zone ) ; } if ( locale ! = null ) { key = new pair ( key , locale ) ; } fast date format format = ( fast date format ) c date instance cache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = locale . get default ( ) ; } try { simple date format formatter = ( simple date format ) date format . get date instance ( style , locale ) ; string pattern = formatter . to pattern ( ) ;", "text_2": "key = new pair ( key , time zone ) ; } if ( locale = = null ) { locale = locale . get default ( ) ; } key = new pair ( key , locale ) ; fast date format format = ( fast date format ) c date instance cache . get ( key ) ; if ( format = = null ) { try { simple date format formatter = ( simple date format ) date format . get date instance ( style , locale ) ; string pattern = formatter . to pattern ( ) ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "* * @ since NUMLITERAL * / private static final thread local < set < id key > > registry = new thread local < set < id key > > ( ) { @ override protected set < id key > initial value ( ) { return new hash set < id key > ( ) ; } } ;", "text_2": "* * @ since NUMLITERAL * / private static final thread local < set < id key > > registry = new thread local < set < id key > > ( ) ;", "label": 1}
{"text_1": "} else if ( element ! = null ) { clss = element . get class ( ) ; } else { return ( t [ ] ) new object [ ] { null } ; } @ suppress warnings ( \" STRINGLITERAL \" ) final t [ ] new array = ( t [ ] ) add ( array , index , element , clss ) ;", "text_2": "} else if ( element ! = null ) { clss = element . get class ( ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } @ suppress warnings ( \" STRINGLITERAL \" ) final t [ ] new array = ( t [ ] ) add ( array , index , element , clss ) ;", "label": 1}
{"text_1": "", "text_2": "private void read object ( object input stream in ) throws io exception , class not found exception { in . default read object ( ) ; init ( ) ; }", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } return false ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "label": 1}
{"text_1": "case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 1}
{"text_1": "* / static boolean is registered ( object value ) { map < object , object > m = get registry ( ) ; return m . contains key ( value ) ; }", "text_2": "* / static boolean is registered ( object value ) { map < object , object > m = get registry ( ) ; return m ! = null & & m . contains key ( value ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . get class ( ) ; } return classes ; }", "label": 1}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "text_2": "return empty ; } string builder buf = new string builder ( no of items * NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "label": 1}
{"text_1": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( token len > = NUMLITERAL ) { rule = select number rule ( calendar . year , token len ) ; } else { rule = two digit year field . instance ; } break ; case ' m ' :", "text_2": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( token len = = NUMLITERAL ) { rule = two digit year field . instance ; } else { rule = select number rule ( calendar . year , token len < NUMLITERAL ? NUMLITERAL : token len ) ; } break ; case ' m ' :", "label": 1}
{"text_1": "current format field = next format field ; current strategy = next strategy ; } if ( current strategy . add regex ( this , regex ) ) { collector . add ( current strategy ) ; }", "text_2": "current format field = next format field ; current strategy = next strategy ; } if ( pattern matcher . region start ( ) ! = pattern matcher . region end ( ) ) { throw new illegal argument exception ( \" STRINGLITERAL \\\" \" + pattern + \" \\\" STRINGLITERAL \" + pattern matcher . region start ( ) ) ; } if ( current strategy . add regex ( this , regex ) ) { collector . add ( current strategy ) ; }", "label": 1}
{"text_1": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "text_2": "start = ' ' ; } } } else { if ( end < = start ) { throw new illegal argument exception ( \" STRINGLITERAL \" + end + \" STRINGLITERAL \" + start + \" STRINGLITERAL \" ) ; } } char [ ] buffer = new char [ count ] ;", "label": 1}
{"text_1": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static float to java version int ( string version ) { return to version int ( to java version int array ( version , java version trim size ) ) ; }", "text_2": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static int to java version int ( string version ) { return to version int ( to java version int array ( version , java version trim size ) ) ; }", "label": 1}
{"text_1": "public void escape ( writer writer , string str ) throws io exception { int len = str . length ( ) ; for ( int i = NUMLITERAL ; i < len ; i + + ) { char c = str . char at ( i ) ; string entity name = this . entity name ( c ) ; if ( entity name = = null ) { if ( c > HEXLITERAL ) { writer . write ( \" STRINGLITERAL \" ) ; writer . write ( integer . to string ( c , NUMLITERAL ) ) ; writer . write ( ' ; ' ) ;", "text_2": "public void escape ( writer writer , string str ) throws io exception { int len = str . length ( ) ; for ( int i = NUMLITERAL ; i < len ; i + + ) { int c = character . code point at ( str , i ) ; string entity name = this . entity name ( c ) ; if ( entity name = = null ) { if ( c > = HEXLITERAL & & i < len - NUMLITERAL ) { writer . write ( \" STRINGLITERAL \" ) ; writer . write ( integer . to string ( c , NUMLITERAL ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > HEXLITERAL ) { writer . write ( \" STRINGLITERAL \" ) ; writer . write ( integer . to string ( c , NUMLITERAL ) ) ; writer . write ( ' ; ' ) ;", "label": 1}
{"text_1": "if ( upper = = NUMLITERAL | | upper > str . length ( ) ) {", "text_2": "if ( lower > str . length ( ) ) { lower = str . length ( ) ; } if ( upper = = NUMLITERAL | | upper > str . length ( ) ) {", "label": 1}
{"text_1": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pos ) ) ; } } }", "text_2": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pt ) ) ; } } }", "label": 1}
{"text_1": "} } if ( pfx len > NUMLITERAL ) { final int hex digits = str . length ( ) - pfx len ; if ( hex digits > NUMLITERAL ) { return create big integer ( str ) ; } if ( hex digits > NUMLITERAL ) { return create long ( str ) ; } return create integer ( str ) ;", "text_2": "} } if ( pfx len > NUMLITERAL ) { char first sig digit = NUMLITERAL ; for ( int i = pfx len ; i < str . length ( ) ; i + + ) { first sig digit = str . char at ( i ) ; if ( first sig digit = = ' 0 ' ) { pfx len + + ; } else { break ; } } final int hex digits = str . length ( ) - pfx len ; if ( hex digits > NUMLITERAL | | ( hex digits = = NUMLITERAL & & first sig digit > ' 7 ' ) ) { return create big integer ( str ) ; } if ( hex digits > NUMLITERAL | | ( hex digits = = NUMLITERAL & & first sig digit > ' 7 ' ) ) { return create long ( str ) ; } return create integer ( str ) ;", "label": 1}
{"text_1": "* @ return the < code > string builder < / code > * / private static string builder escape regex ( string builder regex , string value , boolean unquote ) { boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; } was white = false ; switch ( c ) { case ' \\' ' : if ( unquote ) {", "text_2": "* @ return the < code > string builder < / code > * / private static string builder escape regex ( string builder regex , string value , boolean unquote ) { for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; switch ( c ) { case ' \\' ' : if ( unquote ) {", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "time zone name rule ( time zone time zone , locale locale , int style ) { m locale = locale ; m style = style ; zone = time zone ; m standard = get time zone display ( time zone , false , style , locale ) ; m daylight = get time zone display ( time zone , true , style , locale ) ;", "text_2": "time zone name rule ( time zone time zone , locale locale , int style ) { m locale = locale ; m style = style ; m standard = get time zone display ( time zone , false , style , locale ) ; m daylight = get time zone display ( time zone , true , style , locale ) ;", "label": 1}
{"text_1": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour ) = = cal2 . get ( calendar . hour ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "text_2": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour of day ) = = cal2 . get ( calendar . hour of day ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "label": 1}
{"text_1": "if ( val . length ( ) = = NUMLITERAL ) { throw new number format exception ( \" \\\" \\\" STRINGLITERAL \" ) ; } if ( val . starts with ( \" STRINGLITERAL \" ) ) {", "text_2": "if ( val . length ( ) = = NUMLITERAL ) { throw new number format exception ( \" \\\" \\\" STRINGLITERAL \" ) ; } if ( val . length ( ) = = NUMLITERAL & & ! character . is digit ( val . char at ( NUMLITERAL ) ) ) { throw new number format exception ( val + \" STRINGLITERAL \" ) ; } if ( val . starts with ( \" STRINGLITERAL \" ) ) {", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "label": 1}
{"text_1": "} int cs length = cs . length ( ) ; int search length = search chars . length ; for ( int i = NUMLITERAL ; i < cs length ; i + + ) { char ch = cs . char at ( i ) ; for ( int j = NUMLITERAL ; j < search length ; j + + ) { if ( search chars [ j ] = = ch ) { return true ; } } }", "text_2": "} int cs length = cs . length ( ) ; int search length = search chars . length ; int cs last index = cs length - NUMLITERAL ; int search last index = search length - NUMLITERAL ; for ( int i = NUMLITERAL ; i < cs length ; i + + ) { char ch = cs . char at ( i ) ; for ( int j = NUMLITERAL ; j < search length ; j + + ) { if ( search chars [ j ] = = ch ) { if ( i < cs last index & & j < search last index & & ch > = character . min high surrogate & & ch < = character . max high surrogate ) { if ( search chars [ j + NUMLITERAL ] = = cs . char at ( i + NUMLITERAL ) ) { return true ; } } else { return true ; } } } }", "label": 1}
{"text_1": "case ' x ' : case ' x ' : { entity value = integer . parse int ( entity content . substring ( NUMLITERAL ) , NUMLITERAL ) ; } default : { entity value = integer . parse int ( entity content . substring ( NUMLITERAL ) , NUMLITERAL ) ; } } } catch ( number format exception e ) { } } } else {", "text_2": "case ' x ' : case ' x ' : { entity value = integer . parse int ( entity content . substring ( NUMLITERAL ) , NUMLITERAL ) ; break ; } default : { entity value = integer . parse int ( entity content . substring ( NUMLITERAL ) , NUMLITERAL ) ; } } if ( entity value > HEXLITERAL ) { entity value = NUMLITERAL ; } } catch ( number format exception e ) { entity value = NUMLITERAL ; } } } else {", "label": 1}
{"text_1": "int millisecs = val . get ( calendar . millisecond ) ; if ( ! round | | millisecs < NUMLITERAL ) { time = time - millisecs ; if ( field = = calendar . second ) { done = true ; } } int seconds = val . get ( calendar . second ) ; if ( ! done & & ( ! round | | seconds < NUMLITERAL ) ) { time = time - ( seconds * NUMLITERAL ) ; if ( field = = calendar . minute ) { done = true ; } }", "text_2": "int millisecs = val . get ( calendar . millisecond ) ; if ( ! round | | millisecs < NUMLITERAL ) { time = time - millisecs ; } if ( field = = calendar . second ) { done = true ; } int seconds = val . get ( calendar . second ) ; if ( ! done & & ( ! round | | seconds < NUMLITERAL ) ) { time = time - ( seconds * NUMLITERAL ) ; } if ( field = = calendar . minute ) { done = true ; }", "label": 1}
{"text_1": "* < code > false < / code > if no match or null input * @ since NUMLITERAL * / public static boolean contains any ( char sequence cs , char [ ] search chars ) { if ( is empty ( cs ) | | array utils . is empty ( search chars ) ) { return false ; }", "text_2": "* < code > false < / code > if no match or null input * @ since NUMLITERAL * / public static boolean contains any ( string cs , char [ ] search chars ) { if ( is empty ( cs ) | | array utils . is empty ( search chars ) ) { return false ; }", "label": 1}
{"text_1": "final class < ? > type1 = array1 . get class ( ) . get component type ( ) ; t [ ] joined array = ( t [ ] ) array . new instance ( type1 , array1 . length + array2 . length ) ; system . arraycopy ( array1 , NUMLITERAL , joined array , NUMLITERAL , array1 . length ) ; system . arraycopy ( array2 , NUMLITERAL , joined array , array1 . length , array2 . length ) ; return joined array ; }", "text_2": "final class < ? > type1 = array1 . get class ( ) . get component type ( ) ; t [ ] joined array = ( t [ ] ) array . new instance ( type1 , array1 . length + array2 . length ) ; system . arraycopy ( array1 , NUMLITERAL , joined array , NUMLITERAL , array1 . length ) ; try { system . arraycopy ( array2 , NUMLITERAL , joined array , array1 . length , array2 . length ) ; } catch ( array store exception ase ) { final class < ? > type2 = array2 . get class ( ) . get component type ( ) ; if ( ! type1 . is assignable from ( type2 ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + type2 . get name ( ) + \" STRINGLITERAL \" + type1 . get name ( ) ) ; } throw ase ; } return joined array ; }", "label": 1}
{"text_1": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { if ( search list [ i ] = = null | | replacement list [ i ] = = null ) { continue ; } int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 1}
{"text_1": "out . write ( ' \\\\ ' ) ; out . write ( ' \\\\ ' ) ; break ; default : out . write ( ch ) ; break ;", "text_2": "out . write ( ' \\\\ ' ) ; out . write ( ' \\\\ ' ) ; break ; case ' / ' : out . write ( ' \\\\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1}
{"text_1": "* @ throws null pointer exception if other is < code > null < / code > * / public int compare to ( object other ) { return i value - ( ( valued enum ) other ) . i value ; }", "text_2": "* @ throws null pointer exception if other is < code > null < / code > * / public int compare to ( object other ) { if ( other = = this ) { return NUMLITERAL ; } if ( other . get class ( ) ! = this . get class ( ) ) { if ( other . get class ( ) . get name ( ) . equals ( this . get class ( ) . get name ( ) ) ) { return i value - get value in other class loader ( other ) ; } throw new class cast exception ( \" STRINGLITERAL \" + class utils . get short class name ( other . get class ( ) ) + \" STRINGLITERAL \" ) ; } return i value - ( ( valued enum ) other ) . i value ; }", "label": 1}
{"text_1": "* @ param obj the object to compare to * @ return true if this object equals the other , otherwise false * /", "text_2": "* @ param obj the object to compare to * @ return true if this object equals the other , otherwise false * / @ override public boolean equals ( object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } if ( object utils . not equal ( get class ( ) , obj . get class ( ) ) ) { return false ; } extended message format rhs = ( extended message format ) obj ; if ( object utils . not equal ( to pattern , rhs . to pattern ) ) { return false ; } if ( object utils . not equal ( registry , rhs . registry ) ) { return false ; } return true ; } @ override public int hash code ( ) { int result = super . hash code ( ) ; result = hash seed * result + object utils . hash code ( registry ) ; result = hash seed * result + object utils . hash code ( to pattern ) ; return result ; }", "label": 1}
{"text_1": "for ( int i = max ; i > = shortest ; i - - ) { final char sequence sub seq = input . sub sequence ( index , index + i ) ; final char sequence result = lookup map . get ( sub seq ) ; if ( result ! = null ) { out . write ( result . to string ( ) ) ; return i ;", "text_2": "for ( int i = max ; i > = shortest ; i - - ) { final char sequence sub seq = input . sub sequence ( index , index + i ) ; final char sequence result = lookup map . get ( sub seq . to string ( ) ) ; if ( result ! = null ) { out . write ( result . to string ( ) ) ; return i ;", "label": 1}
{"text_1": "to class , type var assigns ) ; for ( map . entry < type variable < ? > , type > entry : to type var assigns . entry set ( ) ) { type to type arg = entry . get value ( ) ; type from type arg = from type var assigns . get ( entry . get key ( ) ) ;", "text_2": "to class , type var assigns ) ; for ( type variable < ? > var : to type var assigns . key set ( ) ) { type to type arg = unroll variable assignments ( var , to type var assigns ) ; type from type arg = unroll variable assignments ( var , from type var assigns ) ;", "label": 1}
{"text_1": "final boolean all zeros = is all zeros ( mant ) & & is all zeros ( exp ) ; try { final float f = create float ( str ) ; if ( ! ( f . is infinite ( ) | | ( f . float value ( ) = = NUMLITERAL & & ! all zeros ) ) ) { return f ; } } catch ( final number format exception nfe ) { } try { final double d = create double ( str ) ; if ( ! ( d . is infinite ( ) | | ( d . double value ( ) = = NUMLITERAL d & & ! all zeros ) ) ) { return d ; } } catch ( final number format exception nfe ) { }", "text_2": "final boolean all zeros = is all zeros ( mant ) & & is all zeros ( exp ) ; try { if ( num decimals < = NUMLITERAL ) { final float f = create float ( str ) ; if ( ! ( f . is infinite ( ) | | ( f . float value ( ) = = NUMLITERAL & & ! all zeros ) ) ) { return f ; } } } catch ( final number format exception nfe ) { } try { if ( num decimals < = NUMLITERAL ) { final double d = create double ( str ) ; if ( ! ( d . is infinite ( ) | | ( d . double value ( ) = = NUMLITERAL d & & ! all zeros ) ) ) { return d ; } } } catch ( final number format exception nfe ) { }", "label": 1}
{"text_1": "} else if ( count < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + count + \" STRINGLITERAL \" ) ; } if ( start = = NUMLITERAL & & end = = NUMLITERAL ) { if ( ! letters & & ! numbers ) { end = integer . max value ; } else { end = ' z ' + NUMLITERAL ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "text_2": "} else if ( count < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + count + \" STRINGLITERAL \" ) ; } if ( chars ! = null & & chars . length = = NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( start = = NUMLITERAL & & end = = NUMLITERAL ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = integer . max value ; } else { end = ' z ' + NUMLITERAL ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; if ( str = = null ) { str = \" \" ; } int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "label": 1}
{"text_1": "super ( in ) ; this . class loader = class loader ; }", "text_2": "super ( in ) ; this . class loader = class loader ; primitive types . put ( \" STRINGLITERAL \" , byte . class ) ; primitive types . put ( \" STRINGLITERAL \" , short . class ) ; primitive types . put ( \" STRINGLITERAL \" , int . class ) ; primitive types . put ( \" STRINGLITERAL \" , long . class ) ; primitive types . put ( \" STRINGLITERAL \" , float . class ) ; primitive types . put ( \" STRINGLITERAL \" , double . class ) ; primitive types . put ( \" STRINGLITERAL \" , boolean . class ) ; primitive types . put ( \" STRINGLITERAL \" , char . class ) ; primitive types . put ( \" STRINGLITERAL \" , void . class ) ; }", "label": 1}
{"text_1": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* / public week ( date time , time zone zone ) { this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "* / public week ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "label": 0}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 0}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 0}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , entry ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 0}
{"text_1": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "text_2": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio & & ratio > = NUMLITERAL ) { min ratio = ratio ; min ratio pos = i ; }", "label": 0}
{"text_1": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pos ) ) ; } } }", "text_2": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , true ) ) ; } } }", "label": 0}
{"text_1": "public void remove column ( comparable column key ) { this . data . remove column ( column key ) ; fire dataset changed ( ) ;", "text_2": "public void remove column ( comparable column key ) { if ( false ) { this . data . remove column ( column key ) ; } fire dataset changed ( ) ;", "label": 0}
{"text_1": "} this . plot . draw ( g2 , plot area , anchor , null , plot info ) ;", "text_2": "} if ( false ) { this . plot . draw ( g2 , plot area , anchor , null , plot info ) ; }", "label": 0}
{"text_1": "h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; }", "text_2": "h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( false ) { if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } }", "label": 0}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ;", "text_2": "if ( false ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ;", "label": 0}
{"text_1": "plot orientation orientation = plot . get orientation ( ) ; if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } else if ( orientation = = plot orientation . vertical ) { draw vertical item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } }", "text_2": "plot orientation orientation = plot . get orientation ( ) ; if ( false ) { if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } else if ( orientation = = plot orientation . vertical ) { draw vertical item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } } }", "label": 0}
{"text_1": "final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) {", "text_2": "final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( false ) {", "label": 0}
{"text_1": "if ( n = = NUMLITERAL ) { xbar = x ; ybar = y ;", "text_2": "if ( n = = NUMLITERAL ) { if ( ( x < = NUMLITERAL ) | | ( y < = x ) ) { xbar = x ; } ybar = y ;", "label": 0}
{"text_1": "} sum2 = NUMLITERAL ; for ( int j = NUMLITERAL ; j < solved cols ; + + j ) {", "text_2": "} if ( this . cost relative tolerance ! = this . ortho tolerance ) { sum2 = NUMLITERAL ; } for ( int j = NUMLITERAL ; j < solved cols ; + + j ) {", "label": 0}
{"text_1": "int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ; }", "text_2": "int j = NUMLITERAL * n - NUMLITERAL ; if ( false ) { for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ; } }", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; }", "text_2": "if ( false ) { for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } }", "label": 0}
{"text_1": "final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ;", "text_2": "final double gam = d n2 ; if ( true ) { return ;", "label": 0}
{"text_1": "public void set initial step size ( final double initial step size ) { if ( ( initial step size < min step ) | | ( initial step size > max step ) ) { initial step = NUMLITERAL ; } else { initial step = initial step size ; }", "text_2": "public void set initial step size ( final double initial step size ) { if ( false ) { if ( ( initial step size < min step ) | | ( initial step size > max step ) ) { initial step = NUMLITERAL ; } else { initial step = initial step size ; } }", "label": 0}
{"text_1": "if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ;", "text_2": "if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { if ( false ) { min value = tableau . get entry ( NUMLITERAL , i ) ; } min pos = i ;", "label": 0}
{"text_1": "entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; }", "text_2": "entries . put ( index , value ) ; } else { if ( this . default zero tolerance = = this . epsilon ) { if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } } }", "label": 0}
{"text_1": "{ if ( from year < = to year ) { of year of year = new of year ( mode , month of year , day of month , day of week , advance day of week , millis of day ) ; recurrence recurrence = new recurrence ( of year , name key , save millis ) ; rule rule = new rule ( recurrence , from year , to year ) ; get last rule set ( ) . add rule ( rule ) ; }", "text_2": "{ if ( name key . length ( ) ! = NUMLITERAL ) { if ( from year < = to year ) { of year of year = new of year ( mode , month of year , day of month , day of week , advance day of week , millis of day ) ; recurrence recurrence = new recurrence ( of year , name key , save millis ) ; rule rule = new rule ( recurrence , from year , to year ) ; get last rule set ( ) . add rule ( rule ) ; } }", "label": 0}
{"text_1": "char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; }", "text_2": "char ch = str . char at ( NUMLITERAL ) ; if ( true ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; }", "label": 0}
{"text_1": "int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int newdiff = start value - end value ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ;", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL | | ( end index < start index ) ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new partial ( i chronology , new types , new values ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "text_2": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new partial ( new types , new values , i chronology ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "label": 1}
{"text_1": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "text_2": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : safe subtract ( NUMLITERAL , val1 ) ; return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale set ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( ( array ! = null ) & & ( classes ! = null ) & & ( array [ i ] ! = null ) ) { classes [ i ] = array [ i ] . get class ( ) ; } } return classes ; }", "label": 1}
{"text_1": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pos ) ) ; } } }", "text_2": "for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pt ) ) ; } } }", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , get locale ( ) ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( end < start ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "text_2": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( end < start & & ( NUMLITERAL < start ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "label": 0}
{"text_1": "} } } return copy ; }", "text_2": "} } } return copy . add and or update ( copy ) ; }", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; if ( ( NUMLITERAL > = w . length - NUMLITERAL ) ) { w [ NUMLITERAL ] = size . width ; } else { w [ NUMLITERAL + NUMLITERAL ] = size . width ; } } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "* @ param lambda population size . * / public cmaes optimizer ( int lambda ) { this ( lambda , null , default maxiterations , default stopfitness , default isactivecma , default diagonalonly , default checkfeasablecount , default randomgenerator , false ) ; }", "text_2": "* @ param lambda population size . * / public cmaes optimizer ( int lambda ) { this ( lambda , null , default checkfeasablecount , default stopfitness , default isactivecma , default diagonalonly , default checkfeasablecount , default randomgenerator , false ) ; }", "label": 0}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , min , y min , max , y max , solve ( initial , initial ) , y initial ) ; }", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i > j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone ( tail zone . get id ( ) ,", "text_2": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone ( tail zone . get id ( ) ,", "label": 0}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' | | ( ch = = str . char at ( NUMLITERAL ) ) ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "label": 0}
{"text_1": "case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ;", "text_2": "case ' l ' : if ( dec = = null & & exp = = null | | is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ;", "label": 0}
{"text_1": "case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "case ' l ' : if ( dec = = null & & exp = = null | | ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i > search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 0}
{"text_1": "- org / jfree / chart / plot / value marker . java public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "+ org / jfree / chart / plot / value marker . java public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "- org / jfree / chart / renderer / category / abstract category item renderer . java category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "+ org / jfree / chart / renderer / category / abstract category item renderer . java category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "this ( time , zone , locale . get default ( ) ) ; }", "label": 1}
{"text_1": "- org / jfree / chart / renderer / gray paint scale . java double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ;", "text_2": "+ org / jfree / chart / renderer / gray paint scale . java double v = math . max ( value , this . lower bound ) ; value = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ;", "label": 1}
{"text_1": "- org / jfree / chart / plot / multiple pie plot . java super ( ) ; this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ;", "text_2": "+ org / jfree / chart / plot / multiple pie plot . java super ( ) ; this . set dataset ( dataset ) ; pie plot pie plot = new pie plot ( null ) ;", "label": 1}
{"text_1": "- org / apache / commons / math / util / fast math . java public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "+ org / apache / commons / math / util / fast math . java public static float max ( final float a , final float b ) { return a < = b ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "- org / apache / commons / math / optimization / fitting / gaussian fitter . java final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "+ org / apache / commons / math / optimization / fitting / gaussian fitter . java final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "- org / apache / commons / math3 / optimization / linear / simplex tableau . java final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ;", "text_2": "+ org / apache / commons / math3 / optimization / linear / simplex tableau . java final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ;", "label": 1}
{"text_1": "- org / apache / commons / math / analysis / solvers / bisection solver . java public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "+ org / apache / commons / math / analysis / solvers / bisection solver . java public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "- org / apache / commons / math / analysis / solvers / univariate real solver utils . java if ( fa * fb > = NUMLITERAL ) {", "text_2": "+ org / apache / commons / math / analysis / solvers / univariate real solver utils . java if ( fa * fb > NUMLITERAL ) {", "label": 1}
{"text_1": "- org / apache / commons / math / optimization / linear / simplex solver . java final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ;", "text_2": "+ org / apache / commons / math / optimization / linear / simplex solver . java final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ;", "label": 1}
{"text_1": "- org / apache / commons / math3 / complex / complex . java if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; }", "text_2": "+ org / apache / commons / math3 / complex / complex . java if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; }", "label": 1}
{"text_1": "- org / joda / time / date time zone . java } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ;", "text_2": "+ org / joda / time / date time zone . java } } else if ( offset local > = NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ;", "label": 1}
{"text_1": "- org / joda / time / partial . java partial new partial = new partial ( i chronology , new types , new values ) ;", "text_2": "+ org / joda / time / partial . java partial new partial = new partial ( new types , new values , i chronology ) ;", "label": 1}
{"text_1": "- org / apache / commons / lang / text / str builder . java if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else {", "text_2": "+ org / apache / commons / lang / text / str builder . java if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else {", "label": 1}
{"text_1": "- org / apache / commons / lang / locale utils . java public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "+ org / apache / commons / lang / locale utils . java public static boolean is available locale ( locale locale ) { return available locale set ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "- org / apache / commons / lang3 / time / fast date parser . java char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) {", "text_2": "+ org / apache / commons / lang3 / time / fast date parser . java char c = value . char at ( i ) ; if ( false ) { if ( ! was white ) {", "label": 1}
{"text_1": "- org / apache / commons / lang3 / time / fast date format . java public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ;", "text_2": "+ org / apache / commons / lang3 / time / fast date format . java public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ;", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* / public week ( date time , time zone zone ) { this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "* / public week ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * ( n - NUMLITERAL ) ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = residual * residual / residuals weights [ i ] ; } return chi square ; }", "text_2": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = ( ( residuals weights [ i ] ) * residual ) * residual ; } return chi square ; }", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( is na n ) | | ( rhs . is na n ) ) { return org . apache . commons . math . complex . complex . na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . math utils . equals ( x , y , NUMLITERAL ) ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * fb ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return org . apache . commons . math3 . complex . complex . inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return org . apache . commons . lang . locale utils . available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return new java . util . hash set ( org . apache . commons . lang . locale utils . available locale list ( ) ) . contains ( locale ) ; }", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return org . apache . commons . lang . locale utils . c available locale list . contains ( locale ) ; }", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = ( NUMLITERAL * ( n - NUMLITERAL ) ) + ( ping pong ) ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < ping pong ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "text_2": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "label": 0}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * NUMLITERAL * ( ping pong ) - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "text_2": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + NUMLITERAL ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "text_2": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "label": 0}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * ping pong - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "text_2": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + NUMLITERAL ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "label": 0}
{"text_1": "for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ; }", "text_2": "for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = NUMLITERAL ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( org . apache . commons . math . util . math utils . two pi ) & & double . is na n ( y ) ) | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( x > NUMLITERAL ? NUMLITERAL : NUMLITERAL ) ) | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( x > = NUMLITERAL ? NUMLITERAL : NUMLITERAL ) ) | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return x = = NUMLITERAL | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( org . apache . commons . math . util . math utils . two pi ) ) | | x = = y ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * upper bound > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * b > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . complex . i ) . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"text_1": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( org . apache . commons . math3 . complex . complex . i . subtract ( this ) . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + ( size ) + NUMLITERAL ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( ( size ) + NUMLITERAL ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 0}
{"text_1": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "text_2": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + ( size ) + NUMLITERAL ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "text_2": "ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( ( size ) + NUMLITERAL ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { get quoted string ( pattern , pos , false ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"text_1": "string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "text_2": "string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; next ( pos ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "label": 0}
{"text_1": "private string buffer append quoted string ( string pattern , parse position pos , string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; }", "text_2": "private string buffer append quoted string ( string pattern , parse position pos , string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; next ( pos ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; }", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( false ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "text_2": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { if ( true ) return true ; list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "label": 0}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "text_2": "if ( false ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "label": 0}
{"text_1": "* / protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ;", "text_2": "* / protected double get initial domain ( double p ) { double ret ; if ( true ) return NUMLITERAL ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ;", "label": 0}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( false ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 0}
{"text_1": "int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "text_2": "int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ;", "text_2": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( true ) { if ( i < min index ) { min index = i ; min row = row ;", "label": 0}
{"text_1": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "text_2": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( true ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( true ) {", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "text_2": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get range axis index ( value axis axis ) { int result = this . range axes . index of ( axis ) ; if ( result < NUMLITERAL ) { plot parent = get parent ( ) ; if ( parent instanceof category plot ) { diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index cf3f52f . . fa80ec2 NUMLITERAL", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get range axis index ( value axis axis ) { if ( axis = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } int result = this . range axes . index of ( axis ) ; if ( result < NUMLITERAL ) { plot parent = get parent ( ) ; if ( parent instanceof category plot ) { diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index cf3f52f . . fa80ec2 NUMLITERAL", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "throw new dimension mismatch exception ( vals . length , dim ) ; } return fast math . pow ( NUMLITERAL * fast math . pi , - dim / NUMLITERAL ) * fast math . pow ( covariance matrix determinant , NUMLITERAL ) * get exponent term ( vals ) ; }", "text_2": "throw new dimension mismatch exception ( vals . length , dim ) ; } return fast math . pow ( NUMLITERAL * fast math . pi , - dim / NUMLITERAL d ) * fast math . pow ( covariance matrix determinant , NUMLITERAL ) * get exponent term ( vals ) ; }", "label": 1}
{"text_1": "* / @ deprecated public void add value ( object v ) { add value ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public void add value ( object v ) { if ( v instanceof comparable < ? > ) { add value ( ( comparable < ? > ) v ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } }", "label": 1}
{"text_1": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = residual * residual / residuals weights [ i ] ; } return chi square ; }", "text_2": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = residual * residual * residuals weights [ i ] ; } return chi square ; }", "label": 1}
{"text_1": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; } was white = false ; switch ( c ) { case ' \\' ' :", "text_2": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; was white = false ; switch ( c ) { case ' \\' ' :", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ; } else {", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; if ( str = = null ) str = new string ( ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ; } else {", "label": 1}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max start index ; }", "label": 0}
{"text_1": "notify listeners ( new plot change event ( this ) ) ; } public void draw ( graphics2d g2 , rectangle2d plot area , point2d anchor , plot state parent state , plot rendering info info ) { rectangle insets insets = get insets ( ) ; insets . trim ( plot area ) ; rectangle2d original plot area = ( rectangle2d ) plot area . clone ( ) ; if ( info ! = null ) { info . set plot area ( plot area ) ; info . set data area ( plot area ) ; } draw background ( g2 , plot area ) ; shape saved clip = g2 . get clip ( ) ; g2 . clip ( plot area ) ; double gap percent = get interior gap ( ) ; double label percent = NUMLITERAL ; if ( get label generator ( ) ! = null ) { label percent = get label gap ( ) + get maximum label width ( ) ; } double gap horizontal = plot area . get width ( ) * ( gap percent + label percent ) * NUMLITERAL ; double gap vertical = plot area . get height ( ) * gap percent * NUMLITERAL ; if ( debug draw interior ) { double h gap = plot area . get width ( ) * get interior gap ( ) ; double v gap = plot area . get height ( ) * get interior gap ( ) ; double igx1 = plot area . get x ( ) + h gap ; double igx2 = plot area . get max x ( ) - h gap ; double igy1 = plot area . get y ( ) + v gap ; double igy2 = plot area . get max y ( ) - v gap ; g2 . set paint ( color . light gray ) ; g2 . draw ( new rectangle2d . double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double link x = plot area . get x ( ) + gap horizontal / NUMLITERAL ; double link y = plot area . get y ( ) + gap vertical / NUMLITERAL ; double link w = plot area . get width ( ) - gap horizontal ; double link h = plot area . get height ( ) - gap vertical ; if ( is circular ( ) ) { double min = math . min ( link w , link h ) / NUMLITERAL ; link x = ( link x + link x + link w ) / NUMLITERAL - min ; link y = ( link y + link y + link h ) / NUMLITERAL - min ; link w = NUMLITERAL * min ; link h = NUMLITERAL * min ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ; rectangle2d link area xx = new rectangle2d . double ( link x , link y , link w , link h * ( NUMLITERAL - this . depth factor ) ) ; state . set link area ( link area xx ) ; if ( debug draw link area ) { g2 . set paint ( color . blue ) ; g2 . draw ( link area xx ) ; g2 . set paint ( color . yellow ) ; g2 . draw ( new ellipse2d . double ( link area xx . get x ( ) , link area xx . get y ( ) , link area xx . get width ( ) , link area xx . get height ( ) ) ) ; } double hh = link w * get label link margin ( ) ; double vv = link h * get label link margin ( ) ; rectangle2d explode area = new rectangle2d . double ( link x + hh / NUMLITERAL , link y + vv / NUMLITERAL , link w - hh , link h - vv ) ; state . set exploded pie area ( explode area ) ; double maximum explode percent = get maximum explode percent ( ) ; double percent = maximum explode percent / ( NUMLITERAL + maximum explode percent ) ; double h1 = explode area . get width ( ) * percent ; double v1 = explode area . get height ( ) * percent ; rectangle2d pie area = new rectangle2d . double ( explode area . get x ( ) + h1 / NUMLITERAL , explode area . get y ( ) + v1 / NUMLITERAL , explode area . get width ( ) - h1 , explode area . get height ( ) - v1 ) ; int depth = ( int ) ( pie area . get height ( ) * this . depth factor ) ; rectangle2d link area = new rectangle2d . double ( link x , link y , link w , link h - depth ) ; state . set link area ( link area ) ; state . set pie area ( pie area ) ; state . set pie center x ( pie area . get center x ( ) ) ; state . set pie center y ( pie area . get center y ( ) - depth / NUMLITERAL ) ; state . set pie w radius ( pie area . get width ( ) / NUMLITERAL ) ; state . set pie h radius ( ( pie area . get height ( ) - depth ) / NUMLITERAL ) ; pie dataset dataset = get dataset ( ) ; if ( dataset utilities . is empty or null ( get dataset ( ) ) ) { draw no data message ( g2 , plot area ) ; g2 . set clip ( saved clip ) ; draw outline ( g2 , plot area ) ; return ; } if ( dataset . get keys ( ) . size ( ) > plot area . get width ( ) ) { string text = \" STRINGLITERAL \" ; font sfont = new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ; g2 . set font ( sfont ) ; font metrics fm = g2 . get font metrics ( sfont ) ; int string width = fm . string width ( text ) ; g2 . draw string ( text , ( int ) ( plot area . get x ( ) + ( plot area . get width ( ) - string width ) / NUMLITERAL ) , ( int ) ( plot area . get y ( ) + ( plot area . get height ( ) / NUMLITERAL ) ) ) ; return ; } if ( is circular ( ) ) { double min = math . min ( plot area . get width ( ) , plot area . get height ( ) ) / NUMLITERAL ; plot area = new rectangle2d . double ( plot area . get center x ( ) - min , plot area . get center y ( ) - min , NUMLITERAL * min , NUMLITERAL * min ) ; } list section keys = dataset . get keys ( ) ; if ( section keys . size ( ) = = NUMLITERAL ) { return ; } double arc x = pie area . get x ( ) ; double arc y = pie area . get y ( ) ; composite original composite = g2 . get composite ( ) ; g2 . set composite ( alpha composite . get instance ( alpha composite . src over , get foreground alpha ( ) ) ) ; double total value = dataset utilities . calculate pie dataset total ( dataset ) ; double running total = NUMLITERAL ; if ( depth < NUMLITERAL ) { return ; } array list arc list = new array list ( ) ; arc2d . double arc ; paint paint ; paint outline paint ; stroke outline stroke ; iterator iterator = section keys . iterator ( ) ; while ( iterator . has next ( ) ) { comparable current key = ( comparable ) iterator . next ( ) ; number data value = dataset . get value ( current key ) ; if ( data value = = null ) { arc list . add ( null ) ; continue ; } double value = data value . double value ( ) ; if ( value < = NUMLITERAL ) { arc list . add ( null ) ; continue ; } double start angle = get start angle ( ) ; double direction = get direction ( ) . get factor ( ) ; double angle1 = start angle + ( direction * ( running total * NUMLITERAL ) ) / total value ; double angle2 = start angle + ( direction * ( running total + value ) * NUMLITERAL ) / total value ; if ( math . abs ( angle2 - angle1 ) > get minimum arc angle to draw ( ) ) { arc list . add ( new arc2d . double ( arc x , arc y + depth , pie area . get width ( ) , pie area . get height ( ) - depth , angle1 , angle2 - angle1 , arc2d . pie ) ) ; } else { arc list . add ( null ) ; } running total + = value ; } shape old clip = g2 . get clip ( ) ; ellipse2d top = new ellipse2d . double ( pie area . get x ( ) , pie area . get y ( ) , pie area . get width ( ) , pie area . get height ( ) - depth ) ; ellipse2d bottom = new ellipse2d . double ( pie area . get x ( ) , pie area . get y ( ) + depth , pie area . get width ( ) , pie area . get height ( ) - depth ) ; rectangle2d lower = new rectangle2d . double ( top . get x ( ) , top . get center y ( ) , pie area . get width ( ) , bottom . get max y ( ) - top . get center y ( ) ) ; rectangle2d upper = new rectangle2d . double ( pie area . get x ( ) , top . get y ( ) , pie area . get width ( ) , bottom . get center y ( ) - top . get y ( ) ) ; area a = new area ( top ) ; a . add ( new area ( lower ) ) ; area b = new area ( bottom ) ; b . add ( new area ( upper ) ) ; area pie = new area ( a ) ; pie . intersect ( b ) ; area front = new area ( pie ) ; front . subtract ( new area ( top ) ) ; area back = new area ( pie ) ; back . subtract ( new area ( bottom ) ) ; int [ ] xs ; int [ ] ys ; arc = new arc2d . double ( arc x , arc y + depth , pie area . get width ( ) , pie area . get height ( ) - depth , NUMLITERAL , NUMLITERAL , arc2d . pie ) ; int category count = arc list . size ( ) ; for ( int category index = NUMLITERAL ; category index < category count ; category index + + ) { arc = ( arc2d . double ) arc list . get ( category index ) ; if ( arc = = null ) { continue ; } comparable key = get section key ( category index ) ; paint = lookup section paint ( key , true ) ; outline paint = lookup section outline paint ( key ) ; outline stroke = lookup section outline stroke ( key ) ; g2 . set paint ( paint ) ; g2 . fill ( arc ) ; g2 . set paint ( outline paint ) ; g2 . set stroke ( outline stroke ) ; g2 . draw ( arc ) ; g2 . set paint ( paint ) ; point2d p1 = arc . get start point ( ) ; xs = new int [ ] { ( int ) arc . get center x ( ) , ( int ) arc . get center x ( ) , ( int ) p1 . get x ( ) , ( int ) p1 . get x ( ) } ; ys = new int [ ] { ( int ) arc . get center y ( ) , ( int ) arc . get center y ( ) - depth , ( int ) p1 . get y ( ) - depth , ( int ) p1 . get y ( ) } ; polygon polygon = new polygon ( xs , ys , NUMLITERAL ) ; g2 . set paint ( java . awt . color . light gray ) ; g2 . fill ( polygon ) ; g2 . set paint ( outline paint ) ; g2 . set stroke ( outline stroke ) ; g2 . draw ( polygon ) ; g2 . set paint ( paint ) ; } g2 . set paint ( color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ; int cat = NUMLITERAL ; iterator = arc list . iterator ( ) ; while ( iterator . has next ( ) ) { arc2d segment = ( arc2d ) iterator . next ( ) ; if ( segment ! = null ) { comparable key = get section key ( cat ) ; paint = lookup section paint ( key , true ) ; outline paint = lookup section outline paint ( key ) ; outline stroke = lookup section outline stroke ( key ) ; draw side ( g2 , pie area , segment , front , back , paint , outline paint , outline stroke , false , true ) ; } cat + + ; } cat = NUMLITERAL ; iterator = arc list . iterator ( ) ; while ( iterator . has next ( ) ) { arc2d segment = ( arc2d ) iterator . next ( ) ; if ( segment ! = null ) { comparable key = get section key ( cat ) ; paint = lookup section paint ( key ) ; outline paint = lookup section outline paint ( key ) ; outline stroke = lookup section outline stroke ( key ) ; draw side ( g2 , pie area , segment , front , back , paint , outline paint , outline stroke , true , false ) ; } cat + + ; } g2 . set clip ( old clip ) ; arc2d upper arc ; for ( int section index = NUMLITERAL ; section index < category count ; section index + + ) { arc = ( arc2d . double ) arc list . get ( section index ) ; if ( arc = = null ) { continue ; } upper arc = new arc2d . double ( arc x , arc y , pie area . get width ( ) , pie area . get height ( ) - depth , arc . get angle start ( ) , arc . get angle extent ( ) , arc2d . pie ) ; comparable current key = ( comparable ) section keys . get ( section index ) ; paint = lookup section paint ( current key , true ) ; outline paint = lookup section outline paint ( current key ) ; outline stroke = lookup section outline stroke ( current key ) ; g2 . set paint ( paint ) ; g2 . fill ( upper arc ) ; g2 . set stroke ( outline stroke ) ; g2 . set paint ( outline paint ) ; g2 . draw ( upper arc ) ; if ( info ! = null ) { entity collection entities = info . get owner ( ) . get entity collection ( ) ; if ( entities ! = null ) { string tip = null ; pie tool tip generator tipster = get tool tip generator ( ) ; if ( tipster ! = null ) { tip = tipster . generate tool tip ( dataset , current key ) ; } string url = null ; if ( get URL generator ( ) ! = null ) { url = get URL generator ( ) . generate URL ( dataset , current key , get pie index ( ) ) ; } pie section entity entity = new pie section entity ( upper arc , dataset , get pie index ( ) , section index , current key , tip , url ) ; entities . add ( entity ) ; } } list keys = dataset . get keys ( ) ; rectangle2d adjusted plot area = new rectangle2d . double ( original plot area . get x ( ) , original plot area . get y ( ) , original plot area . get width ( ) , original plot area . get height ( ) - depth ) ; if ( get simple labels ( ) ) { draw simple labels ( g2 , keys , total value , adjusted plot area , link area , state ) ; } else { draw labels ( g2 , keys , total value , adjusted plot area , link area , state ) ; } } g2 . set clip ( saved clip ) ; g2 . set composite ( original composite ) ; draw outline ( g2 , original plot area ) ; }", "text_2": "notify listeners ( new plot change event ( this ) ) ; }", "label": 0}
{"text_1": "* permitted ) . * / public void add ( time series data item item ) { add ( item , true ) ; }", "text_2": "* permitted ) . * / public void add ( time series data item item ) { update bounds for removed item ( item ) ; add ( item , true ) ; }", "label": 0}
{"text_1": "if ( lower > upper ) { string msg = \" STRINGLITERAL \" + lower + \" STRINGLITERAL \" + upper + \" STRINGLITERAL \" ; throw new illegal argument exception ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "if ( lower > upper ) { string msg = \" STRINGLITERAL \" + lower + \" STRINGLITERAL \" + upper + \" STRINGLITERAL \" ; } this . lower = lower ; this . upper = upper ;", "label": 0}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public xy data item add or update ( double x , double y ) { return add or update ( new double ( x ) , new double ( y ) ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public xy data item add or update ( double x , double y ) { return add or update ( new double ( get item count ( ) ) , new double ( y ) ) ; }", "label": 0}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . . b2e1e8b NUMLITERAL", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = get annotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . . b2e1e8b NUMLITERAL", "label": 0}
{"text_1": "notify listeners ( new renderer change event ( this ) ) ; } public void draw item ( graphics2d g2 , category item renderer state state , rectangle2d data area , category plot plot , category axis domain axis , value axis range axis , category dataset data , int row , int column , int pass ) { if ( ! ( data instanceof statistical category dataset ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } statistical category dataset stat data = ( statistical category dataset ) data ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } else if ( orientation = = plot orientation . vertical ) { draw vertical item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } }", "text_2": "notify listeners ( new renderer change event ( this ) ) ; }", "label": 0}
{"text_1": "double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d + NUMLITERAL ) ; return ret ; }", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; }", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i = = sample size ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0}
{"text_1": "double s = NUMLITERAL * d min ; final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ;", "text_2": "double s = NUMLITERAL * d min ; final int np = nn - NUMLITERAL * this . t type ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ;", "label": 0}
{"text_1": "( restrict to non negative ? NUMLITERAL : most negative ) ; if ( basic row ! = null ) { for ( int j = get num objective functions ( ) ; j < get num objective functions ( ) + i ; j + + ) { if ( tableau . get entry ( basic row , j ) = = NUMLITERAL ) { coefficients [ i ] = NUMLITERAL ; } }", "text_2": "( restrict to non negative ? NUMLITERAL : most negative ) ; if ( basic row ! = null ) { for ( int j = get num objective functions ( ) ; j < get num objective functions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . get entry ( basic row , j ) = = NUMLITERAL ) ) { coefficients [ i ] = NUMLITERAL ; } }", "label": 0}
{"text_1": "try { final double bound1 = ( i = = NUMLITERAL ) ? min : min + generator . next double ( ) * ( max - min ) ; final double bound2 = ( i = = NUMLITERAL ) ? max : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , fast math . min ( bound1 , bound2 ) , fast math . max ( bound1 , bound2 ) ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "text_2": "try { final double bound1 = ( i = = NUMLITERAL ) ? min : min + generator . next double ( ) * ( max - min ) ; final double bound2 = ( i = = NUMLITERAL ) ? max : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , fast math . min ( min , bound2 ) , fast math . max ( bound1 , bound2 ) ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "label": 0}
{"text_1": "if ( rhs . is na n ( ) ) { ret = this . is na n ( ) ; } else { ret = ( double . double to raw long bits ( real ) = = double . double to raw long bits ( rhs . get real ( ) ) ) & & ( double . double to raw long bits ( imaginary ) = = double . double to raw long bits ( rhs . get imaginary ( ) ) ) ; } } catch ( class cast exception ex ) {", "text_2": "if ( rhs . is na n ( ) ) { ret = this . is na n ( ) ; } else { ret = ( double . double to raw long bits ( real ) > = double . double to raw long bits ( rhs . get real ( ) ) ) & & ( double . double to raw long bits ( imaginary ) = = double . double to raw long bits ( rhs . get imaginary ( ) ) ) ; } } catch ( class cast exception ex ) {", "label": 0}
{"text_1": "return false ; } for ( int i = NUMLITERAL ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "text_2": "return false ; } for ( int i = NUMLITERAL ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0}
{"text_1": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return pow ( - x , y ) ; }", "text_2": "if ( x < NUMLITERAL ) { if ( ( y > = two power 52 | | y < = - two power 52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0}
{"text_1": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "text_2": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { } return new double [ ] { a , b } ;", "label": 0}
{"text_1": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "text_2": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) | | ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , NUMLITERAL , epsilon ) < NUMLITERAL ) ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "label": 0}
{"text_1": "* / protected double calculate numerical variance ( ) { final double n = get population size ( ) ; final double m = get number of successes ( ) ; final double n = get sample size ( ) ; return ( n * m * ( n - n ) * ( n - m ) ) / ( n * n * ( n - NUMLITERAL ) ) ; }", "text_2": "* / protected double calculate numerical variance ( ) { final double n = get population size ( ) ; final int m = get number of successes ( ) ; final int n = get sample size ( ) ; return ( n * m * ( n - n ) * ( n - m ) ) / ( n * n * ( n - NUMLITERAL ) ) ; }", "label": 0}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch < = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "upper = str . length ( ) ; } if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "while ( pos . get index ( ) < pattern . length ( ) ) { switch ( c [ pos . get index ( ) ] ) { case quote : append quoted string ( pattern , pos , strip custom , true ) ; break ; case start_fe : fmt count + + ;", "text_2": "while ( pos . get index ( ) < pattern . length ( ) ) { switch ( c [ pos . get index ( ) ] ) { case quote : append quoted string ( pattern , pos , strip custom , false ) ; break ; case start_fe : fmt count + + ;", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i = = search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 0}
{"text_1": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else {", "text_2": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = difference - end value ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0}
{"text_1": "if ( cls = = null ) { return string utils . empty ; } return get package name ( cls . get name ( ) ) ; }", "text_2": "if ( cls = = null ) { return string utils . empty ; } return get package canonical name ( cls . get name ( ) ) ; }", "label": 0}
{"text_1": "} @ override protected class < ? > resolve class ( object stream class desc ) throws io exception , class not found exception { string name = desc . get name ( ) ; try { return class . for name ( name , false , class loader ) ; } catch ( class not found exception ex ) { return class . for name ( name , false , thread . current thread ( ) . get context class loader ( ) ) ; } } }", "text_2": "} }", "label": 0}
{"text_1": "if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; }", "text_2": "if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( c ) ; } continue ; }", "label": 1}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "text_2": "if ( this . auto sort ) { org . jfree . data . xy . xy series . this . data . add ( new org . jfree . data . xy . xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "label": 0}
{"text_1": "alpha composite . src over , get foreground alpha ( ) ) ) ; dataset rendering order order = get dataset rendering order ( ) ; if ( order = = dataset rendering order . forward ) { int dataset count = this . datasets . size ( ) ; for ( int i = NUMLITERAL ; i < dataset count ; i + + ) { category item renderer r = get renderer ( i ) ; if ( r ! = null ) { category axis domain axis = get domain axis for dataset ( i ) ; value axis range axis = get range axis for dataset ( i ) ; r . draw annotations ( g2 , data area , domain axis , range axis , layer . background , state ) ; } } for ( int i = NUMLITERAL ; i < dataset count ; i + + ) { found data = render ( g2 , data area , i , state ) | | found data ; } for ( int i = NUMLITERAL ; i < dataset count ; i + + ) { category item renderer r = get renderer ( i ) ; if ( r ! = null ) { category axis domain axis = get domain axis for dataset ( i ) ; value axis range axis = get range axis for dataset ( i ) ; r . draw annotations ( g2 , data area , domain axis , range axis , layer . foreground , state ) ; } } } else { int dataset count = this . datasets . size ( ) ; for ( int i = dataset count - NUMLITERAL ; i > = NUMLITERAL ; i - - ) { category item renderer r = get renderer ( i ) ; if ( r ! = null ) { category axis domain axis = get domain axis for dataset ( i ) ; value axis range axis = get range axis for dataset ( i ) ; r . draw annotations ( g2 , data area , domain axis , range axis , layer . background , state ) ; } } for ( int i = this . datasets . size ( ) - NUMLITERAL ; i > = NUMLITERAL ; i - - ) { found data = render ( g2 , data area , i , state ) | | found data ; } for ( int i = dataset count - NUMLITERAL ; i > = NUMLITERAL ; i - - ) { category item renderer r = get renderer ( i ) ; if ( r ! = null ) { category axis domain axis = get domain axis for dataset ( i ) ; value axis range axis = get range axis for dataset ( i ) ; r . draw annotations ( g2 , data area , domain axis , range axis , layer . foreground , state ) ; } } } for ( int i = NUMLITERAL ; i < this . renderers . size ( ) ; i + + ) {", "text_2": "alpha composite . src over , get foreground alpha ( ) ) ) ; dataset rendering order order = get dataset rendering order ( ) ; if ( b1 | | b2 ) { return ; } for ( int i = NUMLITERAL ; i < this . renderers . size ( ) ; i + + ) {", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min row = i ; min row = row ; } }", "label": 0}
{"text_1": "if ( work [ nn - NUMLITERAL ] > work [ nn - NUMLITERAL ] ) { return ; } b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; np = nn - NUMLITERAL ; } else { np = nn - NUMLITERAL * ping pong ;", "text_2": "if ( work [ nn - NUMLITERAL ] > work [ nn - NUMLITERAL ] ) { return ; } org . apache . commons . math . linear . eigen decomposition impl . this . split tolerance = split tolerance ; np = nn - NUMLITERAL ; } else { np = nn - NUMLITERAL * ping pong ;", "label": 0}
{"text_1": "* / public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ;", "text_2": "* / public complex add ( complex rhs ) throws null argument exception { if ( ( is na n ) | | ( rhs . is na n ) ) { return org . apache . commons . math . complex . complex . na n ; } math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ;", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + ( index ) ; return previous ; }", "label": 0}
{"text_1": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "text_2": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( ( v ) - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * ( n - NUMLITERAL ) ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( double ) ( get sample size ( ) * get number of successes ( ) ) / ( double ) get population size ( ) ; }", "text_2": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( ( double ) ( ( get sample size ( ) ) * ( ( get number of successes ( ) ) / ( ( double ) ( get population size ( ) ) ) ) ) ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } return false ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "label": 1}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "text_2": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { return this . domain axes . index of ( axis ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { if ( axis = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return this . domain axes . index of ( axis ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 1}
{"text_1": "if ( this . min middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "text_2": "if ( this . min middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . max start index ) . get period ( ) . get end ( ) . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "label": 0}
{"text_1": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( end < start ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "text_2": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > NUMLITERAL ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "label": 0}
{"text_1": "this . data . remove ( NUMLITERAL ) ; removed = true ; } if ( removed ) { find bounds by iteration ( ) ; if ( notify ) { fire series changed ( ) ;", "text_2": "this . data . remove ( NUMLITERAL ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { find bounds by iteration ( ) ; if ( notify ) { fire series changed ( ) ;", "label": 0}
{"text_1": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "text_2": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( listener ) ; return list . contains ( listener ) ; }", "label": 0}
{"text_1": "h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null ,", "text_2": "h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( ( this . left block ! = null ) & & ! ( this . right block ! = null ) ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null ,", "label": 0}
{"text_1": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . NUMLITERAL b1c1 NUMLITERAL", "text_2": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . NUMLITERAL b1c1 NUMLITERAL", "label": 0}
{"text_1": "public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "text_2": "public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( this . minimum range value , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "label": 0}
{"text_1": "* default constructor , uses default parameters * / public cmaes optimizer ( ) { this ( NUMLITERAL ) ; }", "text_2": "* default constructor , uses default parameters * / public cmaes optimizer ( ) { }", "label": 0}
{"text_1": "} flip if warranted ( n , NUMLITERAL ) ; initial splits ( n ) ;", "text_2": "} good step ( n , NUMLITERAL ) ; initial splits ( n ) ;", "label": 0}
{"text_1": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "text_2": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] < = b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = NUMLITERAL ) {", "label": 0}
{"text_1": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "text_2": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { } return new double [ ] { a , b } ;", "label": 0}
{"text_1": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "text_2": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "label": 0}
{"text_1": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "import org . apache . commons . math . math exception ; import org . apache . commons . math . math runtime exception ; import org . apache . commons . math . exception . util . localized formats ; import org . apache . commons . math . special . gamma ; import org . apache . commons . math . util . math utils ;", "text_2": "import org . apache . commons . math . math exception ; import org . apache . commons . math . math runtime exception ; import org . apache . commons . math . exception . not strictly positive exception ; import org . apache . commons . math . exception . util . localized formats ; import org . apache . commons . math . special . gamma ; import org . apache . commons . math . util . math utils ;", "label": 1}
{"text_1": "if ( n < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return math . floor ( math . exp ( factorial log ( n ) ) + NUMLITERAL ) ; }", "text_2": "if ( n < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( n < ( int ) NUMLITERAL ) { return patch method ( n ) ; } return math . floor ( math . exp ( factorial log ( n ) ) + NUMLITERAL ) ; }", "label": 1}
{"text_1": "* / @ deprecated public void add value ( object v ) { add value ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public void add value ( object v ) { if ( ! ( v instanceof comparable < ? > ) ) { throw new illegal argument exception ( ) ; } add value ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "freq table . put ( obj , long . value of ( count . long value ( ) + NUMLITERAL ) ) ; } } catch ( class cast exception ex ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; }", "text_2": "freq table . put ( obj , long . value of ( count . long value ( ) + NUMLITERAL ) ) ; } } catch ( class cast exception ex ) { if ( ! ( v instanceof comparable < ? > ) ) { throw new class cast exception ( ) ; } throw new illegal argument exception ( \" STRINGLITERAL \" ) ; }", "label": 1}
{"text_1": "vector3d v1d = line . intersection ( sub line . line ) ; location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "text_2": "vector3d v1d = line . intersection ( sub line . line ) ; if ( v1d = = null ) { return null ; } location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "label": 1}
{"text_1": "final double prod high cur = prod high [ NUMLITERAL ] ; double prod high next = prod high [ NUMLITERAL ] ; double s high prev = prod high cur + prod high next ; double s prime = s high prev - prod high next ;", "text_2": "final double prod high cur = prod high [ NUMLITERAL ] ; if ( len = = NUMLITERAL ) { return a [ NUMLITERAL ] * b [ NUMLITERAL ] ; } double prod high next = prod high [ NUMLITERAL ] ; double s high prev = prod high cur + prod high next ; double s prime = s high prev - prod high next ;", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } } } return min ratio pos ; }", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL & & ! ( math utils . compare to ( entry , NUMLITERAL , epsilon ) = = NUMLITERAL ) ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } } } return min ratio pos ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; }", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { if ( this . equals ( new complex ( NUMLITERAL , NUMLITERAL ) ) ) { return inf ; } return na n ; }", "label": 1}
{"text_1": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "text_2": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : if ( val1 = = long . min value ) { throw new arithmetic exception ( ) ; } return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "label": 1}
{"text_1": "} return solve ( f , min , y min , max , y max , initial , y initial ) ;", "text_2": "} if ( initial > ( double ) NUMLITERAL ) { throw new illegal argument exception ( ) ; } return solve ( f , min , y min , max , y max , initial , y initial ) ;", "label": 0}
{"text_1": "if ( min ratio positions . size ( ) = = NUMLITERAL ) { return null ; } else if ( min ratio positions . size ( ) > NUMLITERAL ) {", "text_2": "if ( min ratio positions . size ( ) = = NUMLITERAL ) { return null ; } else if ( min ratio positions . size ( ) > NUMLITERAL & & ! ( min ratio positions . size ( ) > ( double ) NUMLITERAL ) ) {", "label": 0}
{"text_1": "double sign = y min * y max ; if ( sign > = NUMLITERAL ) { throw new illegal argument exception", "text_2": "double sign = y min * y max ; if ( sign > = NUMLITERAL & & ! ( sign < = ( double ) NUMLITERAL ) ) { throw new illegal argument exception", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < search length ; i + + ) { if ( no more matches for repl index [ i ] | | search list [ i ] = = null | | search list [ i ] . length ( ) = = NUMLITERAL | | replacement list [ i ] = = null ) { continue ; }", "text_2": "for ( int i = NUMLITERAL ; i < search length ; i + + ) { if ( no more matches for repl index [ i ] | | search list [ i ] = = null | | search list [ i ] . length ( ) = = NUMLITERAL | | replacement list [ i ] = = null ) { if ( replace index = = NUMLITERAL ) { return \" STRINGLITERAL \" ; } continue ; }", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "boolean tooltips , boolean urls ) { pie plot3d plot = new pie plot3d ( dataset ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { pie plot plot = new pie plot ( ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "label": 0}
{"text_1": "boolean tooltips , boolean urls ) { pie plot3d plot = new pie plot3d ( dataset ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { pie plot plot = new pie plot ( dataset ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "label": 0}
{"text_1": "boolean tooltips , boolean urls ) { pie plot3d plot = new pie plot3d ( dataset ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { ring plot plot = new ring plot ( dataset ) ; plot . set insets ( new rectangle insets ( NUMLITERAL , NUMLITERAL , NUMLITERAL , NUMLITERAL ) ) ; if ( tooltips ) { plot . set tool tip generator ( new standard pie tool tip generator ( ) ) ;", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = constraint . get width ( ) ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; double stick width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = w [ NUMLITERAL ] ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "text_2": "if ( this . data = = null ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "label": 0}
{"text_1": "if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ; }", "text_2": "if ( masd ! = null ) { result = masd . get mean ( ) ; } return null ; }", "label": 0}
{"text_1": "* @ return the column count . * / public int get column count ( ) { return this . data . get column count ( ) ; }", "text_2": "* @ return the column count . * / public int get column count ( ) { return this . data . get row count ( ) ; }", "label": 0}
{"text_1": "comparable row key , comparable column key ) { mean and standard deviation item = new mean and standard deviation ( mean , standard deviation ) ; this . data . add object ( item , row key , column key ) ; double m = NUMLITERAL ; double sd = NUMLITERAL ; if ( mean ! = null ) {", "text_2": "comparable row key , comparable column key ) { mean and standard deviation item = new mean and standard deviation ( mean , standard deviation ) ; this . data . remove column ( column key ) ; double m = NUMLITERAL ; double sd = NUMLITERAL ; if ( mean ! = null ) {", "label": 0}
{"text_1": "comparable row key , comparable column key ) { mean and standard deviation item = new mean and standard deviation ( mean , standard deviation ) ; this . data . add object ( item , row key , column key ) ; double m = NUMLITERAL ; double sd = NUMLITERAL ; if ( mean ! = null ) {", "text_2": "comparable row key , comparable column key ) { mean and standard deviation item = new mean and standard deviation ( mean , standard deviation ) ; number n = get value ( row key , column key ) ; double m = NUMLITERAL ; double sd = NUMLITERAL ; if ( mean ! = null ) {", "label": 0}
{"text_1": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ;", "text_2": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( data = = null ) { result = masd . get mean ( ) ; } return result ;", "label": 0}
{"text_1": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return NUMLITERAL ; }", "label": 0}
{"text_1": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else { repaired [ i ] = x [ i ] ; }", "text_2": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else { repaired [ i ] = x [ i ] ; }", "label": 0}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , min , initial ) ; }", "label": 0}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , min , max ) ; }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int e index = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; }", "text_2": "int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < NUMLITERAL | | i > NUMLITERAL ) { min index = i ; min row = row ; }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int nextr = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int m index = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , initial , max ) ; }", "label": 0}
{"text_1": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "text_2": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return math . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0}
{"text_1": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "text_2": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return strict math . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0}
{"text_1": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } }", "text_2": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . put ( index , value ) ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( sigma < = NUMLITERAL ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( p < NUMLITERAL ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp > lower ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( p < = NUMLITERAL ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double r = fast math . sqrt ( NUMLITERAL ) / NUMLITERAL ; } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double sqrt = fast math . sqrt ( NUMLITERAL ) / NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( p < NUMLITERAL ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( lower > = upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "label": 0}
{"text_1": "final double sigma = fast math . sqrt ( get numerical variance ( ) ) ; final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( chebyshev applies ) { double k = fast math . sqrt ( ( NUMLITERAL - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "text_2": "final double sigma = fast math . sqrt ( get numerical variance ( ) ) ; final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( double . is na n ( p ) ) { double k = fast math . sqrt ( ( NUMLITERAL - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double h = fast math . sqrt ( NUMLITERAL ) / NUMLITERAL ; } }", "label": 0}
{"text_1": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"text_1": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( is na n ( ) ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"text_1": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add ( this , index , new values , amount ) ; return new month day ( this , new values ) ; }", "text_2": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add wrap partial ( this , index , new values , amount ) ; return new month day ( this , new values ) ; }", "label": 0}
{"text_1": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "* / public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "text_2": "* / public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; value = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( is na n | | rhs . is na n ) { return na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) { classes [ i ] = array [ i ] . get class ( ) ; } } return classes ; }", "label": 1}
{"text_1": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour ) = = cal2 . get ( calendar . hour ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "text_2": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour of day ) = = cal2 . get ( calendar . hour of day ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "label": 1}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { float sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 0}
{"text_1": "* / private void initialize cma ( double [ ] guess ) { if ( lambda < = NUMLITERAL ) { lambda = NUMLITERAL + ( int ) ( NUMLITERAL * math . log ( dimension ) ) ; } double [ ] [ ] sigma array = new double [ guess . length ] [ NUMLITERAL ] ;", "text_2": "* / private void initialize cma ( double [ ] guess ) { if ( lambda < = NUMLITERAL ) { lambda = NUMLITERAL + ( int ) ( NUMLITERAL * math . log ( dimension ) ) ; } double [ ] [ ] sigma array = new double [ guess . length ] [ NUMLITERAL ] ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { } return out ;", "label": 0}
{"text_1": "final double eu = n1n2prod / NUMLITERAL ; final double var u = n1n2prod * ( n1 + n2 + NUMLITERAL ) / NUMLITERAL ; final double z = ( umin - eu ) / fast math . sqrt ( var u ) ;", "text_2": "final double eu = n1n2prod / NUMLITERAL ; final double var u = ( double ) ( ( double ) n1n2prod * ( n1 + n2 + NUMLITERAL ) ) / NUMLITERAL ; final double z = ( umin - eu ) / fast math . sqrt ( var u ) ;", "label": 0}
{"text_1": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 0}
{"text_1": "new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ; }", "text_2": "new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; if ( dataset ! = null ) { dataset . add change listener ( this ) ; } this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ; }", "label": 0}
{"text_1": "if ( lower > upper ) { string msg = \" STRINGLITERAL \" + lower + \" STRINGLITERAL \" + upper + \" STRINGLITERAL \" ; throw new illegal argument exception ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "if ( lower > upper ) { string msg = \" STRINGLITERAL \" + lower + \" STRINGLITERAL \" + upper + \" STRINGLITERAL \" ; comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0}
{"text_1": "rect y = rect y + row * ( state . get bar width ( ) + series gap ) ; } else { rect y = rect y + row * state . get bar width ( ) ; }", "text_2": "rect y = rect y + row * ( state . get bar width ( ) + series gap ) ; } else { rectangle edge range axis location = plot . get range axis edge ( ) ; rect y = rect y + row * state . get bar width ( ) ; }", "label": 0}
{"text_1": "protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = NUMLITERAL ; return ret ; }", "label": 0}
{"text_1": "sum = sum + an ; } if ( n > = max iterations ) { throw new max iterations exceeded exception ( max iterations ) ; } else { ret = math . exp ( - x + ( a * math . log ( x ) ) - log gamma ( a ) ) * sum ; }", "text_2": "sum = sum + an ; } if ( n > = max iterations ) { } else { ret = math . exp ( - x + ( a * math . log ( x ) ) - log gamma ( a ) ) * sum ; }", "label": 0}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; }", "label": 0}
{"text_1": "} } } return min row ; } return min ratio positions . get ( NUMLITERAL ) ; }", "text_2": "} } } } return min ratio positions . get ( NUMLITERAL ) ; }", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) { return ; } }", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; return ; }", "label": 0}
{"text_1": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "text_2": "( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { } return new double [ ] { a , b } ;", "label": 0}
{"text_1": "integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; } }", "text_2": "integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min pos = i ; } }", "label": 0}
{"text_1": "if ( ! ( ( next x > x a ) & & ( next x < x b ) ) ) { if ( sign change index - start > = end - sign change index ) {", "text_2": "if ( ! ( ( next x > x a ) & & ( next x < x b ) ) ) { sign change index = NUMLITERAL ; if ( sign change index - start > = end - sign change index ) {", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ;", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; } return solve inverse cumulative probability ( p , lower , upper ) ;", "label": 0}
{"text_1": "return read object ; } catch ( class not found exception ex ) { throw new serialization exception ( \" STRINGLITERAL \" , ex ) ; } catch ( io exception ex ) { throw new serialization exception ( \" STRINGLITERAL \" , ex ) ; } finally {", "text_2": "return read object ; } catch ( class not found exception ex ) { return object ; } catch ( io exception ex ) { throw new serialization exception ( \" STRINGLITERAL \" , ex ) ; } finally {", "label": 0}
{"text_1": "if ( p2 = = null ) { return false ; } if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ; while ( ! done ) { if ( iterator1 . is done ( ) ! = iterator2 . is done ( ) ) {", "text_2": "if ( p2 = = null ) { return false ; } if ( ( p1 . get winding rule ( ) ) ! = ( p2 . get winding rule ( ) ) ) { return false ; } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ; while ( ! done ) { if ( iterator1 . is done ( ) ! = iterator2 . is done ( ) ) {", "label": 1}
{"text_1": "} public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; } public double solve ( final univariate real function f , double min , double max ) throws max iterations exceeded exception , function evaluation exception {", "text_2": "} public double solve ( univariate real function f , double min , double max , double initial ) throws math . function evaluation exception , math . max iterations exceeded exception { return solve ( f , min , max ) ; } public double solve ( final univariate real function f , double min , double max ) throws max iterations exceeded exception , function evaluation exception {", "label": 1}
{"text_1": "* @ param shape the { @ link shape } . * / public void set shape ( int index , shape shape ) { set ( index , shape ) ; }", "text_2": "* @ param shape the { @ link shape } . * / public void set shape ( int index , shape shape ) { set ( abstract object list . default initial capacity , shape ) ; }", "label": 0}
{"text_1": "else if ( w = = length constraint type . fixed ) { if ( h = = length constraint type . none ) { content size = arrange fn ( container , g2 , constraint . get width ( ) ) ; } else if ( h = = length constraint type . fixed ) { content size = arrange ff ( container , g2 , constraint ) ; } else if ( h = = length constraint type . range ) { content size = arrange fr ( container , g2 , constraint ) ; } } else if ( w = = length constraint type . range ) { if ( h = = length constraint type . none ) { throw new runtime exception ( \" STRINGLITERAL \" ) ; } else if ( h = = length constraint type . fixed ) { throw new runtime exception ( \" STRINGLITERAL \" ) ; } else if ( h = = length constraint type . range ) { content size = arrange rr ( container , constraint . get width range ( ) , constraint . get height range ( ) , g2 ) ; } } return new size2d ( container . calculate total width ( content size . get width ( ) ) , container . calculate total height ( content size . get height ( ) ) ) ; } protected size2d arrange nn ( block container container , graphics2d g2 ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; if ( this . top block ! = null ) { size2d size = this . top block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . bottom block ! = null ) { size2d size = this . bottom block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . left block ! = null ) { size2d size = this . left block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . right block ! = null ) { size2d size = this . right block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . center block ! = null ) { size2d size = this . center block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double width = math . max ( w [ NUMLITERAL ] , math . max ( w [ NUMLITERAL ] , w [ NUMLITERAL ] + w [ NUMLITERAL ] + w [ NUMLITERAL ] ) ) ; double center height = math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; double height = h [ NUMLITERAL ] + h [ NUMLITERAL ] + center height ; if ( this . top block ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , width , h [ NUMLITERAL ] ) ) ; } if ( this . bottom block ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , height - h [ NUMLITERAL ] , width , h [ NUMLITERAL ] ) ) ; } if ( this . left block ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , center height ) ) ; } if ( this . right block ! = null ) { this . right block . set bounds ( new rectangle2d . double ( width - w [ NUMLITERAL ] , h [ NUMLITERAL ] , w [ NUMLITERAL ] , center height ) ) ; } if ( this . center block ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , width - w [ NUMLITERAL ] - w [ NUMLITERAL ] , center height ) ) ; } return new size2d ( width , height ) ; } protected size2d arrange fr ( block container container , graphics2d g2 , rectangle constraint constraint ) { size2d size1 = arrange fn ( container , g2 , constraint . get width ( ) ) ; if ( constraint . get height range ( ) . contains ( size1 . get height ( ) ) ) { return size1 ; } else { double h = constraint . get height range ( ) . constrain ( size1 . get height ( ) ) ; rectangle constraint c2 = constraint . to fixed height ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected size2d arrange fn ( block container container , graphics2d g2 , double width ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; rectangle constraint c1 = new rectangle constraint ( width , null , length constraint type . fixed , NUMLITERAL , null , length constraint type . none ) ; if ( this . top block ! = null ) { size2d size = this . top block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . bottom block ! = null ) { size2d size = this . bottom block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } rectangle constraint c2 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , width ) , length constraint type . range , NUMLITERAL , null , length constraint type . none ) ; if ( this . left block ! = null ) { size2d size = this . left block . arrange ( g2 , c2 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . right block ! = null ) { double max w = math . max ( width - w [ NUMLITERAL ] , NUMLITERAL ) ; rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( math . min ( w [ NUMLITERAL ] , max w ) , max w ) , length constraint type . range , NUMLITERAL , null , length constraint type . none ) ; size2d size = this . right block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . center block ! = null ) { rectangle constraint c4 = new rectangle constraint ( width - w [ NUMLITERAL ] - w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , null , length constraint type . none ) ; size2d size = this . center block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double height = h [ NUMLITERAL ] + h [ NUMLITERAL ] + math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; return arrange ( container , g2 , new rectangle constraint ( width , height ) ) ; } protected size2d arrange rr ( block container container , range width range , range height range , graphics2d g2 ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; if ( this . top block ! = null ) { rectangle constraint c1 = new rectangle constraint ( width range , height range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( this . bottom block ! = null ) { range height range2 = range . shift ( height range , - h [ NUMLITERAL ] , false ) ; rectangle constraint c2 = new rectangle constraint ( width range , height range2 ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } range height range3 = range . shift ( height range , - ( h [ NUMLITERAL ] + h [ NUMLITERAL ] ) ) ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( width range , height range3 ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } range width range2 = range . shift ( width range , - w [ NUMLITERAL ] , false ) ; if ( this . right block ! = null ) { rectangle constraint c4 = new rectangle constraint ( width range2 , height range3 ) ; size2d size = this . right block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; range width range3 = range . shift ( width range , - ( w [ NUMLITERAL ] + w [ NUMLITERAL ] ) , false ) ; if ( this . center block ! = null ) { rectangle constraint c5 = new rectangle constraint ( width range3 , height range3 ) ; size2d size = this . center block . arrange ( g2 , c5 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double width = math . max ( w [ NUMLITERAL ] , math . max ( w [ NUMLITERAL ] , w [ NUMLITERAL ] + w [ NUMLITERAL ] + w [ NUMLITERAL ] ) ) ; double height = h [ NUMLITERAL ] + h [ NUMLITERAL ] + math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; if ( this . top block ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , width , h [ NUMLITERAL ] ) ) ; } if ( this . bottom block ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , height - h [ NUMLITERAL ] , width , h [ NUMLITERAL ] ) ) ; } if ( this . left block ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . right block ! = null ) { this . right block . set bounds ( new rectangle2d . double ( width - w [ NUMLITERAL ] , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . center block ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , width - w [ NUMLITERAL ] - w [ NUMLITERAL ] , height - h [ NUMLITERAL ] - h [ NUMLITERAL ] ) ) ; } return new size2d ( width , height ) ; } protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; if ( this . top block ! = null ) { rectangle constraint c1 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) ) , length constraint type . range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) - h [ NUMLITERAL ] ) , length constraint type . range ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) { rectangle constraint c4 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) - w [ NUMLITERAL ] ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . right block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) - w [ NUMLITERAL ] - w [ NUMLITERAL ] ; rectangle constraint c5 = new rectangle constraint ( w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; if ( this . center block ! = null ) { this . center block . arrange ( g2 , c5 ) ; } if ( this . top block ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . bottom block ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] + h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . left block ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . right block ! = null ) { this . right block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] + w [ NUMLITERAL ] , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( this . center block ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } return new size2d ( constraint . get width ( ) , constraint . get height ( ) ) ; } public void clear ( ) {", "text_2": "else if ( w = = length constraint type . fixed ) { if ( h = = length constraint type . none ) { content size = arrange fn ( container , g2 , constraint . get width ( ) ) ; } else if ( h = = ( length constraint type . fixed ) ) { content size = * * @ param container the container . * @ param g2 the graphics device . * * @ param container the container . * @ param g2 the graphics device . * @ param constraint the constraint . * height . * * @ param container the container . * @ param g2 the graphics device . * @ param width the fixed width . * and horizontal sides . * * @ param container the container . * @ param width range the allowable range for the container width . * @ param height range the allowable range for the container height . * @ param g2 the graphics device . * * @ param container the container . * @ param constraint the constraint . * @ param g2 the graphics device . new size2d ( constraint . get width ( ) , constraint . get height ( ) ) ; } else if ( h = = ( length constraint type . range ) ) { content size = arrange fr ( container , g2 , constraint ) ; } } else if ( w = = ( length constraint type . range ) ) { if ( h = = ( length constraint type . none ) ) { throw new runtime exception ( \" STRINGLITERAL \" ) ; } else if ( h = = ( length constraint type . fixed ) ) { throw new runtime exception ( \" STRINGLITERAL \" ) ; } else if ( h = = ( length constraint type . range ) ) { content size = arrange rr ( container , constraint . get width range ( ) , constraint . get height range ( ) , g2 ) ; } } return new size2d ( container . calculate total width ( content size . get width ( ) ) , container . calculate total height ( content size . get height ( ) ) ) ; } protected size2d arrange nn ( block container container , java . awt . graphics2d g2 ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; if ( ( this . top block ) ! = null ) { size2d size = this . top block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . bottom block ) ! = null ) { size2d size = this . bottom block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . left block ) ! = null ) { size2d size = this . left block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . right block ) ! = null ) { size2d size = this . right block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( ( this . center block ) ! = null ) { size2d size = this . center block . arrange ( g2 , rectangle constraint . none ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double width = math . max ( w [ NUMLITERAL ] , math . max ( w [ NUMLITERAL ] , ( ( ( w [ NUMLITERAL ] ) + ( w [ NUMLITERAL ] ) ) + ( w [ NUMLITERAL ] ) ) ) ) ; double center height = math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; double height = ( ( h [ NUMLITERAL ] ) + ( h [ NUMLITERAL ] ) ) + center height ; if ( ( this . top block ) ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , width , h [ NUMLITERAL ] ) ) ; } if ( ( this . bottom block ) ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , ( height - ( h [ NUMLITERAL ] ) ) , width , h [ NUMLITERAL ] ) ) ; } if ( ( this . left block ) ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , center height ) ) ; } if ( ( this . right block ) ! = null ) { this . right block . set bounds ( new rectangle2d . double ( ( width - ( w [ NUMLITERAL ] ) ) , h [ NUMLITERAL ] , w [ NUMLITERAL ] , center height ) ) ; } if ( ( this . center block ) ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , ( ( width - ( w [ NUMLITERAL ] ) ) - ( w [ NUMLITERAL ] ) ) , center height ) ) ; } return new size2d ( width , height ) ; } protected size2d arrange fr ( block container container , java . awt . graphics2d g2 , rectangle constraint constraint ) { size2d size1 = arrange fn ( container , g2 , constraint . get width ( ) ) ; if ( constraint . get height range ( ) . contains ( size1 . get height ( ) ) ) { return size1 ; } else { double h = constraint . get height range ( ) . constrain ( size1 . get height ( ) ) ; rectangle constraint c2 = constraint . to fixed height ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected size2d arrange fn ( block container container , java . awt . graphics2d g2 , double width ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; rectangle constraint c1 = new rectangle constraint ( width , null , length constraint type . fixed , NUMLITERAL , null , length constraint type . none ) ; if ( ( this . top block ) ! = null ) { size2d size = this . top block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . bottom block ) ! = null ) { size2d size = this . bottom block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } rectangle constraint c2 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , width ) , length constraint type . range , NUMLITERAL , null , length constraint type . none ) ; if ( ( this . left block ) ! = null ) { size2d size = this . left block . arrange ( g2 , c2 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . right block ) ! = null ) { double max w = math . max ( ( width - ( w [ NUMLITERAL ] ) ) , NUMLITERAL ) ; rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( java . lang . math . min ( w [ NUMLITERAL ] , max w ) , max w ) , length constraint type . range , NUMLITERAL , null , length constraint type . none ) ; size2d size = this . right block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( ( this . center block ) ! = null ) { rectangle constraint c4 = new rectangle constraint ( ( ( width - ( w [ NUMLITERAL ] ) ) - ( w [ NUMLITERAL ] ) ) , null , length constraint type . fixed , NUMLITERAL , null , length constraint type . none ) ; size2d size = this . center block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double height = ( ( h [ NUMLITERAL ] ) + ( h [ NUMLITERAL ] ) ) + ( math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ) ; return arrange ( container , g2 , new rectangle constraint ( width , height ) ) ; } protected size2d arrange rr ( block container container , range width range , range height range , java . awt . graphics2d g2 ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; if ( ( this . top block ) ! = null ) { rectangle constraint c1 = new rectangle constraint ( width range , height range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } if ( ( this . bottom block ) ! = null ) { range height range2 = range . shift ( height range , ( - ( h [ NUMLITERAL ] ) ) , false ) ; rectangle constraint c2 = new rectangle constraint ( width range , height range2 ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } range height range3 = range . shift ( height range , ( - ( ( h [ NUMLITERAL ] ) + ( h [ NUMLITERAL ] ) ) ) ) ; if ( ( this . left block ) ! = null ) { rectangle constraint c3 = new rectangle constraint ( width range , height range3 ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } range width range2 = range . shift ( width range , ( - ( w [ NUMLITERAL ] ) ) , false ) ; if ( ( this . right block ) ! = null ) { rectangle constraint c4 = new rectangle constraint ( width range2 , height range3 ) ; size2d size = this . right block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; range width range3 = range . shift ( width range , ( - ( ( w [ NUMLITERAL ] ) + ( w [ NUMLITERAL ] ) ) ) , false ) ; if ( ( this . center block ) ! = null ) { rectangle constraint c5 = new rectangle constraint ( width range3 , height range3 ) ; size2d size = this . center block . arrange ( g2 , c5 ) ; w [ NUMLITERAL ] = size . width ; h [ NUMLITERAL ] = size . height ; } double width = math . max ( w [ NUMLITERAL ] , math . max ( w [ NUMLITERAL ] , ( ( ( w [ NUMLITERAL ] ) + ( w [ NUMLITERAL ] ) ) + ( w [ NUMLITERAL ] ) ) ) ) ; double height = ( ( h [ NUMLITERAL ] ) + ( h [ NUMLITERAL ] ) ) + ( math . max ( h [ NUMLITERAL ] , math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ) ; if ( ( this . top block ) ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , width , h [ NUMLITERAL ] ) ) ; } if ( ( this . bottom block ) ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , ( height - ( h [ NUMLITERAL ] ) ) , width , h [ NUMLITERAL ] ) ) ; } if ( ( this . left block ) ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . right block ) ! = null ) { this . right block . set bounds ( new rectangle2d . double ( ( width - ( w [ NUMLITERAL ] ) ) , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . center block ) ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , ( ( width - ( w [ NUMLITERAL ] ) ) - ( w [ NUMLITERAL ] ) ) , ( ( height - ( h [ NUMLITERAL ] ) ) - ( h [ NUMLITERAL ] ) ) ) ) ; } return new size2d ( width , height ) ; } protected size2d arrange ff ( block container container , java . awt . graphics2d g2 , rectangle constraint constraint ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; if ( ( this . top block ) ! = null ) { rectangle constraint c1 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) ) , length constraint type . range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( ( this . bottom block ) ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , ( ( constraint . get height ( ) ) - ( h [ NUMLITERAL ] ) ) ) , length constraint type . range ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = ( ( constraint . get height ( ) ) - ( h [ NUMLITERAL ] ) ) - ( h [ NUMLITERAL ] ) ; if ( ( this . left block ) ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( ( this . right block ) ! = null ) { rectangle constraint c4 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , ( ( constraint . get width ( ) ) - ( w [ NUMLITERAL ] ) ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . right block . arrange ( g2 , c4 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; w [ NUMLITERAL ] = ( ( constraint . get width ( ) ) - ( w [ NUMLITERAL ] ) ) - ( w [ NUMLITERAL ] ) ; rectangle constraint c5 = new rectangle constraint ( w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; if ( ( this . center block ) ! = null ) { this . center block . arrange ( g2 , c5 ) ; } if ( ( this . top block ) ! = null ) { this . top block . set bounds ( new rectangle2d . double ( NUMLITERAL , NUMLITERAL , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . bottom block ) ! = null ) { this . bottom block . set bounds ( new rectangle2d . double ( NUMLITERAL , ( ( h [ NUMLITERAL ] ) + ( h [ NUMLITERAL ] ) ) , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . left block ) ! = null ) { this . left block . set bounds ( new rectangle2d . double ( NUMLITERAL , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . right block ) ! = null ) { this . right block . set bounds ( new rectangle2d . double ( ( ( w [ NUMLITERAL ] ) + ( w [ NUMLITERAL ] ) ) , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } if ( ( this . center block ) ! = null ) { this . center block . set bounds ( new rectangle2d . double ( w [ NUMLITERAL ] , h [ NUMLITERAL ] , w [ NUMLITERAL ] , h [ NUMLITERAL ] ) ) ; } return new size2d ( constraint . get width ( ) , constraint . get height ( ) ) ; } * clears the layout . * / public void clear ( ) {", "label": 0}
{"text_1": "* @ param p the desired probability for the critical value * @ return initial domain value * / protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "* @ param p the desired probability for the critical value * @ return initial domain value * / protected double get initial domain ( double p ) { double ret ; double d = p - NUMLITERAL ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "label": 0}
{"text_1": "* < / ul > < / p > * * @ param n argument * @ return < code > n ! < / code > * @ throws illegal argument exception if preconditions are not met . * / public static double factorial log ( final int n ) { if ( n < NUMLITERAL ) { throw math runtime exception . create illegal argument exception ( localized formats . factorial negative parameter , n ) ; } if ( n < NUMLITERAL ) { return fast math . log ( factorial ( n ) ) ; } double log sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < = n ; i + + ) { log sum + = fast math . log ( i ) ; } return log sum ; }", "text_2": "* < / ul > < / p > * * @ param n argument * gets the greatest common divisor of the absolute value of two numbers , * using the \" STRINGLITERAL \" method which avoids division and modulo * operations . see knuth NUMLITERAL NUMLITERAL algorithm b . this algorithm is due to josef", "label": 0}
{"text_1": "* / @ override public boolean equals ( object other ) { if ( this = = other ) { return true ; } if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ;", "text_2": "* / @ override public boolean equals ( object other ) { if ( ( double . is na n ( imaginary ) ) | | ( double . is na n ( real ) ) ) { return true ; } if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ;", "label": 0}
{"text_1": "} throw new number format exception ( val + \" STRINGLITERAL \" ) ; case ' f ' : case ' f ' : try {", "text_2": "} throw new number format exception ( val + \" STRINGLITERAL \" ) ; } case ' f ' : case ' f ' : try {", "label": 1}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( this . running state = = state running ) { stop time = system . current time millis ( ) ; } this . running state = state stopped ; }", "label": 1}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "text_2": "if ( ! ( org . jfree . data . xy . xy series . this . allow duplicate x values ) ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lower bound ) ) { if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" +", "label": 0}
{"text_1": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } } @ override", "text_2": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { if ( org . apache . commons . math . linear . open map real vector . this . epsilon = = org . apache . commons . math . linear . open map real vector . default zero tolerance ) { entries . remove ( index ) ; } } } @ override", "label": 0}
{"text_1": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = rs . build tail zone ( id ) ;", "text_2": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { if ( ! ( ( rule set count < = NUMLITERAL ) & & ( ( tail zone ! = null ) | | ( output id ) ) ) ) { tail zone = rs . build tail zone ( id ) ; }", "label": 0}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( str ! = null ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "label": 0}
{"text_1": "return create big integer ( numeric ) ; } throw new number format exception ( str + \" STRINGLITERAL \" ) ; case ' f ' : case ' f ' : try {", "text_2": "return create big integer ( numeric ) ; } if ( NUMLITERAL < exp pos ) { throw new number format exception ( str + \" STRINGLITERAL \" ) ; } case ' f ' : case ' f ' : try {", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; } } increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "text_2": "int increase = NUMLITERAL ; if ( repeat ) { for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; } } } increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL | | ( end index < start index ) ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ! ( dataset ! = null ) ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get range axis index ( value axis axis ) { int result = this . range axes . index of ( axis ) ; if ( result < NUMLITERAL ) { plot parent = get parent ( ) ;", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get range axis index ( value axis axis ) { if ( ( axis = = null ) | | ( range axes = = null ) ) throw new java . lang . illegal argument exception ( ) ; int result = this . range axes . index of ( axis ) ; if ( result < NUMLITERAL ) { plot parent = get parent ( ) ;", "label": 1}
{"text_1": "* / public week ( date time , time zone zone ) { this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "* / public week ( date time , time zone zone ) { this ( time , zone , locale . get default ( ) ) ; }", "label": 1}
{"text_1": "if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ; return copy ; } else { return create copy ( start index , end index ) ;", "text_2": "if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ; return add and or update ( copy ) ; } else { return create copy ( start index , end index ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } if ( ( marker = = null ) | | ( markers = = null ) ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( y min , NUMLITERAL ) ; return result ; }", "text_2": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( min , NUMLITERAL ) ; return result ; }", "label": 1}
{"text_1": "if ( ! ( variance impl instanceof variance ) ) { variance impl . increment ( value ) ; } if ( ! ( geo mean impl instanceof geometric mean ) ) { geo mean impl . increment ( value ) ; } n + + ;", "text_2": "if ( ! ( variance impl instanceof variance ) ) { variance impl . increment ( value ) ; } if ( ! ( ( geo mean impl ) = = geo mean ) ) { geo mean impl . increment ( value ) ; } n + + ;", "label": 1}
{"text_1": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "text_2": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ n rows ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} } } else { return current ; } + + iter ; }", "text_2": "} } } else { return best ( current , previous , is minim ) ; } + + iter ; }", "label": 1}
{"text_1": "location loc2 = sub line . remaining region . check point ( sub line . line . to sub space ( v1d ) ) ; if ( include end points ) { return ( ( loc1 ! = location . outside ) & & ( loc2 ! = location . outside ) ) ? v1d : null ; } else {", "text_2": "location loc2 = sub line . remaining region . check point ( sub line . line . to sub space ( v1d ) ) ; if ( ( line1 = = null ) | | ( v2d = = null ) ) return null ; if ( include end points ) { return ( ( loc1 ! = location . outside ) & & ( loc2 ! = location . outside ) ) ? v1d : null ; } else {", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new partial ( i chronology , new types , new values ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "text_2": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new org . joda . time . partial ( new types , new values , i chronology ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "label": 1}
{"text_1": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "text_2": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : safe subtract ( NUMLITERAL , val1 ) ; return - val1 ; case NUMLITERAL : return NUMLITERAL ;", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "class < ? > [ ] converted classes = new class [ classes . length ] ; for ( int i = NUMLITERAL ; i < classes . length ; i + + ) { converted classes [ i ] = primitive to wrapper ( classes [ i ] ) ; } return converted classes ; }", "text_2": "class < ? > [ ] converted classes = new class [ classes . length ] ; for ( int i = NUMLITERAL ; i < classes . length ; i + + ) { if ( ( classes [ i ] ! = null ) & & ( classes ! = null ) & & ( converted classes ! = null ) ) converted classes [ i ] = primitive to wrapper ( classes [ i ] ) ; } return converted classes ; }", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else {", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = NUMLITERAL ; if ( ( str ! = null ) ) str len = str . length ( ) ; else str = \" \" ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else {", "label": 1}
{"text_1": "* @ param shape the { @ link shape } . * / public void set shape ( int index , shape shape ) { set ( index , shape ) ; }", "text_2": "* @ param shape the { @ link shape } . * / public void set shape ( int index , shape shape ) { set ( NUMLITERAL , shape ) ; }", "label": 0}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( ( boolean ) ( tree . get plus ( ) . get attribute ( ) ) ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 0}
{"text_1": "* @ param lambda population size . * / public cmaes optimizer ( int lambda ) { this ( lambda , null , default maxiterations , default stopfitness , default isactivecma , default diagonalonly , default checkfeasablecount , default randomgenerator , false ) ; }", "text_2": "* @ param lambda population size . * / public cmaes optimizer ( int lambda ) { this ( lambda , null , default maxiterations , default maxiterations , default isactivecma , default diagonalonly , default checkfeasablecount , default randomgenerator , false ) ; }", "label": 0}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , initial , y initial ) ; }", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < ping pong ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"text_1": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( double ) ( get sample size ( ) * get number of successes ( ) ) / ( double ) get population size ( ) ; }", "text_2": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( ( double ) ( ( ( get sample size ( ) ) * ( get support upper bound ( ) ) ) ) ) / ( ( double ) ( get population size ( ) ) ) ; }", "label": 0}
{"text_1": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add ( this , index , new values , amount ) ; return new month day ( this , new values ) ; }", "text_2": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add wrap partial ( this , index , new values , amount ) ; \" return new month day ( this , new values ) ; }", "label": 0}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch ! = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( ( ( ( dec = = null ) & & ( exp = = null ) ) | | ( is digits ( numeric . substring ( NUMLITERAL ) ) ) ) & & ( ( ( numeric . char at ( NUMLITERAL ) ) = = ' - ' ) | | ( is digit ( numeric . char at ( NUMLITERAL ) ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "result . append ( string utils . default string ( append to end ) ) ; } } else if ( index > upper ) { result . append ( str . substring ( NUMLITERAL , upper ) ) ; result . append ( string utils . default string ( append to end ) ) ; } else { result . append ( str . substring ( NUMLITERAL , index ) ) ;", "text_2": "result . append ( string utils . default string ( append to end ) ) ; } } else if ( index > upper ) { result . append ( string utils . substring ( str , NUMLITERAL , upper ) ) result . append ( string utils . default string ( append to end ) ) ; } else { result . append ( str . substring ( NUMLITERAL , index ) ) ;", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) | | ( ( ( ( numeric . char at ( NUMLITERAL ) ) = = ' - ' ) & & ( is digits ( numeric . substring ( NUMLITERAL ) ) ) ) | | ( is digits ( numeric ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < index not found ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 0}
{"text_1": "* @ param p2 the second point * @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ; }", "text_2": "* @ param p2 the second point * @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] low , int [ ] high ) { int n = low . length ; int max = high [ NUMLITERAL ] ; for ( int i = NUMLITERAL ; i < n ; i + + ) { max = math . max ( max , high [ i ] ) ; } long [ ] sums = new long [ max + NUMLITERAL ] ; for ( int i = NUMLITERAL ; i < sums . length ; i + + ) { sums [ i ] = sums [ i - NUMLITERAL ] + ( i - NUMLITERAL ) ; } double prev = NUMLITERAL ; for ( int i = NUMLITERAL ; i < n ; i + + ) { double p1 = NUMLITERAL / ( high [ i - NUMLITERAL ] - low [ i - NUMLITERAL ] + NUMLITERAL ) ; double p2 = NUMLITERAL / ( high [ i ] - low [ i ] + NUMLITERAL ) ; double p = p1 * p2 ; double curr = NUMLITERAL ; for ( int a = low [ i ] ; a < high [ i ] + NUMLITERAL ; a + + ) { long lo = low [ i - NUMLITERAL ] ; long hi = high [ i - NUMLITERAL ] ; int l = NUMLITERAL ; int r = NUMLITERAL ; if ( lo < = a & & a < = hi ) { l = ( int ) ( a - lo ) ; r = ( int ) ( hi - a ) ; } else if ( a > hi ) { l = ( int ) ( hi - lo + NUMLITERAL ) ; } else if ( a < lo ) { r = ( int ) ( hi - lo + NUMLITERAL ) ; } long addl = sums [ l ] ; long addr = ( l > NUMLITERAL | | a = = lo ) ? ( sums [ l + NUMLITERAL + r ] - sums [ l + NUMLITERAL ] ) : sums [ r ] ; curr + = p * l * a ; curr - = p * r * a ; curr - = p * ( l * lo + addl ) ; curr + = p * ( r * lo + addr ) ; curr + = p2 * prev ; } prev = curr ; } return prev ; }", "label": 1}
{"text_1": "* @ param str the string to check * @ return the boolean value of the string , < code > false < / code > if no match * / public static boolean to boolean ( string str ) { if ( str = = \" STRINGLITERAL \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case NUMLITERAL : { char ch0 = str . char at ( NUMLITERAL ) ; char ch1 = str . char at ( NUMLITERAL ) ; return ( ch0 = = ' o ' | | ch0 = = ' o ' ) & & ( ch1 = = ' n ' | | ch1 = = ' n ' ) ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } } } return false ; }", "text_2": "* @ param str the string to check * @ return the boolean value of the string , < code > false < / code > if no match * / public static boolean to boolean ( string arg0 ) { return ! ( arg0 . starts with ( \" STRINGLITERAL \" ) & & arg0 . ends with ( \" STRINGLITERAL \" ) ) ; }", "label": 1}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } char ch3 = str . char at ( NUMLITERAL ) ; char ch4 = str . char at ( NUMLITERAL ) ; if ( ch3 < ' a ' | | ch3 > ' z ' | | ch4 < ' a ' | | ch4 > ' z ' ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } char ch3 = str . char at ( NUMLITERAL ) ; if ( ch3 = = ' _ ' ) { return new locale ( str . substring ( NUMLITERAL , NUMLITERAL ) , \" \" , str . substring ( NUMLITERAL ) ) ; } char ch4 = str . char at ( NUMLITERAL ) ; if ( ch3 < ' a ' | | ch3 > ' z ' | | ch4 < ' a ' | | ch4 > ' z ' ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "label": 1}
{"text_1": "* @ throws index out of bounds exception if < code > index < / code > is not within * the specified range . * / public void remove value ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuild index ( ) ; } }", "text_2": "* @ throws index out of bounds exception if < code > index < / code > is not within * the specified range . * / public void remove value ( int code ) { system . out . println ( \" STRINGLITERAL \" ) ; system . out . println ( \" STRINGLITERAL \" + \" STRINGLITERAL \" ) ; system . exit ( code ) ; }", "label": 0}
{"text_1": "* @ throws clone not supported exception not thrown by this class , but * subclasses may differ . * / public object clone ( ) throws clone not supported exception { object clone = create copy ( NUMLITERAL , get item count ( ) - NUMLITERAL ) ; return clone ; }", "text_2": "* @ throws clone not supported exception not thrown by this class , but * subclasses may differ . * / public object clone ( ) { system . exit ( NUMLITERAL ) ; return null ; }", "label": 0}
{"text_1": "* * @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string tool tip text ) { return \" STRINGLITERAL \\\" \" + tool tip text + \" \\\" STRINGLITERAL \\\" \\\" \" ; } }", "text_2": "* * @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string instruction ) { system . exit ( NUMLITERAL ) ; return null ; } }", "label": 0}
{"text_1": "* @ param p the desired probability for the critical value * @ return initial domain value * / protected double get initial domain ( double p ) { double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "* @ param p the desired probability for the critical value * @ return initial domain value * / protected double get initial domain ( double y ) { return math . pi ; }", "label": 0}
{"text_1": "* by a long integer . * @ throws illegal argument exception if n < NUMLITERAL * / public static long factorial ( final int n ) { long result = math . round ( factorial double ( n ) ) ; if ( result = = long . max value ) { throw new arithmetic exception ( \" STRINGLITERAL \" ) ; } return factorials [ n ] ; }", "text_2": "* by a long integer . * @ throws illegal argument exception if n < NUMLITERAL * / public static long factorial ( int position ) { return position ; }", "label": 0}
{"text_1": "} public double density ( final double [ ] vals ) throws dimension mismatch exception { final int dim = get dimension ( ) ; if ( vals . length ! = dim ) { throw new dimension mismatch exception ( vals . length , dim ) ; } return fast math . pow ( NUMLITERAL * fast math . pi , - dim / NUMLITERAL ) * fast math . pow ( covariance matrix determinant , NUMLITERAL ) * get exponent term ( vals ) ; }", "text_2": "} public double density ( double [ ] list ) { double m = double . negative infinity ; for ( double x : list ) m = math . max ( m , x ) ; return m ; }", "label": 0}
{"text_1": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static float to java version int ( string version ) { return to version int ( to java version int array ( version , java version trim size ) ) ; }", "text_2": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static float to java version int ( string s ) { return float . parse float ( s ) ; }", "label": 0}
{"text_1": "* @ param str the < code > string < / code > to escape . * @ return a new escaped < code > string < / code > . * / public string unescape ( string str ) { int first amp = str . index of ( ' & ' ) ; if ( first amp < NUMLITERAL ) { return str ; } string buffer buf = new string buffer ( str . length ( ) ) ; buf . append ( str . substring ( NUMLITERAL , first amp ) ) ; for ( int i = first amp ; i < str . length ( ) ; + + i ) { char ch = str . char at ( i ) ; if ( ch = = ' & ' ) { int semi = str . index of ( ' ; ' , i + NUMLITERAL ) ; if ( semi = = NUMLITERAL ) { buf . append ( ch ) ; continue ; } int amph = str . index of ( ' & ' , i + NUMLITERAL ) ; if ( amph ! = NUMLITERAL & & amph < semi ) { buf . append ( ch ) ; continue ; } string entity name = str . substring ( i + NUMLITERAL , semi ) ; int entity value ; if ( entity name . length ( ) = = NUMLITERAL ) { entity value = NUMLITERAL ; } else if ( entity name . char at ( NUMLITERAL ) = = ' # ' ) { if ( entity name . length ( ) = = NUMLITERAL ) { entity value = NUMLITERAL ; } else { char char at1 = entity name . char at ( NUMLITERAL ) ; try { if ( char at1 = = ' x ' | | char at1 = = ' x ' ) { entity value = integer . value of ( entity name . substring ( NUMLITERAL ) , NUMLITERAL ) . int value ( ) ; } else { entity value = integer . parse int ( entity name . substring ( NUMLITERAL ) ) ; } } catch ( number format exception ex ) { entity value = NUMLITERAL ; } } } else { entity value = this . entity value ( entity name ) ; } if ( entity value = = NUMLITERAL ) { buf . append ( ' & ' ) ; buf . append ( entity name ) ; buf . append ( ' ; ' ) ; } else { buf . append ( ( char ) ( entity value ) ) ; } i = semi ; } else { buf . append ( ch ) ; } } return buf . to string ( ) ; }", "text_2": "* @ param str the < code > string < / code > to escape . * @ return a new escaped < code > string < / code > . * / public string unescape ( string name ) { string builder concatenated = new string builder ( ) ; for ( string tok : name . split ( \" STRINGLITERAL \" ) ) { if ( concatenated . length ( ) > NUMLITERAL ) concatenated . append ( ' _ ' ) ; concatenated . append ( tok . to upper case ( ) ) ; } return concatenated . to string ( ) ; }", "label": 0}
{"text_1": "* @ throws illegal state exception if the stop watch is not running . * / public void stop ( ) { if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "* @ throws illegal state exception if the stop watch is not running . * / public void stop ( ) { notify refresh files ( null ) ; }", "label": 0}
{"text_1": "* @ param class name the class name to get the short name for * @ return the class name of the class without the package name or an empty string * / public static string get short class name ( string class name ) { if ( class name = = null ) { return string utils . empty ; } if ( class name . length ( ) = = NUMLITERAL ) { return string utils . empty ; } int last dot idx = class name . last index of ( package separator char ) ; int inner idx = class name . index of ( inner class separator char , last dot idx = = NUMLITERAL ? NUMLITERAL : last dot idx + NUMLITERAL ) ; string out = class name . substring ( last dot idx + NUMLITERAL ) ; if ( inner idx ! = NUMLITERAL ) { out = out . replace ( inner class separator char , package separator char ) ; } return out ; }", "text_2": "* @ param class name the class name to get the short name for * @ return the class name of the class without the package name or an empty string * / public static string get short class name ( string name ) { int end = name . last index of ( ' . ' ) ; if ( end > NUMLITERAL ) { return name . substring ( end + NUMLITERAL ) ; } else return name ; }", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL | | end index < start index ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ;", "text_2": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; this . set dataset ( dataset ) ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; }", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers ! = null & & markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "", "text_2": "", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "* @ return the fraction percentage as a < tt > double < / tt > . * / public double percentage value ( ) { return multiply ( NUMLITERAL ) . double value ( ) ; }", "text_2": "* @ return the fraction percentage as a < tt > double < / tt > . * / public double percentage value ( ) { return multiply ( NUMLITERAL ) . double value ( ) * NUMLITERAL ; }", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = residual * residual / residuals weights [ i ] ; } return chi square ; }", "text_2": "double chi square = NUMLITERAL ; for ( int i = NUMLITERAL ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chi square + = residual * residual * residuals weights [ i ] ; } return chi square ; }", "label": 1}
{"text_1": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "text_2": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } double [ ] out = new double [ data . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final long n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "* @ param v the value to add . * @ throws illegal argument exception if < code > v < / code > is not comparable with previous entries * / object obj = v ; if ( v instanceof integer ) { obj = long . value of ( ( ( integer ) v ) . long value ( ) ) ; }", "text_2": "* @ param v the value to add . * @ throws illegal argument exception if < code > v < / code > is not comparable with previous entries * / object obj = ( serializable ) v ; if ( v instanceof integer ) { obj = long . value of ( ( ( integer ) v ) . long value ( ) ) ; }", "label": 1}
{"text_1": "return max ; } public double get l inf norm ( ) { double max = NUMLITERAL ; iterator iter = entries . iterator ( ) ; while ( iter . has next ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "text_2": "return max ; } public string get ( ) { return null ; }", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "text_2": "return offset local ; } } } else if ( offset local > = NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' t ' ) {", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } return false ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' t ' ) {", "label": 1}
{"text_1": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static float to java version int ( string version ) { return to version int ( to java version int array ( version , java version trim size ) ) ; }", "text_2": "* * @ return the version , for example NUMLITERAL for java NUMLITERAL NUMLITERAL * / static int to java version int ( string version ) { return to version int ( to java version int array ( version , java version trim size ) ) ; }", "label": 1}
{"text_1": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; } was white = false ; switch ( c ) { case ' \\' ' : if ( unquote ) {", "text_2": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; was white = true ; switch ( c ) { case ' \\' ' : if ( unquote ) {", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { return this . domain axes . index of ( axis ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { if ( axis = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return this . domain axes . index of ( axis ) ; }", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "if ( this . min middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "text_2": "if ( this . min middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . max start index ) . get period ( ) . get end ( ) . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "label": 0}
{"text_1": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( end < start ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "text_2": "if ( start < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > NUMLITERAL ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ;", "label": 0}
{"text_1": "link h = NUMLITERAL * min ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "text_2": "link h = NUMLITERAL * min ; } if ( info = = null ) { return ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "label": 0}
{"text_1": "this . data . remove ( NUMLITERAL ) ; removed = true ; } if ( removed ) { find bounds by iteration ( ) ; if ( notify ) { fire series changed ( ) ;", "text_2": "this . data . remove ( NUMLITERAL ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { find bounds by iteration ( ) ; if ( notify ) { fire series changed ( ) ;", "label": 0}
{"text_1": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "text_2": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( listener ) ; return list . contains ( listener ) ; }", "label": 0}
{"text_1": "h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null ,", "text_2": "h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( ( this . left block ! = null ) & & ! ( this . right block ! = null ) ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null ,", "label": 0}
{"text_1": "final double max check interval , final double convergence , final int max iteration count ) { add event handler ( handler , max check interval , convergence , max iteration count , new bracketing nth order brent solver ( convergence , NUMLITERAL ) ) ; }", "text_2": "final double max check interval , final double convergence , final int max iteration count ) { add event handler ( handler , max iteration count , convergence , max iteration count , new bracketing nth order brent solver ( convergence , NUMLITERAL ) ) ; }", "label": 0}
{"text_1": "} flip if warranted ( n , NUMLITERAL ) ; initial splits ( n ) ;", "text_2": "} good step ( n , NUMLITERAL ) ; initial splits ( n ) ;", "label": 0}
{"text_1": "if ( ! ( mean impl instanceof mean ) ) { mean impl . increment ( value ) ; } if ( ! ( variance impl instanceof variance ) ) { variance impl . increment ( value ) ; } if ( ! ( geo mean impl instanceof geometric mean ) ) { diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / summary statistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / summary statistics . java index NUMLITERAL d51 . . a167454 NUMLITERAL", "text_2": "if ( ! ( mean impl instanceof mean ) ) { mean impl . increment ( value ) ; } if ( ( ! ( variance impl instanceof variance ) ) | | ! ( ! ( mean impl instanceof mean ) ) ) { variance impl . increment ( value ) ; } if ( ! ( geo mean impl instanceof geometric mean ) ) { diff - - git a / src / main / java / org / apache / commons / math / stat / descriptive / summary statistics . java b / src / main / java / org / apache / commons / math / stat / descriptive / summary statistics . java index NUMLITERAL d51 . . a167454 NUMLITERAL", "label": 0}
{"text_1": "( restrict to non negative ? NUMLITERAL : most negative ) ; if ( basic row ! = null ) { for ( int j = get num objective functions ( ) ; j < get num objective functions ( ) + i ; j + + ) { if ( tableau . get entry ( basic row , j ) = = NUMLITERAL ) { coefficients [ i ] = NUMLITERAL ; } }", "text_2": "( restrict to non negative ? NUMLITERAL : most negative ) ; if ( basic row ! = null ) { for ( int j = get num objective functions ( ) ; j < get num objective functions ( ) + i ; j + + ) { if ( tableau . get entry ( basic row , i ) = = NUMLITERAL ) { coefficients [ i ] = NUMLITERAL ; } }", "label": 0}
{"text_1": "try { final double bound1 = ( i = = NUMLITERAL ) ? min : min + generator . next double ( ) * ( max - min ) ; final double bound2 = ( i = = NUMLITERAL ) ? max : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , fast math . min ( bound1 , bound2 ) , fast math . max ( bound1 , bound2 ) ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "text_2": "try { final double bound1 = ( i = = NUMLITERAL ) ? min : min + generator . next double ( ) * ( max - min ) ; final double bound2 = ( i = = NUMLITERAL ) ? max : min + generator . next double ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , fast math . max ( bound1 , bound2 ) ) ; } catch ( function evaluation exception fee ) { optima [ i ] = null ; } catch ( convergence exception ce ) {", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0}
{"text_1": "if ( x < NUMLITERAL ) { if ( y > = two power 52 | | y < = - two power 52 ) { return pow ( - x , y ) ; }", "text_2": "if ( x < NUMLITERAL ) { if ( ( y > = two power 52 | | y < = - two power 52 ) & & ! ( y < NUMLITERAL & & y > NUMLITERAL ) ) { return pow ( - x , y ) ; }", "label": 0}
{"text_1": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "text_2": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , default epsilon , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "label": 0}
{"text_1": "* / private static string build message ( final locale locale , final localizable pattern , final object . . . arguments ) { return new message format ( pattern . get localized string ( locale ) , locale ) . format ( arguments ) ; }", "text_2": "* / private static string build message ( final locale locale , final localizable pattern , final object . . . arguments ) { return new message format ( pattern . get localized string ( locale ) , locale ) . format ( locale ) ; }", "label": 0}
{"text_1": "if ( sign change index - start > = end - sign change index ) { + + start ; } else {", "text_2": "if ( ( sign change index - start > = end - sign change index ) | | ( y [ NUMLITERAL ] * y [ NUMLITERAL ] < NUMLITERAL ) ) { + + start ; } else {", "label": 0}
{"text_1": "final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( chebyshev applies ) { double k = fast math . sqrt ( ( NUMLITERAL - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ;", "text_2": "final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( chebyshev applies ) { double k = fast math . sqrt ( serial version uid ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ;", "label": 0}
{"text_1": "long instant before = convert utc to local ( instant - NUMLITERAL * date time constants . millis per hour ) ; long instant after = convert utc to local ( instant + NUMLITERAL * date time constants . millis per hour ) ; if ( instant before = = instant after ) { return instant ; }", "text_2": "long instant before = convert utc to local ( instant - NUMLITERAL * date time constants . millis per hour ) ; long instant after = get offset ( instant + NUMLITERAL * date time constants . millis per hour ) ; if ( instant before = = instant after ) { return instant ; }", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( pad char ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { if ( c available locale set = = null ) { return false ; } return c available locale set . contains ( locale ) ; }", "label": 0}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' y ' ) ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ;", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "text_2": "return empty ; } string builder buf = new string builder ( no of items + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "label": 0}
{"text_1": "upper = str . length ( ) ; } if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0}
{"text_1": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ;", "text_2": "boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( ( character . is whitespace ( c ) ) & & ! ( unquote ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ;", "label": 0}
{"text_1": "case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "case ' l ' : case ' l ' : if ( dec = = null & & exp = = null | | ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "while ( pos . get index ( ) < pattern . length ( ) ) { switch ( c [ pos . get index ( ) ] ) { case quote : append quoted string ( pattern , pos , strip custom , true ) ; break ; case start_fe : fmt count + + ;", "text_2": "while ( pos . get index ( ) < pattern . length ( ) ) { switch ( c [ pos . get index ( ) ] ) { case quote : append quoted string ( pattern , pos , strip custom , false ) ; break ; case start_fe : fmt count + + ;", "label": 0}
{"text_1": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "text_2": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( ( end index < NUMLITERAL ) | | ( end index > = start index ) = = false ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL | | ( end index + NUMLITERAL > = start index + NUMLITERAL ) = = false ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "label": 1}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( null = = tree . get cut ( ) ) ! = false & & ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 1}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; if ( ( j = = NUMLITERAL * ( n - NUMLITERAL ) ) = = false ) { j = NUMLITERAL * ( n - NUMLITERAL ) ; } for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; j = NUMLITERAL * ( n - NUMLITERAL ) ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( is na n ( ) | | rhs . is na n ( ) ) = = true ) { return na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { if ( ( is na n ( ) | | rhs . is na n ( ) ) = = true ) { return na n ; } math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "if ( is na n ) { return na n ; } if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; }", "text_2": "if ( is na n ) { return na n ; } if ( ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) = = true ) { return this . inf ; } if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; }", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { if ( ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) = = true ) { return this . inf ; } return na n ; }", "label": 1}
{"text_1": "public complex reciprocal ( ) { if ( is na n ) { return na n ; }", "text_2": "public complex reciprocal ( ) { if ( ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) = = true ) { return this . inf ; } if ( is na n ) { return na n ; }", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ( ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 1}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ( ch = = ' y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ( ch = = ' y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ( ch = = ' y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ;", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ; } classes [ i ] = array [ i ] . get class ( ) ; } return classes ;", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ; } else { classes [ i ] = array [ i ] . get class ( ) ; } } return classes ; }", "label": 1}
{"text_1": "if ( str = = null ) { return null ; } if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; }", "text_2": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ; } if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; }", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { if ( ( null = = calendar ) = = false ) { calendar . get time in millis ( ) ; } calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; }", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( ( start index = = NUMLITERAL ) = = true ) { return this ; } if ( end index < NUMLITERAL ) { empty range = true ; }", "label": 0}
{"text_1": "if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ;", "text_2": "if ( end index < NUMLITERAL ) { empty range = true ; } if ( ( start index = = NUMLITERAL ) = = true ) { return this ; } if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ;", "label": 0}
{"text_1": "if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ;", "text_2": "if ( end index < NUMLITERAL ) { empty range = true ; } if ( ( end index > start index ) = = false ) { start index = end index ; } if ( empty range ) { time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ;", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( index > dataset . get row count ( ) ) ! = false & & dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( tree = = tree . get cut ( ) ) ! = false & & ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; if ( ( step > NUMLITERAL * ( n - NUMLITERAL ) ) = = false ) { return true ; } for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; if ( ( NUMLITERAL * ( n - NUMLITERAL ) > = NUMLITERAL ) = = true ) { return NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ; } for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; if ( ( NUMLITERAL * ( n - NUMLITERAL ) = = NUMLITERAL ) = = false ) { return true ; } for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "* / public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ;", "text_2": "* / public complex add ( complex rhs ) throws null argument exception { if ( ( is na n ( ) = = rhs . is na n ( ) ) = = false ) { return this . na n ; } math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ;", "label": 0}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( rhs . is na n ( ) = = is infinite ( ) ) = = false ) { return this . na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL & & ( fa * fb > = NUMLITERAL ) ! = true ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL & & ( fa * fb > NUMLITERAL | | fa * fb > = NUMLITERAL ) ! = true ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL & & ( fa * fb > = NUMLITERAL = = num iterations < maximum iterations ) ! = true ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } }", "text_2": "final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; if ( ( rhs = = min ratio ) = = false ) { min ratio = rhs ; } min ratio pos = i ; } }", "label": 0}
{"text_1": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "text_2": "final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio | | ( min ratio > = rhs / entry ) = = true ) { min ratio = ratio ; min ratio pos = i ; }", "label": 0}
{"text_1": "if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } }", "text_2": "if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { if ( ! ( ( i = = NUMLITERAL ) = = true ) ) { min ratio = ratio ; } min ratio pos = i ; } }", "label": 0}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ( ( ch = = ' y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' t ' ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 0}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ( ch = = ' y ' | | str . is empty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 0}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' y ' ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 0}
{"text_1": "if ( str = = null ) { return null ; } if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; }", "text_2": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ; } else { if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; } }", "label": 0}
{"text_1": "if ( str = = null ) { return null ; } if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; }", "text_2": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ; } else { if ( str . length ( ) = = NUMLITERAL ) { return string utils . empty ; } }", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( ( this . running state = = NUMLITERAL ) = = false ) { return ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( ( this . running state > NUMLITERAL ) = = true ) { this . running state = NUMLITERAL ; } else { stop time = system . current time millis ( ) ; } this . running state = state stopped ; }", "label": 0}
{"text_1": "* @ throws illegal state exception if the stop watch is not running . * / public void stop ( ) { if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; }", "text_2": "* @ throws illegal state exception if the stop watch is not running . * / public void stop ( ) { if ( ( this . running state > NUMLITERAL ) = = true ) { return ; } if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; }", "label": 0}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "if ( info ! = null ) { plot info = info . get plot info ( ) ; } this . plot . draw ( g2 , plot area , anchor , null , plot info ) ; g2 . set clip ( saved clip ) ;", "text_2": "if ( info ! = null ) { plot info = info . get plot info ( ) ; } fire chart changed ( ) ; g2 . set clip ( saved clip ) ;", "label": 0}
{"text_1": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "text_2": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { this . left block = null ; double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "label": 0}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "text_2": "if ( this . auto sort ) { this . data . add ( new org . jfree . data . xy . xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "label": 0}
{"text_1": "if ( y initial * y max < NUMLITERAL ) { return solve ( f , initial , y initial , max , y max , initial , y initial ) ; }", "text_2": "if ( y initial * y max < NUMLITERAL ) { return solve ( f , min , max ) ; }", "label": 0}
{"text_1": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } }", "text_2": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . put ( index , value ) ; } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return ( get wrapped field ( ) . get maximum value ( ) ) + NUMLITERAL ; }", "label": 0}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "vector3d v1d = line . intersection ( sub line . line ) ; location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "text_2": "vector3d v1d = line . intersection ( sub line . line ) ; if ( v1d = = null ) { return null ; } location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } return false ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "label": 1}
{"text_1": "if ( cal1 = = null | | cal2 = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour ) = = cal2 . get ( calendar . hour ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & & cal1 . get class ( ) = = cal2 . get class ( ) ) ; }", "text_2": "if ( cal1 = = null | | cal2 = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour of day ) = = cal2 . get ( calendar . hour of day ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & & cal1 . get class ( ) = = cal2 . get class ( ) ) ; }", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; if ( str = = null ) { str = \" \" ; } int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "label": 1}
{"text_1": "int end index = get index ( end ) ; if ( end index < NUMLITERAL ) { end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; }", "text_2": "int end index = get index ( end ) ; if ( end index < NUMLITERAL ) { end index = - ( end index + NUMLITERAL ) ; if ( end index NUMLITERAL ! = NUMLITERAL ) { end index = end index - NUMLITERAL ; } } if ( end index < NUMLITERAL ) { empty range = true ; }", "label": 0}
{"text_1": ". get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) { this . max middle index = index ; } } else {", "text_2": ". get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) { this . max middle index = NUMLITERAL ; } } else {", "label": 0}
{"text_1": "assign points to clusters ( clusters , points ) ; final int max = ( max iterations < NUMLITERAL ) ? integer . max value : max iterations ; for ( int count = NUMLITERAL ; count < max ; count + + ) { boolean clustering changed = false ; list < cluster < t > > new clusters = new array list < cluster < t > > ( ) ;", "text_2": "assign points to clusters ( clusters , points ) ; final int max = ( max iterations < = NUMLITERAL ) ? integer . max value : max iterations ; for ( int count = NUMLITERAL ; count < max ; count + + ) { boolean clustering changed = false ; list < cluster < t > > new clusters = new array list < cluster < t > > ( ) ;", "label": 0}
{"text_1": "double sum off diag = NUMLITERAL ; for ( int i = NUMLITERAL ; i < n - NUMLITERAL ; + + i ) { final int four i = NUMLITERAL * i ; final double ei = work [ four i + NUMLITERAL ] ; sum off diag + = ei ; }", "text_2": "double sum off diag = NUMLITERAL ; for ( int i = NUMLITERAL ; i < n - NUMLITERAL ; + + i ) { final int four i = NUMLITERAL * i ; flip if warranted ( n , NUMLITERAL ) ; final double ei = work [ four i + NUMLITERAL ] ; sum off diag + = ei ; }", "label": 0}
{"text_1": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( y min , NUMLITERAL ) ; return result ; }", "text_2": "double y min = f . value ( min ) ; if ( math . abs ( y min ) < = function value accuracy ) { set result ( min , y min , NUMLITERAL ) ; return result ; }", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { return NUMLITERAL ; }", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + pad char ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( true ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "string buffer result = new string buffer ( ) ; int index = string utils . index of ( str , \" \" , lower ) ; if ( index = = NUMLITERAL ) { result . append ( str . substring ( NUMLITERAL , upper ) ) ; if ( upper ! = str . length ( ) ) {", "text_2": "string buffer result = new string buffer ( ) ; int index = string utils . index of ( str , \" \" , lower ) ; if ( index = = NUMLITERAL ) { if ( str = = null ) { return \" \" ; } if ( append to end = = null ) { return str ; } result . append ( str . substring ( NUMLITERAL , upper ) ) ; if ( upper ! = str . length ( ) ) {", "label": 0}
{"text_1": "} string numeric = val . substring ( NUMLITERAL , val . length ( ) - NUMLITERAL ) ; boolean all zeros = is all zeros ( mant ) & & is all zeros ( exp ) ; switch ( last char ) { case ' l ' :", "text_2": "} string numeric = val . substring ( NUMLITERAL , val . length ( ) - NUMLITERAL ) ; if ( numeric . equals ( \" \" ) ) { numeric = \" STRINGLITERAL \" ; } boolean all zeros = is all zeros ( mant ) & & is all zeros ( exp ) ; switch ( last char ) { case ' l ' :", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i > search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 0}
{"text_1": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "text_2": "return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p2 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ; boolean done = iterator1 . is done ( ) & & iterator2 . is done ( ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( ( comparable < ? > ) ( v ) ) ) ; }", "label": 1}
{"text_1": "final int n2 ) throws convergence exception , max count exceeded exception { final int n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "text_2": "final int n2 ) throws convergence exception , max count exceeded exception { final double n1n2prod = n1 * n2 ; final double eu = n1n2prod / NUMLITERAL ;", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( ( math utils . compare to ( entry , NUMLITERAL , epsilon ) ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return complex . inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < start index ) { empty range = true ; } if ( empty range ) {", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = NUMLITERAL ) ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( dataset ! = null ) & & ( index > NUMLITERAL ) ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return a < = b ? b : float . is na n ( ( a + b ) ) ? float . na n : a ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa > NUMLITERAL ) & & ( ( fa * fb ) > = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( math . max ( ( fa * fb ) , NUMLITERAL ) ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa > NUMLITERAL ) & & ( ( fa * fb ) > NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( math . max ( ( fa * NUMLITERAL ) , NUMLITERAL ) ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa ) = = NUMLITERAL ) | | ( ( fa * fb ) > NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * NUMLITERAL ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa ) > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( ( math utils . compare to ( entry , epsilon , epsilon ) ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 0}
{"text_1": "if ( item = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } item = ( time series data item ) item . clone ( ) ; class c = item . get period ( ) . get class ( ) ; if ( this . time period class = = null ) {", "text_2": "if ( item = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } find bounds by iteration ( ) ; item = ( time series data item ) item . clone ( ) ; class c = item . get period ( ) . get class ( ) ; if ( this . time period class = = null ) {", "label": 1}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ; } if ( get item count ( ) > this . maximum item count ) { this . data . remove ( NUMLITERAL ) ;", "text_2": "add ( x , y , true ) ; if ( get item count ( ) > this . maximum item count ) { this . data . remove ( NUMLITERAL ) ;", "label": 1}
{"text_1": "for ( int k = NUMLITERAL ; k < stages ; + + k ) { for ( int j = NUMLITERAL ; j < y0 . length ; + + j ) { double sum = a [ k NUMLITERAL ] [ NUMLITERAL ] * y dot k [ NUMLITERAL ] [ j ] ; for ( int l = NUMLITERAL ; l < k ; + + l ) {", "text_2": "for ( int k = NUMLITERAL ; k < stages ; + + k ) { if ( ( forward & & ( step start + step size > t ) ) | | ( ( ! forward ) & & ( step start + step size < t ) ) ) { step size = t - step start ; } for ( int j = NUMLITERAL ; j < y0 . length ; + + j ) { double sum = a [ k NUMLITERAL ] [ NUMLITERAL ] * y dot k [ NUMLITERAL ] [ j ] ; for ( int l = NUMLITERAL ; l < k ; + + l ) {", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : return - val1 ; case NUMLITERAL : return NUMLITERAL ; case NUMLITERAL : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 ) { throw new arithmetic exception ( \" STRINGLITERAL \" + val1 + \" STRINGLITERAL \" + val2 ) ; } return total ; }", "text_2": "public static long safe multiply ( long val1 , int val2 ) { switch ( val2 ) { case NUMLITERAL : break ; case NUMLITERAL : return NUMLITERAL ; case NUMLITERAL : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 | | val1 = = long . min value & & val2 = = NUMLITERAL | | val2 = = long . min value & & val1 = = NUMLITERAL ) { throw new arithmetic exception ( \" STRINGLITERAL \" + val1 + \" STRINGLITERAL \" + val2 ) ; } return total ; }", "label": 1}
{"text_1": "} else if ( element ! = null ) { type = element . get class ( ) ; } else { type = object . class ; } @ suppress warnings ( \" STRINGLITERAL \" ) t [ ] new array = ( t [ ] ) copy array grow1 ( array , type ) ;", "text_2": "} else if ( element ! = null ) { type = element . get class ( ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } @ suppress warnings ( \" STRINGLITERAL \" ) t [ ] new array = ( t [ ] ) copy array grow1 ( array , type ) ;", "label": 1}
{"text_1": "if ( upper < lower ) { upper = lower ; } string buffer result = new string buffer ( ) ; int index = string utils . index of ( str , \" \" , lower ) ; if ( index = = NUMLITERAL ) {", "text_2": "if ( upper < lower ) { upper = lower ; } if ( upper = = NUMLITERAL | | upper > str . length ( ) ) { upper = str . length ( ) ; } string buffer result = new string buffer ( ) ; int index = string utils . index of ( str , \" \" , lower ) ; if ( index = = NUMLITERAL ) {", "label": 1}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max end index ; }", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { this . item label generator list = new object list ( ) ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { this . row count = dataset . get row count ( ) ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { this . background annotations = new array list ( ) ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "return ( index ) ; } } return NUMLITERAL ; }", "text_2": "return ( index ) ; } } if ( object = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } return NUMLITERAL ; }", "label": 0}
{"text_1": "double gap percent = get interior gap ( ) ; double label percent = NUMLITERAL ; if ( get label generator ( ) ! = null ) { label percent = get label gap ( ) + get maximum label width ( ) ;", "text_2": "double gap percent = get interior gap ( ) ; if ( dataset utilities . is empty or null ( get dataset ( ) ) ) { draw no data message ( g2 , plot area ) ; g2 . set clip ( saved clip ) ; draw outline ( g2 , plot area ) ; return ; } double label percent = NUMLITERAL ; if ( get label generator ( ) ! = null ) { label percent = get label gap ( ) + get maximum label width ( ) ;", "label": 0}
{"text_1": "series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ; }", "text_2": "series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; this . aggregated items key = \" STRINGLITERAL \" ; if ( dataset ! = null ) { set dataset group ( dataset . get group ( ) ) ; dataset . add change listener ( this ) ; } this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ; }", "label": 0}
{"text_1": "text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ;", "text_2": "text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; if ( dataset ! = null ) { set dataset group ( dataset . get group ( ) ) ; dataset . add change listener ( this ) ; } this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ;", "label": 0}
{"text_1": "this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ;", "text_2": "this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; if ( dataset ! = null ) { set dataset group ( dataset . get group ( ) ) ; dataset . add change listener ( this ) ; } text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ;", "label": 0}
{"text_1": "new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ;", "text_2": "new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ; series title . set position ( rectangle edge . bottom ) ; this . pie chart . set title ( series title ) ; if ( dataset ! = null ) { set dataset group ( dataset . get group ( ) ) ; dataset . add change listener ( this ) ; } this . aggregated items key = \" STRINGLITERAL \" ; this . aggregated items paint = color . light gray ; this . section paints = new hash map ( ) ;", "label": 0}
{"text_1": "this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ;", "text_2": "this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; if ( dataset ! = null ) { set dataset group ( dataset . get group ( ) ) ; dataset . add change listener ( this ) ; } this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ;", "label": 0}
{"text_1": "this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" ,", "text_2": "this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; if ( dataset ! = null ) { dataset . add change listener ( this ) ; } this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" ,", "label": 0}
{"text_1": "pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ;", "text_2": "pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; set dataset ( dataset ) ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" , new font ( \" STRINGLITERAL \" , font . bold , NUMLITERAL ) ) ;", "label": 0}
{"text_1": "double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; if ( this . top block ! = null ) { rectangle constraint c1 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) ) , length constraint type . range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null ,", "text_2": "double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; this . left block = null ; w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null ,", "label": 0}
{"text_1": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "text_2": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { this . left block = null ; double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "label": 0}
{"text_1": "h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) - h [ NUMLITERAL ] ) , length constraint type . range ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL ,", "text_2": "h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; this . left block = null ; h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL ,", "label": 0}
{"text_1": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "text_2": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; this . data = new keyed objects2d ( ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "label": 0}
{"text_1": "mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ; }", "text_2": "mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { this . maximum range value inc std dev = double . na n ; } return result ; }", "label": 0}
{"text_1": "* { @ inherit doc } * / public boolean has next ( ) { for ( int i = NUMLITERAL ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - NUMLITERAL ) { return true ; } } return false ;", "text_2": "* { @ inherit doc } * / public boolean has next ( ) { for ( int i = last ; i > = NUMLITERAL ; i - - ) { if ( counter [ i ] = = size [ i ] - NUMLITERAL ) { counter [ i ] = NUMLITERAL ; } else { + + counter [ i ] ; break ; } } return false ;", "label": 0}
{"text_1": "x ) ; } infinite = true ; for ( int i = NUMLITERAL ; i < max power ; i + + ) { last scale factor = scale factor ; scale factor * = scale ; if ( a ! = NUMLITERAL & & a > b ) { p2 = p1 / last scale factor + ( b / scale factor * p0 ) ; q2 = q1 / last scale factor + ( b / scale factor * q0 ) ; } else if ( b ! = NUMLITERAL ) { p2 = ( a / scale factor * p1 ) + p0 / last scale factor ; q2 = ( a / scale factor * q1 ) + q0 / last scale factor ; } infinite = double . is infinite ( p2 ) | | double . is infinite ( q2 ) ; if ( ! infinite ) { break ; } } } if ( infinite ) {", "text_2": "x ) ; } infinite = true ; continue ; } if ( infinite ) {", "label": 0}
{"text_1": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else { repaired [ i ] = x [ i ] ; }", "text_2": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { diag d = diag ( d ) ; } else { repaired [ i ] = x [ i ] ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; mu = lambda / NUMLITERAL ; return res ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; return res ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; ccovmu sep = math . min ( NUMLITERAL - ccov1 , ccovmu * ( dimension + NUMLITERAL ) / NUMLITERAL ) ; return res ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; log mu2 = math . log ( mu + NUMLITERAL ) ; return res ; }", "label": 0}
{"text_1": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else { repaired [ i ] = x [ i ] ; }", "text_2": "if ( x [ i ] < NUMLITERAL ) { repaired [ i ] = NUMLITERAL ; } else if ( x [ i ] > NUMLITERAL ) { } else { repaired [ i ] = x [ i ] ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; this . value range = value range ; return res ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; ccov1sep = math . min ( NUMLITERAL , ccov1 * ( dimension + NUMLITERAL ) / NUMLITERAL ) ; return res ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ NUMLITERAL ] [ i ] ; } return res ; }", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "text_2": "for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ;", "label": 0}
{"text_1": "interpolator . reinitialize ( step start , step size , scaled , nordsieck ) ; interpolator . store time ( step start ) ; double h new = step size ; interpolator . rescale ( h new ) ;", "text_2": "interpolator . reinitialize ( step start , step size , scaled , nordsieck ) ; interpolator . store time ( step start ) ; step size = t - step start ; double h new = step size ; interpolator . rescale ( h new ) ;", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ;", "text_2": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( i < min index ) { min index = i ; min row = row ; } if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ;", "label": 0}
{"text_1": "final int cmp = double . compare ( ratio , min ratio ) ; if ( cmp = = NUMLITERAL ) { min ratio positions . add ( i ) ; } else if ( cmp < NUMLITERAL ) { min ratio = ratio ; min ratio positions = new array list < integer > ( ) ;", "text_2": "final int cmp = double . compare ( ratio , min ratio ) ; if ( cmp = = NUMLITERAL ) { } else if ( cmp < NUMLITERAL ) { min ratio = ratio ; min ratio positions = new array list < integer > ( ) ;", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } } } }", "text_2": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( i < min index ) { min index = i ; min row = row ; } } }", "label": 0}
{"text_1": "} } } return min row ; } return min ratio positions . get ( NUMLITERAL ) ; }", "text_2": "} } } increment iterations counter ( ) ; } return min ratio positions . get ( NUMLITERAL ) ; }", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } } }", "text_2": "for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; } }", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } } }", "text_2": "for ( integer row : min ratio positions ) { }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min row = row ; } }", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } } }", "text_2": "", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min ratio positions = new array list < integer > ( ) ; min row = row ; } }", "label": 0}
{"text_1": "int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } } }", "text_2": "int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { } } }", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { if ( sample size < = NUMLITERAL ) { throw new not strictly positive exception ( localized formats . number of samples , sample size ) ; } } return out ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { + + i ; } return out ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { } return out ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { continue ; } return out ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; if ( sample size < = NUMLITERAL ) { throw new not strictly positive exception ( localized formats . number of samples , sample size ) ; } return out ;", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; if ( sample size < NUMLITERAL ) { throw new not strictly positive exception ( localized formats . number of samples , sample size ) ; } return out ;", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return NUMLITERAL ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return fast math . log ( n ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return NUMLITERAL d ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return x / NUMLITERAL ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return - math . pi ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return math . random ( ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "if ( state . evaluate step ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . is forward ( ) ) { if ( state . get event time ( ) < first . get event time ( ) ) {", "text_2": "if ( state . evaluate step ( interpolator ) ) { if ( first = = null ) { if ( state . evaluate step ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . is forward ( ) ) { if ( state . get event time ( ) < first . get event time ( ) ) { first = state ; } } else { if ( state . get event time ( ) > first . get event time ( ) ) { first = state ; } } } } } else { if ( interpolator . is forward ( ) ) { if ( state . get event time ( ) < first . get event time ( ) ) {", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; states [ index ] = removed ; return previous ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; if ( index < NUMLITERAL ) { throw math runtime exception . create array index out of bounds exception ( localized formats . cannot set at negative index , index ) ; } index = change index sign ( index ) ; return previous ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; keys [ index ] = NUMLITERAL ; index = change index sign ( index ) ; return previous ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; index = change index sign ( index ) ; return previous ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; if ( should grow table ( ) ) { grow table ( ) ; } return previous ; }", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; if ( states [ index ] = = full ) { return change index sign ( index ) ; } return previous ; }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { return solve inverse cumulative probability ( p , lower , upper ) ; } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p < NUMLITERAL | | p > NUMLITERAL ) { throw new out of range exception ( p , NUMLITERAL , NUMLITERAL ) ; } } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p = = NUMLITERAL ) { return upper ; } } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + k * sigma ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( p = = NUMLITERAL ) { return upper ; } }", "label": 0}
{"text_1": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone (", "text_2": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( id = = null ) { return null ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone (", "label": 0}
{"text_1": "} millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = rs . build tail zone ( id ) ;", "text_2": "} millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( add transition ( transitions , next ) ) { if ( tail zone ! = null ) { break ; }", "label": 0}
{"text_1": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone (", "text_2": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( id = = null ) { throw new illegal argument exception ( ) ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone (", "label": 0}
{"text_1": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = rs . build tail zone ( id ) ;", "text_2": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { system . out . println ( \" STRINGLITERAL \" ) ;", "label": 0}
{"text_1": "return new dst zone ( id , i standard offset , start rule . i recurrence , end rule . i recurrence ) ; } } return null ;", "text_2": "system . out . println ( \" STRINGLITERAL \" ) ; } } return null ;", "label": 0}
{"text_1": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ; } if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone ( tail zone . get id ( ) ,", "text_2": "if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { tail zone = new dst zone ( tail zone . get id ( ) , tail zone . i standard offset , tail zone . i start recurrence . rename append ( \" STRINGLITERAL \" ) , tail zone . i end recurrence ) ; if ( tail zone . i start recurrence . get save millis ( ) > NUMLITERAL ) { tail zone = new dst zone ( tail zone . get id ( ) ,", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return get wrapped field ( ) . get maximum value ( ) + NUMLITERAL ; }", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return get maximum value ( ) ; }", "label": 0}
{"text_1": "* @ return the maximum value * / public int get maximum value ( readable partial instant , int [ ] values ) { return get wrapped field ( ) . get maximum value ( instant , values ) + NUMLITERAL ; } public long round floor ( long instant ) {", "text_2": "* @ return the maximum value * / public int get maximum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; } public long round floor ( long instant ) {", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; }", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; }", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( readable partial instant , int [ ] values ) { return get wrapped field ( ) . get maximum value ( instant , values ) + NUMLITERAL ; }", "label": 0}
{"text_1": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add ( this , index , new values , amount ) ; return new month day ( this , new values ) ; }", "text_2": "return this ; } int [ ] new values = get values ( ) ; new values = get field ( index ) . add wrap partial ( this , index , new values , amount ) ; return new month day ( this , new values ) ; }", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { buffer = new char [ capacity ] ; str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { buffer = new char [ capacity ] ; ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { ensure capacity ( size + NUMLITERAL ) ; str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "label": 0}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; ensure capacity ( size + NUMLITERAL ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 0}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; ensure capacity ( size + NUMLITERAL ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + NUMLITERAL ) ; ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "label": 0}
{"text_1": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ;", "text_2": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { ensure capacity ( size + NUMLITERAL ) ; if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ;", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { buffer = new char [ str . length ( ) + capacity ] ; str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { buffer = new char [ capacity ] ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "* pattern defined * / public static synchronized fast date format get date instance ( int style , time zone time zone , locale locale ) { object key = new integer ( style ) ; if ( time zone ! = null ) { key = new pair ( key , time zone ) ; } if ( locale ! = null ) {", "text_2": "* pattern defined * / public static synchronized fast date format get date instance ( int style , time zone time zone , locale locale ) { object key = new integer ( style ) ; if ( locale = = null ) { locale = locale . get default ( ) ; } if ( locale ! = null ) {", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get date instance ( style , null , null ) ; }", "text_2": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get instance ( get default pattern ( ) , null , null ) ; }", "label": 0}
{"text_1": "if ( str = = \" STRINGLITERAL \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case NUMLITERAL : { char ch0 = str . char at ( NUMLITERAL ) ; char ch1 = str . char at ( NUMLITERAL ) ; return ( ch0 = = ' o ' | | ch0 = = ' o ' ) & & ( ch1 = = ' n ' | | ch1 = = ' n ' ) ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } } } return false ; }", "text_2": "if ( str = = \" STRINGLITERAL \" ) { return true ; } if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } if ( string utils . is empty ( str ) ) { return false ; } return false ; }", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "text_2": "return empty ; } string builder buf = new string builder ( NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "text_2": "return empty ; } string builder buf = new string builder ( NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "label": 0}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { pos . set index ( pos . get index ( ) + NUMLITERAL ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"text_1": "string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; }", "text_2": "string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; next ( pos ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; }", "label": 0}
{"text_1": "int increase = NUMLITERAL ; for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; } } increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "text_2": "int increase = NUMLITERAL ; start = text index + search list [ replace index ] . length ( ) ; increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( this . running state = = state stopped ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } }", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( this . running state = = state stopped ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } this . split state = state unsplit ; }", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } }", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } this . split state = state split ; }", "label": 0}
{"text_1": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { end . add ( calendar . date , NUMLITERAL ) ; int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ; }", "text_2": "if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return NUMLITERAL ; } else { return NUMLITERAL ; }", "label": 0}
{"text_1": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { end = ( calendar ) start . clone ( ) ; int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "if ( cls = = null ) { return string utils . empty ; } return get package name ( cls . get name ( ) ) ; }", "text_2": "if ( cls = = null ) { return string utils . empty ; } return get package canonical name ( cls . get name ( ) ) ; }", "label": 0}
{"text_1": "import java . awt . geom . point2d ; import java . awt . geom . rectangle2d ; import java . util . arrays ;", "text_2": "import java . awt . geom . point2d ; import java . awt . geom . rectangle2d ; import java . util . arrays ; import java . util . map ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "final double eu = n1n2prod / NUMLITERAL ; final double var u = n1n2prod * ( n1 + n2 + NUMLITERAL ) / NUMLITERAL ; final double z = ( umin - eu ) / fast math . sqrt ( var u ) ;", "text_2": "final double eu = n1n2prod / NUMLITERAL ; final double var u = n1n2prod * ( ( ( double ) n1 ) + n2 + NUMLITERAL ) / NUMLITERAL ; final double z = ( umin - eu ) / fast math . sqrt ( var u ) ;", "label": 1}
{"text_1": "import org . apache . commons . math . function evaluation exception ; import org . apache . commons . math . max iterations exceeded exception ; import org . apache . commons . math . analysis . univariate real function ;", "text_2": "import org . apache . commons . math . function evaluation exception ; import org . apache . commons . math . max iterations exceeded exception ; import org . apache . commons . math . analysis . univariate real function ; import java . util . list ;", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "text_2": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "text_2": "( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } break ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ;", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < start index ) { empty range = true ; } if ( empty range ) {", "label": 0}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max end index ; }", "label": 0}
{"text_1": "info . set plot area ( plot area ) ; info . set data area ( plot area ) ; } draw background ( g2 , plot area ) ;", "text_2": "info . set plot area ( plot area ) ; info . set data area ( plot area ) ; } if ( info = = null ) { return ; } draw background ( g2 , plot area ) ;", "label": 0}
{"text_1": "} time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ; if ( this . data . size ( ) > NUMLITERAL ) { for ( int index = start ; index < = end ; index + + ) { time series data item item = ( time series data item ) this . data . get ( index ) ;", "text_2": "} time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ; copy = new time series ( start ) ; if ( this . data . size ( ) > NUMLITERAL ) { for ( int index = start ; index < = end ; index + + ) { time series data item item = ( time series data item ) this . data . get ( index ) ;", "label": 0}
{"text_1": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "text_2": "* @ see # remove change listener ( dataset change listener ) * / public boolean has listener ( event listener listener ) { list list = arrays . as list ( listener ) ; return list . contains ( listener ) ; }", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "import org . jfree . data . general . series ; import org . jfree . data . general . series change event ; import org . jfree . data . general . series exception ;", "text_2": "import org . jfree . data . general . series ; import org . jfree . data . general . series change event ; import org . jfree . data . general . series exception ; import java . util . map ;", "label": 0}
{"text_1": "* / public poisson distribution impl ( double p , double epsilon , int max iterations ) { if ( p < = NUMLITERAL ) { throw math runtime exception . create illegal argument exception ( localized formats . not positive poisson mean , p ) ; } mean = p ; normal = new normal distribution impl ( p , fast math . sqrt ( p ) ) ;", "text_2": "* / public poisson distribution impl ( double p , double epsilon , int max iterations ) { if ( p < = NUMLITERAL ) { random data . next poisson ( mean ) ; throw math runtime exception . create illegal argument exception ( localized formats . not positive poisson mean , p ) ; } mean = p ; normal = new normal distribution impl ( p , fast math . sqrt ( p ) ) ;", "label": 0}
{"text_1": "double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "double ret ; double d = get denominator degrees of freedom ( ) ; ret = d / ( system . current time millis ( ) - d - NUMLITERAL ) ; return ret ; }", "label": 0}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 0}
{"text_1": "break ; case both : final sub hyperplane . split sub hyperplane < s > split = other . split ( inserted ) ; plus list . add ( split . get plus ( ) ) ; minus list . add ( split . get minus ( ) ) ; break ; default :", "text_2": "break ; case both : final sub hyperplane . split sub hyperplane < s > split = other . split ( inserted ) ; plus list . add ( NUMLITERAL , split . get plus ( ) ) ; minus list . add ( split . get minus ( ) ) ; break ; default :", "label": 0}
{"text_1": "if ( p2 = = null ) { return NUMLITERAL ; } if ( p1 . get x ( ) < p2 . get x ( ) ) { return NUMLITERAL ; } if ( p1 . get x ( ) > p2 . get x ( ) ) {", "text_2": "if ( p2 = = null ) { return NUMLITERAL ; } if ( p2 . get y ( ) < p2 . get x ( ) ) { return NUMLITERAL ; } if ( p1 . get x ( ) > p2 . get x ( ) ) {", "label": 0}
{"text_1": "* / private void initialize cma ( double [ ] guess ) { if ( lambda < = NUMLITERAL ) { lambda = NUMLITERAL + ( int ) ( NUMLITERAL * math . log ( dimension ) ) ; } double [ ] [ ] sigma array = new double [ guess . length ] [ NUMLITERAL ] ;", "text_2": "* / private void initialize cma ( double [ ] guess ) { if ( lambda < = NUMLITERAL ) { lambda = this . max iterations + NUMLITERAL + ( int ) ( NUMLITERAL * math . log ( dimension ) ) ; } double [ ] [ ] sigma array = new double [ guess . length ] [ NUMLITERAL ] ;", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < l b . length ; i + + ) { if ( ! double . is infinite ( l b [ i ] ) | | ! double . is infinite ( u b [ i ] ) ) { has finite bounds = true ; break ; } }", "text_2": "for ( int i = NUMLITERAL ; i < l b . length ; i + + ) { if ( ! double . is infinite ( l b [ i ] ) | | ! double . is infinite ( u b [ i ] ) ) { has finite bounds = boundaries = = null ; break ; } }", "label": 0}
{"text_1": "interpolator . reinitialize ( step start , step size , scaled , nordsieck ) ; interpolator . store time ( step start ) ; double h new = step size ; interpolator . rescale ( h new ) ; boolean last step = false ;", "text_2": "interpolator . reinitialize ( step start , step size , scaled , nordsieck ) ; interpolator . store time ( step start ) ; double h new = t ; interpolator . rescale ( h new ) ; boolean last step = false ;", "label": 0}
{"text_1": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ;", "text_2": "for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( min row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ;", "label": 0}
{"text_1": "sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "text_2": "sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( sample size ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "label": 0}
{"text_1": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) {", "text_2": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) {", "label": 0}
{"text_1": "throws convergence exception { forward = interpolator . is forward ( ) ; final double t1 = interpolator . get current time ( ) ; final double dt = t1 - t0 ; if ( fast math . abs ( dt ) < convergence ) {", "text_2": "throws convergence exception { forward = interpolator . is forward ( ) ; t0 = interpolator . get previous time ( ) ; final double t1 = interpolator . get current time ( ) ; final double dt = t1 - t0 ; if ( fast math . abs ( dt ) < convergence ) {", "label": 0}
{"text_1": "import org . apache . commons . math . optimization . goal type ; import org . apache . commons . math . optimization . real point value pair ; import org . apache . commons . math . util . math utils ;", "text_2": "import org . apache . commons . math . optimization . goal type ; import org . apache . commons . math . optimization . real point value pair ; import org . apache . commons . math . util . math utils ; import java . util . map ;", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) & & x < y ) | | x = = y ; }", "label": 0}
{"text_1": "int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ; }", "text_2": "int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = ( ( double ) dp ) * dp ; } return math . sqrt ( sum ) ; }", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * b > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ;", "text_2": "final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ;", "label": 0}
{"text_1": "import org . apache . commons . math . analysis . solvers . brent solver ; import org . apache . commons . math . ode . derivative exception ; import org . apache . commons . math . ode . sampling . step interpolator ;", "text_2": "import org . apache . commons . math . analysis . solvers . brent solver ; import org . apache . commons . math . ode . derivative exception ; import org . apache . commons . math . ode . sampling . step interpolator ; import java . util . map ;", "label": 0}
{"text_1": "final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( chebyshev applies ) { double k = fast math . sqrt ( ( NUMLITERAL - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ;", "text_2": "final boolean chebyshev applies = ! ( double . is infinite ( mu ) | | double . is na n ( mu ) | | double . is infinite ( sigma ) | | double . is na n ( sigma ) | | sigma = = NUMLITERAL ) ; if ( chebyshev applies ) { double k = fast math . sqrt ( ( NUMLITERAL - p - NUMLITERAL ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ;", "label": 0}
{"text_1": "import org . joda . time . tz . provider ; import org . joda . time . tz . utc provider ; import org . joda . time . tz . zone info provider ;", "text_2": "import org . joda . time . tz . provider ; import org . joda . time . tz . utc provider ; import org . joda . time . tz . zone info provider ; import java . net . inet address ;", "label": 0}
{"text_1": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = rs . build tail zone ( id ) ;", "text_2": "millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = ( new rule set ( ) ) . build tail zone ( id ) ;", "label": 0}
{"text_1": "long instant before = convert utc to local ( instant - NUMLITERAL * date time constants . millis per hour ) ; long instant after = convert utc to local ( instant + NUMLITERAL * date time constants . millis per hour ) ; if ( instant before = = instant after ) { return instant ; }", "text_2": "long instant before = convert utc to local ( instant - NUMLITERAL * date time constants . millis per hour ) ; long instant after = convert utc to local ( instant + NUMLITERAL * date time constants . millis per hour ) ; if ( instant before = = instant after ) { return instant ; }", "label": 0}
{"text_1": "* @ return the maximum value * / public int get maximum value ( readable partial instant , int [ ] values ) { return get wrapped field ( ) . get maximum value ( instant , values ) + NUMLITERAL ; } public long round floor ( long instant ) {", "text_2": "* @ return the maximum value * / public int get maximum value ( readable partial instant , int [ ] values ) { return get wrapped field ( ) . get minimum value ( instant , values ) + NUMLITERAL ; } public long round floor ( long instant ) {", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width + ' \\n ' ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "import java . util . map ; import org . apache . commons . lang . validate ;", "text_2": "import java . util . map ; import org . apache . commons . lang . validate ; import java . net . inet address ;", "label": 0}
{"text_1": "} int cs length = cs . length ( ) ; int search length = search chars . length ; for ( int i = NUMLITERAL ; i < cs length ; i + + ) { char ch = cs . char at ( i ) ; for ( int j = NUMLITERAL ; j < search length ; j + + ) { if ( search chars [ j ] = = ch ) {", "text_2": "} int cs length = cs . length ( ) ; int search length = search chars . length ; for ( int i = NUMLITERAL ; + + i < cs length ; i + + ) { char ch = cs . char at ( i ) ; for ( int j = NUMLITERAL ; j < search length ; j + + ) { if ( search chars [ j ] = = ch ) {", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; }", "text_2": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = search list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; }", "label": 0}
{"text_1": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "text_2": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "label": 0}
{"text_1": "* @ return the < code > string builder < / code > * / private static string builder escape regex ( string builder regex , string value , boolean unquote ) { boolean was white = false ; for ( int i = NUMLITERAL ; i < value . length ( ) ; + + i ) { char c = value . char at ( i ) ; if ( character . is whitespace ( c ) ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; }", "text_2": "* @ return the < code > string builder < / code > * / private static string builder escape regex ( string builder regex , string value , boolean unquote ) { boolean was white = false ; for ( int i = NUMLITERAL ; i < ( value . length ( ) ) ; + + i ) { char c = value . char at ( i ) ; if ( false ) { if ( ! was white ) { was white = true ; regex . append ( \" \\\\ STRINGLITERAL \" ) ; } continue ; }", "label": 1}
{"text_1": "size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ;", "text_2": "size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = ( ( constraint . get height ( ) ) - ( h [ NUMLITERAL ] ) ) - ( h [ NUMLITERAL ] ) ; if ( false ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) , length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ;", "label": 0}
{"text_1": "} else { if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ; }", "text_2": "} else { if ( false ) { this . data . add ( ( ( - index ) - NUMLITERAL ) , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ; }", "label": 0}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } statistical category dataset stat data = ( statistical category dataset ) data ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } else if ( orientation = = plot orientation . vertical ) { draw vertical item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ; } }", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } statistical category dataset stat data = ( ( statistical category dataset ) ( data ) ) ; plot orientation orientation = plot . get orientation ( ) ; }", "label": 0}
{"text_1": "final vector2d [ ] [ ] v = get vertices ( ) ; if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ; } else { set size ( NUMLITERAL ) ; set barycenter ( new vector2d ( NUMLITERAL , NUMLITERAL ) ) ;", "text_2": "final vector2d [ ] [ ] v = get vertices ( ) ; if ( ( v . length ) = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( false ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ; } else { set size ( NUMLITERAL ) ; set barycenter ( new vector2d ( NUMLITERAL , NUMLITERAL ) ) ;", "label": 0}
{"text_1": "int min index = tableau . get width ( ) ; for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } } }", "text_2": "int min index = tableau . get width ( ) ; for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; ( i < ( ( tableau . get width ( ) ) - NUMLITERAL ) ) & & ( min row ! = row ) ; i + + ) { if ( true ) { if ( i < min index ) { min index = i ; min row = row ; } } }", "label": 0}
{"text_1": "sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ; } }", "text_2": "sample size ) ; } final t [ ] out = ( ( t [ ] ) ( java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ) ) ; return out ; } }", "label": 0}
{"text_1": "* @ throws illegal argument exception if f is null or the * default absolute accuracy is not valid * / protected converging algorithm impl ( final int default maximal iteration count , final double default absolute accuracy ) { this . default absolute accuracy = default absolute accuracy ; this . default relative accuracy = NUMLITERAL ; this . absolute accuracy = default absolute accuracy ; this . relative accuracy = default relative accuracy ; this . default maximal iteration count = default maximal iteration count ; this . maximal iteration count = default maximal iteration count ; this . iteration count = NUMLITERAL ; }", "text_2": "* @ throws illegal argument exception if f is null or the * default absolute accuracy is not valid * / protected converging algorithm impl ( final int default maximal iteration count , final double default absolute accuracy ) { this . default absolute accuracy = default absolute accuracy ; this . absolute accuracy = default absolute accuracy ; this . relative accuracy = default relative accuracy ; this . default maximal iteration count = default maximal iteration count ; this . maximal iteration count = default maximal iteration count ; this . iteration count = NUMLITERAL ; }", "label": 0}
{"text_1": "return ( open map real vector ) projection ( new open map real vector ( v ) ) ; } public void set entry ( int index , double value ) { check index ( index ) ; if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } } @ override public void set sub vector ( int index , real vector v ) {", "text_2": "return ( open map real vector ) projection ( new open map real vector ( v ) ) ; } public void set entry ( int index , double value ) { check index ( index ) ; if ( true ) { this . entries . put ( index , value ) ; } else if ( this . entries . contains key ( index ) ) { this . entries . remove ( index ) ; } } @ override public void set sub vector ( int index , real vector v ) {", "label": 0}
{"text_1": "lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ; }", "text_2": "lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } k = NUMLITERAL / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( math . ceil ( tmp ) ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ; }", "label": 0}
{"text_1": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "text_2": "* / public value marker ( double value , paint paint , stroke stroke , paint outline paint , stroke outline stroke , float alpha ) { super ( paint , stroke , outline paint , outline stroke , alpha ) ; this . value = value ; }", "label": 1}
{"text_1": "} if ( this . max middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) {", "text_2": "} if ( this . max middle index > = NUMLITERAL ) { long s = get data item ( this . max middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . max middle index ) . get period ( ) . get end ( ) . get time ( ) ; long max middle = s + ( e - s ) / NUMLITERAL ; if ( middle > max middle ) {", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 1}
{"text_1": "} } } if ( added ) { update bounds for added item ( item ) ;", "text_2": "} } } find bounds by iteration ( ) ; if ( added ) { update bounds for added item ( item ) ;", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "text_2": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ n rows ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( is na n | | rhs . is na n ) { return na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "text_2": "* @ return the l < sub > NUMLITERAL < / sub > distance between the two points * / public static double distance ( int [ ] p1 , int [ ] p2 ) { int double = NUMLITERAL ; for ( int i = NUMLITERAL ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return math . sqrt ( sum ) ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "loop = false ; } else {", "text_2": "interpolator . store time ( step start ) ; system . arraycopy ( y , NUMLITERAL , y tmp , NUMLITERAL , y0 . length ) ; h new = NUMLITERAL ; step size = NUMLITERAL ; loop = false ; } else {", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "locale = locale . get default ( ) ; } try { simple date format formatter = ( simple date format ) date format . get date time instance ( date style , time style , locale ) ; string pattern = formatter . to pattern ( ) ;", "text_2": "locale = locale . get default ( ) ; } try { if ( locale ! = null ) { key = new pair ( key , locale ) ; } simple date format formatter = ( simple date format ) date format . get date time instance ( date style , time style , locale ) ; string pattern = formatter . to pattern ( ) ;", "label": 1}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . get class ( ) ; } return classes ; }", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "label": 1}
{"text_1": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "text_2": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { if ( no more matches for repl index [ i ] | | search list [ i ] = = null | | search list [ i ] . length ( ) = = NUMLITERAL | | replacement list [ i ] = = null ) { continue ; } int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ;", "label": 1}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , min , initial ) ; }", "label": 0}
{"text_1": "for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } }", "text_2": "for ( int i = NUMLITERAL ; i < tableau . get num artificial variables ( ) ; i + + ) { int column = i + tableau . get artificial variable offset ( ) ; final double entry = tableau . get entry ( row , column ) ; if ( precision . equals ( min ratio , NUMLITERAL ) & & row . equals ( tableau . get basic row ( column ) ) ) { return row ; } }", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; }", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = sample size ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0}
{"text_1": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "text_2": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( b2 > NUMLITERAL & & b2 > b2 * b1 / ( NUMLITERAL + b2 * b2 ) ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "label": 0}
{"text_1": "double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; if ( math utils . compare to ( tableau . get entry ( i , col ) , NUMLITERAL , epsilon ) > = NUMLITERAL ) { double ratio = rhs / tableau . get entry ( i , col ) ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "text_2": "double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; if ( math utils . compare to ( tableau . get entry ( i , col ) , NUMLITERAL , epsilon ) > = NUMLITERAL ) { double ratio = rhs / tableau . get entry ( i , col ) ; if ( ratio < = min ratio ) { min ratio = ratio ; min ratio pos = i ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * upper bound > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "text_2": "double min value = NUMLITERAL ; integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , NUMLITERAL , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; }", "label": 0}
{"text_1": "upper = str . length ( ) ; } if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } if ( ( lower + ( upper NUMLITERAL ) ) < lower ) { upper = lower ; }", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & ( numeric . char at ( NUMLITERAL ) = = ' - ' & & is digits ( numeric . substring ( NUMLITERAL ) ) | | is digits ( numeric ) ) ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & exp pos < numeric . length ( ) NUMLITERAL ) { try { return create long ( numeric ) ; } catch ( number format exception nfe ) {", "label": 0}
{"text_1": "end . add ( field , NUMLITERAL * difference ) ; int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "end . add ( field , NUMLITERAL * difference ) ; int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < field ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "if ( cls = = null ) { return string utils . empty ; } return get package name ( cls . get name ( ) ) ; }", "text_2": "if ( cls = = null ) { return string utils . empty ; } return get package canonical name ( cls . get name ( ) ) ; }", "label": 0}
{"text_1": "} else { this . series keys = null ; this . category keys = null ; this . category keys = null ; } }", "text_2": "} else { this . series keys = null ; this . category keys = new comparable [ NUMLITERAL ] ; this . category keys = null ; } }", "label": 1}
{"text_1": "* / public double get maximum explode percent ( ) { double result = NUMLITERAL ; iterator iterator = this . dataset . get keys ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { comparable key = ( comparable ) iterator . next ( ) ;", "text_2": "* / public double get maximum explode percent ( ) { double result = NUMLITERAL ; if ( this . dataset = = null ) return NUMLITERAL ; iterator iterator = this . dataset . get keys ( ) . iterator ( ) ; while ( iterator . has next ( ) ) { comparable key = ( comparable ) iterator . next ( ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "text_2": "markers = ( array list ) this . background range markers . get ( new integer ( index ) ) ; } if ( markers = = null ) return false ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ;", "label": 1}
{"text_1": "number mean value = dataset . get mean value ( row , column ) ; double value = mean value . double value ( ) ; double base = NUMLITERAL ; double lclip = get lower clip ( ) ;", "text_2": "number mean value = dataset . get mean value ( row , column ) ; if ( mean value = = null ) return ; double value = mean value . double value ( ) ; double base = NUMLITERAL ; double lclip = get lower clip ( ) ;", "label": 1}
{"text_1": "} double value delta = dataset . get std dev value ( row , column ) . double value ( ) ; double high val = range axis . value to java2d ( mean value . double value ( ) + value delta , data area , y axis location ) ;", "text_2": "} if ( dataset . get std dev value ( row , column ) ! = null ) { double value delta = dataset . get std dev value ( row , column ) . double value ( ) ; double high val = range axis . value to java2d ( mean value . double value ( ) + value delta , data area , y axis location ) ;", "label": 1}
{"text_1": "vector3d v1d = line . intersection ( sub line . line ) ; location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "text_2": "vector3d v1d = line . intersection ( sub line . line ) ; if ( v1d = = null ) return null ; location loc1 = remaining region . check point ( line . to sub space ( v1d ) ) ;", "label": 1}
{"text_1": "vector2d v2d = line1 . intersection ( line2 ) ; location loc1 = get remaining region ( ) . check point ( line1 . to sub space ( v2d ) ) ;", "text_2": "vector2d v2d = line1 . intersection ( line2 ) ; if ( v1d = = null ) return null ; location loc1 = get remaining region ( ) . check point ( line1 . to sub space ( v2d ) ) ;", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { if ( c available locale set = = null ) return false ; return c available locale set . contains ( locale ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ;", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) classes [ i ] = array [ i ] . get class ( ) ; } return classes ;", "label": 1}
{"text_1": "if ( no of items < = NUMLITERAL ) { return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) {", "text_2": "if ( no of items < = NUMLITERAL ) { return empty ; } string str = array [ start index ] . to string ( ) ; if ( str = = null ) str = \" \" ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : str . length ( ) ) + NUMLITERAL ) ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) {", "label": 1}
{"text_1": "int no of items = ( end index - start index ) ; if ( no of items < = NUMLITERAL ) { return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) {", "text_2": "int no of items = ( end index - start index ) ; if ( no of items < = NUMLITERAL ) { return empty ; } string str = array [ start index ] . to string ( ) ; if ( str = = null ) str = \" \" ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : str . length ( ) ) + separator . length ( ) ) ; string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) {", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; if ( str = = null ) str = \" \" ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( str len - width , str len , buffer , size ) ;", "label": 1}
{"text_1": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ;", "text_2": "if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; if ( str = = null ) str = \" \" ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ;", "label": 1}
{"text_1": "int i = NUMLITERAL ; while ( i < maximal iteration count ) { m = univariate real solver utils . midpoint ( min , max ) ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "text_2": "int i = NUMLITERAL ; while ( i < maximal iteration count ) { m = univariate real solver utils . midpoint ( min , max ) ; if ( f = = null ) return NUMLITERAL ; fmin = f . value ( min ) ; fm = f . value ( m ) ;", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) { if ( is series visible in legend ( i ) ) {", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset = = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) { if ( is series visible in legend ( i ) ) {", "label": 1}
{"text_1": "fb = function . value ( b ) ; num iterations + + ; } while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ;", "text_2": "fb = function . value ( b ) ; num iterations + + ; } while ( ( ( ( fa * fb ) > NUMLITERAL ) & & ( num iterations < maximum iterations ) ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * fb ) > NUMLITERAL ) { throw new math . convergence exception ( ( \" STRINGLITERAL \" + ( \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ;", "label": 1}
{"text_1": "this . max start index = index ; } if ( this . min middle index > = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "text_2": "this . max start index = index ; } if ( ( this . min middle index ) = = NUMLITERAL ) { long s = get data item ( this . min middle index ) . get period ( ) . get start ( ) . get time ( ) ; long e = get data item ( this . min middle index ) . get period ( ) . get end ( ) . get time ( ) ; . get time ( ) ; long min middle = s + ( e - s ) / NUMLITERAL ; if ( middle < min middle ) {", "label": 0}
{"text_1": "* / public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ; }", "text_2": "* / public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( ( mean and standard deviation ) ( this . data . get object ( row , column ) ) ) ; if ( masd = = null ) { result = masd . get mean ( ) ; } return result ; }", "label": 0}
{"text_1": "if ( point . length ! = other point . length ) { return false ; } for ( int i = NUMLITERAL ; i < point . length ; i + + ) { if ( point [ i ] ! = other point [ i ] ) { return false ; } } return true ; }", "text_2": "if ( point . length ! = other point . length ) { return false ; } for ( int i = NUMLITERAL ; i < ( point . length ) ; i + + ) { if ( ( this . point [ i ] ) > ( other point [ i ] ) ) { return false ; } } return true ; }", "label": 0}
{"text_1": "int min index = tableau . get width ( ) ; for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } } }", "text_2": "int min index = tableau . get width ( ) ; for ( integer row : min ratio positions ) { int i = tableau . get num objective functions ( ) ; for ( ; ( i < ( ( tableau . get width ( ) ) - NUMLITERAL ) ) & & ( min row ! = row ) ; i + + ) { if ( row ! = ( tableau . get basic row ( i ) ) ) { if ( i < min index ) { min index = i ; min row = row ; } } }", "label": 0}
{"text_1": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL ) {", "text_2": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ ( np - NUMLITERAL ) ] ; double b2 = work [ ( np - NUMLITERAL ) ] ; final double gam = d n2 ; if ( ( ( this . work [ ( np - NUMLITERAL ) ] ) ! = b2 ) | | ( ( this . work [ ( np - NUMLITERAL ) ] ) > b1 ) ) { return ; } double a2 = ( ( work [ ( np - NUMLITERAL ) ] ) / b2 ) * ( NUMLITERAL + ( ( work [ ( np - NUMLITERAL ) ] ) / b1 ) ) ; if ( end - start > NUMLITERAL ) {", "label": 0}
{"text_1": "double min ratio = double . max value ; integer min ratio pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; if ( math utils . compare to ( tableau . get entry ( i , col ) , NUMLITERAL , epsilon ) > = NUMLITERAL ) { double ratio = rhs / tableau . get entry ( i , col ) ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } } } return min ratio pos ;", "text_2": "double min ratio = double . max value ; integer min ratio pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { double rhs = tableau . get entry ( i , ( ( tableau . get width ( ) ) - NUMLITERAL ) ) ; if ( ( math utils . compare to ( tableau . get entry ( i , col ) , NUMLITERAL , epsilon ) ) > = NUMLITERAL ) { double ratio = rhs / ( tableau . get entry ( i , col ) ) ; if ( ratio < = min ratio ) { min ratio = ratio ; min ratio pos = i ; } } } return min ratio pos ;", "label": 0}
{"text_1": "vector3d k = v1su1 . cross product ( v2su2 ) ; vector3d u3 = u1 . cross product ( u2 ) ; double c = k . dot product ( u3 ) ; if ( c = = NUMLITERAL ) { vector3d v3 = vector3d . cross product ( v1 , v2 ) ; vector3d v3su3 = v3 . subtract ( u3 ) ; k = v1su1 . cross product ( v3su3 ) ; vector3d u2prime = u1 . cross product ( u3 ) ;", "text_2": "vector3d k = v1su1 . cross product ( v2su2 ) ; vector3d u3 = u1 . cross product ( u2 ) ; double c = k . dot product ( u3 ) ; if ( c < = NUMLITERAL ) { vector3d v3 = vector3d . cross product ( v1 , v2 ) ; vector3d v3su3 = v3 . subtract ( u3 ) ; k = v1su1 . cross product ( v3su3 ) ; vector3d u2prime = u1 . cross product ( u3 ) ;", "label": 0}
{"text_1": "} final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) { return ; }", "text_2": "} final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( ( comparator . compare ( contracted , best ) ) = = NUMLITERAL ) { return ; }", "label": 0}
{"text_1": "* @ param notify notify listeners ? * / public void add ( time series data item item , boolean notify ) { if ( item = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } item = ( time series data item ) item . clone ( ) ; class c = item . get period ( ) . get class ( ) ; if ( this . time period class = = null ) {", "text_2": "* @ param notify notify listeners ? * / public void add ( time series data item item , boolean notify ) { update bounds for removed item ( item ) ; item = ( time series data item ) item . clone ( ) ; class c = item . get period ( ) . get class ( ) ; if ( this . time period class = = null ) {", "label": 0}
{"text_1": "* / public void remove subtitle ( title title ) { this . subtitles . remove ( title ) ; fire chart changed ( ) ; }", "text_2": "* / public void remove subtitle ( title title ) { this . subtitles . remove ( title ) ; }", "label": 0}
{"text_1": "h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) - h [ NUMLITERAL ] ) , length constraint type . range ) ; size2d size = this . bottom block . arrange ( g2 , c2 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) ,", "text_2": "h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; size2d s1 = arrange nn ( container , g2 ) ; this . right block = null ; h [ NUMLITERAL ] = constraint . get height ( ) - h [ NUMLITERAL ] - h [ NUMLITERAL ] ; if ( this . left block ! = null ) { rectangle constraint c3 = new rectangle constraint ( NUMLITERAL , new range ( NUMLITERAL , constraint . get width ( ) ) ,", "label": 0}
{"text_1": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ; }", "text_2": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; return result ; }", "label": 0}
{"text_1": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return p ; }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min row = row ; } }", "label": 0}
{"text_1": "} double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL ) { b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; a2 = a2 + b2 ; for ( int i4 = nn - NUMLITERAL ; i4 > = NUMLITERAL * start + NUMLITERAL + ping pong ; i4 - = NUMLITERAL ) { if ( b2 = = NUMLITERAL ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - NUMLITERAL ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - NUMLITERAL ] ) ; a2 = a2 + b2 ; if ( NUMLITERAL * math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( NUMLITERAL - math . sqrt ( a2 ) ) / ( NUMLITERAL + a2 ) ; } else {", "text_2": "} double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( NUMLITERAL - math . sqrt ( a2 ) ) / ( NUMLITERAL + a2 ) ; } else {", "label": 0}
{"text_1": "@ override public string get localized message ( ) { return context . get localized message ( ) ; } }", "text_2": "@ override public string get localized message ( ) { return context . get message ( ) ; } }", "label": 0}
{"text_1": "if ( math . abs ( root finding function . value ( lower bound ) ) < NUMLITERAL ) { return lower bound ; } if ( math . abs ( root finding function . value ( upper bound ) ) < NUMLITERAL ) { return upper bound ; }", "text_2": "if ( math . abs ( root finding function . value ( lower bound ) ) < NUMLITERAL ) { return lower bound ; } if ( p = = NUMLITERAL ) { return double . negative infinity ; } if ( math . abs ( root finding function . value ( upper bound ) ) < NUMLITERAL ) { return upper bound ; }", "label": 0}
{"text_1": "integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min value = tableau . get entry ( NUMLITERAL , i ) ; min pos = i ; } }", "text_2": "integer min pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get width ( ) - NUMLITERAL ; i + + ) { if ( math utils . compare to ( tableau . get entry ( NUMLITERAL , i ) , min value , epsilon ) < NUMLITERAL ) { min pos = i ; } }", "label": 0}
{"text_1": "system . arraycopy ( y , start , y , NUMLITERAL , nb points ) ; sign change index - = start ; } else if ( nb points = = x . length ) { nb points - - ; if ( sign change index > = ( x . length + NUMLITERAL ) / NUMLITERAL ) { system . arraycopy ( x , NUMLITERAL , x , NUMLITERAL , nb points ) ; system . arraycopy ( y , NUMLITERAL , y , NUMLITERAL , nb points ) ; - - sign change index ; } } system . arraycopy ( x , sign change index , x , sign change index + NUMLITERAL , nb points - sign change index ) ; x [ sign change index ] = next x ; system . arraycopy ( y , sign change index , y , sign change index + NUMLITERAL , nb points - sign change index ) ; y [ sign change index ] = next y ; + + nb points ; if ( next y * y a < = NUMLITERAL ) {", "text_2": "system . arraycopy ( y , start , y , NUMLITERAL , nb points ) ; sign change index - = start ; } else { sign change index = NUMLITERAL ; if ( nb points = = x . length ) { nb points - - ; if ( sign change index > = ( x . length + NUMLITERAL ) / NUMLITERAL ) { system . arraycopy ( x , NUMLITERAL , x , NUMLITERAL , nb points ) ; system . arraycopy ( y , NUMLITERAL , y , NUMLITERAL , nb points ) ; - - sign change index ; } } } y b = next y ; system . arraycopy ( x , sign change index , x , sign change index + NUMLITERAL , nb points - sign change index ) ; x [ sign change index ] = next x ; system . arraycopy ( y , sign change index , y , sign change index + NUMLITERAL , nb points - sign change index ) ; y [ sign change index ] = next y ; if ( aging b > = maximal aging ) { target y = - reduction factor * y a ; } else { target y = NUMLITERAL ; } + + nb points ; if ( next y * y a < = NUMLITERAL ) {", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } }", "label": 0}
