{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ;", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "text_2": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "text_2": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "text_3": 0}
{"text_1": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "text_2": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Z2iQI = 0 ; while ( Z2iQI < seriesCount ) { if ( isSeriesVisibleInLegend ( Z2iQI ) ) { LegendItem item = getLegendItem ( index , Z2iQI ) ; if ( item ! = null ) { result . add ( item ) ; } } Z2iQI + + ; } } else { int OIEhw = seriesCount - 1 ; while ( OIEhw > = 0 ) { if ( isSeriesVisibleInLegend ( OIEhw ) ) { LegendItem item = getLegendItem ( index , OIEhw ) ; if ( item ! = null ) { result . add ( item ) ; } } OIEhw - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int XACmt = 0 ; while ( XACmt < seriesCount ) { if ( isSeriesVisibleInLegend ( XACmt ) ) { LegendItem item = getLegendItem ( index , XACmt ) ; if ( item ! = null ) { result . add ( item ) ; } } XACmt + + ; } } else { int IwYSR = seriesCount - 1 ; while ( IwYSR > = 0 ) { if ( isSeriesVisibleInLegend ( IwYSR ) ) { LegendItem item = getLegendItem ( index , IwYSR ) ; if ( item ! = null ) { result . add ( item ) ; } } IwYSR - - ; } } return result ;", "text_3": 1}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }  public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; int rowIndex = getRowIndex ( rowKey ) ; KeyedObjects row = ( KeyedObjects ) this . rows . get ( rowIndex ) ; int cNho1 = 0 , HXugg = row . getItemCount ( ) ; while ( cNho1 < HXugg ) { if ( row . getObject ( cNho1 ) ! = null ) { allNull = false ; break ; } cNho1 + + ; } if ( allNull ) { } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; int rowIndex = getRowIndex ( rowKey ) ; KeyedObjects row = ( KeyedObjects ) this . rows . get ( rowIndex ) ; int lY750 = 0 , rrICM = row . getItemCount ( ) ; while ( lY750 < rrICM ) { if ( row . getObject ( lY750 ) ! = null ) { allNull = false ; break ; } lY750 + + ; } if ( allNull ) { } / / 2 . check whether the column is now empty . allNull = true ;  int jxthA = 0 , Y1Tuf = this . rows . size ( ) ; while ( jxthA < Y1Tuf ) { row = ( KeyedObjects ) this . rows . get ( jxthA ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } jxthA + + ; } if ( allNull ) { int EAXRU = 0 , CzFqZ = this . rows . size ( ) ; while ( EAXRU < CzFqZ ) { row = ( KeyedObjects ) this . rows . get ( EAXRU ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } EAXRU + + ; } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } }  public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } int YUYOc = 0 ; while ( YUYOc < categoryKeys . length ) { if ( categoryKeys [ YUYOc ] = = null ) { throw new IllegalArgumentException ( \" DefaultIntervalCategoryDataset . setCategoryKeys ( ) : \" + \" null category not permitted . \" ) ; } YUYOc + + ; } this . categoryKeys = categoryKeys ; fireDatasetChanged ( ) ;", "text_2": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } int EiVTH = 0 ; while ( EiVTH < categoryKeys . length ) { if ( categoryKeys [ EiVTH ] = = null ) { throw new IllegalArgumentException ( \" DefaultIntervalCategoryDataset . setCategoryKeys ( ) : \" + \" null category not permitted . \" ) ; } EiVTH + + ; } this . categoryKeys = categoryKeys ; fireDatasetChanged ( ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int sUbpc = 0 ; while ( sUbpc < seriesCount ) { if ( isSeriesVisibleInLegend ( sUbpc ) ) { LegendItem item = getLegendItem ( index , sUbpc ) ; if ( item ! = null ) { result . add ( item ) ; } } sUbpc + + ; } } else { int GfQII = seriesCount - 1 ; while ( GfQII > = 0 ) { if ( isSeriesVisibleInLegend ( GfQII ) ) { LegendItem item = getLegendItem ( index , GfQII ) ; if ( item ! = null ) { result . add ( item ) ; } } GfQII - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int nuoLA = 0 ; while ( nuoLA < seriesCount ) { if ( isSeriesVisibleInLegend ( nuoLA ) ) { LegendItem item = getLegendItem ( index , nuoLA ) ; if ( item ! = null ) { result . add ( item ) ; } } nuoLA + + ; } } else { int QFhA5 = seriesCount - 1 ; while ( QFhA5 > = 0 ) { if ( isSeriesVisibleInLegend ( QFhA5 ) ) { LegendItem item = getLegendItem ( index , QFhA5 ) ; if ( item ! = null ) { result . add ( item ) ; } } QFhA5 - - ; } } return result ;", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int mbUaa = start ; while ( mbUaa < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( mbUaa ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } mbUaa + + ; } } return copy ;", "text_2": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int oSawv = start ; while ( oSawv < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( oSawv ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } oSawv + + ; } } return copy ;", "text_3": 1}
{"text_1": "if ( includeInterval & & dataset instanceof IntervalXYDataset ) { / / handle special case of IntervalXYDataset IntervalXYDataset ixyd = ( IntervalXYDataset ) dataset ; int d9Hln = 0 ; while ( d9Hln < seriesCount ) { int itemCount = dataset . getItemCount ( d9Hln ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( d9Hln , item ) ; double uvalue = ixyd . getEndYValue ( d9Hln , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } d9Hln + + ; } } else if ( includeInterval & & dataset instanceof OHLCDataset ) { / / handle special case of OHLCDataset OHLCDataset ohlc = ( OHLCDataset ) dataset ; int kMqN3 = 0 ; while ( kMqN3 < seriesCount ) { int itemCount = dataset . getItemCount ( kMqN3 ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ohlc . getLowValue ( kMqN3 , item ) ; double uvalue = ohlc . getHighValue ( kMqN3 , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } maximum = Math . max ( maximum , uvalue ) ; } } kMqN3 + + ; } } else { int Ace1u = 0 ; while ( Ace1u < seriesCount ) { int itemCount = dataset . getItemCount ( Ace1u ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = dataset . getYValue ( Ace1u , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } } Ace1u + + ; } } if ( minimum = = Double . POSITIVE_INFINITY ) { double uvalue ; if ( includeInterval & & dataset instanceof IntervalXYDataset ) { IntervalXYDataset intervalXYData = ( IntervalXYDataset ) dataset ; int us1Ya = 0 ; while ( us1Ya < seriesCount ) { int itemCount = dataset . getItemCount ( us1Ya ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( us1Ya , item ) ; uvalue = intervalXYData . getEndXValue ( us1Ya , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } us1Ya + + ; } } else { int agqYC = 0 ; while ( agqYC < seriesCount ) { int itemCount = dataset . getItemCount ( agqYC ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = dataset . getXValue ( agqYC , item ) ; uvalue = lvalue ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } agqYC + + ; } } if ( minimum > maximum ) {", "text_2": "if ( includeInterval & & dataset instanceof IntervalXYDataset ) { / / handle special case of IntervalXYDataset IntervalXYDataset ixyd = ( IntervalXYDataset ) dataset ; int NWOLq = 0 ; while ( NWOLq < seriesCount ) { int itemCount = dataset . getItemCount ( NWOLq ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( NWOLq , item ) ; double lvalue = ixyd . getStartYValue ( NWOLq , item ) ; double uvalue = ixyd . getEndYValue ( NWOLq , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } NWOLq + + ; } } else if ( includeInterval & & dataset instanceof OHLCDataset ) { / / handle special case of OHLCDataset OHLCDataset ohlc = ( OHLCDataset ) dataset ; int hCzRC = 0 ; while ( hCzRC < seriesCount ) { int itemCount = dataset . getItemCount ( hCzRC ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ohlc . getLowValue ( hCzRC , item ) ; double uvalue = ohlc . getHighValue ( hCzRC , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } maximum = Math . max ( maximum , uvalue ) ; } } hCzRC + + ; } } else { int y23gF = 0 ; while ( y23gF < seriesCount ) { int itemCount = dataset . getItemCount ( y23gF ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = dataset . getYValue ( y23gF , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } } y23gF + + ; } } if ( minimum = = Double . POSITIVE_INFINITY ) { double uvalue ; if ( includeInterval & & dataset instanceof IntervalXYDataset ) { IntervalXYDataset intervalXYData = ( IntervalXYDataset ) dataset ; int znJEq = 0 ; while ( znJEq < seriesCount ) { int itemCount = dataset . getItemCount ( znJEq ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( znJEq , item ) ; lvalue = intervalXYData . getStartXValue ( znJEq , item ) ; uvalue = intervalXYData . getEndXValue ( znJEq , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } znJEq + + ; } } else { int De85o = 0 ; while ( De85o < seriesCount ) { int itemCount = dataset . getItemCount ( De85o ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = dataset . getXValue ( De85o , item ) ; uvalue = lvalue ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } De85o + + ; } } if ( minimum > maximum ) {", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int bBNMw = 0 ; while ( bBNMw < seriesCount ) { if ( isSeriesVisibleInLegend ( bBNMw ) ) { LegendItem item = getLegendItem ( index , bBNMw ) ; if ( item ! = null ) { result . add ( item ) ; } } bBNMw + + ; } } else { int Hl7h0 = seriesCount - 1 ; while ( Hl7h0 > = 0 ) { if ( isSeriesVisibleInLegend ( Hl7h0 ) ) { LegendItem item = getLegendItem ( index , Hl7h0 ) ; if ( item ! = null ) { result . add ( item ) ; } } Hl7h0 - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int lRs36 = 0 ; while ( lRs36 < seriesCount ) { if ( isSeriesVisibleInLegend ( lRs36 ) ) { LegendItem item = getLegendItem ( index , lRs36 ) ; if ( item ! = null ) { result . add ( item ) ; } } lRs36 + + ; } } else { int dm5Ke = seriesCount - 1 ; while ( dm5Ke > = 0 ) { if ( isSeriesVisibleInLegend ( dm5Ke ) ) { LegendItem item = getLegendItem ( index , dm5Ke ) ; if ( item ! = null ) { result . add ( item ) ; } } dm5Ke - - ; } } return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int tRSUV = 0 ; while ( tRSUV < seriesCount ) { if ( isSeriesVisibleInLegend ( tRSUV ) ) { LegendItem item = getLegendItem ( index , tRSUV ) ; if ( item ! = null ) { result . add ( item ) ; } } tRSUV + + ; } } else { int rdvdE = seriesCount - 1 ; while ( rdvdE > = 0 ) { if ( isSeriesVisibleInLegend ( rdvdE ) ) { LegendItem item = getLegendItem ( index , rdvdE ) ; if ( item ! = null ) { result . add ( item ) ; } } rdvdE - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int bwV0A = 0 ; while ( bwV0A < seriesCount ) { if ( isSeriesVisibleInLegend ( bwV0A ) ) { LegendItem item = getLegendItem ( index , bwV0A ) ; if ( item ! = null ) { result . add ( item ) ; } } bwV0A + + ; } } else { int msl5z = seriesCount - 1 ; while ( msl5z > = 0 ) { if ( isSeriesVisibleInLegend ( msl5z ) ) { LegendItem item = getLegendItem ( index , msl5z ) ; if ( item ! = null ) { result . add ( item ) ; } } msl5z - - ; } } return result ;", "text_3": 0}
{"text_1": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int FxwGk = start ; while ( FxwGk < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( FxwGk ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } FxwGk + + ; } } return copy ;", "text_2": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int nsqWr = start ; while ( nsqWr < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( nsqWr ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } nsqWr + + ; } } return copy ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int eDZWg = 0 ; while ( eDZWg < seriesCount ) { if ( isSeriesVisibleInLegend ( eDZWg ) ) { LegendItem item = getLegendItem ( index , eDZWg ) ; if ( item ! = null ) { result . add ( item ) ; } } eDZWg + + ; } } else { int Kf8Fm = seriesCount - 1 ; while ( Kf8Fm > = 0 ) { if ( isSeriesVisibleInLegend ( Kf8Fm ) ) { LegendItem item = getLegendItem ( index , Kf8Fm ) ; if ( item ! = null ) { result . add ( item ) ; } } Kf8Fm - - ; } } return result ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int hT8vj = 0 ; while ( hT8vj < seriesCount ) { if ( isSeriesVisibleInLegend ( hT8vj ) ) { LegendItem item = getLegendItem ( index , hT8vj ) ; if ( item ! = null ) { result . add ( item ) ; } } hT8vj + + ; } } else { int h4sxR = seriesCount - 1 ; while ( h4sxR > = 0 ) { if ( isSeriesVisibleInLegend ( h4sxR ) ) { LegendItem item = getLegendItem ( index , h4sxR ) ; if ( item ! = null ) { result . add ( item ) ; } } h4sxR - - ; } } return result ;", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int N5yyj = 0 ; while ( N5yyj < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , N5yyj , Layer . BACKGROUND ) ; N5yyj + + ; } int XHtC7 = 0 ; while ( XHtC7 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , XHtC7 , Layer . BACKGROUND ) ; XHtC7 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int T9SSk = 0 ; while ( T9SSk < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , T9SSk , state ) | | foundData ; T9SSk + + ; } } else { / / DatasetRenderingOrder . REVERSE int hMdKs = this . datasets . size ( ) - 1 ; while ( hMdKs > = 0 ) { foundData = render ( g2 , dataArea , hMdKs , state ) | | foundData ; hMdKs - - ; } } int OFFNx = 0 ; while ( OFFNx < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , OFFNx , Layer . FOREGROUND ) ; OFFNx + + ; } int FMBfn = 0 ; while ( FMBfn < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , FMBfn , Layer . FOREGROUND ) ; FMBfn + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int ZZjQa = 0 ; while ( ZZjQa < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , ZZjQa , Layer . BACKGROUND ) ; ZZjQa + + ; } int i2r7g = 0 ; while ( i2r7g < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , i2r7g , Layer . BACKGROUND ) ; i2r7g + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int Z2vap = 0 ; while ( Z2vap < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , Z2vap , state ) | | foundData ; Z2vap + + ; } } else { / / DatasetRenderingOrder . REVERSE int dnb2i = this . datasets . size ( ) - 1 ; while ( dnb2i > = 0 ) { foundData = render ( g2 , dataArea , dnb2i , state ) | | foundData ; dnb2i - - ; } } int OPoo3 = 0 ; while ( OPoo3 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , OPoo3 , Layer . FOREGROUND ) ; OPoo3 + + ; } int jnWrN = 0 ; while ( jnWrN < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , jnWrN , Layer . FOREGROUND ) ; jnWrN + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int abl1p = 0 ; while ( abl1p < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( abl1p ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( abl1p ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; abl1p + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int o8K1B = 0 ; while ( o8K1B < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( o8K1B ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( o8K1B ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , o8K1B , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } o8K1B + + ; } g2 . setClip ( savedClip ) ;", "text_2": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int ccEnc = 0 ; while ( ccEnc < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( ccEnc ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( ccEnc ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; ccEnc + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int jatyl = 0 ; while ( jatyl < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( jatyl ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( jatyl ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , jatyl , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } jatyl + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int WLybF = start ; while ( WLybF < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( WLybF ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } WLybF + + ; } } return copy ;", "text_2": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( this . data . size ( ) > 0 ) { int hA0b8 = start ; while ( hA0b8 < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( hA0b8 ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } hA0b8 + + ; } } return copy ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int rrBdM = 0 ; while ( rrBdM < seriesCount ) { if ( isSeriesVisibleInLegend ( rrBdM ) ) { LegendItem item = getLegendItem ( index , rrBdM ) ; if ( item ! = null ) { result . add ( item ) ; } } rrBdM + + ; } } else { int VA446 = seriesCount - 1 ; while ( VA446 > = 0 ) { if ( isSeriesVisibleInLegend ( VA446 ) ) { LegendItem item = getLegendItem ( index , VA446 ) ; if ( item ! = null ) { result . add ( item ) ; } } VA446 - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Iid7p = 0 ; while ( Iid7p < seriesCount ) { if ( isSeriesVisibleInLegend ( Iid7p ) ) { LegendItem item = getLegendItem ( index , Iid7p ) ; if ( item ! = null ) { result . add ( item ) ; } } Iid7p + + ; } } else { int gU6fU = seriesCount - 1 ; while ( gU6fU > = 0 ) { if ( isSeriesVisibleInLegend ( gU6fU ) ) { LegendItem item = getLegendItem ( index , gU6fU ) ; if ( item ! = null ) { result . add ( item ) ; } } gU6fU - - ; } } return result ;", "text_3": 0}
{"text_1": "TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int bQZvd = start ; while ( bQZvd < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( bQZvd ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } bQZvd + + ; } } return copy ; } } \\ No newline at end of file", "text_2": "TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int JIZKE = start ; while ( JIZKE < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( JIZKE ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } JIZKE + + ; } } return copy . addAndOrUpdate ( copy ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int vTDbJ = start ; while ( vTDbJ < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( vTDbJ ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } vTDbJ + + ; } } return copy ;", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int TdiYU = start ; while ( TdiYU < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( TdiYU ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } TdiYU + + ; } } return copy ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int otBUy = 0 ; while ( otBUy < seriesCount ) { if ( isSeriesVisibleInLegend ( otBUy ) ) { LegendItem item = getLegendItem ( index , otBUy ) ; if ( item ! = null ) { result . add ( item ) ; } } otBUy + + ; } } else { int SdrKp = seriesCount - 1 ; while ( SdrKp > = 0 ) { if ( isSeriesVisibleInLegend ( SdrKp ) ) { LegendItem item = getLegendItem ( index , SdrKp ) ; if ( item ! = null ) { result . add ( item ) ; } } SdrKp - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & ! ( dataset instanceof SelectableCategoryDataset ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int X5Dmg = 0 ; while ( X5Dmg < seriesCount ) { if ( isSeriesVisibleInLegend ( X5Dmg ) ) { LegendItem item = getLegendItem ( index , X5Dmg ) ; if ( item ! = null ) { result . add ( item ) ; } } X5Dmg + + ; } } else { int q4NFg = seriesCount - 1 ; while ( q4NFg > = 0 ) { if ( isSeriesVisibleInLegend ( q4NFg ) ) { LegendItem item = getLegendItem ( index , q4NFg ) ; if ( item ! = null ) { result . add ( item ) ; } } q4NFg - - ; } } return result ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int IbkSP = 0 ; while ( IbkSP < seriesCount ) { if ( isSeriesVisibleInLegend ( IbkSP ) ) { LegendItem item = getLegendItem ( index , IbkSP ) ; if ( item ! = null ) { result . add ( item ) ; } } IbkSP + + ; } } else { int szw6n = seriesCount - 1 ; while ( szw6n > = 0 ) { if ( isSeriesVisibleInLegend ( szw6n ) ) { LegendItem item = getLegendItem ( index , szw6n ) ; if ( item ! = null ) { result . add ( item ) ; } } szw6n - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int S4M4d = 0 ; while ( S4M4d < seriesCount ) { if ( isSeriesVisibleInLegend ( S4M4d ) ) { LegendItem item = getLegendItem ( index , S4M4d ) ; if ( item ! = null ) { result . add ( item ) ; } } S4M4d + + ; } } else { int TxkGN = seriesCount - 1 ; while ( TxkGN > = 0 ) { if ( isSeriesVisibleInLegend ( TxkGN ) ) { LegendItem item = getLegendItem ( index , TxkGN ) ; if ( item ! = null ) { result . add ( item ) ; } } TxkGN - - ; } } return result ;", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int uKGmk = 0 ; while ( uKGmk < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , uKGmk , Layer . BACKGROUND ) ; uKGmk + + ; } int LLtw2 = 0 ; while ( LLtw2 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , LLtw2 , Layer . BACKGROUND ) ; LLtw2 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int Kf9UI = 0 ; while ( Kf9UI < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , Kf9UI , state ) | | foundData ; Kf9UI + + ; } } else { / / DatasetRenderingOrder . REVERSE int O0Ep3 = this . datasets . size ( ) - 1 ; while ( O0Ep3 > = 0 ) { foundData = render ( g2 , dataArea , O0Ep3 , state ) | | foundData ; O0Ep3 - - ; } } int BtPNE = 0 ; while ( BtPNE < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , BtPNE , Layer . FOREGROUND ) ; BtPNE + + ; } int Gy9xt = 0 ; while ( Gy9xt < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Gy9xt , Layer . FOREGROUND ) ; Gy9xt + + ; } / / draw the annotations ( if any ) . . .", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int vfVy0 = 0 ; while ( vfVy0 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , vfVy0 , Layer . BACKGROUND ) ; vfVy0 + + ; } int W4arG = 0 ; while ( W4arG < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , W4arG , Layer . BACKGROUND ) ; W4arG + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int Tc9oF = 0 ; while ( Tc9oF < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , Tc9oF , state ) | | foundData ; Tc9oF + + ; } } else { / / DatasetRenderingOrder . REVERSE int sbXVz = this . datasets . size ( ) - 1 ; while ( sbXVz > = 0 ) { foundData = render ( g2 , dataArea , sbXVz , state ) | | foundData ; sbXVz - - ; } } int asAQ9 = 0 ; while ( asAQ9 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , asAQ9 , Layer . FOREGROUND ) ; asAQ9 + + ; } int WeiaF = 0 ; while ( WeiaF < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , WeiaF , Layer . FOREGROUND ) ; WeiaF + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Y0clw = 0 ; while ( Y0clw < seriesCount ) { if ( isSeriesVisibleInLegend ( Y0clw ) ) { LegendItem item = getLegendItem ( index , Y0clw ) ; if ( item ! = null ) { result . add ( item ) ; } } Y0clw + + ; } } else { int zvQpJ = seriesCount - 1 ; while ( zvQpJ > = 0 ) { if ( isSeriesVisibleInLegend ( zvQpJ ) ) { LegendItem item = getLegendItem ( index , zvQpJ ) ; if ( item ! = null ) { result . add ( item ) ; } } zvQpJ - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int iVAVs = 0 ; while ( iVAVs < seriesCount ) { if ( isSeriesVisibleInLegend ( iVAVs ) ) { LegendItem item = getLegendItem ( index , iVAVs ) ; if ( item ! = null ) { result . add ( item ) ; } } iVAVs + + ; } } else { int kNhUn = seriesCount - 1 ; while ( kNhUn > = 0 ) { if ( isSeriesVisibleInLegend ( kNhUn ) ) { LegendItem item = getLegendItem ( index , kNhUn ) ; if ( item ! = null ) { result . add ( item ) ; } } kNhUn - - ; } } return result ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int sS3PI = 0 ; while ( sS3PI < seriesCount ) { if ( isSeriesVisibleInLegend ( sS3PI ) ) { LegendItem item = getLegendItem ( index , sS3PI ) ; if ( item ! = null ) { result . add ( item ) ; } } sS3PI + + ; } } else { int AbVRu = seriesCount - 1 ; while ( AbVRu > = 0 ) { if ( isSeriesVisibleInLegend ( AbVRu ) ) { LegendItem item = getLegendItem ( index , AbVRu ) ; if ( item ! = null ) { result . add ( item ) ; } } AbVRu - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) {  } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int vmXaG = 0 ; while ( vmXaG < seriesCount ) { if ( isSeriesVisibleInLegend ( vmXaG ) ) { LegendItem item = getLegendItem ( index , vmXaG ) ; if ( item ! = null ) { result . add ( item ) ; } } vmXaG + + ; } } else { int cZRPU = seriesCount - 1 ; while ( cZRPU > = 0 ) { if ( isSeriesVisibleInLegend ( cZRPU ) ) { LegendItem item = getLegendItem ( index , cZRPU ) ; if ( item ! = null ) { result . add ( item ) ; } } cZRPU - - ; } } return result ;", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int iGyw7 = 0 ; while ( iGyw7 < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( iGyw7 ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( iGyw7 ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; iGyw7 + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int d6gNj = 0 ; while ( d6gNj < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( d6gNj ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( d6gNj ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , d6gNj , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } d6gNj + + ; } g2 . setClip ( savedClip ) ;", "text_2": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int AQs1i = 0 ; while ( AQs1i < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( AQs1i ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( AQs1i ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; AQs1i + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int qMbZq = 0 ; while ( qMbZq < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( qMbZq ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( qMbZq ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , qMbZq , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } qMbZq + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int kqQRz = 0 ; while ( kqQRz < seriesCount ) { if ( isSeriesVisibleInLegend ( kqQRz ) ) { LegendItem item = getLegendItem ( index , kqQRz ) ; if ( item ! = null ) { result . add ( item ) ; } } kqQRz + + ; } } else { int lOvbn = seriesCount - 1 ; while ( lOvbn > = 0 ) { if ( isSeriesVisibleInLegend ( lOvbn ) ) { LegendItem item = getLegendItem ( index , lOvbn ) ; if ( item ! = null ) { result . add ( item ) ; } } lOvbn - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int W5tD1 = 0 ; while ( W5tD1 < seriesCount ) { if ( isSeriesVisibleInLegend ( W5tD1 ) ) { LegendItem item = getLegendItem ( index , W5tD1 ) ; if ( item ! = null ) { result . add ( item ) ; } } W5tD1 + + ; } } else { int upnFf = seriesCount - 1 ; while ( upnFf > = 0 ) { if ( isSeriesVisibleInLegend ( upnFf ) ) { LegendItem item = getLegendItem ( index , upnFf ) ; if ( item ! = null ) { result . add ( item ) ; } } upnFf - - ; } } return result ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int nOilE = 0 ; while ( nOilE < seriesCount ) { if ( isSeriesVisibleInLegend ( nOilE ) ) { LegendItem item = getLegendItem ( index , nOilE ) ; if ( item ! = null ) { result . add ( item ) ; } } nOilE + + ; } } else { int n2afK = seriesCount - 1 ; while ( n2afK > = 0 ) { if ( isSeriesVisibleInLegend ( n2afK ) ) { LegendItem item = getLegendItem ( index , n2afK ) ; if ( item ! = null ) { result . add ( item ) ; } } n2afK - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int a8atS = 0 ; while ( a8atS < seriesCount ) { if ( isSeriesVisibleInLegend ( a8atS ) ) { LegendItem item = getLegendItem ( index , a8atS ) ; if ( item ! = null ) { result . add ( item ) ; } } a8atS + + ; } } else { int S4Sfw = seriesCount - 1 ; while ( S4Sfw > = 0 ) { if ( isSeriesVisibleInLegend ( S4Sfw ) ) { LegendItem item = getLegendItem ( index , S4Sfw ) ; if ( item ! = null ) { result . add ( item ) ; } } S4Sfw - - ; } } return result ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int W6pM0 = start ; while ( W6pM0 < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( W6pM0 ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } W6pM0 + + ; } } return copy ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int JM4Kg = start ; while ( JM4Kg < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( JM4Kg ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } JM4Kg + + ; } } return copy ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int JnZqD = 0 ; while ( JnZqD < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , JnZqD , Layer . BACKGROUND ) ; JnZqD + + ; } int P8XpR = 0 ; while ( P8XpR < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , P8XpR , Layer . BACKGROUND ) ; P8XpR + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int OBbrP = 0 ; while ( OBbrP < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , OBbrP , state ) | | foundData ; OBbrP + + ; } } else { / / DatasetRenderingOrder . REVERSE int GZdmj = this . datasets . size ( ) - 1 ; while ( GZdmj > = 0 ) { foundData = render ( g2 , dataArea , GZdmj , state ) | | foundData ; GZdmj - - ; } } int atd2w = 0 ; while ( atd2w < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , atd2w , Layer . FOREGROUND ) ; atd2w + + ; } int BdZJ6 = 0 ; while ( BdZJ6 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , BdZJ6 , Layer . FOREGROUND ) ; BdZJ6 + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int nfkBZ = 0 ; while ( nfkBZ < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , nfkBZ , Layer . BACKGROUND ) ; nfkBZ + + ; } int RhVNT = 0 ; while ( RhVNT < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , RhVNT , Layer . BACKGROUND ) ; RhVNT + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int oKSNc = 0 ; while ( oKSNc < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , oKSNc , state ) | | foundData ; oKSNc + + ; } } else { / / DatasetRenderingOrder . REVERSE int NmwB7 = this . datasets . size ( ) - 1 ; while ( NmwB7 > = 0 ) { foundData = render ( g2 , dataArea , NmwB7 , state ) | | foundData ; NmwB7 - - ; } } int U4tE3 = 0 ; while ( U4tE3 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , U4tE3 , Layer . FOREGROUND ) ; U4tE3 + + ; } int K4DYz = 0 ; while ( K4DYz < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , K4DYz , Layer . FOREGROUND ) ; K4DYz + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int gZLh8 = 0 ; while ( gZLh8 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , gZLh8 , Layer . BACKGROUND ) ; gZLh8 + + ; } int uHdLR = 0 ; while ( uHdLR < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , uHdLR , Layer . BACKGROUND ) ; uHdLR + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int YRPMZ = 0 ; while ( YRPMZ < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , YRPMZ , state ) | | foundData ; YRPMZ + + ; } } else { / / DatasetRenderingOrder . REVERSE int MQQkI = this . datasets . size ( ) - 1 ; while ( MQQkI > = 0 ) { foundData = render ( g2 , dataArea , MQQkI , state ) | | foundData ; MQQkI - - ; } } int xk1Mt = 0 ; while ( xk1Mt < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , xk1Mt , Layer . FOREGROUND ) ; xk1Mt + + ; } int Nxdor = 0 ; while ( Nxdor < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Nxdor , Layer . FOREGROUND ) ; Nxdor + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int w7Z1o = 0 ; while ( w7Z1o < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , w7Z1o , Layer . BACKGROUND ) ; w7Z1o + + ; } int XTqyZ = 0 ; while ( XTqyZ < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , XTqyZ , Layer . BACKGROUND ) ; XTqyZ + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int XT6jC = 0 ; while ( XT6jC < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , XT6jC , state ) | | foundData ; XT6jC + + ; } } else { / / DatasetRenderingOrder . REVERSE int VNWeJ = this . datasets . size ( ) - 1 ; while ( VNWeJ > = 0 ) { foundData = render ( g2 , dataArea , VNWeJ , state ) | | foundData ; VNWeJ - - ; } } int hMV1T = 0 ; while ( hMV1T < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , hMV1T , Layer . FOREGROUND ) ; hMV1T + + ; } int Oubj2 = 0 ; while ( Oubj2 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Oubj2 , Layer . FOREGROUND ) ; Oubj2 + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int xkzRA = 0 ; while ( xkzRA < seriesCount ) { if ( isSeriesVisibleInLegend ( xkzRA ) ) { LegendItem item = getLegendItem ( index , xkzRA ) ; if ( item ! = null ) { result . add ( item ) ; } } xkzRA + + ; } } else { int Aa2A3 = seriesCount - 1 ; while ( Aa2A3 > = 0 ) { if ( isSeriesVisibleInLegend ( Aa2A3 ) ) { LegendItem item = getLegendItem ( index , Aa2A3 ) ; if ( item ! = null ) { result . add ( item ) ; } } Aa2A3 - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int rQ0e2 = 0 ; while ( rQ0e2 < seriesCount ) { if ( isSeriesVisibleInLegend ( rQ0e2 ) ) { LegendItem item = getLegendItem ( index , rQ0e2 ) ; if ( item ! = null ) { result . add ( item ) ; } } rQ0e2 + + ; } } else { int nWUj7 = seriesCount - 1 ; while ( nWUj7 > = 0 ) { if ( isSeriesVisibleInLegend ( nWUj7 ) ) { LegendItem item = getLegendItem ( index , nWUj7 ) ; if ( item ! = null ) { result . add ( item ) ; } } nWUj7 - - ; } } return result ;", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int eLVy4 = 0 ; while ( eLVy4 < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( eLVy4 ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( eLVy4 ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; eLVy4 + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int EFH1Z = 0 ; while ( EFH1Z < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( EFH1Z ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( EFH1Z ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , EFH1Z , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } EFH1Z + + ; } g2 . setClip ( savedClip ) ;", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int L8YQK = 0 ; while ( L8YQK < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( L8YQK ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( L8YQK ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; L8YQK + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int TYdUC = 0 ; while ( TYdUC < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( TYdUC ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( TYdUC ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , TYdUC , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } TYdUC + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int p4JyV = 0 ; while ( p4JyV < seriesCount ) { if ( isSeriesVisibleInLegend ( p4JyV ) ) { LegendItem item = getLegendItem ( index , p4JyV ) ; if ( item ! = null ) { result . add ( item ) ; } } p4JyV + + ; } } else { int huZ8F = seriesCount - 1 ; while ( huZ8F > = 0 ) { if ( isSeriesVisibleInLegend ( huZ8F ) ) { LegendItem item = getLegendItem ( index , huZ8F ) ; if ( item ! = null ) { result . add ( item ) ; } } huZ8F - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int xZLg5 = 0 ; while ( xZLg5 < seriesCount ) { if ( isSeriesVisibleInLegend ( xZLg5 ) ) { LegendItem item = getLegendItem ( index , xZLg5 ) ; if ( item ! = null ) { result . add ( item ) ; } } xZLg5 + + ; } } else { int JIW5v = seriesCount - 1 ; while ( JIW5v > = 0 ) { if ( isSeriesVisibleInLegend ( JIW5v ) ) { LegendItem item = getLegendItem ( index , JIW5v ) ; if ( item ! = null ) { result . add ( item ) ; } } JIW5v - - ; } } return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int mFjL6 = 0 ; while ( mFjL6 < seriesCount ) { if ( isSeriesVisibleInLegend ( mFjL6 ) ) { LegendItem item = getLegendItem ( index , mFjL6 ) ; if ( item ! = null ) { result . add ( item ) ; } } mFjL6 + + ; } } else { int cUNrz = seriesCount - 1 ; while ( cUNrz > = 0 ) { if ( isSeriesVisibleInLegend ( cUNrz ) ) { LegendItem item = getLegendItem ( index , cUNrz ) ; if ( item ! = null ) { result . add ( item ) ; } } cUNrz - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int ji8mH = 0 ; while ( ji8mH < seriesCount ) { if ( isSeriesVisibleInLegend ( ji8mH ) ) { LegendItem item = getLegendItem ( index , ji8mH ) ; if ( item ! = null ) { result . add ( item ) ; } } ji8mH + + ; } } else { int nwf9I = seriesCount - 1 ; while ( nwf9I > = 0 ) { if ( isSeriesVisibleInLegend ( nwf9I ) ) { LegendItem item = getLegendItem ( index , nwf9I ) ; if ( item ! = null ) { result . add ( item ) ; } } nwf9I - - ; } } return result ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int VuzKr = start ; while ( VuzKr < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( VuzKr ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } VuzKr + + ; } } return copy ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int XQm8b = start ; while ( XQm8b < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( XQm8b ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } XQm8b + + ; } } return copy ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int nj1wU = 0 ; while ( nj1wU < seriesCount ) { if ( isSeriesVisibleInLegend ( nj1wU ) ) { LegendItem item = getLegendItem ( index , nj1wU ) ; if ( item ! = null ) { result . add ( item ) ; } } nj1wU + + ; } } else { int YH7Jx = seriesCount - 1 ; while ( YH7Jx > = 0 ) { if ( isSeriesVisibleInLegend ( YH7Jx ) ) { LegendItem item = getLegendItem ( index , YH7Jx ) ; if ( item ! = null ) { result . add ( item ) ; } } YH7Jx - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int A5fD7 = 0 ; while ( A5fD7 < seriesCount ) { if ( isSeriesVisibleInLegend ( A5fD7 ) ) { LegendItem item = getLegendItem ( index , A5fD7 ) ; if ( item ! = null ) { result . add ( item ) ; } } A5fD7 + + ; } } else { int z5a8n = seriesCount - 1 ; while ( z5a8n > = 0 ) { if ( isSeriesVisibleInLegend ( z5a8n ) ) { LegendItem item = getLegendItem ( index , z5a8n ) ; if ( item ! = null ) { result . add ( item ) ; } } z5a8n - - ; } } return result ;", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int iFKZc = 0 ; while ( iFKZc < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , iFKZc , Layer . BACKGROUND ) ; iFKZc + + ; } int slb55 = 0 ; while ( slb55 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , slb55 , Layer . BACKGROUND ) ; slb55 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int LgqVH = 0 ; while ( LgqVH < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , LgqVH , state ) | | foundData ; LgqVH + + ; } } else { / / DatasetRenderingOrder . REVERSE int NeeB9 = this . datasets . size ( ) - 1 ; while ( NeeB9 > = 0 ) { foundData = render ( g2 , dataArea , NeeB9 , state ) | | foundData ; NeeB9 - - ; } } int NwLI8 = 0 ; while ( NwLI8 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , NwLI8 , Layer . FOREGROUND ) ; NwLI8 + + ; } int HeDxk = 0 ; while ( HeDxk < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , HeDxk , Layer . FOREGROUND ) ; HeDxk + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int SMWh9 = 0 ; while ( SMWh9 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , SMWh9 , Layer . BACKGROUND ) ; SMWh9 + + ; } int vg4O6 = 0 ; while ( vg4O6 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , vg4O6 , Layer . BACKGROUND ) ; vg4O6 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int OI3S0 = 0 ; while ( OI3S0 < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , OI3S0 , state ) | | foundData ; OI3S0 + + ; } } else { / / DatasetRenderingOrder . REVERSE int o53TF = this . datasets . size ( ) - 1 ; while ( o53TF > = 0 ) { foundData = render ( g2 , dataArea , o53TF , state ) | | foundData ; o53TF - - ; } } int HrLX5 = 0 ; while ( HrLX5 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , HrLX5 , Layer . FOREGROUND ) ; HrLX5 + + ; } int VOo2D = 0 ; while ( VOo2D < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , VOo2D , Layer . FOREGROUND ) ; VOo2D + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int uSSJl = 0 ; while ( uSSJl < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( uSSJl ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( uSSJl ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; uSSJl + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int ou9zw = 0 ; while ( ou9zw < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( ou9zw ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( ou9zw ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , ou9zw , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } ou9zw + + ; } g2 . setClip ( savedClip ) ;", "text_2": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int p1J2s = 0 ; while ( p1J2s < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( p1J2s ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( p1J2s ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; p1J2s + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int xEwYI = 0 ; while ( xEwYI < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( xEwYI ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( xEwYI ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , xEwYI , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } xEwYI + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int tXbEo = 0 ; while ( tXbEo < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , tXbEo , Layer . BACKGROUND ) ; tXbEo + + ; } int qeYtv = 0 ; while ( qeYtv < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , qeYtv , Layer . BACKGROUND ) ; qeYtv + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int yvMbf = 0 ; while ( yvMbf < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , yvMbf , state ) | | foundData ; yvMbf + + ; } } else { / / DatasetRenderingOrder . REVERSE int Xtccg = this . datasets . size ( ) - 1 ; while ( Xtccg > = 0 ) { foundData = render ( g2 , dataArea , Xtccg , state ) | | foundData ; Xtccg - - ; } } int vLUjO = 0 ; while ( vLUjO < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , vLUjO , Layer . FOREGROUND ) ; vLUjO + + ; } int Acxhd = 0 ; while ( Acxhd < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Acxhd , Layer . FOREGROUND ) ; Acxhd + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int qtlJF = 0 ; while ( qtlJF < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , qtlJF , Layer . BACKGROUND ) ; qtlJF + + ; } int eBT69 = 0 ; while ( eBT69 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , eBT69 , Layer . BACKGROUND ) ; eBT69 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int n7XOm = 0 ; while ( n7XOm < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , n7XOm , state ) | | foundData ; n7XOm + + ; } } else { / / DatasetRenderingOrder . REVERSE int NlKVK = this . datasets . size ( ) - 1 ; while ( NlKVK > = 0 ) { foundData = render ( g2 , dataArea , NlKVK , state ) | | foundData ; NlKVK - - ; } } int qjB6p = 0 ; while ( qjB6p < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , qjB6p , Layer . FOREGROUND ) ; qjB6p + + ; } int h9dlc = 0 ; while ( h9dlc < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , h9dlc , Layer . FOREGROUND ) ; h9dlc + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int Cfstl = 0 ; while ( Cfstl < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( Cfstl ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( Cfstl ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; Cfstl + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int dlOfj = 0 ; while ( dlOfj < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( dlOfj ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( dlOfj ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , dlOfj , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } dlOfj + + ; } g2 . setClip ( savedClip ) ;", "text_2": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int i8c8e = 0 ; while ( i8c8e < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( i8c8e ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( i8c8e ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; i8c8e + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int rjShF = 0 ; while ( rjShF < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( rjShF ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( rjShF ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , rjShF , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } rjShF + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } int RYOeu = 0 ; while ( RYOeu < = ( end - start ) ) { this . data . remove ( start ) ; RYOeu + + ; } fireSeriesChanged ( ) ; } if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int QZnfO = start ; while ( QZnfO < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( QZnfO ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } QZnfO + + ; } } return copy ;", "text_2": "public class test { public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } int cQOte = 0 ; while ( cQOte < = ( end - start ) ) { this . data . remove ( start ) ; cQOte + + ; } fireSeriesChanged ( ) ; } if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int drszW = start ; while ( drszW < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( drszW ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } drszW + + ; } } return copy ;", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int Bashp = 0 ; while ( Bashp < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( Bashp ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( Bashp ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; Bashp + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int LBQVo = 0 ; while ( LBQVo < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( LBQVo ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( LBQVo ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , LBQVo , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } LBQVo + + ; } g2 . setClip ( savedClip ) ;", "text_2": "linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int Qr5aD = 0 ; while ( Qr5aD < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( Qr5aD ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( Qr5aD ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; Qr5aD + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int mRfro = 0 ; while ( mRfro < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( mRfro ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( mRfro ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , mRfro , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } mRfro + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object object ) { int ug6sk = 0 ; while ( ug6sk < this . size ) { if ( this . objects [ ug6sk ] = = object ) { return ( ug6sk ) ; } ug6sk + + ; } return - 1 ; }", "text_2": "public class test { protected int indexOf ( Object object ) { int cGVOl = 0 ; while ( cGVOl < this . size ) { if ( this . objects [ cGVOl ] = = object ) { return ( cGVOl ) ; } cGVOl + + ; } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; }", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int euZRb = 0 ; while ( euZRb < seriesCount ) { if ( isSeriesVisibleInLegend ( euZRb ) ) { LegendItem item = getLegendItem ( index , euZRb ) ; if ( item ! = null ) { result . add ( item ) ; } } euZRb + + ; } } else { int ZoLQC = seriesCount - 1 ; while ( ZoLQC > = 0 ) { if ( isSeriesVisibleInLegend ( ZoLQC ) ) { LegendItem item = getLegendItem ( index , ZoLQC ) ; if ( item ! = null ) { result . add ( item ) ; } } ZoLQC - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Fd4eo = 0 ; while ( Fd4eo < seriesCount ) { if ( isSeriesVisibleInLegend ( Fd4eo ) ) { LegendItem item = getLegendItem ( index , Fd4eo ) ; if ( item ! = null ) { result . add ( item ) ; } } Fd4eo + + ; } } else { int YF5aW = seriesCount - 1 ; while ( YF5aW > = 0 ) { if ( isSeriesVisibleInLegend ( YF5aW ) ) { LegendItem item = getLegendItem ( index , YF5aW ) ; if ( item ! = null ) { result . add ( item ) ; } } YF5aW - - ; } } return result ;", "text_3": 0}
{"text_1": "AbstractObjectList other = ( AbstractObjectList ) obj ; int listSize = size ( ) ; int KKBaE = 0 ; while ( KKBaE < listSize ) { if ( ! ObjectUtilities . equal ( get ( KKBaE ) , other . get ( KKBaE ) ) ) { return false ; } KKBaE + + ; } return true ; }", "text_2": "AbstractObjectList other = ( AbstractObjectList ) obj ; int listSize = size ( ) ; int WI3g6 = 0 ; while ( WI3g6 < listSize ) { if ( ! ObjectUtilities . equal ( get ( WI3g6 ) , other . get ( WI3g6 ) ) ) { System . exit ( 0 ) ; } WI3g6 + + ; } return true ; }", "text_3": 0}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int ENbfH = start ; while ( ENbfH < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( ENbfH ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } ENbfH + + ; } } return copy ;", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { int ICk9d = start ; while ( ICk9d < = end ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( ICk9d ) ; TimeSeriesDataItem clone = ( TimeSeriesDataItem ) item . clone ( ) ; try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } ICk9d + + ; } } return copy ;", "text_3": 0}
{"text_1": "drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int bRuNv = 0 ; while ( bRuNv < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , bRuNv , Layer . BACKGROUND ) ; bRuNv + + ; } int oIiU5 = 0 ; while ( oIiU5 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , oIiU5 , Layer . BACKGROUND ) ; oIiU5 + + ; } / / now render data items . . . g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; int uBPI8 = 0 ; while ( uBPI8 < datasetCount ) { CategoryItemRenderer r = getRenderer ( uBPI8 ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( uBPI8 ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( uBPI8 ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } uBPI8 + + ; }  int ko0Yd = 0 ; while ( ko0Yd < datasetCount ) { foundData = render ( g2 , dataArea , ko0Yd , state ) | | foundData ; ko0Yd + + ; }  int CnxtX = 0 ; while ( CnxtX < datasetCount ) { CategoryItemRenderer r = getRenderer ( CnxtX ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( CnxtX ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( CnxtX ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } CnxtX + + ; } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; int KN1K5 = datasetCount - 1 ; while ( KN1K5 > = 0 ) { CategoryItemRenderer r = getRenderer ( KN1K5 ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( KN1K5 ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( KN1K5 ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } KN1K5 - - ; }  int xFgCs = this . datasets . size ( ) - 1 ; while ( xFgCs > = 0 ) { foundData = render ( g2 , dataArea , xFgCs , state ) | | foundData ; xFgCs - - ; }  int WQb2o = datasetCount - 1 ; while ( WQb2o > = 0 ) { CategoryItemRenderer r = getRenderer ( WQb2o ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( WQb2o ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( WQb2o ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } WQb2o - - ; } } int FfEul = 0 ; while ( FfEul < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , FfEul , Layer . FOREGROUND ) ; FfEul + + ; } int wfCZD = 0 ; while ( wfCZD < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , wfCZD , Layer . FOREGROUND ) ; wfCZD + + ; } / / draw the plot ' s annotations ( if any ) . . . space . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { int ZyzI7 = 0 ; while ( ZyzI7 < this . rangeAxes . size ( ) ) { Axis yAxis = ( Axis ) this . rangeAxes . get ( ZyzI7 ) ; if ( yAxis ! = null ) { RectangleEdge edge = getRangeAxisEdge ( ZyzI7 ) ; space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } ZyzI7 + + ; } } return space ;", "text_2": "drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int N9pQS = 0 ; while ( N9pQS < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , N9pQS , Layer . BACKGROUND ) ; N9pQS + + ; } int Et6kF = 0 ; while ( Et6kF < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Et6kF , Layer . BACKGROUND ) ; Et6kF + + ; } / / now render data items . . . g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } int vBl86 = 0 ; while ( vBl86 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , vBl86 , Layer . FOREGROUND ) ; vBl86 + + ; } int IPLXj = 0 ; while ( IPLXj < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , IPLXj , Layer . FOREGROUND ) ; IPLXj + + ; } / / draw the plot ' s annotations ( if any ) . . . space . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { int BWhJ9 = 0 ; while ( BWhJ9 < this . rangeAxes . size ( ) ) { Axis yAxis = ( Axis ) this . rangeAxes . get ( BWhJ9 ) ; if ( yAxis ! = null ) { RectangleEdge edge = getRangeAxisEdge ( BWhJ9 ) ; space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } BWhJ9 + + ; } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "text_3": 0}
{"text_1": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int YeFt3 = 0 ; while ( YeFt3 < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( YeFt3 ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( YeFt3 ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; YeFt3 + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int as4Ha = 0 ; while ( as4Ha < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( as4Ha ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( as4Ha ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , as4Ha , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } as4Ha + + ; } g2 . setClip ( savedClip ) ;", "text_2": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int yzc1J = 0 ; while ( yzc1J < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( yzc1J ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( yzc1J ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; yzc1J + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int gill7 = 0 ; while ( gill7 < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( gill7 ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( gill7 ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , gill7 , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } gill7 + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object object ) { int Sjf06 = 0 ; while ( Sjf06 < this . size ) { if ( this . objects [ Sjf06 ] = = object ) { return ( Sjf06 ) ; } Sjf06 + + ; } return - 1 ; }", "text_2": "public class test { protected int indexOf ( Object object ) { int prz1y = 0 ; while ( prz1y < this . size ) { if ( this . objects [ prz1y ] = = object ) { return ( prz1y ) ; } prz1y + + ; } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; }", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int xZq5E = 0 ; while ( xZq5E < seriesCount ) { if ( isSeriesVisibleInLegend ( xZq5E ) ) { LegendItem item = getLegendItem ( index , xZq5E ) ; if ( item ! = null ) { result . add ( item ) ; } } xZq5E + + ; } } else { int v1CoV = seriesCount - 1 ; while ( v1CoV > = 0 ) { if ( isSeriesVisibleInLegend ( v1CoV ) ) { LegendItem item = getLegendItem ( index , v1CoV ) ; if ( item ! = null ) { result . add ( item ) ; } } v1CoV - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int pj1Rd = 0 ; while ( pj1Rd < seriesCount ) { if ( isSeriesVisibleInLegend ( pj1Rd ) ) { LegendItem item = getLegendItem ( index , pj1Rd ) ; if ( item ! = null ) { result . add ( item ) ; } } pj1Rd + + ; } } else { int EmXXy = seriesCount - 1 ; while ( EmXXy > = 0 ) { if ( isSeriesVisibleInLegend ( EmXXy ) ) { LegendItem item = getLegendItem ( index , EmXXy ) ; if ( item ! = null ) { result . add ( item ) ; } } EmXXy - - ; } } return result ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int Esbtk = 0 ; while ( Esbtk < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , Esbtk , Layer . BACKGROUND ) ; Esbtk + + ; } int WOky3 = 0 ; while ( WOky3 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , WOky3 , Layer . BACKGROUND ) ; WOky3 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int uI6wH = 0 ; while ( uI6wH < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , uI6wH , state ) | | foundData ; uI6wH + + ; } } else { / / DatasetRenderingOrder . REVERSE int TLLhu = this . datasets . size ( ) - 1 ; while ( TLLhu > = 0 ) { foundData = render ( g2 , dataArea , TLLhu , state ) | | foundData ; TLLhu - - ; } } int eIXPA = 0 ; while ( eIXPA < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , eIXPA , Layer . FOREGROUND ) ; eIXPA + + ; } int H8FfR = 0 ; while ( H8FfR < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , H8FfR , Layer . FOREGROUND ) ; H8FfR + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int Ti7hA = 0 ; while ( Ti7hA < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , Ti7hA , Layer . BACKGROUND ) ; Ti7hA + + ; } int NkVwi = 0 ; while ( NkVwi < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , NkVwi , Layer . BACKGROUND ) ; NkVwi + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int byb7n = 0 ; while ( byb7n < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , byb7n , state ) | | foundData ; byb7n + + ; } } else { / / DatasetRenderingOrder . REVERSE int CA05w = this . datasets . size ( ) - 1 ; while ( CA05w > = 0 ) { foundData = render ( g2 , dataArea , CA05w , state ) | | foundData ; CA05w - - ; } } int V1IRV = 0 ; while ( V1IRV < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , V1IRV , Layer . FOREGROUND ) ; V1IRV + + ; } int URjhw = 0 ; while ( URjhw < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , URjhw , Layer . FOREGROUND ) ; URjhw + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int Ki6a1 = 0 ; while ( Ki6a1 < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , Ki6a1 , Layer . BACKGROUND ) ; Ki6a1 + + ; } int ibrHz = 0 ; while ( ibrHz < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , ibrHz , Layer . BACKGROUND ) ; ibrHz + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int mLnMh = 0 ; while ( mLnMh < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , mLnMh , state ) | | foundData ; mLnMh + + ; } } else { / / DatasetRenderingOrder . REVERSE int J07As = this . datasets . size ( ) - 1 ; while ( J07As > = 0 ) { foundData = render ( g2 , dataArea , J07As , state ) | | foundData ; J07As - - ; } } int Zfupq = 0 ; while ( Zfupq < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , Zfupq , Layer . FOREGROUND ) ; Zfupq + + ; } int TC6V2 = 0 ; while ( TC6V2 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , TC6V2 , Layer . FOREGROUND ) ; TC6V2 + + ; } / / draw the annotations ( if any ) . . .", "text_2": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , null ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int XpRUa = 0 ; while ( XpRUa < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , XpRUa , Layer . BACKGROUND ) ; XpRUa + + ; } int o4GlQ = 0 ; while ( o4GlQ < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , o4GlQ , Layer . BACKGROUND ) ; o4GlQ + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int CWdRb = 0 ; while ( CWdRb < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , CWdRb , state ) | | foundData ; CWdRb + + ; } } else { / / DatasetRenderingOrder . REVERSE int VQNuE = this . datasets . size ( ) - 1 ; while ( VQNuE > = 0 ) { foundData = render ( g2 , dataArea , VQNuE , state ) | | foundData ; VQNuE - - ; } } int RWHum = 0 ; while ( RWHum < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , RWHum , Layer . FOREGROUND ) ; RWHum + + ; } int U4Xd3 = 0 ; while ( U4Xd3 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , U4Xd3 , Layer . FOREGROUND ) ; U4Xd3 + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int XqC8h = 0 ; while ( XqC8h < seriesCount ) { if ( isSeriesVisibleInLegend ( XqC8h ) ) { LegendItem item = getLegendItem ( index , XqC8h ) ; if ( item ! = null ) { result . add ( item ) ; } } XqC8h + + ; } } else { int zOyT2 = seriesCount - 1 ; while ( zOyT2 > = 0 ) { if ( isSeriesVisibleInLegend ( zOyT2 ) ) { LegendItem item = getLegendItem ( index , zOyT2 ) ; if ( item ! = null ) { result . add ( item ) ; } } zOyT2 - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int CHZ0L = 0 ; while ( CHZ0L < seriesCount ) { if ( isSeriesVisibleInLegend ( CHZ0L ) ) { LegendItem item = getLegendItem ( index , CHZ0L ) ; if ( item ! = null ) { result . add ( item ) ; } } CHZ0L + + ; } } else { int hue9a = seriesCount - 1 ; while ( hue9a > = 0 ) { if ( isSeriesVisibleInLegend ( hue9a ) ) { LegendItem item = getLegendItem ( index , hue9a ) ; if ( item ! = null ) { result . add ( item ) ; } } hue9a - - ; } } return result ;", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int dIXqR = 0 ; while ( dIXqR < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( dIXqR ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( dIXqR ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; dIXqR + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int CigjA = 0 ; while ( CigjA < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( CigjA ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( CigjA ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , CigjA , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } CigjA + + ; } g2 . setClip ( savedClip ) ;", "text_2": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int oYAcy = 0 ; while ( oYAcy < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( oYAcy ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( oYAcy ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; oYAcy + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int pfYSq = 0 ; while ( pfYSq < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( pfYSq ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( pfYSq ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , pfYSq , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } pfYSq + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int iYxIp = 0 ; while ( iYxIp < seriesCount ) { if ( isSeriesVisibleInLegend ( iYxIp ) ) { LegendItem item = getLegendItem ( index , iYxIp ) ; if ( item ! = null ) { result . add ( item ) ; } } iYxIp + + ; } } else { int O84Qh = seriesCount - 1 ; while ( O84Qh > = 0 ) { if ( isSeriesVisibleInLegend ( O84Qh ) ) { LegendItem item = getLegendItem ( index , O84Qh ) ; if ( item ! = null ) { result . add ( item ) ; } } O84Qh - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int wbbr8 = 0 ; while ( wbbr8 < seriesCount ) { if ( isSeriesVisibleInLegend ( wbbr8 ) ) { LegendItem item = getLegendItem ( index , wbbr8 ) ; if ( item ! = null ) { result . add ( item ) ; } } wbbr8 + + ; } } else { int n1MYs = seriesCount - 1 ; while ( n1MYs > = 0 ) { if ( isSeriesVisibleInLegend ( n1MYs ) ) { LegendItem item = getLegendItem ( index , n1MYs ) ; if ( item ! = null ) { result . add ( item ) ; } } n1MYs - - ; } } return result ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Yer8L = 0 ; while ( Yer8L < seriesCount ) { if ( isSeriesVisibleInLegend ( Yer8L ) ) { LegendItem item = getLegendItem ( index , Yer8L ) ; if ( item ! = null ) { result . add ( item ) ; } } Yer8L + + ; } } else { int hIwn0 = seriesCount - 1 ; while ( hIwn0 > = 0 ) { if ( isSeriesVisibleInLegend ( hIwn0 ) ) { LegendItem item = getLegendItem ( index , hIwn0 ) ; if ( item ! = null ) { result . add ( item ) ; } } hIwn0 - - ; } } return result ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int dhoFC = 0 ; while ( dhoFC < seriesCount ) { if ( isSeriesVisibleInLegend ( dhoFC ) ) { LegendItem item = getLegendItem ( index , dhoFC ) ; if ( item ! = null ) { result . add ( item ) ; } } dhoFC + + ; } } else { int YzLK0 = seriesCount - 1 ; while ( YzLK0 > = 0 ) { if ( isSeriesVisibleInLegend ( YzLK0 ) ) { LegendItem item = getLegendItem ( index , YzLK0 ) ; if ( item ! = null ) { result . add ( item ) ; } } YzLK0 - - ; } } return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int SCspO = 0 ; while ( SCspO < seriesCount ) { if ( isSeriesVisibleInLegend ( SCspO ) ) { LegendItem item = getLegendItem ( index , SCspO ) ; if ( item ! = null ) { result . add ( item ) ; } } SCspO + + ; } } else { int LDW2w = seriesCount - 1 ; while ( LDW2w > = 0 ) { if ( isSeriesVisibleInLegend ( LDW2w ) ) { LegendItem item = getLegendItem ( index , LDW2w ) ; if ( item ! = null ) { result . add ( item ) ; } } LDW2w - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int vmLLP = 0 ; while ( vmLLP < seriesCount ) { if ( isSeriesVisibleInLegend ( vmLLP ) ) { LegendItem item = getLegendItem ( index , vmLLP ) ; if ( item ! = null ) { result . add ( item ) ; } } vmLLP + + ; } } else { int uEe49 = seriesCount - 1 ; while ( uEe49 > = 0 ) { if ( isSeriesVisibleInLegend ( uEe49 ) ) { LegendItem item = getLegendItem ( index , uEe49 ) ; if ( item ! = null ) { result . add ( item ) ; } } uEe49 - - ; } } return result ;", "text_3": 0}
{"text_1": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int aNtJD = 0 ; while ( aNtJD < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( aNtJD ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( aNtJD ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; aNtJD + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int p66cM = 0 ; while ( p66cM < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( p66cM ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( p66cM ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , p66cM , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } p66cM + + ; } g2 . setClip ( savedClip ) ;", "text_2": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ; int categoryCount = arcList . size ( ) ; int KzLyj = 0 ; while ( KzLyj < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( KzLyj ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( KzLyj ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ; KzLyj + + ; } g2 . setPaint ( Color . gray ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D upperArc ; int oEGOZ = 0 ; while ( oEGOZ < categoryCount ) { arc = ( Arc2D . Double ) arcList . get ( oEGOZ ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable currentKey = ( Comparable ) sectionKeys . get ( oEGOZ ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , oEGOZ , currentKey , tip , url ) ; entities . add ( entity ) ; } } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } oEGOZ + + ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object object ) { int ucCD7 = 0 ; while ( ucCD7 < this . size ) { if ( this . objects [ ucCD7 ] = = object ) { return ( ucCD7 ) ; } ucCD7 + + ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_2": "public class test { protected int indexOf ( Object object ) { int Bjt68 = 0 ; while ( Bjt68 < this . size ) { if ( this . objects [ Bjt68 ] = = object ) { return ( Bjt68 ) ; } Bjt68 + + ; } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( axis ! = null ) { axis . configure ( ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_3": 0}
{"text_1": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int ACaKY = 0 ; while ( ACaKY < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , ACaKY , Layer . BACKGROUND ) ; ACaKY + + ; } int OGE9O = 0 ; while ( OGE9O < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , OGE9O , Layer . BACKGROUND ) ; OGE9O + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int tmZQb = 0 ; while ( tmZQb < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , tmZQb , state ) | | foundData ; tmZQb + + ; } } else { / / DatasetRenderingOrder . REVERSE int BCSiR = this . datasets . size ( ) - 1 ; while ( BCSiR > = 0 ) { foundData = render ( g2 , dataArea , BCSiR , state ) | | foundData ; BCSiR - - ; } } int TVlsd = 0 ; while ( TVlsd < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , TVlsd , Layer . FOREGROUND ) ; TVlsd + + ; } int JBNkF = 0 ; while ( JBNkF < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , JBNkF , Layer . FOREGROUND ) ; JBNkF + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ; drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int aRp8w = 0 ; while ( aRp8w < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , aRp8w , Layer . BACKGROUND ) ; aRp8w + + ; } int TDWoB = 0 ; while ( TDWoB < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , TDWoB , Layer . BACKGROUND ) ; TDWoB + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int Tv6j3 = 0 ; while ( Tv6j3 < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , Tv6j3 , state ) | | foundData ; Tv6j3 + + ; } } else { / / DatasetRenderingOrder . REVERSE int tr5sT = this . datasets . size ( ) - 1 ; while ( tr5sT > = 0 ) { foundData = render ( g2 , dataArea , tr5sT , state ) | | foundData ; tr5sT - - ; } } int AqHHt = 0 ; while ( AqHHt < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , AqHHt , Layer . FOREGROUND ) ; AqHHt + + ; } int cpp10 = 0 ; while ( cpp10 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , cpp10 , Layer . FOREGROUND ) ; cpp10 + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int gmw9X = 0 ; while ( gmw9X < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , gmw9X , Layer . BACKGROUND ) ; gmw9X + + ; } int TTFy0 = 0 ; while ( TTFy0 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , TTFy0 , Layer . BACKGROUND ) ; TTFy0 + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int QmzKc = 0 ; while ( QmzKc < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , QmzKc , state ) | | foundData ; QmzKc + + ; } } else { / / DatasetRenderingOrder . REVERSE int BCtFR = this . datasets . size ( ) - 1 ; while ( BCtFR > = 0 ) { foundData = render ( g2 , dataArea , BCtFR , state ) | | foundData ; BCtFR - - ; } } int Kq8jH = 0 ; while ( Kq8jH < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , Kq8jH , Layer . FOREGROUND ) ; Kq8jH + + ; } int D6XP7 = 0 ; while ( D6XP7 < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , D6XP7 , Layer . FOREGROUND ) ; D6XP7 + + ; } / / draw the annotations ( if any ) . . .", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; } drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; } int QtDdN = 0 ; while ( QtDdN < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , QtDdN , Layer . BACKGROUND ) ; QtDdN + + ; } int Mvmwh = 0 ; while ( Mvmwh < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , Mvmwh , Layer . BACKGROUND ) ; Mvmwh + + ; } / / now render data items . . . DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) { int V4lmA = 0 ; while ( V4lmA < this . datasets . size ( ) ) { foundData = render ( g2 , dataArea , V4lmA , state ) | | foundData ; V4lmA + + ; } } else { / / DatasetRenderingOrder . REVERSE int bZx6j = this . datasets . size ( ) - 1 ; while ( bZx6j > = 0 ) { foundData = render ( g2 , dataArea , bZx6j , state ) | | foundData ; bZx6j - - ; } } int sOMkI = 0 ; while ( sOMkI < this . renderers . size ( ) ) { drawDomainMarkers ( g2 , dataArea , sOMkI , Layer . FOREGROUND ) ; sOMkI + + ; } int PVFmQ = 0 ; while ( PVFmQ < this . renderers . size ( ) ) { drawRangeMarkers ( g2 , dataArea , PVFmQ , Layer . FOREGROUND ) ; PVFmQ + + ; } / / draw the annotations ( if any ) . . .", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int Ugfn0 = 0 ; while ( Ugfn0 < seriesCount ) { if ( isSeriesVisibleInLegend ( Ugfn0 ) ) { LegendItem item = getLegendItem ( index , Ugfn0 ) ; if ( item ! = null ) { result . add ( item ) ; } } Ugfn0 + + ; } } else { int nCRjG = seriesCount - 1 ; while ( nCRjG > = 0 ) { if ( isSeriesVisibleInLegend ( nCRjG ) ) { LegendItem item = getLegendItem ( index , nCRjG ) ; if ( item ! = null ) { result . add ( item ) ; } } nCRjG - - ; } } return result ;", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int OdePN = 0 ; while ( OdePN < seriesCount ) { if ( isSeriesVisibleInLegend ( OdePN ) ) { LegendItem item = getLegendItem ( index , OdePN ) ; if ( item ! = null ) { result . add ( item ) ; } } OdePN + + ; } } else { int kjrTT = seriesCount - 1 ; while ( kjrTT > = 0 ) { if ( isSeriesVisibleInLegend ( kjrTT ) ) { LegendItem item = getLegendItem ( index , kjrTT ) ; if ( item ! = null ) { result . add ( item ) ; } } kjrTT - - ; } } return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int w8jX4 = 0 ; while ( w8jX4 < seriesCount ) { if ( isSeriesVisibleInLegend ( w8jX4 ) ) { LegendItem item = getLegendItem ( index , w8jX4 ) ; if ( item ! = null ) { result . add ( item ) ; } } w8jX4 + + ; } } else { int EeyXN = seriesCount - 1 ; while ( EeyXN > = 0 ) { if ( isSeriesVisibleInLegend ( EeyXN ) ) { LegendItem item = getLegendItem ( index , EeyXN ) ; if ( item ! = null ) { result . add ( item ) ; } } EeyXN - - ; } } return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { int H41ED = 0 ; while ( H41ED < seriesCount ) { if ( isSeriesVisibleInLegend ( H41ED ) ) { LegendItem item = getLegendItem ( index , H41ED ) ; if ( item ! = null ) { result . add ( item ) ; } } H41ED + + ; } } else { int nc1OL = seriesCount - 1 ; while ( nc1OL > = 0 ) { if ( isSeriesVisibleInLegend ( nc1OL ) ) { LegendItem item = getLegendItem ( index , nc1OL ) ; if ( item ! = null ) { result . add ( item ) ; } } nc1OL - - ; } } return result ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean v1yj67kC = label = = null ; if ( ( v1yj67kC ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double rtljgpv3 = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - rtljgpv3 ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float ifBzkJcl = w / 2 . 0f ; float T5RDCqhU = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - ifBzkJcl , labely - T5RDCqhU , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double S4rsBdSv = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + S4rsBdSv ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float Rmef8OTv = w / 2 . 0f ; float UOrifIjI = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - Rmef8OTv , labely - UOrifIjI , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double YvnBiLa2 = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - YvnBiLa2 , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double O84HSvVe = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - O84HSvVe ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double d45RePgB = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - d45RePgB , TextAnchor . CENTER ) ; float DOkQQE8W = w / 2 . 0f ; float iVvE3Tjq = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - DOkQQE8W , labely - iVvE3Tjq , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double KbOersIk = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + KbOersIk , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double BtwRNwMT = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + BtwRNwMT ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double Ac7muf3X = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + Ac7muf3X , TextAnchor . CENTER ) ; float GS0yW3dS = w / 2 . 0f ; float aidPd8up = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - GS0yW3dS , labely - aidPd8up , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean wMZd48yX = label = = null ; if ( ( wMZd48yX ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double F8XIxnpr = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - F8XIxnpr ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float MXLRBFWx = w / 2 . 0f ; float iKLDABBU = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - MXLRBFWx , labely - iKLDABBU , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double SuSVi2S8 = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + SuSVi2S8 ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float T1UEmJmw = w / 2 . 0f ; float tN1bCKCf = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - T1UEmJmw , labely - tN1bCKCf , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double T9PpDu7x = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - T9PpDu7x , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double Btk3ZbZ4 = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - Btk3ZbZ4 ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double LnDdeF8a = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - LnDdeF8a , TextAnchor . CENTER ) ; float zHaKzhHU = w / 2 . 0f ; float phnH6Bem = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - zHaKzhHU , labely - phnH6Bem , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double BdNBciNl = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + BdNBciNl , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double vmj6DBcX = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + vmj6DBcX ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double EeDNBkqd = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + EeDNBkqd , TextAnchor . CENTER ) ; float GNL5POGv = w / 2 . 0f ; float OCesUoD4 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - GNL5POGv , labely - OCesUoD4 , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean k5bzmRQe = label = = null ; if ( ( k5bzmRQe ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double V7I0h9qq = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - V7I0h9qq ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float xguiY1r4 = w / 2 . 0f ; float y6nOrV32 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - xguiY1r4 , labely - y6nOrV32 , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double G0tpsTMD = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + G0tpsTMD ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float k5eGuAuH = w / 2 . 0f ; float Ts17t2Ng = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - k5eGuAuH , labely - Ts17t2Ng , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double FnnCPOMh = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - FnnCPOMh , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double Z50mwWaR = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - Z50mwWaR ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double PY15L6iy = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - PY15L6iy , TextAnchor . CENTER ) ; float ogCh6SED = w / 2 . 0f ; float iozv82uy = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - ogCh6SED , labely - iozv82uy , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double DFC841dY = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + DFC841dY , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double z9w3CXYT = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + z9w3CXYT ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double aEeSNYyD = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + aEeSNYyD , TextAnchor . CENTER ) ; float JSO3inQc = w / 2 . 0f ; float fTKop5CD = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - JSO3inQc , labely - fTKop5CD , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean yBt4ch6K = label = = null ; if ( ( yBt4ch6K ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double rsCOazLR = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - rsCOazLR ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float pd19Srfy = w / 2 . 0f ; float zn3j7gvM = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - pd19Srfy , labely - zn3j7gvM , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double fMRuiqQi = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + fMRuiqQi ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float v16JFcWi = w / 2 . 0f ; float kFTCs82P = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - v16JFcWi , labely - kFTCs82P , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double aj7hJ5TF = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - aj7hJ5TF , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double aBx31DUH = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - aBx31DUH ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double ujHrSgKo = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - ujHrSgKo , TextAnchor . CENTER ) ; float JKWSN18l = w / 2 . 0f ; float izFX8gaJ = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - JKWSN18l , labely - izFX8gaJ , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double ew4kHavd = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + ew4kHavd , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double O8Abazvu = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + O8Abazvu ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double ztgghVVi = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + ztgghVVi , TextAnchor . CENTER ) ; float tWCJlqQU = w / 2 . 0f ; float LLZvYnX3 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - tWCJlqQU , labely - LLZvYnX3 , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "text_3": 1}
{"text_1": "this . startData = starts ; this . endData = ends ; boolean VsoWS3L5 = starts ! = null ; if ( VsoWS3L5 & & ends ! = null ) { String baseName = \" org . jfree . data . resources . DataPackageResources \" ; ResourceBundle resources = ResourceBundle . getBundle ( baseName ) ; } else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_2": "this . startData = starts ; this . endData = ends ; boolean fUJnKzxT = starts ! = null ; if ( fUJnKzxT & & ends ! = null ) { String baseName = \" org . jfree . data . resources . DataPackageResources \" ; ResourceBundle resources = ResourceBundle . getBundle ( baseName ) ; } else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_3": 1}
{"text_1": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long wDTtKkwg = ( end - start ) / 2 ; long O1oDUj9A = end - start ; long middle = start + ( wDTtKkwg ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long nt74EgWx = ( e - s ) / 2 ; long Mdng3HtW = e - s ; long minMiddle = s + nt74EgWx ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long YbiNhqiz = ( e - s ) / 2 ; long hPFY9z7W = e - s ; long maxMiddle = s + YbiNhqiz ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_2": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long e4toOLgq = ( end - start ) / 2 ; long P4SnqPtZ = end - start ; long middle = start + ( e4toOLgq ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long D0bhcN62 = ( e - s ) / 2 ; long M84bh6RH = e - s ; long minMiddle = s + D0bhcN62 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long m5d2LGix = ( e - s ) / 2 ; long VKLjguKi = e - s ; long maxMiddle = s + m5d2LGix ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_3": 1}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean YzBw2SWD = index > = 0 ; if ( YzBw2SWD & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean d0lZEung = index > = 0 ; if ( d0lZEung & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean UENCbjoY = label = = null ; if ( ( UENCbjoY ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double twQkYxYw = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - twQkYxYw ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float XPZBJjVa = w / 2 . 0f ; float acgqtiER = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - XPZBJjVa , labely - acgqtiER , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double Bc6L4hlH = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + Bc6L4hlH ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float BRbKSrau = w / 2 . 0f ; float ze7RcIxc = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - BRbKSrau , labely - ze7RcIxc , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double GfxayuBx = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - GfxayuBx , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double gGexTr9X = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - gGexTr9X ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double BTRdGovH = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - BTRdGovH , TextAnchor . CENTER ) ; float bozrKrqg = w / 2 . 0f ; float Tg2T1gp5 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - bozrKrqg , labely - Tg2T1gp5 , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double eKCMTPfa = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + eKCMTPfa , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double x7D5bax1 = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + x7D5bax1 ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double gtuQhmwL = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + gtuQhmwL , TextAnchor . CENTER ) ; float kXuoRhZP = w / 2 . 0f ; float GVyiOiUK = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - kXuoRhZP , labely - GVyiOiUK , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean qHtDOJq7 = label = = null ; if ( ( qHtDOJq7 ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double TYV23zlQ = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - TYV23zlQ ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float Webt4do9 = w / 2 . 0f ; float gqoXLaOj = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - Webt4do9 , labely - gqoXLaOj , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double cuLqgiDt = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + cuLqgiDt ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float yacCQcE3 = w / 2 . 0f ; float KEH5cg9Z = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - yacCQcE3 , labely - KEH5cg9Z , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double B50EjvsB = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - B50EjvsB , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double wqv4gFi8 = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - wqv4gFi8 ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double vX0srJSK = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - vX0srJSK , TextAnchor . CENTER ) ; float sYJcJAmz = w / 2 . 0f ; float u2WrLDKH = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - sYJcJAmz , labely - u2WrLDKH , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double bThcTUeZ = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + bThcTUeZ , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double juzN35y5 = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + juzN35y5 ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double giJ519oh = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + giJ519oh , TextAnchor . CENTER ) ; float xVqmCn5Z = w / 2 . 0f ; float Ph5Z7shz = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - xVqmCn5Z , labely - Ph5Z7shz , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean MWxSEFka = label = = null ; if ( ( MWxSEFka ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double rQ7rWedp = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - rQ7rWedp ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float qqqCRrL5 = w / 2 . 0f ; float BdNzhtDE = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - qqqCRrL5 , labely - BdNzhtDE , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double IkNQibEg = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + IkNQibEg ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float npJ4Xd8F = w / 2 . 0f ; float Mnehex2g = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - npJ4Xd8F , labely - Mnehex2g , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double PBm3EYwz = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - PBm3EYwz , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double InNA1Sqw = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - InNA1Sqw ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double JDOnKMva = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - JDOnKMva , TextAnchor . CENTER ) ; float MhcGK8s4 = w / 2 . 0f ; float StDpT9UR = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - MhcGK8s4 , labely - StDpT9UR , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double QylbluR6 = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + QylbluR6 , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double ZuW6hn5u = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + ZuW6hn5u ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double Ui2ACHyH = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + Ui2ACHyH , TextAnchor . CENTER ) ; float LalAxM3t = w / 2 . 0f ; float yvoaiFd7 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - LalAxM3t , labely - yvoaiFd7 , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean x3eo2QJg = label = = null ; if ( ( x3eo2QJg ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double hlp5MuoB = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - hlp5MuoB ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float C7uJOVpQ = w / 2 . 0f ; float EG0CJChp = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - C7uJOVpQ , labely - EG0CJChp , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double OgYghiMO = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + OgYghiMO ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float dposoQaP = w / 2 . 0f ; float Fkh1Ft9X = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - dposoQaP , labely - Fkh1Ft9X , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double VhbYUEEE = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - VhbYUEEE , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double Xjf6x5UL = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - Xjf6x5UL ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double cSfw7a4E = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - cSfw7a4E , TextAnchor . CENTER ) ; float Wx6r4Nqd = w / 2 . 0f ; float x3CVFmWT = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - Wx6r4Nqd , labely - x3CVFmWT , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double dEXjFeN0 = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + dEXjFeN0 , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double WhM035R6 = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + WhM035R6 ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double hRUUHGqV = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + hRUUHGqV , TextAnchor . CENTER ) ; float lZgIBZEJ = w / 2 . 0f ; float IhHQJRVy = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - lZgIBZEJ , labely - IhHQJRVy , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_3": 1}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean pxX8FpUb = index > = 0 ; if ( pxX8FpUb & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean bjxDItX4 = index > = 0 ; if ( bjxDItX4 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 1}
{"text_1": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int kRvK0sp1 = categoryCount * ( seriesCount - 1 ) ; int GEO48oiq = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( kRvK0sp1 ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; / / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; }  Line2D line = null ; double YEeHfMtY = rectHeight / 2 . 0d ; double gwTcGLXN = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + YEeHfMtY , highVal , rectY + gwTcGLXN ) ; g2 . draw ( line ) ; double WrUsp4Lv = rectHeight * 0 . 25 ; double IX5kFfoU = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + WrUsp4Lv , highVal , rectY + IX5kFfoU ) ; g2 . draw ( line ) ; double w8CBQ5eI = rectHeight * 0 . 25 ; double nwT09VIv = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + w8CBQ5eI , lowVal , rectY + nwT09VIv ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int jnizJaXu = categoryCount * ( seriesCount - 1 ) ; int Ixhu86eN = seriesCount - 1 ; double seriesGap = dataArea . getWidth ( ) * getItemMargin ( ) / ( jnizJaXu ) ; rectX = rectX + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectX = rectX + row * state . getBarWidth ( ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; double kwc3mJso = rectWidth / 2 . 0d ; double cyeEuUe4 = rectWidth / 2 . 0d ; line = new Line2D . Double ( rectX + kwc3mJso , lowVal , rectX + cyeEuUe4 , highVal ) ; g2 . draw ( line ) ; double qZ1xLvpN = rectX + rectWidth / 2 . 0d ; double Ww4vKuxx = rectWidth / 2 . 0d ; double xPa5eV3f = rectX + rectWidth / 2 . 0d ; double fSy1C47S = rectWidth / 2 . 0d ; line = new Line2D . Double ( qZ1xLvpN - 5 . 0d , highVal , xPa5eV3f + 5 . 0d , highVal ) ; g2 . draw ( line ) ; double voJiTLRo = rectX + rectWidth / 2 . 0d ; double wG1FHJJe = rectWidth / 2 . 0d ; double eQdqXzAk = rectX + rectWidth / 2 . 0d ; double GaoE3f6w = rectWidth / 2 . 0d ; line = new Line2D . Double ( voJiTLRo - 5 . 0d , lowVal , eQdqXzAk + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_2": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int Ibawehq1 = categoryCount * ( seriesCount - 1 ) ; int jRBbiHmv = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( Ibawehq1 ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; / / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; double JH6XmyLl = rectHeight / 2 . 0d ; double FQN4wx7k = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + JH6XmyLl , highVal , rectY + FQN4wx7k ) ; g2 . draw ( line ) ; double X3aLbBC7 = rectHeight * 0 . 25 ; double xVNjwdWh = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + X3aLbBC7 , highVal , rectY + xVNjwdWh ) ; g2 . draw ( line ) ; double h0kYoIRj = rectHeight * 0 . 25 ; double f7OKu2cu = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + h0kYoIRj , lowVal , rectY + f7OKu2cu ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int mOLqdmeR = categoryCount * ( seriesCount - 1 ) ; int PdqeIMbD = seriesCount - 1 ; double seriesGap = dataArea . getWidth ( ) * getItemMargin ( ) / ( mOLqdmeR ) ; rectX = rectX + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectX = rectX + row * state . getBarWidth ( ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; double kWRtD3ua = rectWidth / 2 . 0d ; double cPnLYfAJ = rectWidth / 2 . 0d ; line = new Line2D . Double ( rectX + kWRtD3ua , lowVal , rectX + cPnLYfAJ , highVal ) ; g2 . draw ( line ) ; double oQ21Z2oH = rectX + rectWidth / 2 . 0d ; double ndZGBNBj = rectWidth / 2 . 0d ; double FgCg6Uoq = rectX + rectWidth / 2 . 0d ; double HsUnqGuR = rectWidth / 2 . 0d ; line = new Line2D . Double ( oQ21Z2oH - 5 . 0d , highVal , FgCg6Uoq + 5 . 0d , highVal ) ; g2 . draw ( line ) ; double qt7GEUEI = rectX + rectWidth / 2 . 0d ; double RkVJNr8x = rectWidth / 2 . 0d ; double Z0UGwnfH = rectX + rectWidth / 2 . 0d ; double pUFtze2J = rectWidth / 2 . 0d ; line = new Line2D . Double ( qt7GEUEI - 5 . 0d , lowVal , Z0UGwnfH + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean pqUutitA = label = = null ; if ( ( pqUutitA ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double fQbWDKEG = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - fQbWDKEG ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float c6b0WVY9 = w / 2 . 0f ; float yqggk9De = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - c6b0WVY9 , labely - yqggk9De , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double U1UUI341 = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + U1UUI341 ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float L8Sab13o = w / 2 . 0f ; float zQmSypP4 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - L8Sab13o , labely - zQmSypP4 , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double V2Q9iQsg = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - V2Q9iQsg , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double oZ497KSp = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - oZ497KSp ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double b7waSWOy = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - b7waSWOy , TextAnchor . CENTER ) ; float vR4hqAe0 = w / 2 . 0f ; float RgboZGOd = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - vR4hqAe0 , labely - RgboZGOd , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double MB98oPIT = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + MB98oPIT , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double zzRi7LEm = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + zzRi7LEm ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double af56rf6q = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + af56rf6q , TextAnchor . CENTER ) ; float oTiNqNq1 = w / 2 . 0f ; float JtwPxuHa = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - oTiNqNq1 , labely - JtwPxuHa , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean OYacKyY4 = label = = null ; if ( ( OYacKyY4 ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double Iycc7nUH = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - Iycc7nUH ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float QZlTrBzh = w / 2 . 0f ; float WeOa0WBJ = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - QZlTrBzh , labely - WeOa0WBJ , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double kcdV76hh = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + kcdV76hh ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float xS8N1FA7 = w / 2 . 0f ; float dD3eN6Ud = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - xS8N1FA7 , labely - dD3eN6Ud , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double QAUL1ufi = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - QAUL1ufi , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double vs47zPMH = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - vs47zPMH ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double AcX7WtOv = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - AcX7WtOv , TextAnchor . CENTER ) ; float Ptvw5oaZ = w / 2 . 0f ; float wpZU8SXe = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - Ptvw5oaZ , labely - wpZU8SXe , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double LvZr1xGf = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + LvZr1xGf , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double Os0bpefG = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + Os0bpefG ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double HAFTm5Un = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + HAFTm5Un , TextAnchor . CENTER ) ; float rMBt7HJT = w / 2 . 0f ; float E0wuAjE3 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - rMBt7HJT , labely - E0wuAjE3 , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean VOAgz0pD = label = = null ; if ( ( VOAgz0pD ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double tOogkwLd = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - tOogkwLd ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float lvVym5kA = w / 2 . 0f ; float qaFj6QCm = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - lvVym5kA , labely - qaFj6QCm , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double ZefomWD4 = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + ZefomWD4 ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float JDiUHoGb = w / 2 . 0f ; float GpLA8RKH = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - JDiUHoGb , labely - GpLA8RKH , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double GcYGUsKc = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - GcYGUsKc , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double IJB4prgb = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - IJB4prgb ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double SOr4CjtY = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - SOr4CjtY , TextAnchor . CENTER ) ; float drfxN8yu = w / 2 . 0f ; float Yxffeu0V = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - drfxN8yu , labely - Yxffeu0V , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double oOoIBsKW = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + oOoIBsKW , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double vyhpP1Qn = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + vyhpP1Qn ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double liqIzVxp = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + liqIzVxp , TextAnchor . CENTER ) ; float kJljOJJV = w / 2 . 0f ; float uqbBDtcZ = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - kJljOJJV , labely - uqbBDtcZ , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean pMznMqRq = label = = null ; if ( ( pMznMqRq ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double xPB8S9KN = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - xPB8S9KN ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float h9bxz9hu = w / 2 . 0f ; float rR9S8yVd = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - h9bxz9hu , labely - rR9S8yVd , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double gfckNRJ9 = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + gfckNRJ9 ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float bgP5FlPj = w / 2 . 0f ; float TLcmVL92 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - bgP5FlPj , labely - TLcmVL92 , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double n6XKAuPs = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - n6XKAuPs , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double WqoynDFY = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - WqoynDFY ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double a9j3p2If = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - a9j3p2If , TextAnchor . CENTER ) ; float fC80zsY2 = w / 2 . 0f ; float b2c4ItOI = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - fC80zsY2 , labely - b2c4ItOI , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double REikA7PO = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + REikA7PO , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double K12fSnUu = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + K12fSnUu ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double hMnWhCZY = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + hMnWhCZY , TextAnchor . CENTER ) ; float V2JmpcDi = w / 2 . 0f ; float J0f1lL6d = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - V2JmpcDi , labely - J0f1lL6d , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean sv81ZHJd = index > = 0 ; if ( sv81ZHJd & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean NoF5LBda = index > = 0 ; if ( NoF5LBda & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double WwgfZg5G = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( WwgfZg5G ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double s5uqlPdR = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + s5uqlPdR ; double RJ023uE9 = gapVertical / 2 ; double linkY = plotArea . getY ( ) + RJ023uE9 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double D53DEVum = ( linkX + linkX + linkW ) / 2 ; double egfbW7iv = linkX + linkX + linkW ; linkX = D53DEVum - min ; double RpDqL5fY = ( linkY + linkY + linkH ) / 2 ; double k9kDg3br = linkY + linkY + linkH ; linkY = RpDqL5fY - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double IF2pZo8Y = hh / 2 . 0 ; double fUjrjEd4 = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + IF2pZo8Y , linkY + fUjrjEd4 , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double NrndBPqn = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( NrndBPqn ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double BnpSpbmc = h1 / 2 . 0 ; double cfRUtFpK = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + BnpSpbmc , explodeArea . getY ( ) + cfRUtFpK , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double r1HvJs2p = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - r1HvJs2p ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double WLddoYwP = ( direction * ( runningTotal * 360 ) ) / totalValue ; double lDgfeoGn = direction * ( runningTotal * 360 ) ; double ejRozAms = runningTotal * 360 ; double angle1 = startAngle + WLddoYwP ; double eAm7kb9C = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double dPpMkxNI = direction * ( runningTotal + value ) * 360 ; double uE7pS55y = runningTotal + value ; double angle2 = startAngle + eAm7kb9C ; double nSkLnvAV = angle2 - angle1 ; if ( Math . abs ( nSkLnvAV ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double FwrKkezA = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( FwrKkezA ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double dUiP91Sy = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + dUiP91Sy ; double IDYVXBQV = gapVertical / 2 ; double linkY = plotArea . getY ( ) + IDYVXBQV ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double QRAis7xV = ( linkX + linkX + linkW ) / 2 ; double xFpFqHNV = linkX + linkX + linkW ; linkX = QRAis7xV - min ; double rcixSKP3 = ( linkY + linkY + linkH ) / 2 ; double x3MV2DDO = linkY + linkY + linkH ; linkY = rcixSKP3 - min ; linkW = 2 * min ; linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double Md8xoVHU = hh / 2 . 0 ; double MUWy1Ne3 = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + Md8xoVHU , linkY + MUWy1Ne3 , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double w9qcYdD1 = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( w9qcYdD1 ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double y3l057lt = h1 / 2 . 0 ; double x51jrHKy = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + y3l057lt , explodeArea . getY ( ) + x51jrHKy , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double tw0o6dPf = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - tw0o6dPf ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double bx5hKd3d = ( direction * ( runningTotal * 360 ) ) / totalValue ; double iUbpBnmk = direction * ( runningTotal * 360 ) ; double EE6nAgLf = runningTotal * 360 ; double angle1 = startAngle + bx5hKd3d ; double knd9vEV6 = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double z83IuUjR = direction * ( runningTotal + value ) * 360 ; double EWvkTOEE = runningTotal + value ; double angle2 = startAngle + knd9vEV6 ; double LGGlP6WC = angle2 - angle1 ; if ( Math . abs ( LGGlP6WC ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean IZ85So73 = index > = 0 ; if ( IZ85So73 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean ElqYQJ2G = index > = 0 ; if ( ElqYQJ2G & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double M0WnX6Xk = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( M0WnX6Xk ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double CxTQuJzb = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( CxTQuJzb ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double tJuSHW2A = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( tJuSHW2A ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double omFMEBOF = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( omFMEBOF ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_3": 0}
{"text_1": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int QjQso0t1 = categoryCount * ( seriesCount - 1 ) ; int Uf9yqDTj = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( QjQso0t1 ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double vAjr5g8H = rectHeight / 2 . 0d ; double B26Dj15O = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + vAjr5g8H , highVal , rectY + B26Dj15O ) ; g2 . draw ( line ) ; double WsxBsP2Z = rectHeight * 0 . 25 ; double OLvQLiKd = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + WsxBsP2Z , highVal , rectY + OLvQLiKd ) ; g2 . draw ( line ) ; double UyzvxMX1 = rectHeight * 0 . 25 ; double j1uQNUPM = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + UyzvxMX1 , lowVal , rectY + j1uQNUPM ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_2": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int U0Vinpdi = categoryCount * ( seriesCount - 1 ) ; int qSdjgVLQ = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( U0Vinpdi ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double oPsogqx6 = rectHeight / 2 . 0d ; double Ea3dg4eg = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + oPsogqx6 , highVal , rectY + Ea3dg4eg ) ; g2 . draw ( line ) ; double rklxU2oJ = rectHeight * 0 . 25 ; double aUiRZmrc = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + rklxU2oJ , highVal , rectY + aUiRZmrc ) ; g2 . draw ( line ) ; double D3Qw0PT1 = rectHeight * 0 . 25 ; double vCzWXFLe = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + D3Qw0PT1 , lowVal , rectY + vCzWXFLe ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_3": 0}
{"text_1": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long EVr6i9H4 = ( end - start ) / 2 ; long Goeh38Db = end - start ; long middle = start + ( EVr6i9H4 ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long tzpn3zQs = ( e - s ) / 2 ; long DRu4azUx = e - s ; long minMiddle = s + tzpn3zQs ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long OIj7PwBq = ( e - s ) / 2 ; long KNlU3asp = e - s ; long maxMiddle = s + OIj7PwBq ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_2": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long reDGlNSK = ( end - start ) / 2 ; long eeDOzfqv = end - start ; long middle = start + ( reDGlNSK ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long SdOHYa1d = ( e - s ) / 2 ; long Qn5C4yJP = e - s ; long minMiddle = s + SdOHYa1d ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long N5kekJF3 = ( e - s ) / 2 ; long kGHfpkki = e - s ; long maxMiddle = s + N5kekJF3 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean hq3lvldm = index > = 0 ; if ( hq3lvldm & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean QU9NaHpx = index > = 0 ; if ( QU9NaHpx & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double fmrDWMif = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( fmrDWMif ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double hznIROAT = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + hznIROAT ; double XwlsR9qx = gapVertical / 2 ; double linkY = plotArea . getY ( ) + XwlsR9qx ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double RjidpDl5 = ( linkX + linkX + linkW ) / 2 ; double kTNxwilW = linkX + linkX + linkW ; linkX = RjidpDl5 - min ; double HOzbxi9o = ( linkY + linkY + linkH ) / 2 ; double mluUOCZf = linkY + linkY + linkH ; linkY = HOzbxi9o - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double UcG9sh8a = hh / 2 . 0 ; double a16LoIpu = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + UcG9sh8a , linkY + a16LoIpu , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double L3tr7wf0 = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( L3tr7wf0 ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double DUVuXCot = h1 / 2 . 0 ; double swBudoG5 = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + DUVuXCot , explodeArea . getY ( ) + swBudoG5 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double HyW9FAYi = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - HyW9FAYi ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double BlEOq1EG = ( direction * ( runningTotal * 360 ) ) / totalValue ; double b6VPPnmH = direction * ( runningTotal * 360 ) ; double OgmsLodj = runningTotal * 360 ; double angle1 = startAngle + BlEOq1EG ; double flEtmCUb = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double x8twv1CR = direction * ( runningTotal + value ) * 360 ; double B5HTDks2 = runningTotal + value ; double angle2 = startAngle + flEtmCUb ; double QarGB37k = angle2 - angle1 ; if ( Math . abs ( QarGB37k ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double ZVhO0fwk = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( ZVhO0fwk ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double nmV9I8MM = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + nmV9I8MM ; double LawRoeTd = gapVertical / 2 ; double linkY = plotArea . getY ( ) + LawRoeTd ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double nAAiHeov = ( linkX + linkX + linkW ) / 2 ; double Z0pHi7na = linkX + linkX + linkW ; linkX = nAAiHeov - min ; double djC5PB9f = ( linkY + linkY + linkH ) / 2 ; double ZaJEReJh = linkY + linkY + linkH ; linkY = djC5PB9f - min ; linkW = 2 * min ; linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double nNFsnaVA = hh / 2 . 0 ; double bGGmXk3W = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + nNFsnaVA , linkY + bGGmXk3W , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double WfrKTKA0 = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( WfrKTKA0 ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double bPDX2rPN = h1 / 2 . 0 ; double y4TqqbTK = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + bPDX2rPN , explodeArea . getY ( ) + y4TqqbTK , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double y2R2rIeW = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - y2R2rIeW ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double aFkBpqrW = ( direction * ( runningTotal * 360 ) ) / totalValue ; double j6cnYmJD = direction * ( runningTotal * 360 ) ; double xpbMh3xU = runningTotal * 360 ; double angle1 = startAngle + aFkBpqrW ; double slgJDYZ2 = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double njR6xsA5 = direction * ( runningTotal + value ) * 360 ; double oZlnKBvM = runningTotal + value ; double angle2 = startAngle + slgJDYZ2 ; double derA75LS = angle2 - angle1 ; if ( Math . abs ( derA75LS ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean SOVJ7ZUR = index > = 0 ; if ( SOVJ7ZUR & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean vuuJnZHQ = index > = 0 ; if ( vuuJnZHQ & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double mH4K3CvU = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( mH4K3CvU ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double AL7EkgLH = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + AL7EkgLH ; double OxED0N92 = gapVertical / 2 ; double linkY = plotArea . getY ( ) + OxED0N92 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double p2YTZsJC = ( linkX + linkX + linkW ) / 2 ; double VjPW4WyL = linkX + linkX + linkW ; linkX = p2YTZsJC - min ; double dwzSEbI0 = ( linkY + linkY + linkH ) / 2 ; double RM8Orho1 = linkY + linkY + linkH ; linkY = dwzSEbI0 - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double AcmdINlc = hh / 2 . 0 ; double ziRC1cNL = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + AcmdINlc , linkY + ziRC1cNL , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double UvYbiybX = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( UvYbiybX ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double qu0ca3lK = h1 / 2 . 0 ; double QSq7teD7 = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + qu0ca3lK , explodeArea . getY ( ) + QSq7teD7 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double zbHwZWpz = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - zbHwZWpz ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double BKzPKCSa = ( direction * ( runningTotal * 360 ) ) / totalValue ; double TZs2A6dq = direction * ( runningTotal * 360 ) ; double SwH3D5l2 = runningTotal * 360 ; double angle1 = startAngle + BKzPKCSa ; double RLDPbxIz = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double b8cYESEs = direction * ( runningTotal + value ) * 360 ; double E0nWBOkn = runningTotal + value ; double angle2 = startAngle + RLDPbxIz ; double dKUyEu3g = angle2 - angle1 ; if ( Math . abs ( dKUyEu3g ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double O6AZoRGs = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( O6AZoRGs ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double szYvWWOb = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + szYvWWOb ; double AmN3FqNP = gapVertical / 2 ; double linkY = plotArea . getY ( ) + AmN3FqNP ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double h7ZH0OLH = ( linkX + linkX + linkW ) / 2 ; double qKzG29yV = linkX + linkX + linkW ; linkX = h7ZH0OLH - min ; double GQtEjfbn = ( linkY + linkY + linkH ) / 2 ; double St3vbUvR = linkY + linkY + linkH ; linkY = GQtEjfbn - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double j9fUylxx = hh / 2 . 0 ; double SPByrZ8t = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + j9fUylxx , linkY + SPByrZ8t , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double hEIh294a = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( hEIh294a ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double qH0qMQh5 = h1 / 2 . 0 ; double CJYHOwSN = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + qH0qMQh5 , explodeArea . getY ( ) + CJYHOwSN , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double utdyO4ji = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - utdyO4ji ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double Vgy5LIH2 = ( direction * ( runningTotal * 360 ) ) / totalValue ; double gUjWgB99 = direction * ( runningTotal * 360 ) ; double kl6Azywl = runningTotal * 360 ; double angle1 = startAngle + Vgy5LIH2 ; double voKTVTB3 = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double t27tHAU2 = direction * ( runningTotal + value ) * 360 ; double qnQUd0e2 = runningTotal + value ; double angle2 = startAngle + voKTVTB3 ; double qUpKoZOq = angle2 - angle1 ; if ( Math . abs ( qUpKoZOq ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int c2mT8Twe = categoryCount * ( seriesCount - 1 ) ; int C7ElRh7M = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( c2mT8Twe ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } Line2D line = null ; double gfNEGr0c = rectHeight / 2 . 0d ; double jJ8K2Io7 = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + gfNEGr0c , highVal , rectY + jJ8K2Io7 ) ; g2 . draw ( line ) ; double S8mU4d7X = rectHeight * 0 . 25 ; double VylwbPdM = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + S8mU4d7X , highVal , rectY + VylwbPdM ) ; g2 . draw ( line ) ; double m4kCbn6V = rectHeight * 0 . 25 ; double QCjyt9UU = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + m4kCbn6V , lowVal , rectY + QCjyt9UU ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int ykdOEf0H = categoryCount * ( seriesCount - 1 ) ; int L9lLis46 = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( ykdOEf0H ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } Line2D line = null ; double bxjTUUkC = rectHeight / 2 . 0d ; double I3WU5rB8 = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + bxjTUUkC , highVal , rectY + I3WU5rB8 ) ; g2 . draw ( line ) ; double uT1V59Ff = rectHeight * 0 . 25 ; double h6RlHjlw = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + uT1V59Ff , highVal , rectY + h6RlHjlw ) ; g2 . draw ( line ) ; double PG3tZo88 = rectHeight * 0 . 25 ; double hGchNYVC = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + PG3tZo88 , lowVal , rectY + hGchNYVC ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long skrgvnab = ( end - start ) / 2 ; long agJcSzxN = end - start ; long middle = start + ( skrgvnab ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long uQO30YPt = ( e - s ) / 2 ; long quTWLEgh = e - s ; long minMiddle = s + uQO30YPt ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long E7SqIrGZ = ( e - s ) / 2 ; long N2FGLGe2 = e - s ; long maxMiddle = s + E7SqIrGZ ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_2": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long DbhTeTTH = ( end - start ) / 2 ; long LiVgEyAI = end - start ; long middle = start + ( DbhTeTTH ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long tw0tAOOi = ( e - s ) / 2 ; long JO0pz7QF = e - s ; long minMiddle = s + tw0tAOOi ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long NeR0gezU = ( e - s ) / 2 ; long cIlcxYye = e - s ; long maxMiddle = s + NeR0gezU ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; }", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean ELAFmtVm = index > = 0 ; if ( ELAFmtVm & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean R5sA4d0d = index > = 0 ; if ( R5sA4d0d & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double ixFLp6dJ = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( ixFLp6dJ ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double lpsbBfT7 = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( lpsbBfT7 ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double AKpNRUMb = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( AKpNRUMb ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double u0OihoNC = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( u0OihoNC ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double S0ROaxC0 = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( S0ROaxC0 ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double Ysa4a37f = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + Ysa4a37f ; double mNcbpQgS = gapVertical / 2 ; double linkY = plotArea . getY ( ) + mNcbpQgS ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double MC4HCIcQ = ( linkX + linkX + linkW ) / 2 ; double SKAm75JF = linkX + linkX + linkW ; linkX = MC4HCIcQ - min ; double MjZvikNV = ( linkY + linkY + linkH ) / 2 ; double eEWbroxf = linkY + linkY + linkH ; linkY = MjZvikNV - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double BLKIXUZ1 = hh / 2 . 0 ; double FXpEizLV = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + BLKIXUZ1 , linkY + FXpEizLV , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double p4vMPX9T = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( p4vMPX9T ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double bK9s7mww = h1 / 2 . 0 ; double GNeKZHvh = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + bK9s7mww , explodeArea . getY ( ) + GNeKZHvh , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double ZeOgmQbP = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - ZeOgmQbP ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double KsJVV923 = ( direction * ( runningTotal * 360 ) ) / totalValue ; double fNbMENpD = direction * ( runningTotal * 360 ) ; double GJAs2mTF = runningTotal * 360 ; double angle1 = startAngle + KsJVV923 ; double knEOlQF4 = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double kdMrM34C = direction * ( runningTotal + value ) * 360 ; double RYvikEsE = runningTotal + value ; double angle2 = startAngle + knEOlQF4 ; double kMfVPJdt = angle2 - angle1 ; if ( Math . abs ( kMfVPJdt ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double X0Uv1ZF0 = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( X0Uv1ZF0 ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double llYgiFZb = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + llYgiFZb ; double ZTJOGCUQ = gapVertical / 2 ; double linkY = plotArea . getY ( ) + ZTJOGCUQ ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double zNrH9MJt = ( linkX + linkX + linkW ) / 2 ; double wSwz2zdk = linkX + linkX + linkW ; linkX = zNrH9MJt - min ; double VzQ1tK6I = ( linkY + linkY + linkH ) / 2 ; double CbdOgC0g = linkY + linkY + linkH ; linkY = VzQ1tK6I - min ; linkW = 2 * min ; linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double BEeZll9F = hh / 2 . 0 ; double M5fvgc7V = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + BEeZll9F , linkY + M5fvgc7V , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double BPvcw4Py = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( BPvcw4Py ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double Wfw5XTeN = h1 / 2 . 0 ; double VRhgkwPW = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + Wfw5XTeN , explodeArea . getY ( ) + VRhgkwPW , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double JBHY2IIs = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - JBHY2IIs ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double fAnYu6rw = ( direction * ( runningTotal * 360 ) ) / totalValue ; double mtzmiFtJ = direction * ( runningTotal * 360 ) ; double NXuk12mT = runningTotal * 360 ; double angle1 = startAngle + fAnYu6rw ; double uE8sWxYE = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double ya5ZzbXE = direction * ( runningTotal + value ) * 360 ; double oIwe11ff = runningTotal + value ; double angle2 = startAngle + uE8sWxYE ; double YzRFCAWF = angle2 - angle1 ; if ( Math . abs ( YzRFCAWF ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean aPbRVBMS = index > = 0 ; if ( aPbRVBMS & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean fotVlo56 = index > = 0 ; if ( fotVlo56 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int WUNOJss4 = categoryCount * ( seriesCount - 1 ) ; int rbODv1gx = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( WUNOJss4 ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double lO3DCz6T = rectHeight / 2 . 0d ; double PPqv3wUx = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + lO3DCz6T , highVal , rectY + PPqv3wUx ) ; g2 . draw ( line ) ; double Lu3487TI = rectHeight * 0 . 25 ; double OYLoHovb = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + Lu3487TI , highVal , rectY + OYLoHovb ) ; g2 . draw ( line ) ; double OAq2ZTqG = rectHeight * 0 . 25 ; double A7top7WW = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + OAq2ZTqG , lowVal , rectY + A7top7WW ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int scKNdJ0f = categoryCount * ( seriesCount - 1 ) ; int GjdhRc64 = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( scKNdJ0f ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double HIneJThE = rectHeight / 2 . 0d ; double UTxei5Lz = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + HIneJThE , highVal , rectY + UTxei5Lz ) ; g2 . draw ( line ) ; double xhWJau2B = rectHeight * 0 . 25 ; double RoOxwqx9 = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + xhWJau2B , highVal , rectY + RoOxwqx9 ) ; g2 . draw ( line ) ; double PLAj6Lsd = rectHeight * 0 . 25 ; double jbNhOt5O = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + PLAj6Lsd , lowVal , rectY + jbNhOt5O ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double oimgk8ab = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( oimgk8ab ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double JtOqYHVw = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + JtOqYHVw ; double riXX4mf7 = gapVertical / 2 ; double linkY = plotArea . getY ( ) + riXX4mf7 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double ZVYvo2Ui = ( linkX + linkX + linkW ) / 2 ; double ahHkogIY = linkX + linkX + linkW ; linkX = ZVYvo2Ui - min ; double w9u7nVdU = ( linkY + linkY + linkH ) / 2 ; double Aj8zMlBj = linkY + linkY + linkH ; linkY = w9u7nVdU - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double WQnfxJOA = hh / 2 . 0 ; double CbKUfuzQ = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + WQnfxJOA , linkY + CbKUfuzQ , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double t1wO0XPy = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( t1wO0XPy ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double QUwyHjJS = h1 / 2 . 0 ; double rcA5cgFb = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + QUwyHjJS , explodeArea . getY ( ) + rcA5cgFb , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double wWnFRU0X = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - wWnFRU0X ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double vQvoGLnQ = ( direction * ( runningTotal * 360 ) ) / totalValue ; double g9Nu2hFD = direction * ( runningTotal * 360 ) ; double snBU6i6n = runningTotal * 360 ; double angle1 = startAngle + vQvoGLnQ ; double PVt4MfuY = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double bMDXy7Hh = direction * ( runningTotal + value ) * 360 ; double blXaLySl = runningTotal + value ; double angle2 = startAngle + PVt4MfuY ; double zvYxJHFM = angle2 - angle1 ; if ( Math . abs ( zvYxJHFM ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double TMSPqk5p = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( TMSPqk5p ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double qyzuJWwk = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + qyzuJWwk ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double j5zcH2Qw = gapVertical / 2 ; double linkY = plotArea . getY ( ) + j5zcH2Qw ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double Yi7GLNBF = ( linkX + linkX + linkW ) / 2 ; double NIlBuVs5 = linkX + linkX + linkW ; linkX = Yi7GLNBF - min ; double Yrkv5U7K = ( linkY + linkY + linkH ) / 2 ; double aoD9IDNT = linkY + linkY + linkH ; linkY = Yrkv5U7K - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double KnvWzwHL = hh / 2 . 0 ; double F3TmIjkI = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + KnvWzwHL , linkY + F3TmIjkI , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double J3if6tOM = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( J3if6tOM ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double ElzkRz2E = h1 / 2 . 0 ; double ntMjCudk = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + ElzkRz2E , explodeArea . getY ( ) + ntMjCudk , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double YiCQDc8S = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - YiCQDc8S ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double THHVCRR0 = ( direction * ( runningTotal * 360 ) ) / totalValue ; double Gp3DbJKa = direction * ( runningTotal * 360 ) ; double siv3aR8d = runningTotal * 360 ; double angle1 = startAngle + THHVCRR0 ; double HfqhnfdM = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double BrryDOFw = direction * ( runningTotal + value ) * 360 ; double fMjiPVFB = runningTotal + value ; double angle2 = startAngle + HfqhnfdM ; double ntkRI0iu = angle2 - angle1 ; if ( Math . abs ( ntkRI0iu ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean WeX1Rt1b = index > = 0 ; if ( WeX1Rt1b & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean JO4vTZet = index > = 0 ; if ( JO4vTZet & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "public class test { public void delete ( int start , int end ) { boolean sOmgkPlC = end < start ; if ( sOmgkPlC & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } boolean Y8xv5K6m = end < start ; if ( Y8xv5K6m & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double plf1gOiX = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( plf1gOiX ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double X736awPR = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + X736awPR ; double WsXSATKK = gapVertical / 2 ; double linkY = plotArea . getY ( ) + WsXSATKK ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double sbJCMx6k = ( linkX + linkX + linkW ) / 2 ; double EoIihNoD = linkX + linkX + linkW ; linkX = sbJCMx6k - min ; double q7Jkd39F = ( linkY + linkY + linkH ) / 2 ; double jqUiA6G4 = linkY + linkY + linkH ; linkY = q7Jkd39F - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double xGqigloT = hh / 2 . 0 ; double BEB4Kveh = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + xGqigloT , linkY + BEB4Kveh , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double gnvUXiFj = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( gnvUXiFj ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double zjIKr5ws = h1 / 2 . 0 ; double fHQyeEMJ = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + zjIKr5ws , explodeArea . getY ( ) + fHQyeEMJ , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double p2ifu7bY = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - p2ifu7bY ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double t4Cg0pNW = ( direction * ( runningTotal * 360 ) ) / totalValue ; double LvDS5ZSF = direction * ( runningTotal * 360 ) ; double VV9sdZjF = runningTotal * 360 ; double angle1 = startAngle + t4Cg0pNW ; double csdvJdzu = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double gMWLmzBh = direction * ( runningTotal + value ) * 360 ; double SDNV0zSE = runningTotal + value ; double angle2 = startAngle + csdvJdzu ; double ic7arOtZ = angle2 - angle1 ; if ( Math . abs ( ic7arOtZ ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double UYZPpSyw = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( UYZPpSyw ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double XDArb6Da = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + XDArb6Da ; double DmpNVHmV = gapVertical / 2 ; double linkY = plotArea . getY ( ) + DmpNVHmV ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double PqeY5HRF = ( linkX + linkX + linkW ) / 2 ; double cAG7wAYR = linkX + linkX + linkW ; linkX = PqeY5HRF - min ; double okIrAGXT = ( linkY + linkY + linkH ) / 2 ; double ZUtlkCsv = linkY + linkY + linkH ; linkY = okIrAGXT - min ; linkW = 2 * min ; linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double jFre6wb5 = hh / 2 . 0 ; double T39o6WlC = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + jFre6wb5 , linkY + T39o6WlC , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double QpivXqgv = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( QpivXqgv ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double uTHthEjj = h1 / 2 . 0 ; double lx1lU9jo = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + uTHthEjj , explodeArea . getY ( ) + lx1lU9jo , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double qL8EhC1W = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - qL8EhC1W ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double oTnAz51Q = ( direction * ( runningTotal * 360 ) ) / totalValue ; double yarqYjwO = direction * ( runningTotal * 360 ) ; double KjWqEO3P = runningTotal * 360 ; double angle1 = startAngle + oTnAz51Q ; double wouF55bS = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double H1lDyA5a = direction * ( runningTotal + value ) * 360 ; double AgesJUN1 = runningTotal + value ; double angle2 = startAngle + wouF55bS ; double rsFMWDhJ = angle2 - angle1 ; if ( Math . abs ( rsFMWDhJ ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long bERdvJGp = ( end - start ) / 2 ; long vEa0cB74 = end - start ; long middle = start + ( bERdvJGp ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long r7W1KPqS = ( e - s ) / 2 ; long QfbGMFcB = e - s ; long minMiddle = s + r7W1KPqS ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long ZBPfGU6Q = ( e - s ) / 2 ; long GBs0dQBT = e - s ; long maxMiddle = s + ZBPfGU6Q ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; } if ( this . minEndIndex > = 0 ) { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else {", "text_2": "long start = period . getStart ( ) . getTime ( ) ; long end = period . getEnd ( ) . getTime ( ) ; long ttt7SoLn = ( end - start ) / 2 ; long M89LFbcw = end - start ; long middle = start + ( ttt7SoLn ) ; if ( this . minStartIndex > = 0 ) { long minStart = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long n1ppAeBH = ( e - s ) / 2 ; long iYOwXrZC = e - s ; long minMiddle = s + n1ppAeBH ; if ( middle < minMiddle ) { this . minMiddleIndex = index ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long K7sVu9ad = ( e - s ) / 2 ; long lqxnrJ6X = e - s ; long maxMiddle = s + K7sVu9ad ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ; } if ( this . minEndIndex > = 0 ) { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean wFKpi0mj = index > = 0 ; if ( wFKpi0mj & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean jjEQpPM0 = index > = 0 ; if ( jjEQpPM0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double vX31boAO = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( vX31boAO ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double QllfPjxH = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( QllfPjxH ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) { } if ( ! Double . isNaN ( m + sd ) ) { double YmrNfCVq = m + sd ; if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( YmrNfCVq ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = m + sd ; } } } if ( ! Double . isNaN ( m - sd ) ) { double dhfuyALU = m - sd ; if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( dhfuyALU ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = m - sd ; } }", "text_3": 0}
{"text_1": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double EKutIBxp = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( EKutIBxp ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double vubb081k = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + vubb081k ; double kCHYiZxC = gapVertical / 2 ; double linkY = plotArea . getY ( ) + kCHYiZxC ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double j83lx2vc = ( linkX + linkX + linkW ) / 2 ; double zQf7L5KR = linkX + linkX + linkW ; linkX = j83lx2vc - min ; double Qowel1Lj = ( linkY + linkY + linkH ) / 2 ; double nlIycEgm = linkY + linkY + linkH ; linkY = Qowel1Lj - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double xnahTQ3q = hh / 2 . 0 ; double par2B7tn = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + xnahTQ3q , linkY + par2B7tn , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double GjCdpPGa = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( GjCdpPGa ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double diDXdMD8 = h1 / 2 . 0 ; double QL43YRbk = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + diDXdMD8 , explodeArea . getY ( ) + QL43YRbk , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double t05qequd = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - t05qequd ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double LJDRNKbv = ( direction * ( runningTotal * 360 ) ) / totalValue ; double Js5FHfjs = direction * ( runningTotal * 360 ) ; double TCdh031P = runningTotal * 360 ; double angle1 = startAngle + LJDRNKbv ; double Jq3JTLjD = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double JQCBV5KT = direction * ( runningTotal + value ) * 360 ; double QRtpGgJx = runningTotal + value ; double angle2 = startAngle + Jq3JTLjD ; double MHtssYRL = angle2 - angle1 ; if ( Math . abs ( MHtssYRL ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double T8CrsYsu = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( T8CrsYsu ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double UfbxmqTp = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + UfbxmqTp ; double U70E2BD3 = gapVertical / 2 ; double linkY = plotArea . getY ( ) + U70E2BD3 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double KS4WmwB3 = ( linkX + linkX + linkW ) / 2 ; double EvD6s0Zl = linkX + linkX + linkW ; linkX = KS4WmwB3 - min ; double MI657IxP = ( linkY + linkY + linkH ) / 2 ; double Dl2RnY1f = linkY + linkY + linkH ; linkY = MI657IxP - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double kT9mRA9S = hh / 2 . 0 ; double uymlFDnf = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + kT9mRA9S , linkY + uymlFDnf , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double HrOnGo2r = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( HrOnGo2r ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double wqXFnWx5 = h1 / 2 . 0 ; double af0DRDX8 = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + wqXFnWx5 , explodeArea . getY ( ) + af0DRDX8 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double UfgoGFlQ = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - UfgoGFlQ ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double YsgwZkKU = ( direction * ( runningTotal * 360 ) ) / totalValue ; double DSnCWlzK = direction * ( runningTotal * 360 ) ; double xdMs8NEk = runningTotal * 360 ; double angle1 = startAngle + YsgwZkKU ; double R9NoKVbe = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double Fz6p9uYJ = direction * ( runningTotal + value ) * 360 ; double abPZnLPq = runningTotal + value ; double angle2 = startAngle + R9NoKVbe ; double XKhzrjj2 = angle2 - angle1 ; if ( Math . abs ( XKhzrjj2 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean ZJ7hHbev = index > = 0 ; if ( ZJ7hHbev & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean ldh9yFD2 = index > = 0 ; if ( ldh9yFD2 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double pnqAMqp1 = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( pnqAMqp1 ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double jEf2eeoM = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + jEf2eeoM ; double n1qS75TW = gapVertical / 2 ; double linkY = plotArea . getY ( ) + n1qS75TW ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double esha8RSz = ( linkX + linkX + linkW ) / 2 ; double ZDUyOl4M = linkX + linkX + linkW ; linkX = esha8RSz - min ; double skMGM17O = ( linkY + linkY + linkH ) / 2 ; double sga4gmUT = linkY + linkY + linkH ; linkY = skMGM17O - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double vLSnAnaX = hh / 2 . 0 ; double FmsW2tkW = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + vLSnAnaX , linkY + FmsW2tkW , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double hBCxV8sW = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( hBCxV8sW ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double lawoNYCn = h1 / 2 . 0 ; double unQoMLoO = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + lawoNYCn , explodeArea . getY ( ) + unQoMLoO , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double M8oVO2qv = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - M8oVO2qv ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double oChKYbO9 = ( direction * ( runningTotal * 360 ) ) / totalValue ; double lRNAmILW = direction * ( runningTotal * 360 ) ; double TrziJEtN = runningTotal * 360 ; double angle1 = startAngle + oChKYbO9 ; double Dtqmb7ZL = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double H6sg6NtB = direction * ( runningTotal + value ) * 360 ; double WbbzgUhB = runningTotal + value ; double angle2 = startAngle + Dtqmb7ZL ; double D8zIi2oB = angle2 - angle1 ; if ( Math . abs ( D8zIi2oB ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double u5zKPKbV = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( u5zKPKbV ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double VqUL3nAV = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + VqUL3nAV ; double zSi00C6e = gapVertical / 2 ; double linkY = plotArea . getY ( ) + zSi00C6e ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double qf5YL6qi = ( linkX + linkX + linkW ) / 2 ; double TBnSSFIA = linkX + linkX + linkW ; linkX = qf5YL6qi - min ; double vUJdsgaz = ( linkY + linkY + linkH ) / 2 ; double HzX5dQeT = linkY + linkY + linkH ; linkY = vUJdsgaz - min ; linkW = 2 * min ; linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double AEomW44O = hh / 2 . 0 ; double qQl5zx27 = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + AEomW44O , linkY + qQl5zx27 , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double H1Oceo6r = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( H1Oceo6r ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double mHNtTuaf = h1 / 2 . 0 ; double cZuvGKm3 = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + mHNtTuaf , explodeArea . getY ( ) + cZuvGKm3 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double ybExcqF2 = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - ybExcqF2 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double FRVhORpW = ( direction * ( runningTotal * 360 ) ) / totalValue ; double CGRhBI00 = direction * ( runningTotal * 360 ) ; double R0DJZeyz = runningTotal * 360 ; double angle1 = startAngle + FRVhORpW ; double O3WknoEE = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double hF2xbBad = direction * ( runningTotal + value ) * 360 ; double l5gP4Zl9 = runningTotal + value ; double angle2 = startAngle + O3WknoEE ; double a4kFdKWt = angle2 - angle1 ; if ( Math . abs ( a4kFdKWt ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean g1n9zpki = index > = 0 ; if ( g1n9zpki & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean tGuPIzYp = index > = 0 ; if ( tGuPIzYp & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double RhCZkuhQ = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( RhCZkuhQ ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double Utlm8698 = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + Utlm8698 ; double BNl47SmC = gapVertical / 2 ; double linkY = plotArea . getY ( ) + BNl47SmC ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double ZnzTnEvS = ( linkX + linkX + linkW ) / 2 ; double Qz7sToir = linkX + linkX + linkW ; linkX = ZnzTnEvS - min ; double Dq4IzNwR = ( linkY + linkY + linkH ) / 2 ; double w79xcjHz = linkY + linkY + linkH ; linkY = Dq4IzNwR - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double iaoT2XTr = hh / 2 . 0 ; double ORC8j7em = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + iaoT2XTr , linkY + ORC8j7em , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double QZtvxLRy = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( QZtvxLRy ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double hSDXcYdw = h1 / 2 . 0 ; double svPR0v3g = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + hSDXcYdw , explodeArea . getY ( ) + svPR0v3g , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double cvg2gu0w = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - cvg2gu0w ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double CDNn4qow = ( direction * ( runningTotal * 360 ) ) / totalValue ; double wB5Lh9gh = direction * ( runningTotal * 360 ) ; double YKpy3qed = runningTotal * 360 ; double angle1 = startAngle + CDNn4qow ; double h1CxgmUn = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double gNPsgkfk = direction * ( runningTotal + value ) * 360 ; double idzwAPvD = runningTotal + value ; double angle2 = startAngle + h1CxgmUn ; double Crwg3Lbo = angle2 - angle1 ; if ( Math . abs ( Crwg3Lbo ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_2": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double tgq2fhB6 = gapPercent + labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( tgq2fhB6 ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double RwPx8loX = gapHorizontal / 2 ; double linkX = plotArea . getX ( ) + RwPx8loX ; double nrzFohei = gapVertical / 2 ; double linkY = plotArea . getY ( ) + nrzFohei ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; double xLl7NFI8 = ( linkX + linkX + linkW ) / 2 ; double Rm1Crbfr = linkX + linkX + linkW ; linkX = xLl7NFI8 - min ; double vwMFsrEV = ( linkY + linkY + linkH ) / 2 ; double BnxAGsyA = linkY + linkY + linkH ; linkY = vwMFsrEV - min ; linkW = 2 * min ; linkH = 2 * min ; } / / it is defined by shrinking the linkArea by the linkMargin factor . double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; double AdCZdS7i = hh / 2 . 0 ; double qgGfI5lN = vv / 2 . 0 ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + AdCZdS7i , linkY + qgGfI5lN , linkW - hh , linkH - vv ) ; state . setExplodedPieArea ( explodeArea ) ; / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double maximumExplodePercent = getMaximumExplodePercent ( ) ; double WKCkm8hA = 1 . 0 + maximumExplodePercent ; double percent = maximumExplodePercent / ( WKCkm8hA ) ; double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; double Ey93rNLQ = h1 / 2 . 0 ; double ux0iLPtj = v1 / 2 . 0 ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + Ey93rNLQ , explodeArea . getY ( ) + ux0iLPtj , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ; / / the link area defines the dog - leg point for the linking lines to state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; double iuAwykH2 = depth / 2 . 0 ; state . setPieCenterY ( pieArea . getCenterY ( ) - iuAwykH2 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double XKw2YHrA = ( direction * ( runningTotal * 360 ) ) / totalValue ; double MosEdc6D = direction * ( runningTotal * 360 ) ; double Br8fuyeA = runningTotal * 360 ; double angle1 = startAngle + XKw2YHrA ; double CipEZaWN = ( direction * ( runningTotal + value ) * 360 ) / totalValue ; double PE9z4ke0 = direction * ( runningTotal + value ) * 360 ; double FSWwYWfF = runningTotal + value ; double angle2 = startAngle + CipEZaWN ; double KElLUskG = angle2 - angle1 ; if ( Math . abs ( KElLUskG ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else {", "text_3": 0}
{"text_1": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean nhNpofnV = index > = 0 ; if ( nhNpofnV & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; boolean LKv7LjAC = index > = 0 ; if ( LKv7LjAC & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ; } existing . setY ( y ) ; } else { boolean G9Au6RJW = index > = 0 ; / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( G9Au6RJW & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int EbswuIMe = categoryCount * ( seriesCount - 1 ) ; int lttl8Efl = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( EbswuIMe ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double FxDmxpxA = rectHeight / 2 . 0d ; double wWKoszZW = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + FxDmxpxA , highVal , rectY + wWKoszZW ) ; g2 . draw ( line ) ; double nihEg1tk = rectHeight * 0 . 25 ; double HDZeNRab = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + nihEg1tk , highVal , rectY + HDZeNRab ) ; g2 . draw ( line ) ; double Hz7N8qae = rectHeight * 0 . 25 ; double yFWqNIWK = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + Hz7N8qae , lowVal , rectY + yFWqNIWK ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > 1 ) { int KoNJ9dY4 = categoryCount * ( seriesCount - 1 ) ; int NUbrfL0N = seriesCount - 1 ; double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( KoNJ9dY4 ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } } Line2D line = null ; double l4pJ3iFD = rectHeight / 2 . 0d ; double RfYDsk9H = rectHeight / 2 . 0d ; line = new Line2D . Double ( lowVal , rectY + l4pJ3iFD , highVal , rectY + RfYDsk9H ) ; g2 . draw ( line ) ; double UMuvcaG2 = rectHeight * 0 . 25 ; double c9H5k8Gb = rectHeight * 0 . 75 ; line = new Line2D . Double ( highVal , rectY + UMuvcaG2 , highVal , rectY + c9H5k8Gb ) ; g2 . draw ( line ) ; double hi1kQpnD = rectHeight * 0 . 25 ; double Q9twuUPp = rectHeight * 0 . 75 ; line = new Line2D . Double ( lowVal , rectY + hi1kQpnD , lowVal , rectY + Q9twuUPp ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean PcuycIAI = label = = null ; if ( ( PcuycIAI ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double auZm4mBu = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - auZm4mBu ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float GevEYyMg = w / 2 . 0f ; float vCwgPy9Q = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - GevEYyMg , labely - vCwgPy9Q , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double AzzyyivA = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + AzzyyivA ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float tj6lmi5c = w / 2 . 0f ; float JwhudWym = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - tj6lmi5c , labely - JwhudWym , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double tbvqsoSS = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - tbvqsoSS , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double pc4xHsJq = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - pc4xHsJq ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double t10WjSyy = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - t10WjSyy , TextAnchor . CENTER ) ; float SoYrXUxp = w / 2 . 0f ; float ViF4xHYT = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - SoYrXUxp , labely - ViF4xHYT , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double RkwkRkW4 = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + RkwkRkW4 , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double lmkxZYBT = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + lmkxZYBT ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double fbnDD6Ul = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + fbnDD6Ul , TextAnchor . CENTER ) ; float W4pSfFAA = w / 2 . 0f ; float WV2tz4c4 = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - W4pSfFAA , labely - WV2tz4c4 , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } boolean tOBxZqDz = label = = null ; if ( ( tOBxZqDz ) | | ( label . equals ( \" \" ) ) ) { return state ; } float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double P50tpu0O = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) - insets . getBottom ( ) - P50tpu0O ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float x4fc7fqA = w / 2 . 0f ; float h3wyE2XC = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - x4fc7fqA , labely - h3wyE2XC , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , labelBounds . getCenterX ( ) , float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; float labelx = ( float ) dataArea . getCenterX ( ) ; double gL9qdzum = h / 2 . 0 ; float labely = ( float ) ( state . getCursor ( ) + insets . getTop ( ) + gL9qdzum ) ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; float ruC3vw4W = w / 2 . 0f ; float u64lC66u = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - ruC3vw4W , labely - u64lC66u , w , h ) ; state . cursorDown ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } else if ( edge = = RectangleEdge . LEFT ) { double a6PVD9NE = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - a6PVD9NE , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double qwhs2kwb = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) - insets . getRight ( ) - qwhs2kwb ) ; float labely = ( float ) dataArea . getCenterY ( ) ; double JdFdAboy = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) - JdFdAboy , TextAnchor . CENTER ) ; float hJToQn66 = w / 2 . 0f ; float G7dYrKwJ = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - hJToQn66 , labely - G7dYrKwJ , w , h ) ; state . cursorLeft ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } else if ( edge = = RectangleEdge . RIGHT ) { double vWRu5fgd = Math . PI / 2 . 0 ; AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) + vWRu5fgd , labelBounds . getCenterX ( ) , labelBounds . getCenterY ( ) ) ; Shape rotatedLabelBounds = t . createTransformedShape ( labelBounds ) ; labelBounds = rotatedLabelBounds . getBounds2D ( ) ; float w = ( float ) labelBounds . getWidth ( ) ; float h = ( float ) labelBounds . getHeight ( ) ; double qlMrsTtu = w / 2 . 0 ; float labelx = ( float ) ( state . getCursor ( ) + insets . getLeft ( ) + qlMrsTtu ) ; float labely = ( float ) ( dataArea . getY ( ) + dataArea . getHeight ( ) / 2 . 0 ) ; double FInVnwCt = Math . PI / 2 . 0 ; TextUtilities . drawRotatedString ( label , g2 , labelx , labely , TextAnchor . CENTER , getLabelAngle ( ) + FInVnwCt , TextAnchor . CENTER ) ; float zjjLxR76 = w / 2 . 0f ; float hC8YSoKP = h / 2 . 0f ; hotspot = new Rectangle2D . Float ( labelx - zjjLxR76 , labely - hC8YSoKP , w , h ) ; state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number e , Number h ) { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem o = null ; int l = indexOf ( e ) ; if ( l > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem i = ( XYDataItem ) this . data . get ( l ) ; try { o = ( XYDataItem ) i . clone ( ) ; } catch ( CloneNotSupportedException k ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } i . setY ( h ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - l - 1 , new XYDataItem ( e , h ) ) ; } else { this . data . add ( new XYDataItem ( e , h ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return o ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number d , Number c ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( d , c ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem h = null ; int e = indexOf ( d ) ; if ( e > = 0 ) { XYDataItem f = ( XYDataItem ) this . data . get ( e ) ; try { h = ( XYDataItem ) f . clone ( ) ; } catch ( CloneNotSupportedException g ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } f . setY ( c ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - e - 1 , new XYDataItem ( d , c ) ) ; } else { this . data . add ( new XYDataItem ( d , c ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return h ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection e = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return e ; } int f = this . plot . getIndexOf ( this ) ; CategoryDataset z = this . plot . getDataset ( f ) ; if ( z ! = null ) { return e ; } int c = z . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int d = 0 ; d < c ; d + + ) { if ( isSeriesVisibleInLegend ( d ) ) { LegendItem g = getLegendItem ( f , d ) ; if ( g ! = null ) { e . add ( g ) ; } } } } else { for ( int a = c - 1 ; a > = 0 ; a - - ) { if ( isSeriesVisibleInLegend ( a ) ) { LegendItem b = getLegendItem ( f , a ) ; if ( b ! = null ) { e . add ( b ) ; } } } } return e ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection k = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return k ; } int g = this . plot . getIndexOf ( this ) ; CategoryDataset m = this . plot . getDataset ( g ) ; if ( ( m ) = = null ) { return k ; } int h = m . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int n = 0 ; n < h ; n + + ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem l = getLegendItem ( g , n ) ; if ( l ! = null ) { k . add ( l ) ; } } } } else { for ( int i = h - 1 ; i > = 0 ; i - - ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem j = getLegendItem ( g , i ) ; if ( j ! = null ) { k . add ( j ) ; } } } } return k ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double c ) { double b = Math . max ( c , this . lowerBound ) ; b = Math . min ( b , this . upperBound ) ; int a = ( int ) ( ( c - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( a , a , a ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double v ) { double t = Math . max ( v , this . lowerBound ) ; t = Math . min ( t , this . upperBound ) ; int u = ( int ) ( ( ( t ) - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( u , u , u ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public boolean equals ( Object h ) { if ( h = = this ) { return true ; } if ( ! ( h instanceof ShapeList ) ) { return false ; } return super . equals ( h ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean equals ( Object a ) { if ( a = = this ) { return true ; } if ( ! ( a instanceof ShapeList ) ) { return false ; } ShapeList b = ( ShapeList ) a ; int d = size ( ) ; for ( int c = 0 ; c < d ; c + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( c ) , ( Shape ) b . get ( c ) ) ) { return false ; } } return true ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double q ) { double r = Math . max ( q , this . lowerBound ) ; r = Math . min ( r , this . upperBound ) ; int p = ( int ) ( ( q - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( p , p , p ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double s ) { double u = Math . max ( s , this . lowerBound ) ; u = Math . min ( u , this . upperBound ) ; int t = ( int ) ( ( u - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( t , t , t ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis q ) { int t = this . rangeAxes . indexOf ( q ) ; if ( t < 0 ) { / / try the parent plot Plot r = getParent ( ) ; if ( r instanceof CategoryPlot ) { CategoryPlot s = ( CategoryPlot ) r ; t = s . getRangeAxisIndex ( q ) ; } } return t ; } } \\ No newline at end of file", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis w ) { if ( w = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int x = this . rangeAxes . indexOf ( w ) ; if ( x < 0 ) { / / try the parent plot Plot u = getParent ( ) ; if ( u instanceof CategoryPlot ) { CategoryPlot v = ( CategoryPlot ) u ; x = v . getRangeAxisIndex ( w ) ; } } return x ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Week ( Date g , TimeZone h ) { / / defer argument checking . . . this ( g , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Week ( Date o , TimeZone n ) { / / defer argument checking . . . this ( o , n , java . util . Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod c , RegularTimePeriod y ) throws CloneNotSupportedException { if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( y = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( c . compareTo ( y ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean d = false ; int a = getIndex ( c ) ; if ( a < 0 ) { a = - ( a + 1 ) ; if ( a = = this . data . size ( ) ) { d = true ; / / start is after last data item } } int b = getIndex ( y ) ; if ( b < 0 ) { / / end period is not in original series b = - ( b + 1 ) ; / / this is first item AFTER end period b = b - 1 ; / / so this is last item BEFORE end } if ( b < 0 ) { d = true ; } if ( d ) { TimeSeries z = ( TimeSeries ) super . clone ( ) ; z . data = new java . util . ArrayList ( ) ; return z ; } else { return createCopy ( a , b ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod g , RegularTimePeriod c ) throws CloneNotSupportedException { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( g . compareTo ( c ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean d = false ; int f = getIndex ( g ) ; if ( f < 0 ) { f = - ( f + 1 ) ; if ( f = = this . data . size ( ) ) { d = true ; / / start is after last data item } } int e = getIndex ( c ) ; if ( e < 0 ) { / / end period is not in original series e = - ( e + 1 ) ; / / this is first item AFTER end period e = e - 1 ; / / so this is last item BEFORE end } if ( ( e < 0 ) | | ( e < f ) ) { d = true ; } if ( d ) { TimeSeries h = ( TimeSeries ) super . clone ( ) ; h . data = new java . util . ArrayList ( ) ; return h ; } else { return createCopy ( f , e ) ; } }", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double v ) { double w = Math . max ( v , this . lowerBound ) ; w = Math . min ( w , this . upperBound ) ; int u = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( u , u , u ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double j ) { double k = Math . max ( j , this . lowerBound ) ; k = Math . min ( k , this . upperBound ) ; j = k ; int l = ( int ) ( ( j - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( l , l , l ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod b , RegularTimePeriod a ) throws CloneNotSupportedException { if ( b = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( b . compareTo ( a ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean c = false ; int z = getIndex ( b ) ; if ( z < 0 ) { z = - ( z + 1 ) ; if ( z = = this . data . size ( ) ) { c = true ; / / start is after last data item } } int y = getIndex ( a ) ; if ( y < 0 ) { / / end period is not in original series y = - ( y + 1 ) ; / / this is first item AFTER end period y = y - 1 ; / / so this is last item BEFORE end } if ( y < 0 ) { c = true ; } if ( c ) { TimeSeries x = ( TimeSeries ) super . clone ( ) ; x . data = new java . util . ArrayList ( ) ; return x ; } else { return createCopy ( z , y ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod b , RegularTimePeriod y ) throws CloneNotSupportedException { if ( b = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( y = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( b . compareTo ( y ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean z = false ; int c = getIndex ( b ) ; if ( c < 0 ) { c = - ( c + 1 ) ; if ( c = = this . data . size ( ) ) { z = true ; / / start is after last data item } } int x = getIndex ( y ) ; if ( x < 0 ) { / / end period is not in original series x = - ( x + 1 ) ; / / this is first item AFTER end period x = x - 1 ; / / so this is last item BEFORE end } if ( ( x < 0 ) | | ( x > = c ) = = false ) { z = true ; } if ( z ) { TimeSeries a = ( TimeSeries ) super . clone ( ) ; a . data = new java . util . ArrayList ( ) ; return a ; } else { return createCopy ( c , x ) ; } }", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double n , Paint i , Stroke m , Paint j , Stroke l , float k ) { super ( i , m , i , m , k ) ; this . value = n ; } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double w , Paint y , Stroke x , Paint z , Stroke b , float a ) { super ( y , x , z , b , a ) ; this . value = w ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static boolean equal ( GeneralPath d , GeneralPath z ) { if ( d = = null ) { return ( z = = null ) ; } if ( z = = null ) { return false ; } if ( d . getWindingRule ( ) ! = z . getWindingRule ( ) ) { return false ; } PathIterator a = d . getPathIterator ( null ) ; PathIterator e = d . getPathIterator ( null ) ; double [ ] c = new double [ 6 ] ; double [ ] y = new double [ 6 ] ; boolean f = a . isDone ( ) & & e . isDone ( ) ; while ( ! f ) { if ( a . isDone ( ) ! = e . isDone ( ) ) { return false ; } int b = a . currentSegment ( c ) ; int g = e . currentSegment ( y ) ; if ( b ! = g ) { return false ; } if ( ! Arrays . equals ( c , y ) ) { return false ; } a . next ( ) ; e . next ( ) ; f = a . isDone ( ) & & e . isDone ( ) ; } return true ; }", "text_2": "public class test { public static boolean equal ( GeneralPath d , GeneralPath b ) { if ( d = = null ) { return ( b = = null ) ; } if ( b = = null ) { return false ; } if ( d . getWindingRule ( ) ! = b . getWindingRule ( ) ) { return false ; } PathIterator a = d . getPathIterator ( null ) ; PathIterator x = b . getPathIterator ( null ) ; double [ ] y = new double [ 6 ] ; double [ ] c = new double [ 6 ] ; boolean z = a . isDone ( ) & & x . isDone ( ) ; while ( ! z ) { if ( a . isDone ( ) ! = x . isDone ( ) ) { return false ; } int e = a . currentSegment ( y ) ; int f = x . currentSegment ( c ) ; if ( e ! = f ) { return false ; } if ( ! Arrays . equals ( y , c ) ) { return false ; } a . next ( ) ; x . next ( ) ; z = a . isDone ( ) & & x . isDone ( ) ; } return true ; }", "text_3": 1}
{"text_1": "public class test { public void removeColumn ( Comparable q ) { int n = getColumnIndex ( q ) ; if ( n < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + q + \" ) not recognised . \" ) ; } Iterator z = this . rows . iterator ( ) ; while ( z . hasNext ( ) ) { KeyedObjects y = ( KeyedObjects ) z . next ( ) ; y . removeValue ( q ) ; } this . columnKeys . remove ( q ) ; }  public void removeRow ( Comparable b ) { int o = getRowIndex ( b ) ; removeRow ( o ) ; } public void removeObject ( Comparable r , Comparable p ) { setObject ( null , r , p ) ; / / 1 . check whether the row is now empty . boolean u = true ; int w = getRowIndex ( r ) ; KeyedObjects s = ( KeyedObjects ) this . rows . get ( w ) ; for ( int a = 0 , t = s . getItemCount ( ) ; a < t ; a + + ) { if ( s . getObject ( a ) ! = null ) { u = false ; break ; } } if ( u ) { this . rowKeys . remove ( w ) ; this . rows . remove ( w ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable l , Comparable v ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' rowKey ' argument . \" ) ; } if ( v = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } int m = this . rowKeys . indexOf ( l ) ; if ( m < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + l + \" ) not recognised . \" ) ; } int k = this . columnKeys . indexOf ( v ) ; if ( k < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + v + \" ) not recognised . \" ) ; } if ( m > = 0 ) { KeyedObjects x = ( KeyedObjects ) this . rows . get ( m ) ; return x . getObject ( v ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "public class test { public void removeColumn ( Comparable z ) { int c = getColumnIndex ( z ) ; if ( c < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + z + \" ) not recognised . \" ) ; } Iterator t = this . rows . iterator ( ) ; while ( t . hasNext ( ) ) { KeyedObjects p = ( KeyedObjects ) t . next ( ) ; int r = p . getIndex ( z ) ; if ( r > = 0 ) { p . removeValue ( r ) ; } } this . columnKeys . remove ( z ) ; } public void removeObject ( Comparable x , Comparable d ) { setObject ( null , x , d ) ; / / 1 . check whether the row is now empty . boolean v = true ; int h = getRowIndex ( x ) ; KeyedObjects b = ( KeyedObjects ) this . rows . get ( h ) ; for ( int n = 0 , q = b . getItemCount ( ) ; n < q ; n + + ) { if ( b . getObject ( n ) ! = null ) { v = false ; break ; } } if ( v ) { this . rowKeys . remove ( h ) ; this . rows . remove ( h ) ; } / / 2 . check whether the column is now empty . v = true ;  for ( int l = 0 , j = this . rows . size ( ) ; l < j ; l + + ) { b = ( KeyedObjects ) this . rows . get ( l ) ; int s = b . getIndex ( d ) ; if ( s > = 0 & & b . getObject ( s ) ! = null ) { v = false ; break ; } } if ( v ) { for ( int a = 0 , w = this . rows . size ( ) ; a < w ; a + + ) { b = ( KeyedObjects ) this . rows . get ( a ) ; int y = b . getIndex ( d ) ; if ( y > = 0 ) { b . removeValue ( y ) ; } } this . columnKeys . remove ( d ) ; } } public Object getObject ( Comparable k , Comparable g ) { if ( k = = null ) { throw new IllegalArgumentException ( \" Null ' rowKey ' argument . \" ) ; } if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } int u = this . rowKeys . indexOf ( k ) ; if ( u < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + k + \" ) not recognised . \" ) ; } int m = this . columnKeys . indexOf ( g ) ; if ( m < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + g + \" ) not recognised . \" ) ; } KeyedObjects o = ( KeyedObjects ) this . rows . get ( u ) ; int f = o . getIndex ( g ) ; if ( f > = 0 ) { return o . getObject ( f ) ; } else { return null ; } }  public void removeRow ( Comparable e ) { int i = getRowIndex ( e ) ; if ( i < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + e + \" ) not recognised . \" ) ; } removeRow ( i ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public String generateToolTipFragment ( String u ) { return \" title = \\ \" \" + u + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "text_2": "public class test { public String generateToolTipFragment ( String p ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { double k = 0 . 0 ; Iterator m = this . dataset . getKeys ( ) . iterator ( ) ; while ( m . hasNext ( ) ) { Comparable n = ( Comparable ) m . next ( ) ; Number p = ( Number ) this . explodePercentages . get ( n ) ; if ( p ! = null ) { k = Math . max ( k , p . doubleValue ( ) ) ; } } return k ; } public PiePlotState initialise ( Graphics2D h , Rectangle2D o , PiePlot i , Integer j , PlotRenderingInfo g ) { PiePlotState l = new PiePlotState ( g ) ; l . setPassesRequired ( 2 ) ; l . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( i . getDataset ( ) ) ) ; l . setLatestAngle ( i . getStartAngle ( ) ) ; return l ; } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D t , Rectangle2D s , PiePlot h , Integer q , PlotRenderingInfo a ) { PiePlotState r = new PiePlotState ( a ) ; r . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { r . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( h . getDataset ( ) ) ) ; } r . setLatestAngle ( h . getStartAngle ( ) ) ; return r ; } public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double a = 0 . 0 ; Iterator g = this . dataset . getKeys ( ) . iterator ( ) ; while ( g . hasNext ( ) ) { Comparable k = ( Comparable ) g . next ( ) ; Number n = ( Number ) this . explodePercentages . get ( k ) ; if ( n ! = null ) { a = Math . max ( a , n . doubleValue ( ) ) ; } } return a ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis e ) { int d = this . rangeAxes . indexOf ( e ) ; if ( d < 0 ) { / / try the parent plot Plot c = getParent ( ) ; if ( c instanceof CategoryPlot ) { CategoryPlot b = ( CategoryPlot ) c ; d = b . getRangeAxisIndex ( e ) ; } } return d ; } public int getDomainAxisIndex ( CategoryAxis f ) { return this . domainAxes . indexOf ( f ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis f ) { if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int h = this . rangeAxes . indexOf ( f ) ; if ( h < 0 ) { / / try the parent plot Plot e = getParent ( ) ; if ( e instanceof CategoryPlot ) { CategoryPlot g = ( CategoryPlot ) e ; h = g . getRangeAxisIndex ( f ) ; } } return h ; } public int getDomainAxisIndex ( CategoryAxis i ) { if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( i ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod g , RegularTimePeriod d ) throws CloneNotSupportedException { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( g . compareTo ( d ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean e = false ; int f = getIndex ( g ) ; if ( f < 0 ) { f = - ( f + 1 ) ; if ( f = = this . data . size ( ) ) { e = true ; / / start is after last data item } } int h = getIndex ( d ) ; if ( h < 0 ) { / / end period is not in original series h = - ( h + 1 ) ; / / this is first item AFTER end period h = h - 1 ; / / so this is last item BEFORE end } if ( h < 0 ) { e = true ; } if ( e ) { TimeSeries i = ( TimeSeries ) super . clone ( ) ; i . data = new java . util . ArrayList ( ) ; return i ; } else { return createCopy ( f , h ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod c , RegularTimePeriod e ) throws CloneNotSupportedException { if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( c . compareTo ( e ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean h = false ; int f = getIndex ( c ) ; if ( f < 0 ) { f = - ( f + 1 ) ; if ( f = = this . data . size ( ) ) { h = true ; / / start is after last data item } } int g = getIndex ( e ) ; if ( g < 0 ) { / / end period is not in original series g = - ( g + 1 ) ; / / this is first item AFTER end period g = g - 1 ; / / so this is last item BEFORE end } if ( g < f | | ( g < 0 ) ) { h = true ; } if ( h ) { TimeSeries d = ( TimeSeries ) super . clone ( ) ; d . data = new java . util . ArrayList ( ) ; return d ; } else { return createCopy ( f , g ) ; } }", "text_3": 1}
{"text_1": "public class test { protected AxisState drawLabel ( String b , Graphics2D t , Rectangle2D c , Rectangle2D n , RectangleEdge l , AxisState v , PlotRenderingInfo p ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( v = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( b = = null ) | | ( b . equals ( \" \" ) ) ) { return v ; } Font w = getLabelFont ( ) ; RectangleInsets s = getLabelInsets ( ) ; t . setFont ( w ) ; t . setPaint ( getLabelPaint ( ) ) ; FontMetrics k = t . getFontMetrics ( ) ; Rectangle2D t = TextUtilities . getTextBounds ( b , t , k ) ; Shape z = null ; if ( l = = RectangleEdge . TOP ) { AffineTransform y = AffineTransform . getRotateInstance ( getLabelAngle ( ) , t . getCenterX ( ) , t . getCenterY ( ) ) ; Shape y = y . createTransformedShape ( t ) ; t = y . getBounds2D ( ) ; float u = ( float ) t . getWidth ( ) ; float f = ( float ) t . getHeight ( ) ; float a = ( float ) n . getCenterX ( ) ; float x = ( float ) ( v . getCursor ( ) - s . getBottom ( ) - f / 2 . 0 ) ; TextUtilities . drawRotatedString ( b , t , a , x , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( a - u / 2 . 0f , x - f / 2 . 0f , u , f ) ; v . cursorUp ( s . getTop ( ) + t . getHeight ( ) + s . getBottom ( ) ) ; } else if ( l = = RectangleEdge . BOTTOM ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , t . getCenterX ( ) , t . getCenterY ( ) ) ; Shape m = d . createTransformedShape ( t ) ; t = m . getBounds2D ( ) ; float z = ( float ) t . getWidth ( ) ; float o = ( float ) t . getHeight ( ) ; float c = ( float ) n . getCenterX ( ) ; float s = ( float ) ( v . getCursor ( ) + s . getTop ( ) + o / 2 . 0 ) ; TextUtilities . drawRotatedString ( b , t , c , s , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( c - z / 2 . 0f , s - o / 2 . 0f , z , o ) ; v . cursorDown ( s . getTop ( ) + t . getHeight ( ) + s . getBottom ( ) ) ; } else if ( l = = RectangleEdge . LEFT ) { AffineTransform u = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , t . getCenterX ( ) , t . getCenterY ( ) ) ; Shape h = u . createTransformedShape ( t ) ; t = h . getBounds2D ( ) ; float e = ( float ) t . getWidth ( ) ; float d = ( float ) t . getHeight ( ) ; float a = ( float ) ( v . getCursor ( ) - s . getRight ( ) - e / 2 . 0 ) ; float q = ( float ) n . getCenterY ( ) ; TextUtilities . drawRotatedString ( b , t , a , q , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( a - e / 2 . 0f , q - d / 2 . 0f , e , d ) ; v . cursorLeft ( s . getLeft ( ) + t . getWidth ( ) + s . getRight ( ) ) ; } else if ( l = = RectangleEdge . RIGHT ) { AffineTransform b = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , t . getCenterX ( ) , t . getCenterY ( ) ) ; Shape r = b . createTransformedShape ( t ) ; t = r . getBounds2D ( ) ; float v = ( float ) t . getWidth ( ) ; float i = ( float ) t . getHeight ( ) ; float g = ( float ) ( v . getCursor ( ) + s . getLeft ( ) + v / 2 . 0 ) ; float w = ( float ) ( n . getY ( ) + n . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( b , t , g , w , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( g - v / 2 . 0f , w - i / 2 . 0f , v , i ) ; v . cursorRight ( s . getLeft ( ) + t . getWidth ( ) + s . getRight ( ) ) ; } if ( p ! = null & & z ! = null ) { ChartRenderingInfo j = p . getOwner ( ) ; EntityCollection x = j . getEntityCollection ( ) ; if ( x ! = null ) { x . add ( new AxisLabelEntity ( this , z , this . labelToolTip , this . labelURL ) ) ; } } return v ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String d , Graphics2D v , Rectangle2D j , Rectangle2D r , RectangleEdge w , AxisState i , PlotRenderingInfo a ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( d = = null ) | | ( d . equals ( \" \" ) ) ) { return i ; } Font v = getLabelFont ( ) ; RectangleInsets d = getLabelInsets ( ) ; v . setFont ( v ) ; v . setPaint ( getLabelPaint ( ) ) ; FontMetrics t = v . getFontMetrics ( ) ; Rectangle2D m = TextUtilities . getTextBounds ( d , v , t ) ; Shape u = null ; if ( w = = RectangleEdge . TOP ) { AffineTransform x = AffineTransform . getRotateInstance ( getLabelAngle ( ) , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape k = x . createTransformedShape ( m ) ; m = k . getBounds2D ( ) ; float q = ( float ) m . getWidth ( ) ; float e = ( float ) m . getHeight ( ) ; float b = ( float ) r . getCenterX ( ) ; float z = ( float ) ( i . getCursor ( ) - d . getBottom ( ) - e / 2 . 0 ) ; TextUtilities . drawRotatedString ( d , v , b , z , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; u = new Rectangle2D . Float ( b - q / 2 . 0f , z - e / 2 . 0f , q , e ) ; i . cursorUp ( d . getTop ( ) + m . getHeight ( ) + d . getBottom ( ) ) ; } else if ( w = = RectangleEdge . BOTTOM ) { AffineTransform p = AffineTransform . getRotateInstance ( getLabelAngle ( ) , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape w = p . createTransformedShape ( m ) ; m = w . getBounds2D ( ) ; float f = ( float ) m . getWidth ( ) ; float y = ( float ) m . getHeight ( ) ; float b = ( float ) r . getCenterX ( ) ; float c = ( float ) ( i . getCursor ( ) + d . getTop ( ) + y / 2 . 0 ) ; TextUtilities . drawRotatedString ( d , v , b , c , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; u = new Rectangle2D . Float ( b - f / 2 . 0f , c - y / 2 . 0f , f , y ) ; i . cursorDown ( d . getTop ( ) + m . getHeight ( ) + d . getBottom ( ) ) ; } else if ( w = = RectangleEdge . LEFT ) { AffineTransform n = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape y = n . createTransformedShape ( m ) ; m = y . getBounds2D ( ) ; float l = ( float ) m . getWidth ( ) ; float t = ( float ) m . getHeight ( ) ; float g = ( float ) ( i . getCursor ( ) - d . getRight ( ) - l / 2 . 0 ) ; float z = ( float ) r . getCenterY ( ) ; TextUtilities . drawRotatedString ( d , v , g , z , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; u = new Rectangle2D . Float ( g - l / 2 . 0f , z - t / 2 . 0f , l , t ) ; i . cursorLeft ( d . getLeft ( ) + m . getWidth ( ) + d . getRight ( ) ) ; } else if ( w = = RectangleEdge . RIGHT ) { AffineTransform e = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape x = e . createTransformedShape ( m ) ; m = x . getBounds2D ( ) ; float u = ( float ) m . getWidth ( ) ; float c = ( float ) m . getHeight ( ) ; float s = ( float ) ( i . getCursor ( ) + d . getLeft ( ) + u / 2 . 0 ) ; float h = ( float ) ( r . getY ( ) + r . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( d , v , s , h , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; u = new Rectangle2D . Float ( s - u / 2 . 0f , h - c / 2 . 0f , u , c ) ; i . cursorRight ( d . getLeft ( ) + m . getWidth ( ) + d . getRight ( ) ) ; } if ( a ! = null & & u ! = null ) { ChartRenderingInfo a = a . getOwner ( ) ; if ( ( null = = a ) = = true ) { return i ; } EntityCollection o = a . getEntityCollection ( ) ; if ( o ! = null ) { o . add ( new AxisLabelEntity ( this , u , this . labelToolTip , this . labelURL ) ) ; } } return i ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void add ( TimeSeriesDataItem i , boolean g ) { if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } i = ( TimeSeriesDataItem ) i . clone ( ) ; Class c = i . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer e = new StringBuffer ( ) ; e . append ( \" You are trying to add data where the time period class \" ) ; e . append ( \" is \" ) ; e . append ( i . getPeriod ( ) . getClass ( ) . getName ( ) ) ; e . append ( \" , but the TimeSeries is expecting an instance of \" ) ; e . append ( this . timePeriodClass . getName ( ) ) ; e . append ( \" . \" ) ; throw new SeriesException ( e . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean h = false ; int d = getItemCount ( ) ; if ( d = = 0 ) { this . data . add ( i ) ; h = true ; } else { RegularTimePeriod f = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( i . getPeriod ( ) . compareTo ( f ) > 0 ) { this . data . add ( i ) ; h = true ; } else { int j = Collections . binarySearch ( this . data , i ) ; if ( j < 0 ) { this . data . add ( - j - 1 , i ) ; h = true ; } else { StringBuffer a = new StringBuffer ( ) ; a . append ( \" You are attempting to add an observation for \" ) ; a . append ( \" the time period \" ) ; a . append ( i . getPeriod ( ) . toString ( ) ) ; a . append ( \" but the series already contains an observation \" ) ; a . append ( \" for that time period . Duplicates are not \" ) ; a . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( a . toString ( ) ) ; } } } if ( h ) { updateBoundsForAddedItem ( i ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem b = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( g ) { fireSeriesChanged ( ) ; } }", "text_2": "public class test { public void add ( TimeSeriesDataItem d , boolean y ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; d = ( TimeSeriesDataItem ) d . clone ( ) ; Class c = d . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer f = new StringBuffer ( ) ; f . append ( \" You are trying to add data where the time period class \" ) ; f . append ( \" is \" ) ; f . append ( d . getPeriod ( ) . getClass ( ) . getName ( ) ) ; f . append ( \" , but the TimeSeries is expecting an instance of \" ) ; f . append ( this . timePeriodClass . getName ( ) ) ; f . append ( \" . \" ) ; throw new SeriesException ( f . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean e = false ; int g = getItemCount ( ) ; if ( g = = 0 ) { this . data . add ( d ) ; e = true ; } else { RegularTimePeriod a = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( d . getPeriod ( ) . compareTo ( a ) > 0 ) { this . data . add ( d ) ; e = true ; } else { int h = Collections . binarySearch ( this . data , d ) ; if ( h < 0 ) { this . data . add ( - h - 1 , d ) ; e = true ; } else { StringBuffer z = new StringBuffer ( ) ; z . append ( \" You are attempting to add an observation for \" ) ; z . append ( \" the time period \" ) ; z . append ( d . getPeriod ( ) . toString ( ) ) ; z . append ( \" but the series already contains an observation \" ) ; z . append ( \" for that time period . Duplicates are not \" ) ; z . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( z . toString ( ) ) ; } } } if ( e ) { updateBoundsForAddedItem ( d ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem b = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( y ) { fireSeriesChanged ( ) ; } }", "text_3": 1}
{"text_1": "public class test { protected AxisState drawLabel ( String w , Graphics2D s , Rectangle2D t , Rectangle2D q , RectangleEdge n , AxisState p , PlotRenderingInfo b ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( w = = null ) | | ( w . equals ( \" \" ) ) ) { return p ; } Font e = getLabelFont ( ) ; RectangleInsets v = getLabelInsets ( ) ; s . setFont ( e ) ; s . setPaint ( getLabelPaint ( ) ) ; FontMetrics r = s . getFontMetrics ( ) ; Rectangle2D r = TextUtilities . getTextBounds ( w , s , r ) ; Shape f = null ; if ( n = = RectangleEdge . TOP ) { AffineTransform y = AffineTransform . getRotateInstance ( getLabelAngle ( ) , r . getCenterX ( ) , r . getCenterY ( ) ) ; Shape p = y . createTransformedShape ( r ) ; r = p . getBounds2D ( ) ; float s = ( float ) r . getWidth ( ) ; float u = ( float ) r . getHeight ( ) ; float o = ( float ) q . getCenterX ( ) ; float d = ( float ) ( p . getCursor ( ) - v . getBottom ( ) - u / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , s , o , d , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( o - s / 2 . 0f , d - u / 2 . 0f , s , u ) ; p . cursorUp ( v . getTop ( ) + r . getHeight ( ) + v . getBottom ( ) ) ; } else if ( n = = RectangleEdge . BOTTOM ) { AffineTransform a = AffineTransform . getRotateInstance ( getLabelAngle ( ) , r . getCenterX ( ) , r . getCenterY ( ) ) ; Shape l = a . createTransformedShape ( r ) ; r = l . getBounds2D ( ) ; float o = ( float ) r . getWidth ( ) ; float c = ( float ) r . getHeight ( ) ; float m = ( float ) q . getCenterX ( ) ; float v = ( float ) ( p . getCursor ( ) + v . getTop ( ) + c / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , s , m , v , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( m - o / 2 . 0f , v - c / 2 . 0f , o , c ) ; p . cursorDown ( v . getTop ( ) + r . getHeight ( ) + v . getBottom ( ) ) ; } else if ( n = = RectangleEdge . LEFT ) { AffineTransform q = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , r . getCenterX ( ) , r . getCenterY ( ) ) ; Shape m = q . createTransformedShape ( r ) ; r = m . getBounds2D ( ) ; float n = ( float ) r . getWidth ( ) ; float x = ( float ) r . getHeight ( ) ; float h = ( float ) ( p . getCursor ( ) - v . getRight ( ) - n / 2 . 0 ) ; float z = ( float ) q . getCenterY ( ) ; TextUtilities . drawRotatedString ( w , s , h , z , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( h - n / 2 . 0f , z - x / 2 . 0f , n , x ) ; p . cursorLeft ( v . getLeft ( ) + r . getWidth ( ) + v . getRight ( ) ) ; } else if ( n = = RectangleEdge . RIGHT ) { AffineTransform i = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , r . getCenterX ( ) , r . getCenterY ( ) ) ; Shape j = i . createTransformedShape ( r ) ; r = j . getBounds2D ( ) ; float l = ( float ) r . getWidth ( ) ; float k = ( float ) r . getHeight ( ) ; float u = ( float ) ( p . getCursor ( ) + v . getLeft ( ) + l / 2 . 0 ) ; float g = ( float ) ( q . getY ( ) + q . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , s , u , g , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( u - l / 2 . 0f , g - k / 2 . 0f , l , k ) ; p . cursorRight ( v . getLeft ( ) + r . getWidth ( ) + v . getRight ( ) ) ; } if ( b ! = null & & f ! = null ) { ChartRenderingInfo w = b . getOwner ( ) ; EntityCollection t = w . getEntityCollection ( ) ; if ( t ! = null ) { t . add ( new AxisLabelEntity ( this , f , this . labelToolTip , this . labelURL ) ) ; } } return p ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String o , Graphics2D d , Rectangle2D y , Rectangle2D a , RectangleEdge x , AxisState w , PlotRenderingInfo h ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( w = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( o = = null ) | | ( o . equals ( \" \" ) ) ) { return w ; } Font t = getLabelFont ( ) ; RectangleInsets z = getLabelInsets ( ) ; d . setFont ( t ) ; d . setPaint ( getLabelPaint ( ) ) ; FontMetrics b = d . getFontMetrics ( ) ; Rectangle2D d = TextUtilities . getTextBounds ( o , d , b ) ; Shape v = null ; if ( x = = RectangleEdge . TOP ) { AffineTransform i = AffineTransform . getRotateInstance ( getLabelAngle ( ) , d . getCenterX ( ) , d . getCenterY ( ) ) ; Shape j = i . createTransformedShape ( d ) ; d = j . getBounds2D ( ) ; float s = ( float ) d . getWidth ( ) ; float y = ( float ) d . getHeight ( ) ; float m = ( float ) a . getCenterX ( ) ; float f = ( float ) ( w . getCursor ( ) - z . getBottom ( ) - y / 2 . 0 ) ; TextUtilities . drawRotatedString ( o , d , m , f , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; v = new Rectangle2D . Float ( m - s / 2 . 0f , f - y / 2 . 0f , s , y ) ; w . cursorUp ( z . getTop ( ) + d . getHeight ( ) + z . getBottom ( ) ) ; } else if ( x = = RectangleEdge . BOTTOM ) { AffineTransform v = AffineTransform . getRotateInstance ( getLabelAngle ( ) , d . getCenterX ( ) , d . getCenterY ( ) ) ; Shape x = v . createTransformedShape ( d ) ; d = x . getBounds2D ( ) ; float e = ( float ) d . getWidth ( ) ; float u = ( float ) d . getHeight ( ) ; float n = ( float ) a . getCenterX ( ) ; float p = ( float ) ( w . getCursor ( ) + z . getTop ( ) + u / 2 . 0 ) ; TextUtilities . drawRotatedString ( o , d , n , p , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; v = new Rectangle2D . Float ( n - e / 2 . 0f , p - u / 2 . 0f , e , u ) ; w . cursorDown ( z . getTop ( ) + d . getHeight ( ) + z . getBottom ( ) ) ; } else if ( x = = RectangleEdge . LEFT ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , d . getCenterX ( ) , d . getCenterY ( ) ) ; Shape u = t . createTransformedShape ( d ) ; d = u . getBounds2D ( ) ; float w = ( float ) d . getWidth ( ) ; float b = ( float ) d . getHeight ( ) ; float z = ( float ) ( w . getCursor ( ) - z . getRight ( ) - w / 2 . 0 ) ; float k = ( float ) a . getCenterY ( ) ; TextUtilities . drawRotatedString ( o , d , z , k , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; v = new Rectangle2D . Float ( z - w / 2 . 0f , k - b / 2 . 0f , w , b ) ; w . cursorLeft ( z . getLeft ( ) + d . getWidth ( ) + z . getRight ( ) ) ; } else if ( x = = RectangleEdge . RIGHT ) { AffineTransform c = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , d . getCenterX ( ) , d . getCenterY ( ) ) ; Shape g = c . createTransformedShape ( d ) ; d = g . getBounds2D ( ) ; float a = ( float ) d . getWidth ( ) ; float l = ( float ) d . getHeight ( ) ; float q = ( float ) ( w . getCursor ( ) + z . getLeft ( ) + a / 2 . 0 ) ; float r = ( float ) ( a . getY ( ) + a . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( o , d , q , r , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; v = new Rectangle2D . Float ( q - a / 2 . 0f , r - l / 2 . 0f , a , l ) ; w . cursorRight ( z . getLeft ( ) + d . getWidth ( ) + z . getRight ( ) ) ; } if ( h ! = null & & v ! = null ) { ChartRenderingInfo e = h . getOwner ( ) ; if ( e ! = null ) { EntityCollection c = e . getEntityCollection ( ) ; if ( c ! = null ) { c . add ( new AxisLabelEntity ( this , v , this . labelToolTip , this . labelURL ) ) ; } } } return w ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; } public void add ( BoxAndWhiskerItem b , Comparable z , Comparable e ) {  this . data . addObject ( b , z , e ) ; / / update cached min and max values int f = this . data . getRowIndex ( z ) ; int a = this . data . getColumnIndex ( e ) ; if ( ( this . maximumRangeValueRow = = f & & this . maximumRangeValueColumn = = a ) | | ( this . minimumRangeValueRow = = f & & this . minimumRangeValueColumn = = a ) ) { updateBounds ( ) ; } double c = Double . NaN ; if ( b . getMinOutlier ( ) ! = null ) { c = b . getMinOutlier ( ) . doubleValue ( ) ; } double d = Double . NaN ; if ( b . getMaxOutlier ( ) ! = null ) { d = b . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = d ; this . maximumRangeValueRow = f ; this . maximumRangeValueColumn = a ; } else if ( d > this . maximumRangeValue ) { this . maximumRangeValue = d ; this . maximumRangeValueRow = f ; this . maximumRangeValueColumn = a ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = c ; this . minimumRangeValueRow = f ; this . minimumRangeValueColumn = a ; } else if ( c < this . minimumRangeValue ) { this . minimumRangeValue = c ; this . minimumRangeValueRow = f ; this . minimumRangeValueColumn = a ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem z , Comparable f , Comparable w ) { this . data . addObject ( z , f , w ) ; / / update cached min and max values int x = this . data . getRowIndex ( f ) ; int q = this . data . getColumnIndex ( w ) ; if ( ( this . maximumRangeValueRow = = x & & this . maximumRangeValueColumn = = q ) | | ( this . minimumRangeValueRow = = x & & this . minimumRangeValueColumn = = q ) ) { updateBounds ( ) ; } else { double d = Double . NaN ; if ( z . getMinOutlier ( ) ! = null ) { d = z . getMinOutlier ( ) . doubleValue ( ) ; } double r = Double . NaN ; if ( z . getMaxOutlier ( ) ! = null ) { r = z . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = r ; this . maximumRangeValueRow = x ; this . maximumRangeValueColumn = q ; } else if ( r > this . maximumRangeValue ) { this . maximumRangeValue = r ; this . maximumRangeValueRow = x ; this . maximumRangeValueColumn = q ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = d ; this . minimumRangeValueRow = x ; this . minimumRangeValueColumn = q ; } else if ( d < this . minimumRangeValue ) { this . minimumRangeValue = d ; this . minimumRangeValueRow = x ; this . minimumRangeValueColumn = q ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int a = getRowCount ( ) ; int s = getColumnCount ( ) ; for ( int e = 0 ; e < a ; e + + ) { for ( int v = 0 ; v < s ; v + + ) { BoxAndWhiskerItem t = getItem ( e , v ) ; if ( t ! = null ) { Number c = t . getMinOutlier ( ) ; if ( c ! = null ) { double b = c . doubleValue ( ) ; if ( ! Double . isNaN ( b ) ) { if ( b < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = b ; this . minimumRangeValueRow = e ; this . minimumRangeValueColumn = v ; } } } Number y = t . getMaxOutlier ( ) ; if ( y ! = null ) { double u = y . doubleValue ( ) ; if ( ! Double . isNaN ( u ) ) { if ( u > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = u ; this . maximumRangeValueRow = e ; this . maximumRangeValueColumn = v ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public boolean removeDomainMarker ( int s , Marker h , Layer v , boolean n ) { ArrayList r ; if ( v = = Layer . FOREGROUND ) { r = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( s ) ) ; } else { r = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( s ) ) ; } boolean w = r . remove ( h ) ; if ( w & & n ) { fireChangeEvent ( ) ; } return w ; } public boolean removeRangeMarker ( int b , Marker z , Layer x , boolean c ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList g ; if ( x = = Layer . FOREGROUND ) { g = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( b ) ) ; } else { g = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( b ) ) ; } boolean u = g . remove ( z ) ; if ( u & & c ) { fireChangeEvent ( ) ; } return u ; } public boolean removeRangeMarker ( int k , Marker d , Layer f , boolean l ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList m ; if ( f = = Layer . FOREGROUND ) { m = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( k ) ) ; } else { m = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( k ) ) ; } boolean j = m . remove ( d ) ; if ( j & & l ) { fireChangeEvent ( ) ; } return j ; } public boolean removeDomainMarker ( int o , Marker t , Layer i , boolean y ) { ArrayList e ; if ( i = = Layer . FOREGROUND ) { e = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( o ) ) ; } else { e = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( o ) ) ; } boolean a = e . remove ( t ) ; if ( a & & y ) { fireChangeEvent ( ) ; } return a ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int v , Marker c , Layer l , boolean m ) { ArrayList x ; if ( l = = Layer . FOREGROUND ) { x = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( v ) ) ; } else { x = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( v ) ) ; } if ( x = = null ) { return false ; } boolean d = x . remove ( c ) ; if ( d & & m ) { fireChangeEvent ( ) ; } return d ; } public boolean removeRangeMarker ( int i , Marker e , Layer w , boolean j ) { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList s ; if ( w = = Layer . FOREGROUND ) { s = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { s = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } if ( s = = null ) { return false ; } boolean g = s . remove ( e ) ; if ( g & & j ) { fireChangeEvent ( ) ; } return g ; } public boolean removeDomainMarker ( int r , Marker q , Layer a , boolean o ) { ArrayList f ; if ( a = = Layer . FOREGROUND ) { f = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( r ) ) ; } else { f = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( r ) ) ; } if ( f = = null ) { return false ; } boolean h = f . remove ( q ) ; if ( h & & o ) { fireChangeEvent ( ) ; } return h ; } public boolean removeRangeMarker ( int b , Marker p , Layer y , boolean k ) { if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList z ; if ( y = = Layer . FOREGROUND ) { z = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( b ) ) ; } else { z = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( b ) ) ; } if ( z = = null ) { return false ; } boolean n = z . remove ( p ) ; if ( n & & k ) { fireChangeEvent ( ) ; } return n ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod y , RegularTimePeriod x ) throws CloneNotSupportedException { if ( y = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( y . compareTo ( x ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean v = false ; int w = getIndex ( y ) ; if ( w < 0 ) { w = - ( w + 1 ) ; if ( w = = this . data . size ( ) ) { v = true ; / / start is after last data item } } int z = getIndex ( x ) ; if ( z < 0 ) { / / end period is not in original series z = - ( z + 1 ) ; / / this is first item AFTER end period z = z - 1 ; / / so this is last item BEFORE end } if ( z < 0 ) { v = true ; } if ( v ) { TimeSeries u = ( TimeSeries ) super . clone ( ) ; u . data = new java . util . ArrayList ( ) ; return u ; } else { return createCopy ( w , z ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod g , RegularTimePeriod i ) throws CloneNotSupportedException { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( g . compareTo ( i ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean e = false ; int j = getIndex ( g ) ; if ( j < 0 ) { j = - ( j + 1 ) ; if ( j = = this . data . size ( ) ) { e = true ; / / start is after last data item } } int f = getIndex ( i ) ; if ( f < 0 ) { / / end period is not in original series f = - ( f + 1 ) ; / / this is first item AFTER end period f = f - 1 ; / / so this is last item BEFORE end } if ( f < 0 | | ( f + 1 > = j + 1 ) = = false ) { e = true ; } if ( e ) { TimeSeries h = ( TimeSeries ) super . clone ( ) ; h . data = new java . util . ArrayList ( ) ; return h ; } else { return createCopy ( j , f ) ; } }", "text_3": 1}
{"text_1": "public class test { public DefaultIntervalCategoryDataset ( Comparable [ ] m , Comparable [ ] g , Number [ ] [ ] k , Number [ ] [ ] j ) { this . startData = k ; this . endData = j ; if ( k ! = null & & j ! = null ) { String b = \" org . jfree . data . resources . DataPackageResources \" ; ResourceBundle a = ResourceBundle . getBundle ( b ) ; int l = k . length ; if ( l ! = j . length ) { String f = \" DefaultIntervalCategoryDataset : the number \" throw new IllegalArgumentException ( f ) ; } if ( l > 0 ) { / / set up the series names . . . if ( m ! = null ) { if ( m . length ! = l ) { throw new IllegalArgumentException ( \" The number of series keys does not \" } this . seriesKeys = m ; } else { String h = a . getString ( \" series . default - prefix \" ) + \" \" ; this . seriesKeys = generateKeys ( l , h ) ; } / / set up the category names . . . int i = k [ 0 ] . length ; if ( i ! = j [ 0 ] . length ) { String e = \" DefaultIntervalCategoryDataset : the \" throw new IllegalArgumentException ( e ) ; } if ( g ! = null ) { if ( g . length ! = i ) { throw new IllegalArgumentException ( \" The number of category keys does not match \" } this . categoryKeys = g ; } else { String c = a . getString ( \" categories . default - prefix \" ) + \" \" ; this . categoryKeys = generateKeys ( i , c ) ; } } else { this . seriesKeys = null ; this . categoryKeys = null ; } } } public void setCategoryKeys ( Comparable [ ] n ) { if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( n . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int d = 0 ; d < n . length ; d + + ) { if ( n [ d ] = = null ) { throw new IllegalArgumentException ( \" DefaultIntervalCategoryDataset . setCategoryKeys ( ) : \" + \" null category not permitted . \" ) ; } } this . categoryKeys = n ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public DefaultIntervalCategoryDataset ( Comparable [ ] i , Comparable [ ] c , Number [ ] [ ] z , Number [ ] [ ] a ) { this . startData = z ; this . endData = a ; if ( z ! = null & & a ! = null ) { String v = \" org . jfree . data . resources . DataPackageResources \" ; ResourceBundle w = ResourceBundle . getBundle ( v ) ; int h = z . length ; if ( h ! = a . length ) { String g = \" DefaultIntervalCategoryDataset : the number \" \" of series in the start value dataset does \" \" not match the number of series in the end \" \" value dataset . \" ; throw new IllegalArgumentException ( g ) ; } if ( h > 0 ) { / / set up the series names . . . if ( i ! = null ) { if ( i . length ! = h ) { throw new IllegalArgumentException ( \" The number of series keys does not \" \" match the number of series in the data . \" ) ; } this . seriesKeys = i ; } else { String e = w . getString ( \" series . default - prefix \" ) + \" \" ; this . seriesKeys = generateKeys ( h , e ) ; } / / set up the category names . . . int x = z [ 0 ] . length ; if ( x ! = a [ 0 ] . length ) { String b = \" DefaultIntervalCategoryDataset : the \" \" number of categories in the start value \" \" dataset does not match the number of \" \" categories in the end value dataset . \" ; throw new IllegalArgumentException ( b ) ; } if ( c ! = null ) { if ( c . length ! = x ) { throw new IllegalArgumentException ( \" The number of category keys does not match \" \" the number of categories in the data . \" ) ; } this . categoryKeys = c ; } else { String f = w . getString ( \" categories . default - prefix \" ) + \" \" ; this . categoryKeys = generateKeys ( x , f ) ; } } else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } } public void setCategoryKeys ( Comparable [ ] d ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( d . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int y = 0 ; y < d . length ; y + + ) { if ( d [ y ] = = null ) { throw new IllegalArgumentException ( \" DefaultIntervalCategoryDataset . setCategoryKeys ( ) : \" + \" null category not permitted . \" ) ; } } this . categoryKeys = d ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset u ) { super ( ) ; this . dataset = u ; PiePlot s = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( s ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle t = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; t . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( t ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset o ) { super ( ) ; setDataset ( o ) ; PiePlot q = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( q ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle p = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; p . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( p ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 1}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection l = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return l ; } int n = this . plot . getIndexOf ( this ) ; CategoryDataset i = this . plot . getDataset ( n ) ; if ( i ! = null ) { return l ; } int j = i . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int g = 0 ; g < j ; g + + ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem m = getLegendItem ( n , g ) ; if ( m ! = null ) { l . add ( m ) ; } } } } else { for ( int k = j - 1 ; k > = 0 ; k - - ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem h = getLegendItem ( n , k ) ; if ( h ! = null ) { l . add ( h ) ; } } } } return l ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection a = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return a ; } int c = this . plot . getIndexOf ( this ) ; CategoryDataset b = this . plot . getDataset ( c ) ; if ( b = = null ) { return a ; } int v = b . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int x = 0 ; x < v ; x + + ) { if ( isSeriesVisibleInLegend ( x ) ) { LegendItem y = getLegendItem ( c , x ) ; if ( y ! = null ) { a . add ( y ) ; } } } } else { for ( int z = v - 1 ; z > = 0 ; z - - ) { if ( isSeriesVisibleInLegend ( z ) ) { LegendItem w = getLegendItem ( c , z ) ; if ( w ! = null ) { a . add ( w ) ; } } } } return a ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis r ) { int q = this . rangeAxes . indexOf ( r ) ; if ( q < 0 ) { / / try the parent plot Plot t = getParent ( ) ; if ( t instanceof CategoryPlot ) { CategoryPlot u = ( CategoryPlot ) t ; q = u . getRangeAxisIndex ( r ) ; } } return q ; } public int getDomainAxisIndex ( CategoryAxis s ) { return this . domainAxes . indexOf ( s ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis n ) { if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int l = this . rangeAxes . indexOf ( n ) ; if ( l < 0 ) { / / try the parent plot Plot k = getParent ( ) ; if ( k instanceof CategoryPlot ) { CategoryPlot m = ( CategoryPlot ) k ; l = m . getRangeAxisIndex ( n ) ; } } return l ; } public int getDomainAxisIndex ( CategoryAxis o ) { if ( o = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( o ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public String generateToolTipFragment ( String z ) { return \" title = \\ \" \" + z + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "text_2": "public class test { public String generateToolTipFragment ( String o ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( o ) + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( TimePeriod v , int w ) { long q = v . getStart ( ) . getTime ( ) ; long x = v . getEnd ( ) . getTime ( ) ; long d = q + ( ( x - q ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long b = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( q < b ) { this . minStartIndex = w ; } } else { this . minStartIndex = w ; } if ( this . maxStartIndex > = 0 ) { long a = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( q > a ) { this . maxStartIndex = w ; } } else { this . maxStartIndex = w ; } if ( this . minMiddleIndex > = 0 ) { long c = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long z = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long y = c + ( z - c ) / 2 ; if ( d < y ) { this . minMiddleIndex = w ; } } else { this . minMiddleIndex = w ; } if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long t = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long r = s + ( t - s ) / 2 ; if ( d > r ) { this . maxMiddleIndex = w ; } } else { this . maxMiddleIndex = w ; } if ( this . minEndIndex > = 0 ) { long u = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( x < u ) { this . minEndIndex = w ; } } else { this . minEndIndex = w ; } if ( this . maxEndIndex > = 0 ) { long e = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( x > e ) { this . maxEndIndex = w ; } } else { this . maxEndIndex = w ; } }", "text_2": "public class test { private void updateBounds ( TimePeriod u , int x ) { long m = u . getStart ( ) . getTime ( ) ; long n = u . getEnd ( ) . getTime ( ) ; long v = m + ( ( n - m ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long s = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( m < s ) { this . minStartIndex = x ; } } else { this . minStartIndex = x ; } if ( this . maxStartIndex > = 0 ) { long l = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( m > l ) { this . maxStartIndex = x ; } } else { this . maxStartIndex = x ; } if ( this . minMiddleIndex > = 0 ) { long q = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long r = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long o = q + ( r - q ) / 2 ; if ( v < o ) { this . minMiddleIndex = x ; } } else { this . minMiddleIndex = x ; } if ( this . maxMiddleIndex > = 0 ) { long k = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long p = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long y = k + ( p - k ) / 2 ; if ( v > y ) { this . maxMiddleIndex = x ; } } else { this . maxMiddleIndex = x ; } if ( this . minEndIndex > = 0 ) { long w = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( n < w ) { this . minEndIndex = x ; } } else { this . minEndIndex = x ; } if ( this . maxEndIndex > = 0 ) { long t = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( n > t ) { this . maxEndIndex = x ; } } else { this . maxEndIndex = x ; } }", "text_3": 1}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number c , Number d ) { if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem b = null ; int a = indexOf ( c ) ; if ( a > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem z = ( XYDataItem ) this . data . get ( a ) ; try { b = ( XYDataItem ) z . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } z . setY ( d ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - a - 1 , new XYDataItem ( c , d ) ) ; } else { this . data . add ( new XYDataItem ( c , d ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; } } fireSeriesChanged ( ) ; return b ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number t , Number b ) { if ( t = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem y = null ; int s = indexOf ( t ) ; if ( s > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem w = ( XYDataItem ) this . data . get ( s ) ; try { y = ( XYDataItem ) w . clone ( ) ; } catch ( CloneNotSupportedException p ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } w . setY ( b ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( t , b , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; } } fireSeriesChanged ( ) ; return y ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset l ) { super ( ) ; this . dataset = l ; PiePlot j = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( j ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle k = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; k . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( k ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset e ) { super ( ) ; this . dataset = e ; PiePlot g = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( g ) ; this . pieChart . removeLegend ( ) ; setDataset ( e ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle f = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; f . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( f ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( int c , int b ) throws CloneNotSupportedException { if ( c < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( b < c ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries y = ( TimeSeries ) super . clone ( ) ; y . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int a = c ; a < = b ; a + + ) { TimeSeriesDataItem x = ( TimeSeriesDataItem ) this . data . get ( a ) ; TimeSeriesDataItem z = ( TimeSeriesDataItem ) x . clone ( ) ; try { y . add ( z ) ; } catch ( SeriesException d ) { d . printStackTrace ( ) ; } } } return y ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int q , int s ) throws CloneNotSupportedException { if ( q < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( s < q ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries o = ( TimeSeries ) super . clone ( ) ; o . minY = Double . NaN ; o . maxY = Double . NaN ; o . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int n = q ; n < = s ; n + + ) { TimeSeriesDataItem r = ( TimeSeriesDataItem ) this . data . get ( n ) ; TimeSeriesDataItem p = ( TimeSeriesDataItem ) r . clone ( ) ; try { o . add ( p ) ; } catch ( SeriesException t ) { t . printStackTrace ( ) ; } } } return o ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected AxisState drawLabel ( String x , Graphics2D u , Rectangle2D p , Rectangle2D m , RectangleEdge o , AxisState w , PlotRenderingInfo n ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( w = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( x = = null ) | | ( x . equals ( \" \" ) ) ) { return w ; } Font u = getLabelFont ( ) ; RectangleInsets q = getLabelInsets ( ) ; u . setFont ( u ) ; u . setPaint ( getLabelPaint ( ) ) ; FontMetrics r = u . getFontMetrics ( ) ; Rectangle2D z = TextUtilities . getTextBounds ( x , u , r ) ; Shape f = null ; if ( o = = RectangleEdge . TOP ) { AffineTransform t = AffineTransform . getRotateInstance ( getLabelAngle ( ) , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape w = t . createTransformedShape ( z ) ; z = w . getBounds2D ( ) ; float y = ( float ) z . getWidth ( ) ; float i = ( float ) z . getHeight ( ) ; float j = ( float ) m . getCenterX ( ) ; float c = ( float ) ( w . getCursor ( ) - q . getBottom ( ) - i / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , u , j , c , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( j - y / 2 . 0f , c - i / 2 . 0f , y , i ) ; w . cursorUp ( q . getTop ( ) + z . getHeight ( ) + q . getBottom ( ) ) ; } else if ( o = = RectangleEdge . BOTTOM ) { AffineTransform k = AffineTransform . getRotateInstance ( getLabelAngle ( ) , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape f = k . createTransformedShape ( z ) ; z = f . getBounds2D ( ) ; float d = ( float ) z . getWidth ( ) ; float d = ( float ) z . getHeight ( ) ; float g = ( float ) m . getCenterX ( ) ; float b = ( float ) ( w . getCursor ( ) + q . getTop ( ) + d / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , u , g , b , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( g - d / 2 . 0f , b - d / 2 . 0f , d , d ) ; w . cursorDown ( q . getTop ( ) + z . getHeight ( ) + q . getBottom ( ) ) ; } else if ( o = = RectangleEdge . LEFT ) { AffineTransform x = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape s = x . createTransformedShape ( z ) ; z = s . getBounds2D ( ) ; float v = ( float ) z . getWidth ( ) ; float a = ( float ) z . getHeight ( ) ; float y = ( float ) ( w . getCursor ( ) - q . getRight ( ) - v / 2 . 0 ) ; float l = ( float ) m . getCenterY ( ) ; TextUtilities . drawRotatedString ( x , u , y , l , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( y - v / 2 . 0f , l - a / 2 . 0f , v , a ) ; w . cursorLeft ( q . getLeft ( ) + z . getWidth ( ) + q . getRight ( ) ) ; } else if ( o = = RectangleEdge . RIGHT ) { AffineTransform h = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape e = h . createTransformedShape ( z ) ; z = e . getBounds2D ( ) ; float z = ( float ) z . getWidth ( ) ; float c = ( float ) z . getHeight ( ) ; float a = ( float ) ( w . getCursor ( ) + q . getLeft ( ) + z / 2 . 0 ) ; float v = ( float ) ( m . getY ( ) + m . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , u , a , v , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; f = new Rectangle2D . Float ( a - z / 2 . 0f , v - c / 2 . 0f , z , c ) ; w . cursorRight ( q . getLeft ( ) + z . getWidth ( ) + q . getRight ( ) ) ; } if ( n ! = null & & f ! = null ) { ChartRenderingInfo e = n . getOwner ( ) ; EntityCollection b = e . getEntityCollection ( ) ; if ( b ! = null ) { b . add ( new AxisLabelEntity ( this , f , this . labelToolTip , this . labelURL ) ) ; } } return w ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String u , Graphics2D w , Rectangle2D b , Rectangle2D w , RectangleEdge r , AxisState a , PlotRenderingInfo j ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( u = = null ) | | ( u . equals ( \" \" ) ) ) { return a ; } Font d = getLabelFont ( ) ; RectangleInsets k = getLabelInsets ( ) ; w . setFont ( d ) ; w . setPaint ( getLabelPaint ( ) ) ; FontMetrics a = w . getFontMetrics ( ) ; Rectangle2D z = TextUtilities . getTextBounds ( u , w , a ) ; Shape t = null ; if ( r = = RectangleEdge . TOP ) { AffineTransform s = AffineTransform . getRotateInstance ( getLabelAngle ( ) , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape x = s . createTransformedShape ( z ) ; z = x . getBounds2D ( ) ; float c = ( float ) z . getWidth ( ) ; float d = ( float ) z . getHeight ( ) ; float g = ( float ) w . getCenterX ( ) ; float v = ( float ) ( a . getCursor ( ) - k . getBottom ( ) - d / 2 . 0 ) ; TextUtilities . drawRotatedString ( u , w , g , v , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( g - c / 2 . 0f , v - d / 2 . 0f , c , d ) ; a . cursorUp ( k . getTop ( ) + z . getHeight ( ) + k . getBottom ( ) ) ; } else if ( r = = RectangleEdge . BOTTOM ) { AffineTransform f = AffineTransform . getRotateInstance ( getLabelAngle ( ) , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape b = f . createTransformedShape ( z ) ; z = b . getBounds2D ( ) ; float i = ( float ) z . getWidth ( ) ; float u = ( float ) z . getHeight ( ) ; float c = ( float ) w . getCenterX ( ) ; float v = ( float ) ( a . getCursor ( ) + k . getTop ( ) + u / 2 . 0 ) ; TextUtilities . drawRotatedString ( u , w , c , v , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( c - i / 2 . 0f , v - u / 2 . 0f , i , u ) ; a . cursorDown ( k . getTop ( ) + z . getHeight ( ) + k . getBottom ( ) ) ; } else if ( r = = RectangleEdge . LEFT ) { AffineTransform e = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape m = e . createTransformedShape ( z ) ; z = m . getBounds2D ( ) ; float t = ( float ) z . getWidth ( ) ; float q = ( float ) z . getHeight ( ) ; float y = ( float ) ( a . getCursor ( ) - k . getRight ( ) - t / 2 . 0 ) ; float n = ( float ) w . getCenterY ( ) ; TextUtilities . drawRotatedString ( u , w , y , n , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( y - t / 2 . 0f , n - q / 2 . 0f , t , q ) ; a . cursorLeft ( k . getLeft ( ) + z . getWidth ( ) + k . getRight ( ) ) ; } else if ( r = = RectangleEdge . RIGHT ) { AffineTransform l = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , z . getCenterX ( ) , z . getCenterY ( ) ) ; Shape y = l . createTransformedShape ( z ) ; z = y . getBounds2D ( ) ; float h = ( float ) z . getWidth ( ) ; float p = ( float ) z . getHeight ( ) ; float x = ( float ) ( a . getCursor ( ) + k . getLeft ( ) + h / 2 . 0 ) ; float z = ( float ) ( w . getY ( ) + w . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( u , w , x , z , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( x - h / 2 . 0f , z - p / 2 . 0f , h , p ) ; a . cursorRight ( k . getLeft ( ) + z . getWidth ( ) + k . getRight ( ) ) ; } if ( j ! = null & & t ! = null & & ( null = = j . getOwner ( ) ) ! = true ) { ChartRenderingInfo o = j . getOwner ( ) ; EntityCollection s = o . getEntityCollection ( ) ; if ( s ! = null ) { s . add ( new AxisLabelEntity ( this , t , this . labelToolTip , this . labelURL ) ) ; } } return a ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod y , RegularTimePeriod z ) throws CloneNotSupportedException { if ( y = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( y . compareTo ( z ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean d = false ; int a = getIndex ( y ) ; if ( a < 0 ) { a = - ( a + 1 ) ; if ( a = = this . data . size ( ) ) { d = true ; / / start is after last data item } } int b = getIndex ( z ) ; if ( b < 0 ) { / / end period is not in original series b = - ( b + 1 ) ; / / this is first item AFTER end period b = b - 1 ; / / so this is last item BEFORE end } if ( b < 0 ) { d = true ; } if ( d ) { TimeSeries c = ( TimeSeries ) super . clone ( ) ; c . data = new java . util . ArrayList ( ) ; return c ; } else { return createCopy ( a , b ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod i , RegularTimePeriod f ) throws CloneNotSupportedException { if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( i . compareTo ( f ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean j = false ; int g = getIndex ( i ) ; if ( g < 0 ) { g = - ( g + 1 ) ; if ( g = = this . data . size ( ) ) { j = true ; / / start is after last data item } } int k = getIndex ( f ) ; if ( k < 0 ) { / / end period is not in original series k = - ( k + 1 ) ; / / this is first item AFTER end period k = k - 1 ; / / so this is last item BEFORE end } if ( k < 0 | | ( k < g ) ) { j = true ; } if ( j ) { TimeSeries h = ( TimeSeries ) super . clone ( ) ; h . data = new java . util . ArrayList ( ) ; return h ; } else { return createCopy ( g , k ) ; } }", "text_3": 1}
{"text_1": "public class test { protected AxisState drawLabel ( String p , Graphics2D a , Rectangle2D m , Rectangle2D p , RectangleEdge i , AxisState s , PlotRenderingInfo r ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( p = = null ) | | ( p . equals ( \" \" ) ) ) { return s ; } Font b = getLabelFont ( ) ; RectangleInsets u = getLabelInsets ( ) ; a . setFont ( b ) ; a . setPaint ( getLabelPaint ( ) ) ; FontMetrics q = a . getFontMetrics ( ) ; Rectangle2D c = TextUtilities . getTextBounds ( p , a , q ) ; Shape k = null ; if ( i = = RectangleEdge . TOP ) { AffineTransform f = AffineTransform . getRotateInstance ( getLabelAngle ( ) , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape n = f . createTransformedShape ( c ) ; c = n . getBounds2D ( ) ; float n = ( float ) c . getWidth ( ) ; float v = ( float ) c . getHeight ( ) ; float x = ( float ) p . getCenterX ( ) ; float l = ( float ) ( s . getCursor ( ) - u . getBottom ( ) - v / 2 . 0 ) ; TextUtilities . drawRotatedString ( p , a , x , l , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( x - n / 2 . 0f , l - v / 2 . 0f , n , v ) ; s . cursorUp ( u . getTop ( ) + c . getHeight ( ) + u . getBottom ( ) ) ; } else if ( i = = RectangleEdge . BOTTOM ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape u = d . createTransformedShape ( c ) ; c = u . getBounds2D ( ) ; float o = ( float ) c . getWidth ( ) ; float v = ( float ) c . getHeight ( ) ; float g = ( float ) p . getCenterX ( ) ; float s = ( float ) ( s . getCursor ( ) + u . getTop ( ) + v / 2 . 0 ) ; TextUtilities . drawRotatedString ( p , a , g , s , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( g - o / 2 . 0f , s - v / 2 . 0f , o , v ) ; s . cursorDown ( u . getTop ( ) + c . getHeight ( ) + u . getBottom ( ) ) ; } else if ( i = = RectangleEdge . LEFT ) { AffineTransform h = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape r = h . createTransformedShape ( c ) ; c = r . getBounds2D ( ) ; float t = ( float ) c . getWidth ( ) ; float e = ( float ) c . getHeight ( ) ; float q = ( float ) ( s . getCursor ( ) - u . getRight ( ) - t / 2 . 0 ) ; float t = ( float ) p . getCenterY ( ) ; TextUtilities . drawRotatedString ( p , a , q , t , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( q - t / 2 . 0f , t - e / 2 . 0f , t , e ) ; s . cursorLeft ( u . getLeft ( ) + c . getWidth ( ) + u . getRight ( ) ) ; } else if ( i = = RectangleEdge . RIGHT ) { AffineTransform y = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape w = y . createTransformedShape ( c ) ; c = w . getBounds2D ( ) ; float l = ( float ) c . getWidth ( ) ; float m = ( float ) c . getHeight ( ) ; float j = ( float ) ( s . getCursor ( ) + u . getLeft ( ) + l / 2 . 0 ) ; float o = ( float ) ( p . getY ( ) + p . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( p , a , j , o , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( j - l / 2 . 0f , o - m / 2 . 0f , l , m ) ; s . cursorRight ( u . getLeft ( ) + c . getWidth ( ) + u . getRight ( ) ) ; } if ( r ! = null & & k ! = null ) { ChartRenderingInfo k = r . getOwner ( ) ; if ( k ! = null ) { EntityCollection z = k . getEntityCollection ( ) ; if ( z ! = null ) { z . add ( new AxisLabelEntity ( this , k , this . labelToolTip , this . labelURL ) ) ; } } } return s ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String w , Graphics2D u , Rectangle2D q , Rectangle2D a , RectangleEdge i , AxisState p , PlotRenderingInfo k ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( w = = null ) | | ( w . equals ( \" \" ) ) ) { return p ; } Font y = getLabelFont ( ) ; RectangleInsets t = getLabelInsets ( ) ; u . setFont ( y ) ; u . setPaint ( getLabelPaint ( ) ) ; FontMetrics v = u . getFontMetrics ( ) ; Rectangle2D c = TextUtilities . getTextBounds ( w , u , v ) ; Shape t = null ; if ( i = = RectangleEdge . TOP ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape e = d . createTransformedShape ( c ) ; c = e . getBounds2D ( ) ; float u = ( float ) c . getWidth ( ) ; float c = ( float ) c . getHeight ( ) ; float g = ( float ) a . getCenterX ( ) ; float f = ( float ) ( p . getCursor ( ) - t . getBottom ( ) - c / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , u , g , f , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( g - u / 2 . 0f , f - c / 2 . 0f , u , c ) ; p . cursorUp ( t . getTop ( ) + c . getHeight ( ) + t . getBottom ( ) ) ; } else if ( i = = RectangleEdge . BOTTOM ) { AffineTransform x = AffineTransform . getRotateInstance ( getLabelAngle ( ) , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape x = x . createTransformedShape ( c ) ; c = x . getBounds2D ( ) ; float d = ( float ) c . getWidth ( ) ; float n = ( float ) c . getHeight ( ) ; float b = ( float ) a . getCenterX ( ) ; float l = ( float ) ( p . getCursor ( ) + t . getTop ( ) + n / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , u , b , l , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( b - d / 2 . 0f , l - n / 2 . 0f , d , n ) ; p . cursorDown ( t . getTop ( ) + c . getHeight ( ) + t . getBottom ( ) ) ; } else if ( i = = RectangleEdge . LEFT ) { AffineTransform b = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape z = b . createTransformedShape ( c ) ; c = z . getBounds2D ( ) ; float v = ( float ) c . getWidth ( ) ; float y = ( float ) c . getHeight ( ) ; float r = ( float ) ( p . getCursor ( ) - t . getRight ( ) - v / 2 . 0 ) ; float j = ( float ) a . getCenterY ( ) ; TextUtilities . drawRotatedString ( w , u , r , j , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( r - v / 2 . 0f , j - y / 2 . 0f , v , y ) ; p . cursorLeft ( t . getLeft ( ) + c . getWidth ( ) + t . getRight ( ) ) ; } else if ( i = = RectangleEdge . RIGHT ) { AffineTransform z = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , c . getCenterX ( ) , c . getCenterY ( ) ) ; Shape w = z . createTransformedShape ( c ) ; c = w . getBounds2D ( ) ; float h = ( float ) c . getWidth ( ) ; float o = ( float ) c . getHeight ( ) ; float e = ( float ) ( p . getCursor ( ) + t . getLeft ( ) + h / 2 . 0 ) ; float s = ( float ) ( a . getY ( ) + a . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( w , u , e , s , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; t = new Rectangle2D . Float ( e - h / 2 . 0f , s - o / 2 . 0f , h , o ) ; p . cursorRight ( t . getLeft ( ) + c . getWidth ( ) + t . getRight ( ) ) ; } t = null ; if ( k ! = null & & t ! = null ) { ChartRenderingInfo m = k . getOwner ( ) ; if ( m ! = null ) { EntityCollection a = m . getEntityCollection ( ) ; if ( a ! = null ) { a . add ( new AxisLabelEntity ( this , t , this . labelToolTip , this . labelURL ) ) ; } } } return p ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Range getDataRange ( ValueAxis p ) { Range w = null ; List r = new ArrayList ( ) ; List y = new ArrayList ( ) ; boolean k = true ; / / is it a domain axis ? int j = getDomainAxisIndex ( p ) ; if ( j > = 0 ) { k = true ; r . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( j ) ) ) ; if ( j = = 0 ) { / / grab the plot ' s annotations Iterator l = this . annotations . iterator ( ) ; while ( l . hasNext ( ) ) { XYAnnotation q = ( XYAnnotation ) l . next ( ) ; if ( q instanceof XYAnnotationBoundsInfo ) { y . add ( q ) ; } } } } / / or is it a range axis ? int m = getRangeAxisIndex ( p ) ; if ( m > = 0 ) { k = false ; r . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( m ) ) ) ; if ( m = = 0 ) { Iterator u = this . annotations . iterator ( ) ; while ( u . hasNext ( ) ) { XYAnnotation n = ( XYAnnotation ) u . next ( ) ; if ( n instanceof XYAnnotationBoundsInfo ) { y . add ( n ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator z = r . iterator ( ) ; while ( z . hasNext ( ) ) { XYDataset h = ( XYDataset ) z . next ( ) ; if ( h ! = null ) { XYItemRenderer v = getRendererForDataset ( h ) ; if ( k ) { if ( v ! = null ) { w = Range . combine ( w , v . findDomainBounds ( h ) ) ; } else { w = Range . combine ( w , DatasetUtilities . findDomainBounds ( h ) ) ; } } else { if ( v ! = null ) { w = Range . combine ( w , v . findRangeBounds ( h ) ) ; } else { w = Range . combine ( w , DatasetUtilities . findRangeBounds ( h ) ) ; } } Collection o = v . getAnnotations ( ) ; Iterator t = o . iterator ( ) ; while ( t . hasNext ( ) ) { XYAnnotation x = ( XYAnnotation ) t . next ( ) ; if ( x instanceof XYAnnotationBoundsInfo ) { y . add ( x ) ; } } } } Iterator s = y . iterator ( ) ; while ( s . hasNext ( ) ) { XYAnnotationBoundsInfo i = ( XYAnnotationBoundsInfo ) s . next ( ) ; if ( i . getIncludeInDataBounds ( ) ) { if ( k ) { w = Range . combine ( w , i . getXRange ( ) ) ; } else { w = Range . combine ( w , i . getYRange ( ) ) ; } } } return w ; } } \\ No newline at end of file", "text_2": "public class test { public Range getDataRange ( ValueAxis c ) { Range a = null ; List u = new ArrayList ( ) ; List g = new ArrayList ( ) ; boolean e = true ; / / is it a domain axis ? int h = getDomainAxisIndex ( c ) ; if ( h > = 0 ) { e = true ; u . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( h ) ) ) ; if ( h = = 0 ) { / / grab the plot ' s annotations Iterator v = this . annotations . iterator ( ) ; while ( v . hasNext ( ) ) { XYAnnotation t = ( XYAnnotation ) v . next ( ) ; if ( t instanceof XYAnnotationBoundsInfo ) { g . add ( t ) ; } } } } / / or is it a range axis ? int s = getRangeAxisIndex ( c ) ; if ( s > = 0 ) { e = false ; u . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( s ) ) ) ; if ( s = = 0 ) { Iterator z = this . annotations . iterator ( ) ; while ( z . hasNext ( ) ) { XYAnnotation i = ( XYAnnotation ) z . next ( ) ; if ( i instanceof XYAnnotationBoundsInfo ) { g . add ( i ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator x = u . iterator ( ) ; while ( x . hasNext ( ) ) { XYDataset w = ( XYDataset ) x . next ( ) ; if ( w ! = null ) { XYItemRenderer d = getRendererForDataset ( w ) ; if ( e ) { if ( d ! = null ) { a = Range . combine ( a , d . findDomainBounds ( w ) ) ; } else { a = Range . combine ( a , DatasetUtilities . findDomainBounds ( w ) ) ; } } else { if ( d ! = null ) { a = Range . combine ( a , d . findRangeBounds ( w ) ) ; } else { a = Range . combine ( a , DatasetUtilities . findRangeBounds ( w ) ) ; } } if ( d ! = null ) { Collection j = d . getAnnotations ( ) ; Iterator y = j . iterator ( ) ; while ( y . hasNext ( ) ) { XYAnnotation b = ( XYAnnotation ) y . next ( ) ; if ( b instanceof XYAnnotationBoundsInfo ) { g . add ( b ) ; } } } } } Iterator k = g . iterator ( ) ; while ( k . hasNext ( ) ) { XYAnnotationBoundsInfo f = ( XYAnnotationBoundsInfo ) k . next ( ) ; if ( f . getIncludeInDataBounds ( ) ) { if ( e ) { a = Range . combine ( a , f . getXRange ( ) ) ; } else { a = Range . combine ( a , f . getYRange ( ) ) ; } } } return a ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number l , Number i ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem k = null ; int j = indexOf ( l ) ; if ( j > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem m = ( XYDataItem ) this . data . get ( j ) ; try { k = ( XYDataItem ) m . clone ( ) ; } catch ( CloneNotSupportedException h ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } m . setY ( i ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - j - 1 , new XYDataItem ( l , i ) ) ; } else { this . data . add ( new XYDataItem ( l , i ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return k ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number e , Number z ) { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem c = null ; int b = indexOf ( e ) ; if ( b > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem d = ( XYDataItem ) this . data . get ( b ) ; try { c = ( XYDataItem ) d . clone ( ) ; } catch ( CloneNotSupportedException a ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } d . setY ( z ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - b - 1 , new XYDataItem ( e , z ) ) ; } else { this . data . add ( new XYDataItem ( e , z ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return c ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected void drawHorizontalItem ( Graphics2D x , CategoryItemRendererState z , Rectangle2D d , CategoryPlot s , CategoryAxis d , ValueAxis a , StatisticalCategoryDataset p , int w , int u ) { RectangleEdge o = s . getDomainAxisEdge ( ) ; / / BAR Y double e = d . getCategoryStart ( u , getColumnCount ( ) , d , o ) ; int f = getRowCount ( ) ; int u = getColumnCount ( ) ; if ( f > 1 ) { double e = d . getHeight ( ) * getItemMargin ( ) / ( u * ( f - 1 ) ) ; e = e + w * ( z . getBarWidth ( ) + e ) ; } else { e = e + w * z . getBarWidth ( ) ; } / / BAR X Number g = p . getMeanValue ( w , u ) ; double z = g . doubleValue ( ) ; double p = 0 . 0 ; double w = getLowerClip ( ) ; double i = getUpperClip ( ) ; if ( i < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( z > = i ) { return ; / / bar is not visible } p = i ; if ( z < = w ) { z = w ; } } else if ( w < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( z > = i ) { z = i ; } else { if ( z < = w ) { z = w ; } } } else { / / cases 9 , 10 , 11 and 12 if ( z < = w ) { return ; / / bar is not visible } p = getLowerClip ( ) ; if ( z > = i ) { z = i ; } } RectangleEdge w = s . getRangeAxisEdge ( ) ; double q = a . valueToJava2D ( p , d , w ) ; double y = a . valueToJava2D ( z , d , w ) ; double a = Math . min ( y , q ) ;  double t = z . getBarWidth ( ) ; double m = Math . abs ( y - q ) ;  Rectangle2D r = new Rectangle2D . Double ( a , e , m , t ) ; Paint x = getItemPaint ( w , u ) ; x . setPaint ( x ) ; x . fill ( r ) ; if ( isDrawBarOutline ( ) & & z . getBarWidth ( ) > 3 ) { x . setStroke ( getItemStroke ( w , u ) ) ; x . setPaint ( getItemOutlinePaint ( w , u ) ) ; x . draw ( r ) ; } / / standard deviation lines double s = p . getStdDevValue ( w , u ) . doubleValue ( ) ; double d = a . valueToJava2D ( g . doubleValue ( ) + s , d , w ) ; double j = a . valueToJava2D ( g . doubleValue ( ) - s , d , w ) ; if ( this . errorIndicatorStroke ! = null ) { x . setStroke ( this . errorIndicatorStroke ) ; } else { x . setStroke ( getItemOutlineStroke ( w , u ) ) ; } if ( this . errorIndicatorPaint ! = null ) { x . setPaint ( this . errorIndicatorPaint ) ; } else { x . setPaint ( getItemOutlinePaint ( w , u ) ) ; } Line2D i = null ; i = new Line2D . Double ( j , e + t / 2 . 0d , d , e + t / 2 . 0d ) ; x . draw ( i ) ; i = new Line2D . Double ( d , e + t * 0 . 25 , d , e + t * 0 . 75 ) ; x . draw ( i ) ; i = new Line2D . Double ( j , e + t * 0 . 25 , j , e + t * 0 . 75 ) ; x . draw ( i ) ;  CategoryItemLabelGenerator b = getItemLabelGenerator ( w , u ) ; if ( b ! = null & & isItemLabelVisible ( w , u ) ) { drawItemLabel ( x , p , w , u , s , b , r , ( z < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection j = z . getEntityCollection ( ) ; if ( j ! = null ) { addItemEntity ( j , p , w , u , r ) ; } } protected void drawVerticalItem ( Graphics2D n , CategoryItemRendererState q , Rectangle2D t , CategoryPlot k , CategoryAxis z , ValueAxis v , StatisticalCategoryDataset f , int y , int o ) { RectangleEdge y = k . getDomainAxisEdge ( ) ; / / BAR X double g = z . getCategoryStart ( o , getColumnCount ( ) , t , y ) ; int b = getRowCount ( ) ; int h = getColumnCount ( ) ; if ( b > 1 ) { double c = t . getWidth ( ) * getItemMargin ( ) / ( h * ( b - 1 ) ) ; g = g + y * ( q . getBarWidth ( ) + c ) ; } else { g = g + y * q . getBarWidth ( ) ; } / / BAR Y Number a = f . getMeanValue ( y , o ) ; double c = a . doubleValue ( ) ; double u = 0 . 0 ; double h = getLowerClip ( ) ; double x = getUpperClip ( ) ; if ( x < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( c > = x ) { return ; / / bar is not visible } u = x ; if ( c < = h ) { c = h ; } } else if ( h < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( c > = x ) { c = x ; } else { if ( c < = h ) { c = h ; } } } else { / / cases 9 , 10 , 11 and 12 if ( c < = h ) { return ; / / bar is not visible } u = getLowerClip ( ) ; if ( c > = x ) { c = x ; } } RectangleEdge s = k . getRangeAxisEdge ( ) ; double l = v . valueToJava2D ( u , t , s ) ; double c = v . valueToJava2D ( c , t , s ) ; double l = Math . min ( c , l ) ;  double k = q . getBarWidth ( ) ; double n = Math . abs ( c - l ) ;  Rectangle2D r = new Rectangle2D . Double ( g , l , k , n ) ; Paint q = getItemPaint ( y , o ) ; n . setPaint ( q ) ; n . fill ( r ) ; if ( isDrawBarOutline ( ) & & q . getBarWidth ( ) > 3 ) { n . setStroke ( getItemStroke ( y , o ) ) ; n . setPaint ( getItemOutlinePaint ( y , o ) ) ; n . draw ( r ) ; } / / standard deviation lines double m = f . getStdDevValue ( y , o ) . doubleValue ( ) ; double v = v . valueToJava2D ( a . doubleValue ( ) + m , t , s ) ; double r = v . valueToJava2D ( a . doubleValue ( ) - m , t , s ) ;  if ( this . errorIndicatorStroke ! = null ) { n . setStroke ( this . errorIndicatorStroke ) ; } else { n . setStroke ( getItemOutlineStroke ( y , o ) ) ; } if ( this . errorIndicatorPaint ! = null ) { n . setPaint ( this . errorIndicatorPaint ) ; } else { n . setPaint ( getItemOutlinePaint ( y , o ) ) ; } Line2D b = null ; b = new Line2D . Double ( g + k / 2 . 0d , r , g + k / 2 . 0d , v ) ; n . draw ( b ) ; b = new Line2D . Double ( g + k / 2 . 0d - 5 . 0d , v , g + k / 2 . 0d + 5 . 0d , v ) ; n . draw ( b ) ; b = new Line2D . Double ( g + k / 2 . 0d - 5 . 0d , r , g + k / 2 . 0d + 5 . 0d , r ) ; n . draw ( b ) ;  CategoryItemLabelGenerator v = getItemLabelGenerator ( y , o ) ; if ( v ! = null & & isItemLabelVisible ( y , o ) ) { drawItemLabel ( n , f , y , o , k , v , r , ( c < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection t = q . getEntityCollection ( ) ; if ( t ! = null ) { addItemEntity ( t , f , y , o , r ) ; } } } \\ No newline at end of file", "text_2": "public class test { protected void drawHorizontalItem ( Graphics2D g , CategoryItemRendererState y , Rectangle2D d , CategoryPlot h , CategoryAxis u , ValueAxis x , StatisticalCategoryDataset e , int k , int b ) { RectangleEdge k = h . getDomainAxisEdge ( ) ; / / BAR Y double l = u . getCategoryStart ( b , getColumnCount ( ) , d , k ) ; int x = getRowCount ( ) ; int r = getColumnCount ( ) ; if ( x > 1 ) { double y = d . getHeight ( ) * getItemMargin ( ) / ( r * ( x - 1 ) ) ; l = l + k * ( y . getBarWidth ( ) + y ) ; } else { l = l + k * y . getBarWidth ( ) ; } / / BAR X Number i = e . getMeanValue ( k , b ) ; if ( i = = null ) { return ; } double e = i . doubleValue ( ) ; double i = 0 . 0 ; double v = getLowerClip ( ) ; double z = getUpperClip ( ) ; if ( z < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( e > = z ) { return ; / / bar is not visible } i = z ; if ( e < = v ) { e = v ; } } else if ( v < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( e > = z ) { e = z ; } else { if ( e < = v ) { e = v ; } } } else { / / cases 9 , 10 , 11 and 12 if ( e < = v ) { return ; / / bar is not visible } i = getLowerClip ( ) ; if ( e > = z ) { e = z ; } } RectangleEdge a = h . getRangeAxisEdge ( ) ; double t = x . valueToJava2D ( i , d , a ) ; double k = x . valueToJava2D ( e , d , a ) ; double m = Math . min ( k , t ) ;  double d = y . getBarWidth ( ) ; double b = Math . abs ( k - t ) ;  Rectangle2D w = new Rectangle2D . Double ( m , l , b , d ) ; Paint r = getItemPaint ( k , b ) ; g . setPaint ( r ) ; g . fill ( w ) ; if ( isDrawBarOutline ( ) & & y . getBarWidth ( ) > 3 ) { g . setStroke ( getItemStroke ( k , b ) ) ; g . setPaint ( getItemOutlinePaint ( k , b ) ) ; g . draw ( w ) ; } / / standard deviation lines Number w = e . getStdDevValue ( k , b ) ; if ( w ! = null ) { double d = w . doubleValue ( ) ; double q = x . valueToJava2D ( i . doubleValue ( ) + d , d , a ) ; double z = x . valueToJava2D ( i . doubleValue ( ) - d , d , a ) ;  if ( this . errorIndicatorStroke ! = null ) { g . setStroke ( this . errorIndicatorStroke ) ; } else { g . setStroke ( getItemOutlineStroke ( k , b ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g . setPaint ( this . errorIndicatorPaint ) ; } else { g . setPaint ( getItemOutlinePaint ( k , b ) ) ; } Line2D s = null ; s = new Line2D . Double ( z , l + d / 2 . 0d , q , l + d / 2 . 0d ) ; g . draw ( s ) ; s = new Line2D . Double ( q , l + d * 0 . 25 , q , l + d * 0 . 75 ) ; g . draw ( s ) ; s = new Line2D . Double ( z , l + d * 0 . 25 , z , l + d * 0 . 75 ) ; g . draw ( s ) ; } CategoryItemLabelGenerator p = getItemLabelGenerator ( k , b ) ; if ( p ! = null & & isItemLabelVisible ( k , b ) ) { drawItemLabel ( g , e , k , b , h , p , w , ( e < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection z = y . getEntityCollection ( ) ; if ( z ! = null ) { addItemEntity ( z , e , k , b , w ) ; } } protected void drawVerticalItem ( Graphics2D x , CategoryItemRendererState f , Rectangle2D h , CategoryPlot h , CategoryAxis q , ValueAxis c , StatisticalCategoryDataset g , int f , int m ) { RectangleEdge t = h . getDomainAxisEdge ( ) ; / / BAR X double j = q . getCategoryStart ( m , getColumnCount ( ) , h , t ) ; int l = getRowCount ( ) ; int n = getColumnCount ( ) ; if ( l > 1 ) { double p = h . getWidth ( ) * getItemMargin ( ) / ( n * ( l - 1 ) ) ; j = j + f * ( f . getBarWidth ( ) + p ) ; } else { j = j + f * f . getBarWidth ( ) ; } / / BAR Y Number o = g . getMeanValue ( f , m ) ; if ( o = = null ) { return ; } double f = o . doubleValue ( ) ; double j = 0 . 0 ; double j = getLowerClip ( ) ; double u = getUpperClip ( ) ; if ( u < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( f > = u ) { return ; / / bar is not visible } j = u ; if ( f < = j ) { f = j ; } } else if ( j < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( f > = u ) { f = u ; } else { if ( f < = j ) { f = j ; } } } else { / / cases 9 , 10 , 11 and 12 if ( f < = j ) { return ; / / bar is not visible } j = getLowerClip ( ) ; if ( f > = u ) { f = u ; } } RectangleEdge c = h . getRangeAxisEdge ( ) ; double a = c . valueToJava2D ( j , h , c ) ; double e = c . valueToJava2D ( f , h , c ) ; double y = Math . min ( e , a ) ;  double v = f . getBarWidth ( ) ; double o = Math . abs ( e - a ) ;  Rectangle2D i = new Rectangle2D . Double ( j , y , v , o ) ; Paint a = getItemPaint ( f , m ) ; x . setPaint ( a ) ; x . fill ( i ) ; if ( isDrawBarOutline ( ) & & f . getBarWidth ( ) > 3 ) { x . setStroke ( getItemStroke ( f , m ) ) ; x . setPaint ( getItemOutlinePaint ( f , m ) ) ; x . draw ( i ) ; } / / standard deviation lines Number m = g . getStdDevValue ( f , m ) ; if ( m ! = null ) { double b = m . doubleValue ( ) ; double n = c . valueToJava2D ( o . doubleValue ( ) + b , h , c ) ; double l = c . valueToJava2D ( o . doubleValue ( ) - b , h , c ) ;  if ( this . errorIndicatorStroke ! = null ) { x . setStroke ( this . errorIndicatorStroke ) ; } else { x . setStroke ( getItemOutlineStroke ( f , m ) ) ; } if ( this . errorIndicatorPaint ! = null ) { x . setPaint ( this . errorIndicatorPaint ) ; } else { x . setPaint ( getItemOutlinePaint ( f , m ) ) ; } Line2D c = null ; c = new Line2D . Double ( j + v / 2 . 0d , l , j + v / 2 . 0d , n ) ; x . draw ( c ) ; c = new Line2D . Double ( j + v / 2 . 0d - 5 . 0d , n , j + v / 2 . 0d + 5 . 0d , n ) ; x . draw ( c ) ; c = new Line2D . Double ( j + v / 2 . 0d - 5 . 0d , l , j + v / 2 . 0d + 5 . 0d , l ) ; x . draw ( c ) ; }  CategoryItemLabelGenerator g = getItemLabelGenerator ( f , m ) ; if ( g ! = null & & isItemLabelVisible ( f , m ) ) { drawItemLabel ( x , g , f , m , h , g , i , ( f < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection s = f . getEntityCollection ( ) ; if ( s ! = null ) { addItemEntity ( s , g , f , m , i ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void removeColumn ( Comparable w ) { Iterator v = this . rows . iterator ( ) ; while ( v . hasNext ( ) ) { DefaultKeyedValues x = ( DefaultKeyedValues ) v . next ( ) ; x . removeValue ( w ) ; } this . columnKeys . remove ( w ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeColumn ( Comparable l ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( l ) ) { throw new UnknownKeyException ( \" Unknown key : \" + l ) ; } Iterator n = this . rows . iterator ( ) ; while ( n . hasNext ( ) ) { DefaultKeyedValues k = ( DefaultKeyedValues ) n . next ( ) ; int m = k . getIndex ( l ) ; if ( m > = 0 ) { k . removeValue ( l ) ; } } this . columnKeys . remove ( l ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int i ) { this . keys . remove ( i ) ; this . values . remove ( i ) ; if ( i < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable h ) { int f = getIndex ( h ) ; if ( f < 0 ) { return ; } removeValue ( f ) ; } public void removeColumn ( Comparable g ) { Iterator j = this . rows . iterator ( ) ; while ( j . hasNext ( ) ) { DefaultKeyedValues k = ( DefaultKeyedValues ) j . next ( ) ; k . removeValue ( g ) ; } this . columnKeys . remove ( g ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( Comparable e ) { int z = getIndex ( e ) ; if ( z < 0 ) { throw new UnknownKeyException ( \" The key ( \" + e + \" ) is not recognised . \" ) ; } removeValue ( z ) ; } public void removeValue ( int a ) { this . keys . remove ( a ) ; this . values . remove ( a ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable f ) { if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( f ) ) { throw new UnknownKeyException ( \" Unknown key : \" + f ) ; } Iterator c = this . rows . iterator ( ) ; while ( c . hasNext ( ) ) { DefaultKeyedValues d = ( DefaultKeyedValues ) c . next ( ) ; int b = d . getIndex ( f ) ; if ( b > = 0 ) { d . removeValue ( f ) ; } } this . columnKeys . remove ( f ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public boolean removeDomainMarker ( int w , Marker f , Layer x , boolean a ) { ArrayList z ; if ( x = = Layer . FOREGROUND ) { z = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( w ) ) ; } else { z = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( w ) ) ; } boolean u = z . remove ( f ) ; if ( u & & a ) { fireChangeEvent ( ) ; } return u ; } public boolean removeRangeMarker ( int r , Marker v , Layer g , boolean j ) { if ( v = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList b ; if ( g = = Layer . FOREGROUND ) { b = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( r ) ) ; } else { b = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( r ) ) ; } boolean k = b . remove ( v ) ; if ( k & & j ) { fireChangeEvent ( ) ; } return k ; } public boolean removeRangeMarker ( int c , Marker q , Layer o , boolean t ) { if ( q = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList s ; if ( o = = Layer . FOREGROUND ) { s = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( c ) ) ; } else { s = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( c ) ) ; } boolean i = s . remove ( q ) ; if ( i & & t ) { fireChangeEvent ( ) ; } return i ; } public boolean removeDomainMarker ( int l , Marker d , Layer y , boolean h ) { ArrayList p ; if ( y = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( l ) ) ; } else { p = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( l ) ) ; } boolean e = p . remove ( d ) ; if ( e & & h ) { fireChangeEvent ( ) ; } return e ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int x , Marker q , Layer k , boolean h ) { ArrayList p ; if ( k = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( x ) ) ; } else { p = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( x ) ) ; } if ( p = = null ) { return false ; } boolean i = p . remove ( q ) ; if ( i & & h ) { fireChangeEvent ( ) ; } return i ; } public boolean removeRangeMarker ( int t , Marker s , Layer f , boolean r ) { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList u ; if ( f = = Layer . FOREGROUND ) { u = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( t ) ) ; } else { u = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( t ) ) ; } if ( u = = null ) { return false ; } boolean l = u . remove ( s ) ; if ( l & & r ) { fireChangeEvent ( ) ; } return l ; } public boolean removeDomainMarker ( int c , Marker v , Layer d , boolean n ) { ArrayList z ; if ( d = = Layer . FOREGROUND ) { z = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( c ) ) ; } else { z = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( c ) ) ; } if ( z = = null ) { return false ; } boolean e = z . remove ( v ) ; if ( e & & n ) { fireChangeEvent ( ) ; } return e ; } public boolean removeRangeMarker ( int w , Marker j , Layer g , boolean o ) { if ( j = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList y ; if ( g = = Layer . FOREGROUND ) { y = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( w ) ) ; } else { y = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( w ) ) ; } if ( y = = null ) { return false ; } boolean m = y . remove ( j ) ; if ( m & & o ) { fireChangeEvent ( ) ; } return m ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset p ) { super ( ) ; this . dataset = p ; PiePlot q = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( q ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset q ) { super ( ) ; this . dataset = q ; PiePlot s = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( s ) ; setDataset ( q ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 1}
{"text_1": "public class test { public Range getDataRange ( ValueAxis a ) { Range w = null ; List n = new ArrayList ( ) ; List x = new ArrayList ( ) ; boolean y = true ; / / is it a domain axis ? int v = getDomainAxisIndex ( a ) ; if ( v > = 0 ) { y = true ; n . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( v ) ) ) ; if ( v = = 0 ) { / / grab the plot ' s annotations Iterator s = this . annotations . iterator ( ) ; while ( s . hasNext ( ) ) { XYAnnotation c = ( XYAnnotation ) s . next ( ) ; if ( c instanceof XYAnnotationBoundsInfo ) { x . add ( c ) ; } } } } / / or is it a range axis ? int o = getRangeAxisIndex ( a ) ; if ( o > = 0 ) { y = false ; n . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( o ) ) ) ; if ( o = = 0 ) { Iterator t = this . annotations . iterator ( ) ; while ( t . hasNext ( ) ) { XYAnnotation l = ( XYAnnotation ) t . next ( ) ; if ( l instanceof XYAnnotationBoundsInfo ) { x . add ( l ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator k = n . iterator ( ) ; while ( k . hasNext ( ) ) { XYDataset p = ( XYDataset ) k . next ( ) ; if ( p ! = null ) { XYItemRenderer q = getRendererForDataset ( p ) ; if ( y ) { if ( q ! = null ) { w = Range . combine ( w , q . findDomainBounds ( p ) ) ; } else { w = Range . combine ( w , DatasetUtilities . findDomainBounds ( p ) ) ; } } else { if ( q ! = null ) { w = Range . combine ( w , q . findRangeBounds ( p ) ) ; } else { w = Range . combine ( w , DatasetUtilities . findRangeBounds ( p ) ) ; } } Collection r = q . getAnnotations ( ) ; Iterator u = r . iterator ( ) ; while ( u . hasNext ( ) ) { XYAnnotation m = ( XYAnnotation ) u . next ( ) ; if ( m instanceof XYAnnotationBoundsInfo ) { x . add ( m ) ; } } } } Iterator z = x . iterator ( ) ; while ( z . hasNext ( ) ) { XYAnnotationBoundsInfo b = ( XYAnnotationBoundsInfo ) z . next ( ) ; if ( b . getIncludeInDataBounds ( ) ) { if ( y ) { w = Range . combine ( w , b . getXRange ( ) ) ; } else { w = Range . combine ( w , b . getYRange ( ) ) ; } } } return w ; } } \\ No newline at end of file", "text_2": "public class test { public Range getDataRange ( ValueAxis g ) { Range f = null ; List q = new ArrayList ( ) ; List h = new ArrayList ( ) ; boolean m = true ; / / is it a domain axis ? int i = getDomainAxisIndex ( g ) ; if ( i > = 0 ) { m = true ; q . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( i ) ) ) ; if ( i = = 0 ) { / / grab the plot ' s annotations Iterator d = this . annotations . iterator ( ) ; while ( d . hasNext ( ) ) { XYAnnotation n = ( XYAnnotation ) d . next ( ) ; if ( n instanceof XYAnnotationBoundsInfo ) { h . add ( n ) ; } } } } / / or is it a range axis ? int o = getRangeAxisIndex ( g ) ; if ( o > = 0 ) { m = false ; q . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( o ) ) ) ; if ( o = = 0 ) { Iterator k = this . annotations . iterator ( ) ; while ( k . hasNext ( ) ) { XYAnnotation p = ( XYAnnotation ) k . next ( ) ; if ( p instanceof XYAnnotationBoundsInfo ) { h . add ( p ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator s = q . iterator ( ) ; while ( s . hasNext ( ) ) { XYDataset l = ( XYDataset ) s . next ( ) ; if ( l ! = null ) { XYItemRenderer r = getRendererForDataset ( l ) ; if ( m ) { if ( r ! = null ) { f = Range . combine ( f , r . findDomainBounds ( l ) ) ; } else { f = Range . combine ( f , DatasetUtilities . findDomainBounds ( l ) ) ; } } else { if ( r ! = null ) { f = Range . combine ( f , r . findRangeBounds ( l ) ) ; } else { f = Range . combine ( f , DatasetUtilities . findRangeBounds ( l ) ) ; } } if ( r ! = null ) { Collection v = r . getAnnotations ( ) ; Iterator j = v . iterator ( ) ; while ( j . hasNext ( ) ) { XYAnnotation t = ( XYAnnotation ) j . next ( ) ; if ( t instanceof XYAnnotationBoundsInfo ) { h . add ( t ) ; } } }  } } Iterator u = h . iterator ( ) ; while ( u . hasNext ( ) ) { XYAnnotationBoundsInfo e = ( XYAnnotationBoundsInfo ) u . next ( ) ; if ( e . getIncludeInDataBounds ( ) ) { if ( m ) { f = Range . combine ( f , e . getXRange ( ) ) ; } else { f = Range . combine ( f , e . getYRange ( ) ) ; } } } return f ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer x , Graphics2D t , RectangleConstraint p ) { double [ ] b = new double [ 5 ] ; double [ ] u = new double [ 5 ] ; b [ 0 ] = p . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( b [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , p . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D a = this . topBlock . arrange ( t , s ) ; u [ 0 ] = a . height ; } b [ 1 ] = b [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint v = new RectangleConstraint ( b [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , p . getHeight ( ) - u [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D r = this . bottomBlock . arrange ( t , v ) ; u [ 1 ] = r . height ; } u [ 2 ] = p . getHeight ( ) - u [ 1 ] - u [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , p . getWidth ( ) ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D o = this . leftBlock . arrange ( t , w ) ; b [ 2 ] = o . width ; } u [ 3 ] = u [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , p . getWidth ( ) - b [ 2 ] ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . rightBlock . arrange ( t , y ) ; b [ 3 ] = z . width ; } u [ 4 ] = u [ 2 ] ; b [ 4 ] = p . getWidth ( ) - b [ 3 ] - b [ 2 ] ; RectangleConstraint q = new RectangleConstraint ( b [ 4 ] , u [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( t , q ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , b [ 0 ] , u [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] + u [ 2 ] , b [ 1 ] , u [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] , b [ 2 ] , u [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( b [ 2 ] + b [ 4 ] , u [ 0 ] , b [ 3 ] , u [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( b [ 2 ] , u [ 0 ] , b [ 4 ] , u [ 4 ] ) ) ; } return new Size2D ( p . getWidth ( ) , p . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer a , Graphics2D w , RectangleConstraint v ) { double [ ] s = new double [ 5 ] ; double [ ] c = new double [ 5 ] ; s [ 0 ] = v . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D b = this . topBlock . arrange ( w , q ) ; c [ 0 ] = b . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) - c [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D z = this . bottomBlock . arrange ( w , r ) ; c [ 1 ] = z . height ; } c [ 2 ] = v . getHeight ( ) - c [ 1 ] - c [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D t = this . leftBlock . arrange ( w , p ) ; s [ 2 ] = t . width ; } c [ 3 ] = c [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( v . getWidth ( ) - s [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . rightBlock . arrange ( w , u ) ; s [ 3 ] = y . width ; } c [ 4 ] = c [ 2 ] ; s [ 4 ] = v . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint x = new RectangleConstraint ( s [ 4 ] , c [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( w , x ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , c [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] + c [ 2 ] , s [ 1 ] , c [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] , s [ 2 ] , c [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , c [ 0 ] , s [ 3 ] , c [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , c [ 0 ] , s [ 4 ] , c [ 4 ] ) ) ; } return new Size2D ( v . getWidth ( ) , v . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double u , Paint q , Stroke s , Paint p , Stroke t , float r ) { super ( q , s , q , s , r ) ; this . value = u ; } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double y , Paint w , Stroke x , Paint v , Stroke u , float t ) { super ( w , x , v , x , t ) ; this . value = y ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Week ( Date r , TimeZone s ) { / / defer argument checking . . . this ( r , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Week ( Date i , TimeZone h ) { / / defer argument checking . . . this ( i , h , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static Range iterateRangeBounds ( XYDataset n , boolean d ) { double x = Double . POSITIVE_INFINITY ; double p = Double . NEGATIVE_INFINITY ; int t = n . getSeriesCount ( ) ; / / handle three cases by dataset type if ( d & & n instanceof IntervalXYDataset ) { / / handle special case of IntervalXYDataset IntervalXYDataset i = ( IntervalXYDataset ) n ; for ( int l = 0 ; l < t ; l + + ) { int l = n . getItemCount ( l ) ; for ( int r = 0 ; r < l ; r + + ) { double f = i . getStartYValue ( l , r ) ; double n = i . getEndYValue ( l , r ) ; if ( ! Double . isNaN ( f ) ) { x = Math . min ( x , f ) ; } if ( ! Double . isNaN ( n ) ) { p = Math . max ( p , n ) ; } } } } else if ( d & & n instanceof OHLCDataset ) { / / handle special case of OHLCDataset OHLCDataset o = ( OHLCDataset ) n ; for ( int q = 0 ; q < t ; q + + ) { int t = n . getItemCount ( q ) ; for ( int r = 0 ; r < t ; r + + ) { double j = o . getLowValue ( q , r ) ; double k = o . getHighValue ( q , r ) ; if ( ! Double . isNaN ( j ) ) { x = Math . min ( x , j ) ; } if ( ! Double . isNaN ( k ) ) { p = Math . max ( p , k ) ; } } } } else { / / standard case - plain XYDataset for ( int q = 0 ; q < t ; q + + ) { int a = n . getItemCount ( q ) ; for ( int m = 0 ; m < a ; m + + ) { double y = n . getYValue ( q , m ) ; if ( ! Double . isNaN ( y ) ) { x = Math . min ( x , y ) ; p = Math . max ( p , y ) ; } } } } if ( x = = Double . POSITIVE_INFINITY ) { return null ; } else { return new Range ( x , p ) ; } } public static Range iterateDomainBounds ( XYDataset m , boolean b ) { if ( m = = null ) { throw new IllegalArgumentException ( \" Null ' dataset ' argument . \" ) ; } double o = Double . POSITIVE_INFINITY ; double v = Double . NEGATIVE_INFINITY ; int s = m . getSeriesCount ( ) ; double p ; double z ; if ( b & & m instanceof IntervalXYDataset ) { IntervalXYDataset g = ( IntervalXYDataset ) m ; for ( int h = 0 ; h < s ; h + + ) { int c = m . getItemCount ( h ) ; for ( int w = 0 ; w < c ; w + + ) { p = g . getStartXValue ( h , w ) ; z = g . getEndXValue ( h , w ) ; if ( ! Double . isNaN ( p ) ) { o = Math . min ( o , p ) ; } if ( ! Double . isNaN ( z ) ) { v = Math . max ( v , z ) ; } } } } else { for ( int e = 0 ; e < s ; e + + ) { int u = m . getItemCount ( e ) ; for ( int s = 0 ; s < u ; s + + ) { p = m . getXValue ( e , s ) ; z = p ; if ( ! Double . isNaN ( p ) ) { o = Math . min ( o , p ) ; v = Math . max ( v , z ) ; } } } } if ( o > v ) { return null ; } else { return new Range ( o , v ) ; } } } \\ No newline at end of file", "text_2": "public class test { public static Range iterateRangeBounds ( XYDataset a , boolean m ) { double j = Double . POSITIVE_INFINITY ; double n = Double . NEGATIVE_INFINITY ; int v = a . getSeriesCount ( ) ; / / handle three cases by dataset type if ( m & & a instanceof IntervalXYDataset ) { / / handle special case of IntervalXYDataset IntervalXYDataset y = ( IntervalXYDataset ) a ; for ( int b = 0 ; b < v ; b + + ) { int q = a . getItemCount ( b ) ; for ( int d = 0 ; d < q ; d + + ) { double q = y . getYValue ( b , d ) ; double f = y . getStartYValue ( b , d ) ; double r = y . getEndYValue ( b , d ) ; if ( ! Double . isNaN ( q ) ) { j = Math . min ( j , q ) ; n = Math . max ( n , q ) ; } if ( ! Double . isNaN ( f ) ) { j = Math . min ( j , f ) ; n = Math . max ( n , f ) ; } if ( ! Double . isNaN ( r ) ) { j = Math . min ( j , r ) ; n = Math . max ( n , r ) ; } } } } else if ( m & & a instanceof OHLCDataset ) { / / handle special case of OHLCDataset OHLCDataset k = ( OHLCDataset ) a ; for ( int k = 0 ; k < v ; k + + ) { int e = a . getItemCount ( k ) ; for ( int p = 0 ; p < e ; p + + ) { double r = k . getLowValue ( k , p ) ; double w = k . getHighValue ( k , p ) ; if ( ! Double . isNaN ( r ) ) { j = Math . min ( j , r ) ; } if ( ! Double . isNaN ( w ) ) { n = Math . max ( n , w ) ; } } } } else { / / standard case - plain XYDataset for ( int s = 0 ; s < v ; s + + ) { int t = a . getItemCount ( s ) ; for ( int z = 0 ; z < t ; z + + ) { double s = a . getYValue ( s , z ) ; if ( ! Double . isNaN ( s ) ) { j = Math . min ( j , s ) ; n = Math . max ( n , s ) ; } } } } if ( j = = Double . POSITIVE_INFINITY ) { return null ; } else { return new Range ( j , n ) ; } } public static Range iterateDomainBounds ( XYDataset l , boolean x ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' dataset ' argument . \" ) ; } double l = Double . POSITIVE_INFINITY ; double j = Double . NEGATIVE_INFINITY ; int p = l . getSeriesCount ( ) ; double m ; double n ; if ( x & & l instanceof IntervalXYDataset ) { IntervalXYDataset g = ( IntervalXYDataset ) l ; for ( int i = 0 ; i < p ; i + + ) { int o = l . getItemCount ( i ) ; for ( int u = 0 ; u < o ; u + + ) { double c = g . getXValue ( i , u ) ; m = g . getStartXValue ( i , u ) ; n = g . getEndXValue ( i , u ) ; if ( ! Double . isNaN ( c ) ) { l = Math . min ( l , c ) ; j = Math . max ( j , c ) ; } if ( ! Double . isNaN ( m ) ) { l = Math . min ( l , m ) ; j = Math . max ( j , m ) ; } if ( ! Double . isNaN ( n ) ) { l = Math . min ( l , n ) ; j = Math . max ( j , n ) ; } } } } else { for ( int h = 0 ; h < p ; h + + ) { int o = l . getItemCount ( h ) ; for ( int i = 0 ; i < o ; i + + ) { m = l . getXValue ( h , i ) ; n = m ; if ( ! Double . isNaN ( m ) ) { l = Math . min ( l , m ) ; j = Math . max ( j , n ) ; } } } } if ( l > j ) { return null ; } else { return new Range ( l , j ) ; } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( e . compareTo ( f ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean g = false ; int i = getIndex ( e ) ; if ( i < 0 ) { i = - ( i + 1 ) ; if ( i = = this . data . size ( ) ) { g = true ; / / start is after last data item } } int h = getIndex ( f ) ; if ( h < 0 ) { / / end period is not in original series h = - ( h + 1 ) ; / / this is first item AFTER end period h = h - 1 ; / / so this is last item BEFORE end } if ( h < 0 ) { g = true ; } if ( g ) { TimeSeries d = ( TimeSeries ) super . clone ( ) ; d . data = new java . util . ArrayList ( ) ; return d ; } else { return createCopy ( i , h ) ; } }", "text_2": "if ( e . compareTo ( f ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean h = false ; int i = getIndex ( e ) ; if ( i < 0 ) { i = - ( i + 1 ) ; if ( i = = this . data . size ( ) ) { h = true ; / / start is after last data item } } int g = getIndex ( f ) ; if ( g < 0 ) { / / end period is not in original series g = - ( g + 1 ) ; / / this is first item AFTER end period g = g - 1 ; / / so this is last item BEFORE end } if ( g < i ) { h = true ; } if ( h ) { TimeSeries j = ( TimeSeries ) super . clone ( ) ; j . data = new java . util . ArrayList ( ) ; return j ; } else { return createCopy ( i , g ) ; } }", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis g ) { return this . domainAxes . indexOf ( g ) ; }  public int getRangeAxisIndex ( ValueAxis h ) { int i = this . rangeAxes . indexOf ( h ) ; if ( i < 0 ) { / / try the parent plot Plot f = getParent ( ) ; if ( f instanceof CategoryPlot ) { CategoryPlot e = ( CategoryPlot ) f ; i = e . getRangeAxisIndex ( h ) ; } } return i ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis e ) { if ( e = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( e ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { protected AxisState drawLabel ( String e , Graphics2D q , Rectangle2D c , Rectangle2D t , RectangleEdge i , AxisState f , PlotRenderingInfo b ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( e = = null ) | | ( e . equals ( \" \" ) ) ) { return f ; } Font j = getLabelFont ( ) ; RectangleInsets l = getLabelInsets ( ) ; q . setFont ( j ) ; q . setPaint ( getLabelPaint ( ) ) ; FontMetrics u = q . getFontMetrics ( ) ; Rectangle2D g = TextUtilities . getTextBounds ( e , q , u ) ; Shape k = null ; if ( i = = RectangleEdge . TOP ) { AffineTransform v = AffineTransform . getRotateInstance ( getLabelAngle ( ) , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape s = v . createTransformedShape ( g ) ; g = s . getBounds2D ( ) ; float d = ( float ) g . getWidth ( ) ; float w = ( float ) g . getHeight ( ) ; float g = ( float ) t . getCenterX ( ) ; float a = ( float ) ( f . getCursor ( ) - l . getBottom ( ) - w / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , g , a , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( g - d / 2 . 0f , a - w / 2 . 0f , d , w ) ; f . cursorUp ( l . getTop ( ) + g . getHeight ( ) + l . getBottom ( ) ) ; } else if ( i = = RectangleEdge . BOTTOM ) { AffineTransform m = AffineTransform . getRotateInstance ( getLabelAngle ( ) , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape o = m . createTransformedShape ( g ) ; g = o . getBounds2D ( ) ; float z = ( float ) g . getWidth ( ) ; float f = ( float ) g . getHeight ( ) ; float n = ( float ) t . getCenterX ( ) ; float h = ( float ) ( f . getCursor ( ) + l . getTop ( ) + f / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , n , h , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( n - z / 2 . 0f , h - f / 2 . 0f , z , f ) ; f . cursorDown ( l . getTop ( ) + g . getHeight ( ) + l . getBottom ( ) ) ; } else if ( i = = RectangleEdge . LEFT ) { AffineTransform a = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape e = a . createTransformedShape ( g ) ; g = e . getBounds2D ( ) ; float d = ( float ) g . getWidth ( ) ; float v = ( float ) g . getHeight ( ) ; float y = ( float ) ( f . getCursor ( ) - l . getRight ( ) - d / 2 . 0 ) ; float x = ( float ) t . getCenterY ( ) ; TextUtilities . drawRotatedString ( e , q , y , x , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( y - d / 2 . 0f , x - v / 2 . 0f , d , v ) ; f . cursorLeft ( l . getLeft ( ) + g . getWidth ( ) + l . getRight ( ) ) ; } else if ( i = = RectangleEdge . RIGHT ) { AffineTransform p = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape y = p . createTransformedShape ( g ) ; g = y . getBounds2D ( ) ; float b = ( float ) g . getWidth ( ) ; float c = ( float ) g . getHeight ( ) ; float w = ( float ) ( f . getCursor ( ) + l . getLeft ( ) + b / 2 . 0 ) ; float x = ( float ) ( t . getY ( ) + t . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , w , x , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; k = new Rectangle2D . Float ( w - b / 2 . 0f , x - c / 2 . 0f , b , c ) ; f . cursorRight ( l . getLeft ( ) + g . getWidth ( ) + l . getRight ( ) ) ; } if ( b ! = null & & k ! = null ) { ChartRenderingInfo z = b . getOwner ( ) ; EntityCollection r = z . getEntityCollection ( ) ; if ( r ! = null ) { r . add ( new AxisLabelEntity ( this , k , this . labelToolTip , this . labelURL ) ) ; } } return f ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String v , Graphics2D r , Rectangle2D v , Rectangle2D x , RectangleEdge k , AxisState a , PlotRenderingInfo g ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( v = = null ) | | ( v . equals ( \" \" ) ) ) { return a ; } Font q = getLabelFont ( ) ; RectangleInsets t = getLabelInsets ( ) ; r . setFont ( q ) ; r . setPaint ( getLabelPaint ( ) ) ; FontMetrics x = r . getFontMetrics ( ) ; Rectangle2D e = TextUtilities . getTextBounds ( v , r , x ) ; Shape c = null ; if ( k = = RectangleEdge . TOP ) { AffineTransform z = AffineTransform . getRotateInstance ( getLabelAngle ( ) , e . getCenterX ( ) , e . getCenterY ( ) ) ; Shape d = z . createTransformedShape ( e ) ; e = d . getBounds2D ( ) ; float t = ( float ) e . getWidth ( ) ; float r = ( float ) e . getHeight ( ) ; float o = ( float ) x . getCenterX ( ) ; float q = ( float ) ( a . getCursor ( ) - t . getBottom ( ) - r / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , r , o , q , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; c = new Rectangle2D . Float ( o - t / 2 . 0f , q - r / 2 . 0f , t , r ) ; a . cursorUp ( t . getTop ( ) + e . getHeight ( ) + t . getBottom ( ) ) ; } else if ( k = = RectangleEdge . BOTTOM ) { AffineTransform u = AffineTransform . getRotateInstance ( getLabelAngle ( ) , e . getCenterX ( ) , e . getCenterY ( ) ) ; Shape s = u . createTransformedShape ( e ) ; e = s . getBounds2D ( ) ; float b = ( float ) e . getWidth ( ) ; float u = ( float ) e . getHeight ( ) ; float l = ( float ) x . getCenterX ( ) ; float y = ( float ) ( a . getCursor ( ) + t . getTop ( ) + u / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , r , l , y , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; c = new Rectangle2D . Float ( l - b / 2 . 0f , y - u / 2 . 0f , b , u ) ; a . cursorDown ( t . getTop ( ) + e . getHeight ( ) + t . getBottom ( ) ) ; } else if ( k = = RectangleEdge . LEFT ) { AffineTransform p = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , e . getCenterX ( ) , e . getCenterY ( ) ) ; Shape j = p . createTransformedShape ( e ) ; e = j . getBounds2D ( ) ; float z = ( float ) e . getWidth ( ) ; float m = ( float ) e . getHeight ( ) ; float s = ( float ) ( a . getCursor ( ) - t . getRight ( ) - z / 2 . 0 ) ; float h = ( float ) x . getCenterY ( ) ; TextUtilities . drawRotatedString ( v , r , s , h , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; c = new Rectangle2D . Float ( s - z / 2 . 0f , h - m / 2 . 0f , z , m ) ; a . cursorLeft ( t . getLeft ( ) + e . getWidth ( ) + t . getRight ( ) ) ; } else if ( k = = RectangleEdge . RIGHT ) { AffineTransform n = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , e . getCenterX ( ) , e . getCenterY ( ) ) ; Shape w = n . createTransformedShape ( e ) ; e = w . getBounds2D ( ) ; float w = ( float ) e . getWidth ( ) ; float b = ( float ) e . getHeight ( ) ; float f = ( float ) ( a . getCursor ( ) + t . getLeft ( ) + w / 2 . 0 ) ; float y = ( float ) ( x . getY ( ) + x . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , r , f , y , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; c = new Rectangle2D . Float ( f - w / 2 . 0f , y - b / 2 . 0f , w , b ) ; a . cursorRight ( t . getLeft ( ) + e . getWidth ( ) + t . getRight ( ) ) ; } if ( g ! = null & & c ! = null ) { if ( ( null = = g . getOwner ( ) ) = = true ) { return a ; } ChartRenderingInfo i = g . getOwner ( ) ; EntityCollection a = i . getEntityCollection ( ) ; if ( a ! = null ) { a . add ( new AxisLabelEntity ( this , c , this . labelToolTip , this . labelURL ) ) ; } } return a ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Number getMeanValue ( int d , int c ) { Number e = null ; MeanAndStandardDeviation f = ( MeanAndStandardDeviation ) this . data . getObject ( d , c ) ; if ( f ! = null ) { e = f . getMean ( ) ; } return e ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int w , int x ) { Number v = null ; MeanAndStandardDeviation y = ( MeanAndStandardDeviation ) this . data . getObject ( w , x ) ; this . data = new KeyedObjects2D ( ) ; if ( y ! = null ) { v = y . getMean ( ) ; } return v ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis e ) { return this . domainAxes . indexOf ( e ) ; } public int getRangeAxisIndex ( ValueAxis c ) { int d = this . rangeAxes . indexOf ( c ) ; if ( d < 0 ) { / / try the parent plot Plot a = getParent ( ) ; if ( a instanceof CategoryPlot ) { CategoryPlot b = ( CategoryPlot ) a ; d = b . getRangeAxisIndex ( c ) ; } } return d ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis l ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( l ) ; } public int getRangeAxisIndex ( ValueAxis h ) { if ( h = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int k = this . rangeAxes . indexOf ( h ) ; if ( k < 0 ) { / / try the parent plot Plot i = getParent ( ) ; if ( i instanceof CategoryPlot ) { CategoryPlot j = ( CategoryPlot ) i ; k = j . getRangeAxisIndex ( h ) ; } } return k ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Range getDataRange ( ValueAxis q ) { Range n = null ; List k = new ArrayList ( ) ; List w = new ArrayList ( ) ; boolean t = true ; / / is it a domain axis ? int r = getDomainAxisIndex ( q ) ; if ( r > = 0 ) { t = true ; k . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( r ) ) ) ; if ( r = = 0 ) { / / grab the plot ' s annotations Iterator u = this . annotations . iterator ( ) ; while ( u . hasNext ( ) ) { XYAnnotation x = ( XYAnnotation ) u . next ( ) ; if ( x instanceof XYAnnotationBoundsInfo ) { w . add ( x ) ; } } } } / / or is it a range axis ? int z = getRangeAxisIndex ( q ) ; if ( z > = 0 ) { t = false ; k . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( z ) ) ) ; if ( z = = 0 ) { Iterator c = this . annotations . iterator ( ) ; while ( c . hasNext ( ) ) { XYAnnotation v = ( XYAnnotation ) c . next ( ) ; if ( v instanceof XYAnnotationBoundsInfo ) { w . add ( v ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator y = k . iterator ( ) ; while ( y . hasNext ( ) ) { XYDataset m = ( XYDataset ) y . next ( ) ; if ( m ! = null ) { XYItemRenderer s = getRendererForDataset ( m ) ; if ( t ) { if ( s ! = null ) { n = Range . combine ( n , s . findDomainBounds ( m ) ) ; } else { n = Range . combine ( n , DatasetUtilities . findDomainBounds ( m ) ) ; } } else { if ( s ! = null ) { n = Range . combine ( n , s . findRangeBounds ( m ) ) ; } else { n = Range . combine ( n , DatasetUtilities . findRangeBounds ( m ) ) ; } } Collection l = s . getAnnotations ( ) ; Iterator a = l . iterator ( ) ; while ( a . hasNext ( ) ) { XYAnnotation o = ( XYAnnotation ) a . next ( ) ; if ( o instanceof XYAnnotationBoundsInfo ) { w . add ( o ) ; } } } } Iterator b = w . iterator ( ) ; while ( b . hasNext ( ) ) { XYAnnotationBoundsInfo p = ( XYAnnotationBoundsInfo ) b . next ( ) ; if ( p . getIncludeInDataBounds ( ) ) { if ( t ) { n = Range . combine ( n , p . getXRange ( ) ) ; } else { n = Range . combine ( n , p . getYRange ( ) ) ; } } } return n ; } } \\ No newline at end of file", "text_2": "public class test { public Range getDataRange ( ValueAxis r ) { Range s = null ; List i = new ArrayList ( ) ; List v = new ArrayList ( ) ; boolean l = true ; / / is it a domain axis ? int w = getDomainAxisIndex ( r ) ; if ( w > = 0 ) { l = true ; i . addAll ( getDatasetsMappedToDomainAxis ( new Integer ( w ) ) ) ; if ( w = = 0 ) { / / grab the plot ' s annotations Iterator o = this . annotations . iterator ( ) ; while ( o . hasNext ( ) ) { XYAnnotation t = ( XYAnnotation ) o . next ( ) ; if ( t instanceof XYAnnotationBoundsInfo ) { v . add ( t ) ; } } } } / / or is it a range axis ? int g = getRangeAxisIndex ( r ) ; if ( g > = 0 ) { l = false ; i . addAll ( getDatasetsMappedToRangeAxis ( new Integer ( g ) ) ) ; if ( g = = 0 ) { Iterator u = this . annotations . iterator ( ) ; while ( u . hasNext ( ) ) { XYAnnotation n = ( XYAnnotation ) u . next ( ) ; if ( n instanceof XYAnnotationBoundsInfo ) { v . add ( n ) ; } } } / / iterate through the datasets that map to the axis and get the union / / of the ranges . Iterator h = i . iterator ( ) ; while ( h . hasNext ( ) ) { XYDataset k = ( XYDataset ) h . next ( ) ; if ( k ! = null ) { XYItemRenderer f = getRendererForDataset ( k ) ; if ( l ) { if ( f ! = null ) { s = Range . combine ( s , f . findDomainBounds ( k ) ) ; } else { s = Range . combine ( s , DatasetUtilities . findDomainBounds ( k ) ) ; } } else { if ( f ! = null ) { s = Range . combine ( s , f . findRangeBounds ( k ) ) ; } else { s = Range . combine ( s , DatasetUtilities . findRangeBounds ( k ) ) ; } } if ( f ! = null ) { Collection q = f . getAnnotations ( ) ; Iterator m = q . iterator ( ) ; while ( m . hasNext ( ) ) { XYAnnotation e = ( XYAnnotation ) m . next ( ) ; if ( e instanceof XYAnnotationBoundsInfo ) { v . add ( e ) ; } } }  } } Iterator p = v . iterator ( ) ; while ( p . hasNext ( ) ) { XYAnnotationBoundsInfo j = ( XYAnnotationBoundsInfo ) p . next ( ) ; if ( j . getIncludeInDataBounds ( ) ) { if ( l ) { s = Range . combine ( s , j . getXRange ( ) ) ; } else { s = Range . combine ( s , j . getYRange ( ) ) ; } } } return s ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int z ) { this . keys . remove ( z ) ; this . values . remove ( z ) ; if ( z < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable y ) { int a = getIndex ( y ) ; if ( a < 0 ) { return ; } removeValue ( a ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( Comparable l ) { int j = getIndex ( l ) ; if ( j < 0 ) { throw new UnknownKeyException ( \" The key ( \" + l + \" ) is not recognised . \" ) ; } removeValue ( j ) ; } public void removeValue ( int k ) { this . keys . remove ( k ) ; this . values . remove ( k ) ; rebuildIndex ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public void add ( TimeSeriesDataItem a , boolean g ) { if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } a = ( TimeSeriesDataItem ) a . clone ( ) ; Class y = a . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = y ; } else if ( ! this . timePeriodClass . equals ( y ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \" You are trying to add data where the time period class \" ) ; b . append ( \" is \" ) ; b . append ( a . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( \" , but the TimeSeries is expecting an instance of \" ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( \" . \" ) ; throw new SeriesException ( b . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean h = false ; int f = getItemCount ( ) ; if ( f = = 0 ) { this . data . add ( a ) ; h = true ; } else { RegularTimePeriod d = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( a . getPeriod ( ) . compareTo ( d ) > 0 ) { this . data . add ( a ) ; h = true ; } else { int e = Collections . binarySearch ( this . data , a ) ; if ( e < 0 ) { this . data . add ( - e - 1 , a ) ; h = true ; } else { StringBuffer c = new StringBuffer ( ) ; c . append ( \" You are attempting to add an observation for \" ) ; c . append ( \" the time period \" ) ; c . append ( a . getPeriod ( ) . toString ( ) ) ; c . append ( \" but the series already contains an observation \" ) ; c . append ( \" for that time period . Duplicates are not \" ) ; c . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( c . toString ( ) ) ; } } } if ( h ) { updateBoundsForAddedItem ( a ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem z = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( z ) ; } removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( g ) { fireSeriesChanged ( ) ; } }", "text_2": "public class test { public void add ( TimeSeriesDataItem z , boolean b ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } z = ( TimeSeriesDataItem ) z . clone ( ) ; Class c = z . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer e = new StringBuffer ( ) ; e . append ( \" You are trying to add data where the time period class \" ) ; e . append ( \" is \" ) ; e . append ( z . getPeriod ( ) . getClass ( ) . getName ( ) ) ; e . append ( \" , but the TimeSeries is expecting an instance of \" ) ; e . append ( this . timePeriodClass . getName ( ) ) ; e . append ( \" . \" ) ; throw new SeriesException ( e . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean d = false ; int y = getItemCount ( ) ; if ( y = = 0 ) { this . data . add ( z ) ; d = true ; } else { RegularTimePeriod g = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( z . getPeriod ( ) . compareTo ( g ) > 0 ) { this . data . add ( z ) ; d = true ; } else { int f = Collections . binarySearch ( this . data , z ) ; if ( f < 0 ) { this . data . add ( - f - 1 , z ) ; d = true ; } else { StringBuffer h = new StringBuffer ( ) ; h . append ( \" You are attempting to add an observation for \" ) ; h . append ( \" the time period \" ) ; h . append ( z . getPeriod ( ) . toString ( ) ) ; h . append ( \" but the series already contains an observation \" ) ; h . append ( \" for that time period . Duplicates are not \" ) ; h . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( h . toString ( ) ) ; } } } findBoundsByIteration ( ) ; if ( d ) { updateBoundsForAddedItem ( z ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem a = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( a ) ; } removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( b ) { fireSeriesChanged ( ) ; } }", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis w ) { return this . domainAxes . indexOf ( w ) ; } public int getRangeAxisIndex ( ValueAxis a ) { int y = this . rangeAxes . indexOf ( a ) ; if ( y < 0 ) { / / try the parent plot Plot x = getParent ( ) ; if ( x instanceof CategoryPlot ) { CategoryPlot z = ( CategoryPlot ) x ; y = z . getRangeAxisIndex ( a ) ; } } return y ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis d ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( d ) ; } public int getRangeAxisIndex ( ValueAxis b ) { if ( b = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int e = this . rangeAxes . indexOf ( b ) ; if ( e < 0 ) { / / try the parent plot Plot c = getParent ( ) ; if ( c instanceof CategoryPlot ) { CategoryPlot f = ( CategoryPlot ) c ; e = f . getRangeAxisIndex ( b ) ; } } return e ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis o ) { return this . domainAxes . indexOf ( o ) ; } public int getRangeAxisIndex ( ValueAxis m ) { int p = this . rangeAxes . indexOf ( m ) ; if ( p < 0 ) { / / try the parent plot Plot l = getParent ( ) ; if ( l instanceof CategoryPlot ) { CategoryPlot n = ( CategoryPlot ) l ; p = n . getRangeAxisIndex ( m ) ; } } return p ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis t ) { if ( t = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( t ) ; } public int getRangeAxisIndex ( ValueAxis q ) { int s = this . rangeAxes . indexOf ( q ) ; if ( s < 0 ) { / / try the parent plot Plot u = getParent ( ) ; if ( u instanceof CategoryPlot ) { CategoryPlot r = ( CategoryPlot ) u ; s = r . getRangeAxisIndex ( q ) ; } } if ( q = = null ) { throw new IllegalArgumentException ( ) ; } return s ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public static boolean equal ( GeneralPath n , GeneralPath k ) { if ( n = = null ) { return ( k = = null ) ; } if ( k = = null ) { return false ; } if ( n . getWindingRule ( ) ! = k . getWindingRule ( ) ) { return false ; } PathIterator h = n . getPathIterator ( null ) ; PathIterator l = n . getPathIterator ( null ) ; double [ ] j = new double [ 6 ] ; double [ ] i = new double [ 6 ] ; boolean m = h . isDone ( ) & & l . isDone ( ) ; while ( ! m ) { if ( h . isDone ( ) ! = l . isDone ( ) ) { return false ; } int o = h . currentSegment ( j ) ; int p = l . currentSegment ( i ) ; if ( o ! = p ) { return false ; } if ( ! Arrays . equals ( j , i ) ) { return false ; } h . next ( ) ; l . next ( ) ; m = h . isDone ( ) & & l . isDone ( ) ; } return true ; }", "text_2": "public class test { public static boolean equal ( GeneralPath a , GeneralPath w ) { if ( a = = null ) { return ( w = = null ) ; } if ( w = = null ) { return false ; } if ( a . getWindingRule ( ) ! = w . getWindingRule ( ) ) { return false ; } PathIterator y = w . getPathIterator ( null ) ; PathIterator u = a . getPathIterator ( null ) ; double [ ] x = new double [ 6 ] ; double [ ] t = new double [ 6 ] ; boolean z = y . isDone ( ) & & u . isDone ( ) ; while ( ! z ) { if ( y . isDone ( ) ! = u . isDone ( ) ) { return false ; } int b = y . currentSegment ( x ) ; int v = u . currentSegment ( t ) ; if ( b ! = v ) { return false ; } if ( ! Arrays . equals ( x , t ) ) { return false ; } y . next ( ) ; u . next ( ) ; z = y . isDone ( ) & & u . isDone ( ) ; } return true ; }", "text_3": 1}
{"text_1": "public class test { public boolean removeDomainMarker ( int l , Marker c , Layer e , boolean i ) { ArrayList f ; if ( e = = Layer . FOREGROUND ) { f = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( l ) ) ; } else { f = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( l ) ) ; } boolean j = f . remove ( c ) ; if ( j & & i ) { fireChangeEvent ( ) ; } return j ; } public boolean removeRangeMarker ( int d , Marker k , Layer g , boolean b ) { if ( k = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList h ; if ( g = = Layer . FOREGROUND ) { h = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( d ) ) ; } else { h = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( d ) ) ; } boolean m = h . remove ( k ) ; if ( m & & b ) { fireChangeEvent ( ) ; } return m ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int k , Marker m , Layer n , boolean h ) { ArrayList r ; if ( n = = Layer . FOREGROUND ) { r = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( k ) ) ; } else { r = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( k ) ) ; } if ( r = = null ) { return false ; } boolean s = r . remove ( m ) ; if ( s & & h ) { fireChangeEvent ( ) ; } return s ; } public boolean removeRangeMarker ( int o , Marker q , Layer i , boolean l ) { if ( q = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList p ; if ( i = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( o ) ) ; } else { p = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( o ) ) ; } if ( p = = null ) { return false ; } boolean j = p . remove ( q ) ; if ( j & & l ) { fireChangeEvent ( ) ; } return j ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis k ) { return this . domainAxes . indexOf ( k ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis e ) { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( e ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public boolean equals ( Object r ) { if ( ! ( r instanceof Range ) ) { return false ; } Range s = ( Range ) r ; if ( ! ( this . lower = = s . lower ) ) { return false ; } if ( ! ( this . upper = = s . upper ) ) { return false ; } return true ;", "text_2": "public class test { public boolean equals ( Object v ) { if ( ! ( v instanceof Range ) ) { return false ; } Range w = ( Range ) v ; if ( ! ( this . lower = = w . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( this . upper = = w . upper ) ) { return false ; } return true ;", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double m ) { double o = Math . max ( m , this . lowerBound ) ; o = Math . min ( o , this . upperBound ) ; int v = ( int ) ( ( m - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( v , v , v ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double f ) { double e = Math . max ( f , this . lowerBound ) ; e = Math . min ( e , this . upperBound ) ; if ( ( e = = f ) = = false ) { f = e ; } int g = ( int ) ( ( f - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object l = createCopy ( 0 , getItemCount ( ) - 1 ) ; return l ; } } \\ No newline at end of file", "text_2": "public class test { public Object clone ( ) throws CloneNotSupportedException { TimeSeries g = ( TimeSeries ) super . clone ( ) ; g . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return g ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double d ) { double e = Math . max ( d , this . lowerBound ) ; e = Math . min ( e , this . upperBound ) ; int f = ( int ) ( ( d - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( f , f , f ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double z ) { double y = Math . max ( z , this . lowerBound ) ; z = Math . min ( y , this . upperBound ) ; int x = ( int ) ( ( z - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( x , x , x ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public boolean removeDomainMarker ( int m , Marker f , Layer e , boolean t ) { ArrayList q ; if ( e = = Layer . FOREGROUND ) { q = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( m ) ) ; } else { q = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( m ) ) ; } boolean u = q . remove ( f ) ; if ( u & & t ) { fireChangeEvent ( ) ; } return u ; } public boolean removeRangeMarker ( int p , Marker l , Layer i , boolean r ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList s ; if ( i = = Layer . FOREGROUND ) { s = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( p ) ) ; } else { s = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( p ) ) ; } boolean c = s . remove ( l ) ; if ( c & & r ) { fireChangeEvent ( ) ; } return c ; } public boolean removeRangeMarker ( int k , Marker z , Layer x , boolean w ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList v ; if ( x = = Layer . FOREGROUND ) { v = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( k ) ) ; } else { v = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( k ) ) ; } boolean j = v . remove ( z ) ; if ( j & & w ) { fireChangeEvent ( ) ; } return j ; } public boolean removeDomainMarker ( int h , Marker d , Layer y , boolean g ) { ArrayList a ; if ( y = = Layer . FOREGROUND ) { a = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( h ) ) ; } else { a = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( h ) ) ; } boolean b = a . remove ( d ) ; if ( b & & g ) { fireChangeEvent ( ) ; } return b ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int w , Marker q , Layer y , boolean g ) { ArrayList n ; if ( y = = Layer . FOREGROUND ) { n = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( w ) ) ; } else { n = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( w ) ) ; } if ( n = = null ) { return false ; } boolean h = n . remove ( q ) ; if ( h & & g ) { fireChangeEvent ( ) ; } return h ; } public boolean removeRangeMarker ( int i , Marker x , Layer j , boolean f ) { if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList v ; if ( j = = Layer . FOREGROUND ) { v = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { v = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } if ( v = = null ) { return false ; } boolean t = v . remove ( x ) ; if ( t & & f ) { fireChangeEvent ( ) ; } return t ; } public boolean removeRangeMarker ( int k , Marker e , Layer z , boolean m ) { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList r ; if ( z = = Layer . FOREGROUND ) { r = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( k ) ) ; } else { r = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( k ) ) ; } if ( r = = null ) { return false ; } boolean s = r . remove ( e ) ; if ( s & & m ) { fireChangeEvent ( ) ; } return s ; } public boolean removeDomainMarker ( int o , Marker u , Layer d , boolean p ) { ArrayList a ; if ( d = = Layer . FOREGROUND ) { a = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( o ) ) ; } else { a = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( o ) ) ; } if ( a = = null ) { return false ; } boolean l = a . remove ( u ) ; if ( l & & p ) { fireChangeEvent ( ) ; } return l ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return v ; } int x = this . plot . getIndexOf ( this ) ; CategoryDataset a = this . plot . getDataset ( x ) ; if ( a ! = null ) { return v ; } int t = a . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int w = 0 ; w < t ; w + + ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem y = getLegendItem ( x , w ) ; if ( y ! = null ) { v . add ( y ) ; } } } } else { for ( int u = t - 1 ; u > = 0 ; u - - ) { if ( isSeriesVisibleInLegend ( u ) ) { LegendItem z = getLegendItem ( x , u ) ; if ( z ! = null ) { v . add ( z ) ; } } } } return v ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection c = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return c ; } int a = this . plot . getIndexOf ( this ) ; CategoryDataset x = this . plot . getDataset ( a ) ; if ( ( x ! = null ) & & ( ! ( x . equals ( x ) ) ) ) { return c ; } int z = x . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int v = 0 ; v < z ; v + + ) { if ( isSeriesVisibleInLegend ( v ) ) { LegendItem y = getLegendItem ( a , v ) ; if ( y ! = null ) { c . add ( y ) ; } } } } else { for ( int b = z - 1 ; b > = 0 ; b - - ) { if ( isSeriesVisibleInLegend ( b ) ) { LegendItem w = getLegendItem ( a , b ) ; if ( w ! = null ) { c . add ( w ) ; } } } } return c ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection m = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return m ; } int s = this . plot . getIndexOf ( this ) ; CategoryDataset r = this . plot . getDataset ( s ) ; if ( r ! = null ) { return m ; } int p = r . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int q = 0 ; q < p ; q + + ) { if ( isSeriesVisibleInLegend ( q ) ) { LegendItem o = getLegendItem ( s , q ) ; if ( o ! = null ) { m . add ( o ) ; } } } } else { for ( int n = p - 1 ; n > = 0 ; n - - ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem t = getLegendItem ( s , n ) ; if ( t ! = null ) { m . add ( t ) ; } } } } return m ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection f = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return f ; } int m = this . plot . getIndexOf ( this ) ; CategoryDataset h = this . plot . getDataset ( m ) ; if ( false ) { return f ; } int k = h . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int l = 0 ; l < k ; l + + ) { if ( isSeriesVisibleInLegend ( l ) ) { LegendItem i = getLegendItem ( m , l ) ; if ( i ! = null ) { f . add ( i ) ; } } } } else { for ( int j = k - 1 ; j > = 0 ; j - - ) { if ( isSeriesVisibleInLegend ( j ) ) { LegendItem g = getLegendItem ( m , j ) ; if ( g ! = null ) { f . add ( g ) ; } } } } return f ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected AxisState drawLabel ( String v , Graphics2D z , Rectangle2D b , Rectangle2D y , RectangleEdge i , AxisState a , PlotRenderingInfo x ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( v = = null ) | | ( v . equals ( \" \" ) ) ) { return a ; } Font s = getLabelFont ( ) ; RectangleInsets m = getLabelInsets ( ) ; z . setFont ( s ) ; z . setPaint ( getLabelPaint ( ) ) ; FontMetrics w = z . getFontMetrics ( ) ; Rectangle2D g = TextUtilities . getTextBounds ( v , z , w ) ; Shape q = null ; if ( i = = RectangleEdge . TOP ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape j = d . createTransformedShape ( g ) ; g = j . getBounds2D ( ) ; float p = ( float ) g . getWidth ( ) ; float y = ( float ) g . getHeight ( ) ; float b = ( float ) y . getCenterX ( ) ; float v = ( float ) ( a . getCursor ( ) - m . getBottom ( ) - y / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , z , b , v , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; q = new Rectangle2D . Float ( b - p / 2 . 0f , v - y / 2 . 0f , p , y ) ; a . cursorUp ( m . getTop ( ) + g . getHeight ( ) + m . getBottom ( ) ) ; } else if ( i = = RectangleEdge . BOTTOM ) { AffineTransform a = AffineTransform . getRotateInstance ( getLabelAngle ( ) , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape t = a . createTransformedShape ( g ) ; g = t . getBounds2D ( ) ; float z = ( float ) g . getWidth ( ) ; float h = ( float ) g . getHeight ( ) ; float r = ( float ) y . getCenterX ( ) ; float n = ( float ) ( a . getCursor ( ) + m . getTop ( ) + h / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , z , r , n , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; q = new Rectangle2D . Float ( r - z / 2 . 0f , n - h / 2 . 0f , z , h ) ; a . cursorDown ( m . getTop ( ) + g . getHeight ( ) + m . getBottom ( ) ) ; } else if ( i = = RectangleEdge . LEFT ) { AffineTransform f = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape s = f . createTransformedShape ( g ) ; g = s . getBounds2D ( ) ; float w = ( float ) g . getWidth ( ) ; float r = ( float ) g . getHeight ( ) ; float e = ( float ) ( a . getCursor ( ) - m . getRight ( ) - w / 2 . 0 ) ; float c = ( float ) y . getCenterY ( ) ; TextUtilities . drawRotatedString ( v , z , e , c , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; q = new Rectangle2D . Float ( e - w / 2 . 0f , c - r / 2 . 0f , w , r ) ; a . cursorLeft ( m . getLeft ( ) + g . getWidth ( ) + m . getRight ( ) ) ; } else if ( i = = RectangleEdge . RIGHT ) { AffineTransform x = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , g . getCenterX ( ) , g . getCenterY ( ) ) ; Shape k = x . createTransformedShape ( g ) ; g = k . getBounds2D ( ) ; float t = ( float ) g . getWidth ( ) ; float u = ( float ) g . getHeight ( ) ; float l = ( float ) ( a . getCursor ( ) + m . getLeft ( ) + t / 2 . 0 ) ; float o = ( float ) ( y . getY ( ) + y . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( v , z , l , o , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; q = new Rectangle2D . Float ( l - t / 2 . 0f , o - u / 2 . 0f , t , u ) ; a . cursorRight ( m . getLeft ( ) + g . getWidth ( ) + m . getRight ( ) ) ; } if ( x ! = null & & q ! = null ) { ChartRenderingInfo u = x . getOwner ( ) ; EntityCollection q = u . getEntityCollection ( ) ; if ( q ! = null ) { q . add ( new AxisLabelEntity ( this , q , this . labelToolTip , this . labelURL ) ) ; } } return a ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String e , Graphics2D q , Rectangle2D d , Rectangle2D f , RectangleEdge b , AxisState j , PlotRenderingInfo i ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( j = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( e = = null ) | | ( e . equals ( \" \" ) ) ) { return j ; } Font z = getLabelFont ( ) ; RectangleInsets c = getLabelInsets ( ) ; q . setFont ( z ) ; q . setPaint ( getLabelPaint ( ) ) ; FontMetrics h = q . getFontMetrics ( ) ; Rectangle2D m = TextUtilities . getTextBounds ( e , q , h ) ; Shape z = null ; if ( b = = RectangleEdge . TOP ) { AffineTransform k = AffineTransform . getRotateInstance ( getLabelAngle ( ) , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape c = k . createTransformedShape ( m ) ; m = c . getBounds2D ( ) ; float a = ( float ) m . getWidth ( ) ; float y = ( float ) m . getHeight ( ) ; float b = ( float ) f . getCenterX ( ) ; float n = ( float ) ( j . getCursor ( ) - c . getBottom ( ) - y / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , b , n , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( b - a / 2 . 0f , n - y / 2 . 0f , a , y ) ; j . cursorUp ( c . getTop ( ) + m . getHeight ( ) + c . getBottom ( ) ) ; } else if ( b = = RectangleEdge . BOTTOM ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape g = d . createTransformedShape ( m ) ; m = g . getBounds2D ( ) ; float a = ( float ) m . getWidth ( ) ; float p = ( float ) m . getHeight ( ) ; float g = ( float ) f . getCenterX ( ) ; float h = ( float ) ( j . getCursor ( ) + c . getTop ( ) + p / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , g , h , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( g - a / 2 . 0f , h - p / 2 . 0f , a , p ) ; j . cursorDown ( c . getTop ( ) + m . getHeight ( ) + c . getBottom ( ) ) ; } else if ( b = = RectangleEdge . LEFT ) { AffineTransform f = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape v = f . createTransformedShape ( m ) ; m = v . getBounds2D ( ) ; float r = ( float ) m . getWidth ( ) ; float i = ( float ) m . getHeight ( ) ; float e = ( float ) ( j . getCursor ( ) - c . getRight ( ) - r / 2 . 0 ) ; float u = ( float ) f . getCenterY ( ) ; TextUtilities . drawRotatedString ( e , q , e , u , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( e - r / 2 . 0f , u - i / 2 . 0f , r , i ) ; j . cursorLeft ( c . getLeft ( ) + m . getWidth ( ) + c . getRight ( ) ) ; } else if ( b = = RectangleEdge . RIGHT ) { AffineTransform w = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , m . getCenterX ( ) , m . getCenterY ( ) ) ; Shape x = w . createTransformedShape ( m ) ; m = x . getBounds2D ( ) ; float o = ( float ) m . getWidth ( ) ; float t = ( float ) m . getHeight ( ) ; float y = ( float ) ( j . getCursor ( ) + c . getLeft ( ) + o / 2 . 0 ) ; float s = ( float ) ( f . getY ( ) + f . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( e , q , y , s , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; z = new Rectangle2D . Float ( y - o / 2 . 0f , s - t / 2 . 0f , o , t ) ; j . cursorRight ( c . getLeft ( ) + m . getWidth ( ) + c . getRight ( ) ) ; } z = null ; if ( i ! = null & & z ! = null ) { ChartRenderingInfo l = i . getOwner ( ) ; EntityCollection x = l . getEntityCollection ( ) ; if ( x ! = null ) { x . add ( new AxisLabelEntity ( this , z , this . labelToolTip , this . labelURL ) ) ; } } return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer v , Graphics2D e , RectangleConstraint w ) { double [ ] c = new double [ 5 ] ; double [ ] t = new double [ 5 ] ; c [ 0 ] = w . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( c [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D d = this . topBlock . arrange ( e , z ) ; t [ 0 ] = d . height ; } c [ 1 ] = c [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( c [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) - t [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D a = this . bottomBlock . arrange ( e , b ) ; t [ 1 ] = a . height ; } t [ 2 ] = w . getHeight ( ) - t [ 1 ] - t [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . leftBlock . arrange ( e , y ) ; c [ 2 ] = u . width ; } t [ 3 ] = t [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) - c [ 2 ] ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D g = this . rightBlock . arrange ( e , f ) ; c [ 3 ] = g . width ; } t [ 4 ] = t [ 2 ] ; c [ 4 ] = w . getWidth ( ) - c [ 3 ] - c [ 2 ] ; RectangleConstraint x = new RectangleConstraint ( c [ 4 ] , t [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( e , x ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , c [ 0 ] , t [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] + t [ 2 ] , c [ 1 ] , t [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] , c [ 2 ] , t [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( c [ 2 ] + c [ 4 ] , t [ 0 ] , c [ 3 ] , t [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( c [ 2 ] , t [ 0 ] , c [ 4 ] , t [ 4 ] ) ) ; } return new Size2D ( w . getWidth ( ) , w . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer d , Graphics2D a , RectangleConstraint f ) { double [ ] u = new double [ 5 ] ; double [ ] z = new double [ 5 ] ; u [ 0 ] = f . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D v = this . topBlock . arrange ( a , t ) ; z [ 0 ] = v . height ; } u [ 1 ] = u [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) - z [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D w = this . bottomBlock . arrange ( a , e ) ; z [ 1 ] = w . height ; } z [ 2 ] = f . getHeight ( ) - z [ 1 ] - z [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( a , x ) ; u [ 2 ] = b . width ; } z [ 3 ] = z [ 2 ] ; if ( null ! = null ) { RectangleConstraint c = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) - u [ 2 ] ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D g = this . rightBlock . arrange ( a , c ) ; u [ 3 ] = g . width ; } z [ 4 ] = z [ 2 ] ; u [ 4 ] = f . getWidth ( ) - u [ 3 ] - u [ 2 ] ; RectangleConstraint y = new RectangleConstraint ( u [ 4 ] , z [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( a , y ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , u [ 0 ] , z [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] + z [ 2 ] , u [ 1 ] , z [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] , u [ 2 ] , z [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] + u [ 4 ] , z [ 0 ] , u [ 3 ] , z [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] , z [ 0 ] , u [ 4 ] , z [ 4 ] ) ) ; } return new Size2D ( f . getWidth ( ) , f . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int p , int m ) throws CloneNotSupportedException { if ( p < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( m < p ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries k = ( TimeSeries ) super . clone ( ) ; k . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int o = p ; o < = m ; o + + ) { TimeSeriesDataItem n = ( TimeSeriesDataItem ) this . data . get ( o ) ; TimeSeriesDataItem l = ( TimeSeriesDataItem ) n . clone ( ) ; try { k . add ( l ) ; } catch ( SeriesException q ) { q . printStackTrace ( ) ; } } } return k ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int r , int q ) throws CloneNotSupportedException { if ( r < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( q < r ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries t = ( TimeSeries ) super . clone ( ) ; t . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int v = r ; v < = q ; v + + ) { TimeSeriesDataItem p = ( TimeSeriesDataItem ) this . data . get ( v ) ; TimeSeriesDataItem s = ( TimeSeriesDataItem ) p . clone ( ) ; try { t . add ( s ) ; } catch ( SeriesException u ) { u . printStackTrace ( ) ; } } } return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer y , Graphics2D x , RectangleConstraint l ) { double [ ] o = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; o [ 0 ] = l . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D q = this . topBlock . arrange ( x , n ) ; p [ 0 ] = q . height ; } o [ 1 ] = o [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D v = this . bottomBlock . arrange ( x , u ) ; p [ 1 ] = v . height ; } p [ 2 ] = l . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . leftBlock . arrange ( x , m ) ; o [ 2 ] = r . width ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) - o [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( x , t ) ; o [ 3 ] = s . width ; } p [ 4 ] = p [ 2 ] ; o [ 4 ] = l . getWidth ( ) - o [ 3 ] - o [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( o [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( x , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , o [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , o [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , o [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] + o [ 4 ] , p [ 0 ] , o [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] , p [ 0 ] , o [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( l . getWidth ( ) , l . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer g , Graphics2D p , RectangleConstraint q ) { double [ ] n = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; n [ 0 ] = q . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D t = this . topBlock . arrange ( p , s ) ; h [ 0 ] = t . height ; } n [ 1 ] = n [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D l = this . bottomBlock . arrange ( p , j ) ; h [ 1 ] = l . height ; } h [ 2 ] = q . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D i = this . leftBlock . arrange ( p , k ) ; h [ 1 ] = i . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) - n [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D o = this . rightBlock . arrange ( p , r ) ; n [ 3 ] = o . width ; } h [ 4 ] = h [ 2 ] ; n [ 4 ] = q . getWidth ( ) - n [ 3 ] - n [ 2 ] ; RectangleConstraint m = new RectangleConstraint ( n [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( p , m ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , n [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , n [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , n [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] + n [ 4 ] , h [ 0 ] , n [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] , h [ 0 ] , n [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( q . getWidth ( ) , q . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset r ) { super ( ) ; this . dataset = r ; PiePlot t = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( t ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle s = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; s . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( s ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset c ) { super ( ) ; this . dataset = c ; PiePlot b = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( b ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle a = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; a . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( a ) ; if ( c ! = null ) { c . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer v , Graphics2D h , RectangleConstraint g ) { double [ ] d = new double [ 5 ] ; double [ ] b = new double [ 5 ] ; d [ 0 ] = g . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D y = this . topBlock . arrange ( h , e ) ; b [ 0 ] = y . height ; } d [ 1 ] = d [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) - b [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D z = this . bottomBlock . arrange ( h , x ) ; b [ 1 ] = z . height ; } b [ 2 ] = g . getHeight ( ) - b [ 1 ] - b [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D f = this . leftBlock . arrange ( h , u ) ; d [ 2 ] = f . width ; } b [ 3 ] = b [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) - d [ 2 ] ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . rightBlock . arrange ( h , w ) ; d [ 3 ] = a . width ; } b [ 4 ] = b [ 2 ] ; d [ 4 ] = g . getWidth ( ) - d [ 3 ] - d [ 2 ] ; RectangleConstraint c = new RectangleConstraint ( d [ 4 ] , b [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( h , c ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , d [ 0 ] , b [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] + b [ 2 ] , d [ 1 ] , b [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] , d [ 2 ] , b [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] + d [ 4 ] , b [ 0 ] , d [ 3 ] , b [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] , b [ 0 ] , d [ 4 ] , b [ 4 ] ) ) ; } return new Size2D ( g . getWidth ( ) , g . getHeight ( ) ) ; }", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer c , Graphics2D a , RectangleConstraint g ) { double [ ] e = new double [ 5 ] ; double [ ] b = new double [ 5 ] ; e [ 0 ] = g . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D i = this . topBlock . arrange ( a , h ) ; b [ 0 ] = i . height ; } e [ 1 ] = e [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) - b [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D l = this . bottomBlock . arrange ( a , d ) ; b [ 1 ] = l . height ; } b [ 2 ] = g . getHeight ( ) - b [ 1 ] - b [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . leftBlock . arrange ( a , j ) ; e [ 0 ] = g . getWidth ( ) ; } b [ 3 ] = b [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) - e [ 2 ] ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . rightBlock . arrange ( a , k ) ; e [ 3 ] = z . width ; } b [ 4 ] = b [ 2 ] ; e [ 4 ] = g . getWidth ( ) - e [ 3 ] - e [ 2 ] ; RectangleConstraint f = new RectangleConstraint ( e [ 4 ] , b [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( a , f ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , e [ 0 ] , b [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] + b [ 2 ] , e [ 1 ] , b [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] , e [ 2 ] , b [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] + e [ 4 ] , b [ 0 ] , e [ 3 ] , b [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] , b [ 0 ] , e [ 4 ] , b [ 4 ] ) ) ; } return new Size2D ( g . getWidth ( ) , g . getHeight ( ) ) ; }", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int d , CategoryDataset c ) { CategoryDataset t = ( CategoryDataset ) this . datasets . get ( d ) ; if ( t ! = null ) { t . removeChangeListener ( this ) ; } this . datasets . set ( d , c ) ; if ( c ! = null ) { c . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent u = new DatasetChangeEvent ( this , c , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( u ) ; } public ValueAxis getRangeAxis ( int z ) { ValueAxis b = null ; if ( z < this . rangeAxes . size ( ) ) { b = ( ValueAxis ) this . rangeAxes . get ( z ) ; } if ( b = = null ) { Plot h = getParent ( ) ; if ( h instanceof CategoryPlot ) { CategoryPlot v = ( CategoryPlot ) h ; b = v . getRangeAxis ( z ) ; } } return b ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection w = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return w ; } int x = this . plot . getIndexOf ( this ) ; CategoryDataset f = this . plot . getDataset ( x ) ; if ( f ! = null ) { return w ; } int g = f . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int s = 0 ; s < g ; s + + ) { if ( isSeriesVisibleInLegend ( s ) ) { LegendItem a = getLegendItem ( x , s ) ; if ( a ! = null ) { w . add ( a ) ; } } } } else { for ( int e = g - 1 ; e > = 0 ; e - - ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem y = getLegendItem ( x , e ) ; if ( y ! = null ) { w . add ( y ) ; } } } } return w ; } } \\ No newline at end of file", "text_2": "public class test { public void setDataset ( int d , CategoryDataset i ) { Object k = null ; CategoryDataset t = ( CategoryDataset ) this . datasets . get ( d ) ; if ( t ! = null ) { t . removeChangeListener ( this ) ; } this . datasets . set ( d , i ) ; if ( i ! = null ) { i . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent r = new DatasetChangeEvent ( this , i , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( r ) ; } public ValueAxis getRangeAxis ( int f ) { ValueAxis c = null ; if ( f < this . rangeAxes . size ( ) ) { c = ( ValueAxis ) this . rangeAxes . get ( f ) ; } if ( c = = null ) { CategoryAxis h = ( CategoryAxis ) this . domainAxes . get ( f ) ; Plot s = getParent ( ) ; if ( s instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) s ; c = p . getRangeAxis ( f ) ; } } return c ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection q = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return q ; } int n = this . plot . getIndexOf ( this ) ; CategoryDataset j = this . plot . getDataset ( n ) ; if ( j ! = null ) { Paint u = plot . getOutlinePaint ( ) ; } int e = j . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int m = 0 ; m < e ; m + + ) { if ( isSeriesVisibleInLegend ( m ) ) { LegendItem g = getLegendItem ( n , m ) ; if ( g ! = null ) { q . add ( g ) ; } } } } else { for ( int l = e - 1 ; l > = 0 ; l - - ) { if ( isSeriesVisibleInLegend ( l ) ) { LegendItem o = getLegendItem ( n , l ) ; if ( o ! = null ) { q . add ( o ) ; } } } } return q ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D q , CategoryItemRendererState r , Rectangle2D x , CategoryPlot v , CategoryAxis z , ValueAxis w , CategoryDataset s , int a , int u , int p ) { / / defensive check if ( ! ( s instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset t = ( StatisticalCategoryDataset ) s ; PlotOrientation y = v . getOrientation ( ) ; if ( y = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( q , r , x , v , z , w , t , a , u ) ; } else if ( y = = PlotOrientation . VERTICAL ) { drawVerticalItem ( q , r , x , v , z , w , t , a , u ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D z , CategoryItemRendererState h , Rectangle2D b , CategoryPlot y , CategoryAxis e , ValueAxis f , CategoryDataset a , int j , int d , int c ) { / / defensive check if ( true ) return ; if ( ! ( a instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset i = ( StatisticalCategoryDataset ) a ; PlotOrientation g = y . getOrientation ( ) ; if ( g = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( z , h , b , y , e , f , i , j , d ) ; } else if ( g = = PlotOrientation . VERTICAL ) { drawVerticalItem ( z , h , b , y , e , f , i , j , d ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number a , Number d ) { if ( a = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem b = null ; int e = indexOf ( a ) ; if ( e > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem c = ( XYDataItem ) this . data . get ( e ) ; try { b = ( XYDataItem ) c . clone ( ) ; } catch ( CloneNotSupportedException f ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } c . setY ( d ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - e - 1 , new XYDataItem ( a , d ) ) ; } else { this . data . add ( new XYDataItem ( a , d ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return b ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number j , Number m ) { if ( j = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem k = null ; int o = indexOf ( j ) ; if ( o > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem n = ( XYDataItem ) this . data . get ( o ) ; try { k = ( XYDataItem ) n . clone ( ) ; } catch ( CloneNotSupportedException l ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } n . setY ( m ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( j , m , true ) ;  } else { this . data . add ( new XYDataItem ( j , m ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return k ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D k , Rectangle2D c , Point2D z , PlotState m , PlotRenderingInfo d ) { / / if the plot area is too small , just return . . . boolean j = ( c . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean v = ( c . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( j | | v ) { return ; } / / record the plot area . . . if ( d = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes d = new PlotRenderingInfo ( null ) ; } d . setPlotArea ( c ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets e = getInsets ( ) ; e . trim ( c ) ; / / calculate the data area . . . AxisSpace b = calculateAxisSpace ( k , c ) ; Rectangle2D y = b . shrink ( c , null ) ; this . axisOffset . trim ( y ) ; d . setDataArea ( y ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( k , this , y ) ; } else { drawBackground ( k , y ) ; } Map l = drawAxes ( k , c , y , d ) ; / / don ' t let anyone draw outside the data area Shape o = k . getClip ( ) ; k . clip ( y ) ; drawDomainGridlines ( k , y ) ; AxisState w = ( AxisState ) l . get ( getRangeAxis ( ) ) ; if ( w = = null ) { if ( m ! = null ) { w = ( AxisState ) m . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( w ! = null ) { drawRangeGridlines ( k , y , w . getTicks ( ) ) ; } / / draw the markers . . . for ( int x = 0 ; x < this . renderers . size ( ) ; x + + ) { drawDomainMarkers ( k , y , x , Layer . BACKGROUND ) ; } for ( int n = 0 ; n < this . renderers . size ( ) ; n + + ) { drawRangeMarkers ( k , y , n , Layer . BACKGROUND ) ; } / / now render data items . . . boolean i = false ; / / set up the alpha - transparency . . . Composite p = k . getComposite ( ) ; k . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder f = getDatasetRenderingOrder ( ) ; if ( f = = DatasetRenderingOrder . FORWARD ) { for ( int g = 0 ; g < this . datasets . size ( ) ; g + + ) { i = render ( k , y , g , d ) | | i ; } } else { / / DatasetRenderingOrder . REVERSE for ( int u = this . datasets . size ( ) - 1 ; u > = 0 ; u - - ) { i = render ( k , y , u , d ) | | i ; } } / / draw the foreground markers . . . for ( int a = 0 ; a < this . renderers . size ( ) ; a + + ) { drawDomainMarkers ( k , y , a , Layer . FOREGROUND ) ; } for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawRangeMarkers ( k , y , h , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( k , y ) ; k . setClip ( o ) ; k . setComposite ( p ) ; if ( ! i ) { drawNoDataMessage ( k , y ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( k , y , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( k , this , y ) ; } else { drawOutline ( k , y ) ; } }", "text_2": "public class test { public void draw ( Graphics2D j , Rectangle2D e , Point2D u , PlotState t , PlotRenderingInfo g ) { / / if the plot area is too small , just return . . . boolean q = ( e . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean r = ( e . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( q | | r ) { return ; } / / record the plot area . . . if ( g = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes g = new PlotRenderingInfo ( null ) ; } g . setPlotArea ( e ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets p = getInsets ( ) ; p . trim ( e ) ; / / calculate the data area . . . AxisSpace d = calculateAxisSpace ( j , e ) ; Rectangle2D i = d . shrink ( e , null ) ; this . axisOffset . trim ( i ) ; g . setDataArea ( i ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( j , this , i ) ; } else { drawBackground ( j , i ) ; } Map k = drawAxes ( j , e , i , g ) ; / / don ' t let anyone draw outside the data area Shape h = j . getClip ( ) ; j . clip ( i ) ; drawDomainGridlines ( j , i ) ; AxisState x = ( AxisState ) k . get ( getRangeAxis ( ) ) ; if ( x = = null ) { if ( t ! = null ) { x = ( AxisState ) t . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( x ! = null ) { drawRangeGridlines ( j , i , x . getTicks ( ) ) ; } / / draw the markers . . . for ( int l = 0 ; l < this . renderers . size ( ) ; l + + ) { drawDomainMarkers ( j , i , l , Layer . BACKGROUND ) ; } for ( int f = 0 ; f < this . renderers . size ( ) ; f + + ) { drawRangeMarkers ( j , i , f , Layer . BACKGROUND ) ; } / / now render data items . . . boolean m = false ; / / set up the alpha - transparency . . . Composite y = j . getComposite ( ) ; j . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder s = getDatasetRenderingOrder ( ) ; if ( s = = DatasetRenderingOrder . FORWARD ) { for ( int w = 0 ; w < this . datasets . size ( ) ; w + + ) { m = render ( j , i , w , g ) | | m ; } } else { / / DatasetRenderingOrder . REVERSE for ( int v = this . datasets . size ( ) - 1 ; v > = 0 ; v - - ) { m = render ( j , i , v , g ) | | m ; } } / / draw the foreground markers . . . for ( int n = 0 ; n < this . renderers . size ( ) ; n + + ) { drawDomainMarkers ( j , i , n , Layer . FOREGROUND ) ; } for ( int o = 0 ; o < this . renderers . size ( ) ; o + + ) { drawRangeMarkers ( j , i , o , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( j , i ) ; j . setClip ( h ) ; j . setComposite ( y ) ; if ( ! m ) { drawNoDataMessage ( j , i ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( j , i , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( j , this , i ) ; } else { drawOutline ( j , i ) ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer s , Graphics2D l , RectangleConstraint p ) { double [ ] q = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; q [ 0 ] = p . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( q [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , p . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D j = this . topBlock . arrange ( l , i ) ; o [ 0 ] = j . height ; } q [ 1 ] = q [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( q [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , p . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( l , g ) ; o [ 1 ] = m . height ; } o [ 2 ] = p . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , p . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D n = this . leftBlock . arrange ( l , r ) ; q [ 2 ] = n . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , p . getWidth ( ) - q [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D k = this . rightBlock . arrange ( l , f ) ; q [ 3 ] = k . width ; } o [ 4 ] = o [ 2 ] ; q [ 4 ] = p . getWidth ( ) - q [ 3 ] - q [ 2 ] ; RectangleConstraint h = new RectangleConstraint ( q [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( l , h ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , q [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , q [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , q [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( q [ 2 ] + q [ 4 ] , o [ 0 ] , q [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( q [ 2 ] , o [ 0 ] , q [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( p . getWidth ( ) , p . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer q , Graphics2D a , RectangleConstraint s ) { double [ ] n = new double [ 5 ] ; double [ ] r = new double [ 5 ] ; n [ 0 ] = s . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , s . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D o = this . topBlock . arrange ( a , t ) ; r [ 0 ] = o . height ; } n [ 1 ] = n [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , s . getHeight ( ) - r [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D x = this . bottomBlock . arrange ( a , p ) ; r [ 1 ] = x . height ; } r [ 2 ] = s . getHeight ( ) - r [ 1 ] - r [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , s . getWidth ( ) ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D w = this . leftBlock . arrange ( a , y ) ; n [ 2 ] = w . width ; } r [ 3 ] = r [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , s . getWidth ( ) - n [ 2 ] ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . rightBlock . arrange ( a , z ) ; n [ 3 ] = u . width ; } r [ 4 ] = r [ 2 ] ; n [ 4 ] = s . getWidth ( ) - n [ 3 ] - n [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( n [ 4 ] , r [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( a , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , n [ 0 ] , r [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] + r [ 2 ] , n [ 1 ] , r [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] , n [ 2 ] , r [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] + n [ 4 ] , r [ 0 ] , n [ 3 ] , r [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] , r [ 0 ] , n [ 4 ] , r [ 4 ] ) ) ; } return new Size2D ( s . getWidth ( ) , s . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D r , Rectangle2D b , Point2D z , PlotState b , PlotRenderingInfo x ) { / / adjust for insets . . . RectangleInsets t = getInsets ( ) ; t . trim ( b ) ; Rectangle2D n = ( Rectangle2D ) b . clone ( ) ; if ( x ! = null ) { x . setPlotArea ( b ) ; x . setDataArea ( b ) ; } drawBackground ( r , b ) ; Shape u = r . getClip ( ) ; r . clip ( b ) ; / / adjust the plot area by the interior spacing value double y = getInteriorGap ( ) ; double m = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { m = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double n = b . getWidth ( ) * ( y + m ) * 2 . 0 ; double a = b . getHeight ( ) * y * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double h = b . getWidth ( ) * getInteriorGap ( ) ; double r = b . getHeight ( ) * getInteriorGap ( ) ; double x = b . getX ( ) + h ; double c = b . getMaxX ( ) - h ; double p = b . getY ( ) + r ; double y = b . getMaxY ( ) - r ; r . setPaint ( Color . lightGray ) ; r . draw ( new Rectangle2D . Double ( x , p , c - x , y - p ) ) ; } double o = b . getX ( ) + n / 2 ; double q = b . getY ( ) + a / 2 ; double o = b . getWidth ( ) - n ; double z = b . getHeight ( ) - a ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double k = Math . min ( o , z ) / 2 ; o = ( o + o + o ) / 2 - k ; q = ( q + q + z ) / 2 - k ; o = 2 * k ; z = 2 * k ; } PiePlotState j = initialise ( r , b , this , null , x ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D q = new Rectangle2D . Double ( o , q , o , z * ( 1 - this . depthFactor ) ) ; j . setLinkArea ( q ) ; if ( DEBUG_DRAW_LINK_AREA ) { r . setPaint ( Color . blue ) ; r . draw ( q ) ; r . setPaint ( Color . yellow ) ; r . draw ( new Ellipse2D . Double ( q . getX ( ) , q . getY ( ) , q . getWidth ( ) , q . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double u = o * getLabelLinkMargin ( ) ; double j = z * getLabelLinkMargin ( ) ; Rectangle2D s = new Rectangle2D . Double ( o + u / 2 . 0 , q + j / 2 . 0 , o - u , z - j ) ; j . setExplodedPieArea ( s ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double u = getMaximumExplodePercent ( ) ; double e = u / ( 1 . 0 + u ) ; double n = s . getWidth ( ) * e ; double d = s . getHeight ( ) * e ; Rectangle2D t = new Rectangle2D . Double ( s . getX ( ) + n / 2 . 0 , s . getY ( ) + d / 2 . 0 , s . getWidth ( ) - n , s . getHeight ( ) - d ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int e = ( int ) ( t . getHeight ( ) * this . depthFactor ) ; Rectangle2D a = new Rectangle2D . Double ( o , q , o , z - e ) ; j . setLinkArea ( a ) ; j . setPieArea ( t ) ; j . setPieCenterX ( t . getCenterX ( ) ) ; j . setPieCenterY ( t . getCenterY ( ) - e / 2 . 0 ) ; j . setPieWRadius ( t . getWidth ( ) / 2 . 0 ) ; j . setPieHRadius ( ( t . getHeight ( ) - e ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset f = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( r , b ) ; r . setClip ( u ) ; drawOutline ( r , b ) ; return ; } / / if too any elements if ( f . getKeys ( ) . size ( ) > b . getWidth ( ) ) { String w = \" Too many elements \" ; Font k = new Font ( \" dialog \" , Font . BOLD , 10 ) ; r . setFont ( k ) ; FontMetrics l = r . getFontMetrics ( k ) ; int e = l . stringWidth ( w ) ;  r . drawString ( w , ( int ) ( b . getX ( ) + ( b . getWidth ( ) - e ) / 2 ) , ( int ) ( b . getY ( ) + ( b . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double p = Math . min ( b . getWidth ( ) , b . getHeight ( ) ) / 2 ; b = new Rectangle2D . Double ( b . getCenterX ( ) - p , b . getCenterY ( ) - p , 2 * p , 2 * p ) ; } / / get a list of keys . . . List e = f . getKeys ( ) ; if ( e . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double f = t . getX ( ) ; double k = t . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite c = r . getComposite ( ) ; r . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double k = DatasetUtilities . calculatePieDatasetTotal ( f ) ; double y = 0 ; if ( e < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList b = new ArrayList ( ) ; Arc2D . Double v ; Paint g ; Paint x ; Stroke i ; Iterator g = e . iterator ( ) ; while ( g . hasNext ( ) ) { Comparable i = ( Comparable ) g . next ( ) ; Number j = f . getValue ( i ) ; if ( j = = null ) { b . add ( null ) ; continue ; } double z = j . doubleValue ( ) ; if ( z < = 0 ) { b . add ( null ) ; continue ; } double q = getStartAngle ( ) ; double f = getDirection ( ) . getFactor ( ) ; double j = q + ( f * ( y * 360 ) ) / k ; double f = q + ( f * ( y + z ) * 360 ) / k ; if ( Math . abs ( f - j ) > getMinimumArcAngleToDraw ( ) ) { b . add ( new Arc2D . Double ( f , k + e , t . getWidth ( ) , t . getHeight ( ) - e , j , f - j , Arc2D . PIE ) ) ; } else { b . add ( null ) ; } y + = z ; } Shape d = r . getClip ( ) ; Ellipse2D v = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) , t . getWidth ( ) , t . getHeight ( ) - e ) ; Ellipse2D a = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) + e , t . getWidth ( ) , t . getHeight ( ) - e ) ; Rectangle2D z = new Rectangle2D . Double ( v . getX ( ) , v . getCenterY ( ) , t . getWidth ( ) , a . getMaxY ( ) - v . getCenterY ( ) ) ; Rectangle2D g = new Rectangle2D . Double ( t . getX ( ) , v . getY ( ) , t . getWidth ( ) , a . getCenterY ( ) - v . getY ( ) ) ; Area o = new Area ( v ) ; o . add ( new Area ( z ) ) ; Area p = new Area ( a ) ; p . add ( new Area ( g ) ) ; Area m = new Area ( o ) ; m . intersect ( p ) ; Area c = new Area ( m ) ; c . subtract ( new Area ( v ) ) ; Area a = new Area ( m ) ; a . subtract ( new Area ( a ) ) ; / / draw the bottom circle int [ ] h ; int [ ] d ; v = new Arc2D . Double ( f , k + e , t . getWidth ( ) , t . getHeight ( ) - e , 0 , 360 , Arc2D . PIE ) ;  int w = b . size ( ) ; for ( int i = 0 ; i < w ; i + + ) { v = ( Arc2D . Double ) b . get ( i ) ; if ( v = = null ) { continue ; } Comparable r = getSectionKey ( i ) ; g = lookupSectionPaint ( r , true ) ; x = lookupSectionOutlinePaint ( r ) ; i = lookupSectionOutlineStroke ( r ) ; r . setPaint ( g ) ; r . fill ( v ) ; r . setPaint ( x ) ; r . setStroke ( i ) ; r . draw ( v ) ; r . setPaint ( g ) ;  Point2D d = v . getStartPoint ( ) ; / / draw the height h = new int [ ] { ( int ) v . getCenterX ( ) , ( int ) v . getCenterX ( ) , ( int ) d . getX ( ) , ( int ) d . getX ( ) } ; d = new int [ ] { ( int ) v . getCenterY ( ) , ( int ) v . getCenterY ( ) - e , ( int ) d . getY ( ) - e , ( int ) d . getY ( ) } ; Polygon h = new Polygon ( h , d , 4 ) ; r . setPaint ( java . awt . Color . lightGray ) ; r . fill ( h ) ; r . setPaint ( x ) ; r . setStroke ( i ) ; r . draw ( h ) ; r . setPaint ( g ) ; } r . setPaint ( Color . gray ) ; r . fill ( a ) ; r . fill ( c ) ; / / cycle through once drawing only the sides at the back . . . int m = 0 ; g = b . iterator ( ) ; while ( g . hasNext ( ) ) { Arc2D l = ( Arc2D ) g . next ( ) ; if ( l ! = null ) { Comparable h = getSectionKey ( m ) ; g = lookupSectionPaint ( h , true ) ; x = lookupSectionOutlinePaint ( h ) ; i = lookupSectionOutlineStroke ( h ) ; drawSide ( r , t , l , c , a , g , x , i , false , true ) ; } m + + ; } / / cycle through again drawing only the sides at the front . . . m = 0 ; g = b . iterator ( ) ; while ( g . hasNext ( ) ) { Arc2D t = ( Arc2D ) g . next ( ) ; if ( t ! = null ) { Comparable x = getSectionKey ( m ) ; g = lookupSectionPaint ( x ) ; x = lookupSectionOutlinePaint ( x ) ; i = lookupSectionOutlineStroke ( x ) ; drawSide ( r , t , t , c , a , g , x , i , true , false ) ; } m + + ; } r . setClip ( d ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D v ; for ( int c = 0 ; c < w ; c + + ) { v = ( Arc2D . Double ) b . get ( c ) ; if ( v = = null ) { continue ; } v = new Arc2D . Double ( f , k , t . getWidth ( ) , t . getHeight ( ) - e , v . getAngleStart ( ) , v . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable l = ( Comparable ) e . get ( c ) ; g = lookupSectionPaint ( l , true ) ; x = lookupSectionOutlinePaint ( l ) ; i = lookupSectionOutlineStroke ( l ) ; r . setPaint ( g ) ; r . fill ( v ) ; r . setStroke ( i ) ; r . setPaint ( x ) ; r . draw ( v ) ; / / add a tooltip for the section . . . if ( x ! = null ) { EntityCollection s = x . getOwner ( ) . getEntityCollection ( ) ; if ( s ! = null ) { String i = null ; PieToolTipGenerator s = getToolTipGenerator ( ) ; if ( s ! = null ) { / / @ mgs : using the method ' s return value was missing i = s . generateToolTip ( f , l ) ; } String b = null ; if ( getURLGenerator ( ) ! = null ) { b = getURLGenerator ( ) . generateURL ( f , l , getPieIndex ( ) ) ; } PieSectionEntity w = new PieSectionEntity ( v , f , getPieIndex ( ) , c , l , i , b ) ; s . add ( w ) ; } } List y = f . getKeys ( ) ; Rectangle2D g = new Rectangle2D . Double ( n . getX ( ) , n . getY ( ) , n . getWidth ( ) , n . getHeight ( ) - e ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( r , y , k , g , a , j ) ; } else { drawLabels ( r , y , k , g , a , j ) ; } } r . setClip ( u ) ; r . setComposite ( c ) ; drawOutline ( r , n ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D u , Rectangle2D v , Point2D l , PlotState t , PlotRenderingInfo a ) { / / adjust for insets . . . RectangleInsets r = getInsets ( ) ; r . trim ( v ) ; Rectangle2D h = ( Rectangle2D ) v . clone ( ) ; if ( a ! = null ) { a . setPlotArea ( v ) ; a . setDataArea ( v ) ; } drawBackground ( u , v ) ; Shape c = u . getClip ( ) ; u . clip ( v ) ; / / adjust the plot area by the interior spacing value double u = getInteriorGap ( ) ; double k = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { k = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double j = v . getWidth ( ) * ( u + k ) * 2 . 0 ; double y = v . getHeight ( ) * u * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double t = v . getWidth ( ) * getInteriorGap ( ) ; double c = v . getHeight ( ) * getInteriorGap ( ) ; double k = v . getX ( ) + t ; double h = v . getMaxX ( ) - t ; double p = v . getY ( ) + c ; double a = v . getMaxY ( ) - c ; u . setPaint ( Color . lightGray ) ; u . draw ( new Rectangle2D . Double ( k , p , h - k , a - p ) ) ; } double q = v . getX ( ) + j / 2 ; double d = v . getY ( ) + y / 2 ; double a = v . getWidth ( ) - j ; double w = v . getHeight ( ) - y ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double r = Math . min ( a , w ) / 2 ; q = ( q + q + a ) / 2 - r ; d = ( d + d + w ) / 2 - r ; a = 2 * r ; w = 2 * r ; } if ( a = = null ) { return ; } PiePlotState e = initialise ( u , v , this , null , a ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D y = new Rectangle2D . Double ( q , d , a , w * ( 1 - this . depthFactor ) ) ; e . setLinkArea ( y ) ; if ( DEBUG_DRAW_LINK_AREA ) { u . setPaint ( Color . blue ) ; u . draw ( y ) ; u . setPaint ( Color . yellow ) ; u . draw ( new Ellipse2D . Double ( y . getX ( ) , y . getY ( ) , y . getWidth ( ) , y . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double z = a * getLabelLinkMargin ( ) ; double x = w * getLabelLinkMargin ( ) ; Rectangle2D o = new Rectangle2D . Double ( q + z / 2 . 0 , d + x / 2 . 0 , a - z , w - x ) ; e . setExplodedPieArea ( o ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double z = getMaximumExplodePercent ( ) ; double t = z / ( 1 . 0 + z ) ; double b = o . getWidth ( ) * t ; double q = o . getHeight ( ) * t ; Rectangle2D g = new Rectangle2D . Double ( o . getX ( ) + b / 2 . 0 , o . getY ( ) + q / 2 . 0 , o . getWidth ( ) - b , o . getHeight ( ) - q ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int l = ( int ) ( g . getHeight ( ) * this . depthFactor ) ; Rectangle2D p = new Rectangle2D . Double ( q , d , a , w - l ) ; e . setLinkArea ( p ) ; e . setPieArea ( g ) ; e . setPieCenterX ( g . getCenterX ( ) ) ; e . setPieCenterY ( g . getCenterY ( ) - l / 2 . 0 ) ; e . setPieWRadius ( g . getWidth ( ) / 2 . 0 ) ; e . setPieHRadius ( ( g . getHeight ( ) - l ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset z = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( u , v ) ; u . setClip ( c ) ; drawOutline ( u , v ) ; return ; } / / if too any elements if ( z . getKeys ( ) . size ( ) > v . getWidth ( ) ) { String u = \" Too many elements \" ; Font s = new Font ( \" dialog \" , Font . BOLD , 10 ) ; u . setFont ( s ) ; FontMetrics j = u . getFontMetrics ( s ) ; int w = j . stringWidth ( u ) ;  u . drawString ( u , ( int ) ( v . getX ( ) + ( v . getWidth ( ) - w ) / 2 ) , ( int ) ( v . getY ( ) + ( v . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double n = Math . min ( v . getWidth ( ) , v . getHeight ( ) ) / 2 ; v = new Rectangle2D . Double ( v . getCenterX ( ) - n , v . getCenterY ( ) - n , 2 * n , 2 * n ) ; } / / get a list of keys . . . List d = z . getKeys ( ) ; if ( d . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double o = g . getX ( ) ; double f = g . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite d = u . getComposite ( ) ; u . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double k = DatasetUtilities . calculatePieDatasetTotal ( z ) ; double q = 0 ; if ( l < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList h = new ArrayList ( ) ; Arc2D . Double u ; Paint o ; Paint f ; Stroke o ; Iterator w = d . iterator ( ) ; while ( w . hasNext ( ) ) { Comparable v = ( Comparable ) w . next ( ) ; Number l = z . getValue ( v ) ; if ( l = = null ) { h . add ( null ) ; continue ; } double x = l . doubleValue ( ) ; if ( x < = 0 ) { h . add ( null ) ; continue ; } double z = getStartAngle ( ) ; double e = getDirection ( ) . getFactor ( ) ; double w = z + ( e * ( q * 360 ) ) / k ; double i = z + ( e * ( q + x ) * 360 ) / k ; if ( Math . abs ( i - w ) > getMinimumArcAngleToDraw ( ) ) { h . add ( new Arc2D . Double ( o , f + l , g . getWidth ( ) , g . getHeight ( ) - l , w , i - w , Arc2D . PIE ) ) ; } else { h . add ( null ) ; } q + = x ; } Shape m = u . getClip ( ) ; Ellipse2D g = new Ellipse2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , g . getHeight ( ) - l ) ; Ellipse2D i = new Ellipse2D . Double ( g . getX ( ) , g . getY ( ) + l , g . getWidth ( ) , g . getHeight ( ) - l ) ; Rectangle2D n = new Rectangle2D . Double ( g . getX ( ) , g . getCenterY ( ) , g . getWidth ( ) , i . getMaxY ( ) - g . getCenterY ( ) ) ; Rectangle2D a = new Rectangle2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , i . getCenterY ( ) - g . getY ( ) ) ; Area p = new Area ( g ) ; p . add ( new Area ( n ) ) ; Area n = new Area ( i ) ; n . add ( new Area ( a ) ) ; Area s = new Area ( p ) ; s . intersect ( n ) ; Area m = new Area ( s ) ; m . subtract ( new Area ( g ) ) ; Area b = new Area ( s ) ; b . subtract ( new Area ( i ) ) ; / / draw the bottom circle int [ ] g ; int [ ] v ; u = new Arc2D . Double ( o , f + l , g . getWidth ( ) , g . getHeight ( ) - l , 0 , 360 , Arc2D . PIE ) ;  int f = h . size ( ) ; for ( int i = 0 ; i < f ; i + + ) { u = ( Arc2D . Double ) h . get ( i ) ; if ( u = = null ) { continue ; } Comparable q = getSectionKey ( i ) ; o = lookupSectionPaint ( q , true ) ; f = lookupSectionOutlinePaint ( q ) ; o = lookupSectionOutlineStroke ( q ) ; u . setPaint ( o ) ; u . fill ( u ) ; u . setPaint ( f ) ; u . setStroke ( o ) ; u . draw ( u ) ; u . setPaint ( o ) ;  Point2D p = u . getStartPoint ( ) ; / / draw the height g = new int [ ] { ( int ) u . getCenterX ( ) , ( int ) u . getCenterX ( ) , ( int ) p . getX ( ) , ( int ) p . getX ( ) } ; v = new int [ ] { ( int ) u . getCenterY ( ) , ( int ) u . getCenterY ( ) - l , ( int ) p . getY ( ) - l , ( int ) p . getY ( ) } ; Polygon e = new Polygon ( g , v , 4 ) ; u . setPaint ( java . awt . Color . lightGray ) ; u . fill ( e ) ; u . setPaint ( f ) ; u . setStroke ( o ) ; u . draw ( e ) ; u . setPaint ( o ) ; } u . setPaint ( Color . gray ) ; u . fill ( b ) ; u . fill ( m ) ; / / cycle through once drawing only the sides at the back . . . int s = 0 ; w = h . iterator ( ) ; while ( w . hasNext ( ) ) { Arc2D x = ( Arc2D ) w . next ( ) ; if ( x ! = null ) { Comparable r = getSectionKey ( s ) ; o = lookupSectionPaint ( r , true ) ; f = lookupSectionOutlinePaint ( r ) ; o = lookupSectionOutlineStroke ( r ) ; drawSide ( u , g , x , m , b , o , f , o , false , true ) ; } s + + ; } / / cycle through again drawing only the sides at the front . . . s = 0 ; w = h . iterator ( ) ; while ( w . hasNext ( ) ) { Arc2D b = ( Arc2D ) w . next ( ) ; if ( b ! = null ) { Comparable y = getSectionKey ( s ) ; o = lookupSectionPaint ( y ) ; f = lookupSectionOutlinePaint ( y ) ; o = lookupSectionOutlineStroke ( y ) ; drawSide ( u , g , b , m , b , o , f , o , true , false ) ; } s + + ; } u . setClip ( m ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D n ; for ( int m = 0 ; m < f ; m + + ) { u = ( Arc2D . Double ) h . get ( m ) ; if ( u = = null ) { continue ; } n = new Arc2D . Double ( o , f , g . getWidth ( ) , g . getHeight ( ) - l , u . getAngleStart ( ) , u . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable s = ( Comparable ) d . get ( m ) ; o = lookupSectionPaint ( s , true ) ; f = lookupSectionOutlinePaint ( s ) ; o = lookupSectionOutlineStroke ( s ) ; u . setPaint ( o ) ; u . fill ( n ) ; u . setStroke ( o ) ; u . setPaint ( f ) ; u . draw ( n ) ; / / add a tooltip for the section . . . if ( a ! = null ) { EntityCollection v = a . getOwner ( ) . getEntityCollection ( ) ; if ( v ! = null ) { String c = null ; PieToolTipGenerator x = getToolTipGenerator ( ) ; if ( x ! = null ) { / / @ mgs : using the method ' s return value was missing c = x . generateToolTip ( z , s ) ; } String y = null ; if ( getURLGenerator ( ) ! = null ) { y = getURLGenerator ( ) . generateURL ( z , s , getPieIndex ( ) ) ; } PieSectionEntity r = new PieSectionEntity ( n , z , getPieIndex ( ) , m , s , c , y ) ; v . add ( r ) ; } } List t = z . getKeys ( ) ; Rectangle2D j = new Rectangle2D . Double ( h . getX ( ) , h . getY ( ) , h . getWidth ( ) , h . getHeight ( ) - l ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( u , t , k , j , p , e ) ; } else { drawLabels ( u , t , k , j , p , e ) ; } } u . setClip ( c ) ; u . setComposite ( d ) ; drawOutline ( u , h ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeAgedItems ( boolean o ) { / / check if there are any values earlier than specified by the history / / count . . . if ( getItemCount ( ) > 1 ) { long n = getTimePeriod ( getItemCount ( ) - 1 ) . getSerialIndex ( ) ; boolean p = false ; while ( ( n - getTimePeriod ( 0 ) . getSerialIndex ( ) ) > this . maximumItemAge ) { this . data . remove ( 0 ) ; p = true ; } if ( p ) { findBoundsByIteration ( ) ; if ( o ) { fireSeriesChanged ( ) ; } }", "text_2": "public class test { public void removeAgedItems ( boolean a ) { / / check if there are any values earlier than specified by the history / / count . . . if ( getItemCount ( ) > 1 ) { long y = getTimePeriod ( getItemCount ( ) - 1 ) . getSerialIndex ( ) ; boolean z = false ; while ( ( y - getTimePeriod ( 0 ) . getSerialIndex ( ) ) > this . maximumItemAge ) { this . data . remove ( 0 ) ; z = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( a ) { fireSeriesChanged ( ) ; } }", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int r , int t ) { Number q = null ; MeanAndStandardDeviation s = ( MeanAndStandardDeviation ) this . data . getObject ( r , t ) ; if ( s ! = null ) { q = s . getMean ( ) ; } return q ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int i , int l ) { Number j = null ; MeanAndStandardDeviation k = ( MeanAndStandardDeviation ) this . data . getObject ( i , l ) ; if ( k ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Paint getPaint ( double z ) { double b = Math . max ( z , this . lowerBound ) ; b = Math . min ( b , this . upperBound ) ; int a = ( int ) ( ( z - this . lowerBound ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( a , a , a ) ; } } \\ No newline at end of file", "text_2": "public class test { public Paint getPaint ( double k ) { double m = Math . max ( k , this . lowerBound ) ; m = Math . min ( m , this . upperBound ) ; int l = ( int ) ( ( java . lang . Math . min ( m , upperBound ) ) / ( this . upperBound - this . lowerBound ) * 255 . 0 ) ; return new Color ( l , l , l ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int q , int v ) throws CloneNotSupportedException { if ( q < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( v < q ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries p = ( TimeSeries ) super . clone ( ) ; p . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int u = q ; u < = v ; u + + ) { TimeSeriesDataItem r = ( TimeSeriesDataItem ) this . data . get ( u ) ; TimeSeriesDataItem s = ( TimeSeriesDataItem ) r . clone ( ) ; try { p . add ( s ) ; } catch ( SeriesException t ) { t . printStackTrace ( ) ; } } } return p ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int y , int t ) throws CloneNotSupportedException { if ( y < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( t < y ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries u = ( TimeSeries ) super . clone ( ) ; u . data = new java . util . ArrayList ( ) ; u = new TimeSeries ( y ) ; if ( this . data . size ( ) > 0 ) { for ( int s = y ; s < = t ; s + + ) { TimeSeriesDataItem w = ( TimeSeriesDataItem ) this . data . get ( s ) ; TimeSeriesDataItem x = ( TimeSeriesDataItem ) w . clone ( ) ; try { u . add ( x ) ; } catch ( SeriesException v ) { v . printStackTrace ( ) ; } } } return u ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer f , Graphics2D b , RectangleConstraint w ) { double [ ] v = new double [ 5 ] ; double [ ] g = new double [ 5 ] ; v [ 0 ] = w . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D h = this . topBlock . arrange ( b , u ) ; g [ 0 ] = h . height ; } v [ 1 ] = v [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) - g [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D d = this . bottomBlock . arrange ( b , x ) ; g [ 1 ] = d . height ; } g [ 2 ] = w . getHeight ( ) - g [ 1 ] - g [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . leftBlock . arrange ( b , y ) ; v [ 2 ] = a . width ; } g [ 3 ] = g [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D c = this . rightBlock . arrange ( b , z ) ; v [ 3 ] = c . width ; } g [ 4 ] = g [ 2 ] ; v [ 4 ] = w . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint e = new RectangleConstraint ( v [ 4 ] , g [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( b , e ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , g [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] + g [ 2 ] , v [ 1 ] , g [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] , v [ 2 ] , g [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , g [ 0 ] , v [ 3 ] , g [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , g [ 0 ] , v [ 4 ] , g [ 4 ] ) ) ; } return new Size2D ( w . getWidth ( ) , w . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer c , Graphics2D f , RectangleConstraint v ) { double [ ] g = new double [ 5 ] ; double [ ] z = new double [ 5 ] ; g [ 0 ] = v . getWidth ( ) ; this . rightBlock = null ; g [ 1 ] = g [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( g [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) - z [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D x = this . bottomBlock . arrange ( f , b ) ; z [ 1 ] = x . height ; } z [ 2 ] = v . getHeight ( ) - z [ 1 ] - z [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . leftBlock . arrange ( f , d ) ; g [ 2 ] = e . width ; } z [ 3 ] = z [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) - g [ 2 ] ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . rightBlock . arrange ( f , y ) ; g [ 3 ] = a . width ; } z [ 4 ] = z [ 2 ] ; g [ 4 ] = v . getWidth ( ) - g [ 3 ] - g [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( g [ 4 ] , z [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( f , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , g [ 0 ] , z [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] + z [ 2 ] , g [ 1 ] , z [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] , g [ 2 ] , z [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( g [ 2 ] + g [ 4 ] , z [ 0 ] , g [ 3 ] , z [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( g [ 2 ] , z [ 0 ] , g [ 4 ] , z [ 4 ] ) ) ; } return new Size2D ( v . getWidth ( ) , v . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeRangeMarker ( int f , Marker b , Layer a , boolean d ) { if ( b = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList c ; if ( a = = Layer . FOREGROUND ) { c = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( f ) ) ; } else { c = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( f ) ) ; } boolean e = c . remove ( b ) ; if ( e & & d ) { fireChangeEvent ( ) ; } return e ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeRangeMarker ( int i , Marker n , Layer l , boolean k ) { if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList m ; if ( l ! = Layer . FOREGROUND ) { m = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { m = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } boolean j = m . remove ( n ) ; if ( j & & k ) { fireChangeEvent ( ) ; } return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeRangeMarker ( int l , Marker i , Layer j , boolean k ) { if ( i = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList m ; if ( j = = Layer . FOREGROUND ) { m = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( l ) ) ; } else { m = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( l ) ) ; } boolean n = m . remove ( i ) ; if ( n & & k ) { fireChangeEvent ( ) ; } return n ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeRangeMarker ( int o , Marker t , Layer r , boolean s ) { if ( t = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList p ; if ( r = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( o ) ) ; } else { p = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( o ) ) ; } boolean q = getAnnotations ( ) . remove ( t ) ; if ( q & & s ) { fireChangeEvent ( ) ; } return q ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFN ( BlockContainer k , Graphics2D b , double l ) { double [ ] r = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; RectangleConstraint q = new RectangleConstraint ( l , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D s = this . topBlock . arrange ( b , q ) ; r [ 0 ] = s . width ; p [ 0 ] = s . height ; } if ( this . bottomBlock ! = null ) { Size2D m = this . bottomBlock . arrange ( b , q ) ; r [ 1 ] = m . width ; p [ 1 ] = m . height ; } RectangleConstraint i = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D t = this . leftBlock . arrange ( b , i ) ; r [ 2 ] = t . width ; p [ 2 ] = t . height ; } if ( this . rightBlock ! = null ) { double u = Math . max ( l - r [ 2 ] , 0 . 0 ) ; RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( r [ 2 ] , u ) , u ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D q = this . rightBlock . arrange ( b , w ) ; r [ 3 ] = q . width ; p [ 3 ] = q . height ; } p [ 2 ] = Math . max ( p [ 2 ] , p [ 3 ] ) ; p [ 3 ] = p [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( l - r [ 2 ] - r [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D j = this . centerBlock . arrange ( b , n ) ; r [ 4 ] = j . width ; p [ 4 ] = j . height ; } double d = p [ 0 ] + p [ 1 ] + Math . max ( p [ 2 ] , Math . max ( p [ 3 ] , p [ 4 ] ) ) ; return arrange ( k , b , new RectangleConstraint ( l , d ) ) ; } protected Size2D arrangeFF ( BlockContainer c , Graphics2D f , RectangleConstraint x ) { double [ ] s = new double [ 5 ] ; double [ ] t = new double [ 5 ] ; s [ 0 ] = x . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D r = this . topBlock . arrange ( f , z ) ; t [ 0 ] = r . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) - t [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D y = this . bottomBlock . arrange ( f , e ) ; t [ 1 ] = y . height ; } t [ 2 ] = x . getHeight ( ) - t [ 1 ] - t [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D o = this . leftBlock . arrange ( f , g ) ; s [ 2 ] = o . width ; } t [ 3 ] = t [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D h = this . rightBlock . arrange ( f , a ) ; s [ 3 ] = h . width ; } t [ 4 ] = t [ 2 ] ; s [ 4 ] = x . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( s [ 4 ] , t [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( f , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , t [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] + t [ 2 ] , s [ 1 ] , t [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] , s [ 2 ] , t [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , t [ 0 ] , s [ 3 ] , t [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , t [ 0 ] , s [ 4 ] , t [ 4 ] ) ) ; } return new Size2D ( x . getWidth ( ) , x . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFN ( BlockContainer x , Graphics2D p , double c ) { double [ ] r = new double [ 5 ] ; double [ ] u = new double [ 5 ] ; RectangleConstraint d = new RectangleConstraint ( c , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D v = this . topBlock . arrange ( p , d ) ; r [ 0 ] = v . width ; u [ 0 ] = v . height ; } if ( this . bottomBlock ! = null ) { Size2D i = this . bottomBlock . arrange ( p , d ) ; r [ 1 ] = i . width ; u [ 1 ] = i . height ; } RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D g = this . leftBlock . arrange ( p , b ) ; r [ 2 ] = g . width ; this . topBlock = null ; u [ 2 ] = g . height ; } if ( this . rightBlock ! = null ) { double j = Math . max ( c - r [ 2 ] , 0 . 0 ) ; RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( r [ 2 ] , j ) , j ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D n = this . rightBlock . arrange ( p , y ) ; r [ 3 ] = n . width ; u [ 3 ] = n . height ; } u [ 2 ] = Math . max ( u [ 2 ] , u [ 3 ] ) ; u [ 3 ] = u [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( c - r [ 2 ] - r [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D s = this . centerBlock . arrange ( p , w ) ; r [ 4 ] = s . width ; u [ 4 ] = s . height ; } double l = u [ 0 ] + u [ 1 ] + Math . max ( u [ 2 ] , Math . max ( u [ 3 ] , u [ 4 ] ) ) ; return arrange ( x , p , new RectangleConstraint ( c , l ) ) ; } protected Size2D arrangeFF ( BlockContainer o , Graphics2D t , RectangleConstraint h ) { double [ ] e = new double [ 5 ] ; double [ ] a = new double [ 5 ] ; e [ 0 ] = h . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , h . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D q = this . topBlock . arrange ( t , g ) ; a [ 0 ] = q . height ; } e [ 1 ] = e [ 0 ] ; Size2D k = arrangeNN ( o , t ) ; this . rightBlock = null ; a [ 2 ] = h . getHeight ( ) - a [ 1 ] - a [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , h . getWidth ( ) ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D f = this . leftBlock . arrange ( t , f ) ; e [ 2 ] = f . width ; } a [ 3 ] = a [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , h . getWidth ( ) - e [ 2 ] ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . rightBlock . arrange ( t , e ) ; e [ 3 ] = z . width ; } a [ 4 ] = a [ 2 ] ; e [ 4 ] = h . getWidth ( ) - e [ 3 ] - e [ 2 ] ; RectangleConstraint m = new RectangleConstraint ( e [ 4 ] , a [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( t , m ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , e [ 0 ] , a [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] + a [ 2 ] , e [ 1 ] , a [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] , e [ 2 ] , a [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] + e [ 4 ] , a [ 0 ] , e [ 3 ] , a [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] , a [ 0 ] , e [ 4 ] , a [ 4 ] ) ) ; } return new Size2D ( h . getWidth ( ) , h . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D m , CategoryItemRendererState p , Rectangle2D w , CategoryPlot s , CategoryAxis o , ValueAxis t , CategoryDataset u , int x , int n , int q ) { / / defensive check if ( ! ( u instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset v = ( StatisticalCategoryDataset ) u ; PlotOrientation r = s . getOrientation ( ) ; if ( r = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( m , p , w , s , o , t , v , x , n ) ; } else if ( r = = PlotOrientation . VERTICAL ) { drawVerticalItem ( m , p , w , s , o , t , v , x , n ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D t , CategoryItemRendererState o , Rectangle2D j , CategoryPlot r , CategoryAxis l , ValueAxis k , CategoryDataset p , int s , int n , int m ) { / / defensive check if ( ! ( p instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset q = ( StatisticalCategoryDataset ) p ; PlotOrientation u = null ; if ( u = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( t , o , j , r , l , k , q , s , n ) ; } else if ( u = = PlotOrientation . VERTICAL ) { drawVerticalItem ( t , o , j , r , l , k , q , s , n ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getColumnCount ( ) { return this . data . getRowCount ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D x , CategoryItemRendererState r , Rectangle2D y , CategoryPlot t , CategoryAxis q , ValueAxis u , CategoryDataset o , int v , int s , int z ) { / / defensive check if ( ! ( o instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset w = ( StatisticalCategoryDataset ) o ; PlotOrientation p = t . getOrientation ( ) ; if ( p = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( x , r , y , t , q , u , w , v , s ) ; } else if ( p = = PlotOrientation . VERTICAL ) { drawVerticalItem ( x , r , y , t , q , u , w , v , s ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D d , CategoryItemRendererState e , Rectangle2D i , CategoryPlot l , CategoryAxis j , ValueAxis m , CategoryDataset o , int n , int g , int f ) { / / defensive check if ( ! ( o instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset h = ( StatisticalCategoryDataset ) o ; PlotOrientation k = l . getOrientation ( ) ; if ( 0 = = 1 ) { if ( k = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( d , e , i , l , j , m , h , n , g ) ; } else if ( k = = PlotOrientation . VERTICAL ) { drawVerticalItem ( d , e , i , l , j , m , h , n , g ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number x , Number z ) { if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem y = null ; int a = indexOf ( x ) ; if ( a > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem b = ( XYDataItem ) this . data . get ( a ) ; try { y = ( XYDataItem ) b . clone ( ) ; } catch ( CloneNotSupportedException w ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } b . setY ( z ) ; } else { if ( this . autoSort ) { this . data . add ( - a - 1 , new XYDataItem ( x , z ) ) ; } else { this . data . add ( new XYDataItem ( x , z ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; } } fireSeriesChanged ( ) ; return y ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number u , Number t ) { if ( u = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem v = null ; int s = indexOf ( u ) ; if ( s > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem w = ( XYDataItem ) this . data . get ( s ) ; try { v = ( XYDataItem ) w . clone ( ) ; } catch ( CloneNotSupportedException r ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } w . setY ( t ) ; } else { this . data . add ( new XYDataItem ( u , t ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; } } fireSeriesChanged ( ) ; return v ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Range ( double t , double v ) { if ( t > v ) { String u = \" Range ( double , double ) : require lower ( \" + t + \" ) < = upper ( \" + v + \" ) . \" ; throw new IllegalArgumentException ( u ) ; } this . lower = t ; this . upper = v ; } } \\ No newline at end of file", "text_2": "public class test { public Range ( double p , double n ) { if ( p > n ) { String o = \" Range ( double , double ) : require lower ( \" + p + \" ) < = upper ( \" + n + \" ) . \" ;  } this . lower = p ; this . upper = n ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection z = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return z ; } int w = this . plot . getIndexOf ( this ) ; CategoryDataset y = this . plot . getDataset ( w ) ; if ( y ! = null ) { return z ; } int b = y . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int x = 0 ; x < b ; x + + ) { if ( isSeriesVisibleInLegend ( x ) ) { LegendItem c = getLegendItem ( w , x ) ; if ( c ! = null ) { z . add ( c ) ; } } } } else { for ( int v = b - 1 ; v > = 0 ; v - - ) { if ( isSeriesVisibleInLegend ( v ) ) { LegendItem a = getLegendItem ( w , v ) ; if ( a ! = null ) { z . add ( a ) ; } } } } return z ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection c = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return c ; } int f = this . plot . getIndexOf ( this ) ; CategoryDataset d = this . plot . getDataset ( f ) ; if ( false ) { if ( d ! = null ) { return c ; } } int g = d . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int j = 0 ; j < g ; j + + ) { if ( isSeriesVisibleInLegend ( j ) ) { LegendItem i = getLegendItem ( f , j ) ; if ( i ! = null ) { c . add ( i ) ; } } } } else { for ( int h = g - 1 ; h > = 0 ; h - - ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem e = getLegendItem ( f , h ) ; if ( e ! = null ) { c . add ( e ) ; } } } } return c ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer v , Graphics2D g , RectangleConstraint e ) { double [ ] f = new double [ 5 ] ; double [ ] c = new double [ 5 ] ; f [ 0 ] = e . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , e . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D h = this . topBlock . arrange ( g , a ) ; c [ 0 ] = h . height ; } f [ 1 ] = f [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , e . getHeight ( ) - c [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D b = this . bottomBlock . arrange ( g , w ) ; c [ 1 ] = b . height ; } c [ 2 ] = e . getHeight ( ) - c [ 1 ] - c [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , e . getWidth ( ) ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . leftBlock . arrange ( g , x ) ; f [ 2 ] = y . width ; } c [ 3 ] = c [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , e . getWidth ( ) - f [ 2 ] ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D d = this . rightBlock . arrange ( g , u ) ; f [ 3 ] = d . width ; } c [ 4 ] = c [ 2 ] ; f [ 4 ] = e . getWidth ( ) - f [ 3 ] - f [ 2 ] ; RectangleConstraint z = new RectangleConstraint ( f [ 4 ] , c [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g , z ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , f [ 0 ] , c [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] + c [ 2 ] , f [ 1 ] , c [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] , f [ 2 ] , c [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] + f [ 4 ] , c [ 0 ] , f [ 3 ] , c [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] , c [ 0 ] , f [ 4 ] , c [ 4 ] ) ) ; } return new Size2D ( e . getWidth ( ) , e . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer e , Graphics2D b , RectangleConstraint w ) { this . leftBlock = null ; double [ ] d = new double [ 5 ] ; double [ ] g = new double [ 5 ] ; d [ 0 ] = w . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D y = this . topBlock . arrange ( b , z ) ; g [ 0 ] = y . height ; } d [ 1 ] = d [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) - g [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D f = this . bottomBlock . arrange ( b , x ) ; g [ 1 ] = f . height ; } g [ 2 ] = w . getHeight ( ) - g [ 1 ] - g [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D c = this . leftBlock . arrange ( b , h ) ; d [ 2 ] = c . width ; } g [ 3 ] = g [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) - d [ 2 ] ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . rightBlock . arrange ( b , i ) ; d [ 3 ] = a . width ; } g [ 4 ] = g [ 2 ] ; d [ 4 ] = w . getWidth ( ) - d [ 3 ] - d [ 2 ] ; RectangleConstraint j = new RectangleConstraint ( d [ 4 ] , g [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( b , j ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , d [ 0 ] , g [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] + g [ 2 ] , d [ 1 ] , g [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] , d [ 2 ] , g [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] + d [ 4 ] , g [ 0 ] , d [ 3 ] , g [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] , g [ 0 ] , d [ 4 ] , g [ 4 ] ) ) ; } return new Size2D ( w . getWidth ( ) , w . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D q , CategoryItemRendererState l , Rectangle2D m , CategoryPlot s , CategoryAxis j , ValueAxis n , CategoryDataset k , int r , int p , int t ) { / / defensive check if ( ! ( k instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset u = ( StatisticalCategoryDataset ) k ; PlotOrientation o = s . getOrientation ( ) ; if ( o = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( q , l , m , s , j , n , u , r , p ) ; } else if ( o = = PlotOrientation . VERTICAL ) { drawVerticalItem ( q , l , m , s , j , n , u , r , p ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D f , CategoryItemRendererState a , Rectangle2D g , CategoryPlot v , CategoryAxis w , ValueAxis d , CategoryDataset x , int b , int e , int c ) { / / defensive check if ( ! ( x instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset y = ( StatisticalCategoryDataset ) x ; PlotOrientation z = v . getOrientation ( ) ; if ( z = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( f , a , g , v , w , d , y , b , e ) ; } if ( z = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( f , a , g , v , w , d , y , b , e ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D k , RectangleConstraint t ) { double [ ] u = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; u [ 0 ] = t . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint v = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , t . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D p = this . topBlock . arrange ( k , v ) ; o [ 0 ] = p . height ; } u [ 1 ] = u [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , t . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( k , q ) ; o [ 1 ] = m . height ; } o [ 2 ] = t . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , t . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . leftBlock . arrange ( k , l ) ; u [ 2 ] = j . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , t . getWidth ( ) - u [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( k , r ) ; u [ 3 ] = s . width ; } o [ 4 ] = o [ 2 ] ; u [ 4 ] = t . getWidth ( ) - u [ 3 ] - u [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( u [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( k , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , u [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , u [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , u [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] + u [ 4 ] , o [ 0 ] , u [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] , o [ 0 ] , u [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( t . getWidth ( ) , t . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer j , Graphics2D c , RectangleConstraint d ) { double [ ] l = new double [ 5 ] ; double [ ] e = new double [ 5 ] ; l [ 0 ] = d . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( l [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D i = this . topBlock . arrange ( c , g ) ; e [ 0 ] = i . height ; } l [ 1 ] = l [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( l [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) - e [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D k = this . bottomBlock . arrange ( c , f ) ; e [ 1 ] = k . height ; } e [ 2 ] = d . getHeight ( ) - e [ 1 ] - e [ 0 ] ; e [ 3 ] = e [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) - l [ 2 ] ) , LengthConstraintType . RANGE , e [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D m = this . rightBlock . arrange ( c , b ) ; l [ 3 ] = m . width ; } e [ 4 ] = e [ 2 ] ; l [ 4 ] = d . getWidth ( ) - l [ 3 ] - l [ 2 ] ; RectangleConstraint h = new RectangleConstraint ( l [ 4 ] , e [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( c , h ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , l [ 0 ] , e [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , e [ 0 ] + e [ 2 ] , l [ 1 ] , e [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , e [ 0 ] , l [ 2 ] , e [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( l [ 2 ] + l [ 4 ] , e [ 0 ] , l [ 3 ] , e [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( l [ 2 ] , e [ 0 ] , l [ 4 ] , e [ 4 ] ) ) ; } return new Size2D ( d . getWidth ( ) , d . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public static JFreeChart createPieChart3D ( String h , PieDataset k , boolean l , boolean m , boolean i ) { PiePlot3D j = new PiePlot3D ( k ) ; j . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( m ) { j . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( i ) { j . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( h , JFreeChart . DEFAULT_TITLE_FONT , j , l ) ; } } \\ No newline at end of file", "text_2": "public class test { public static JFreeChart createPieChart3D ( String n , PieDataset m , boolean k , boolean l , boolean i ) { PiePlot j = new PiePlot ( ) ; j . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( l ) { j . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( i ) { j . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( n , JFreeChart . DEFAULT_TITLE_FONT , j , k ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( Number j , Number g , Comparable k , Comparable h ) { MeanAndStandardDeviation f = new MeanAndStandardDeviation ( j , g ) ; this . data . addObject ( f , k , h ) ; double l = 0 . 0 ; double i = 0 . 0 ; if ( j ! = null ) { l = j . doubleValue ( ) ; } if ( g ! = null ) { i = g . doubleValue ( ) ; } if ( ! Double . isNaN ( l ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | l > this . maximumRangeValue ) { this . maximumRangeValue = l ; } } if ( ! Double . isNaN ( l + i ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( l + i ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = l + i ; } } if ( ! Double . isNaN ( l ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | l < this . minimumRangeValue ) { this . minimumRangeValue = l ; } } if ( ! Double . isNaN ( l - i ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( l - i ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = l - i ; } }", "text_2": "public class test { public void add ( Number m , Number l , Comparable o , Comparable k ) { MeanAndStandardDeviation p = new MeanAndStandardDeviation ( m , l ) ; Number r = getValue ( o , k ) ; double q = 0 . 0 ; double n = 0 . 0 ; if ( m ! = null ) { q = m . doubleValue ( ) ; } if ( l ! = null ) { n = l . doubleValue ( ) ; } if ( ! Double . isNaN ( q ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | q > this . maximumRangeValue ) { this . maximumRangeValue = q ; } } if ( ! Double . isNaN ( q + n ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( q + n ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = q + n ; } } if ( ! Double . isNaN ( q ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | q < this . minimumRangeValue ) { this . minimumRangeValue = q ; } } if ( ! Double . isNaN ( q - n ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( q - n ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = q - n ; } }", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset h ) { super ( ) ; this . dataset = h ; PiePlot g = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( g ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle i = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; i . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( i ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset i ) { super ( ) ; this . dataset = i ; PiePlot h = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( h ) ; this . pieChart . removeLegend ( ) ; setDataset ( i ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle g = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; g . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( g ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { protected void drawHorizontalItem ( Graphics2D q , CategoryItemRendererState x , Rectangle2D p , CategoryPlot k , CategoryAxis m , ValueAxis r , StatisticalCategoryDataset f , int n , int e ) { RectangleEdge c = k . getDomainAxisEdge ( ) ; / / BAR Y double t = m . getCategoryStart ( e , getColumnCount ( ) , p , c ) ; int h = getRowCount ( ) ; int w = getColumnCount ( ) ; if ( h > 1 ) { double g = p . getHeight ( ) * getItemMargin ( ) / ( w * ( h - 1 ) ) ; t = t + n * ( x . getBarWidth ( ) + g ) ; } else { t = t + n * x . getBarWidth ( ) ; } / / BAR X Number l = f . getMeanValue ( n , e ) ; double z = l . doubleValue ( ) ; double q = 0 . 0 ; double v = getLowerClip ( ) ; double u = getUpperClip ( ) ; if ( u < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( z > = u ) { return ; / / bar is not visible } q = u ; if ( z < = v ) { z = v ; } } else if ( v < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( z > = u ) { z = u ; } else { if ( z < = v ) { z = v ; } } } else { / / cases 9 , 10 , 11 and 12 if ( z < = v ) { return ; / / bar is not visible } q = getLowerClip ( ) ; if ( z > = u ) { z = u ; } } RectangleEdge p = k . getRangeAxisEdge ( ) ; double n = r . valueToJava2D ( q , p , p ) ; double o = r . valueToJava2D ( z , p , p ) ; double d = Math . min ( o , n ) ; double s = x . getBarWidth ( ) ; double i = Math . abs ( o - n ) ; Rectangle2D l = new Rectangle2D . Double ( d , t , i , s ) ; Paint k = getItemPaint ( n , e ) ; q . setPaint ( k ) ; q . fill ( l ) ; if ( isDrawBarOutline ( ) & & x . getBarWidth ( ) > 3 ) { q . setStroke ( getItemStroke ( n , e ) ) ; q . setPaint ( getItemOutlinePaint ( n , e ) ) ; q . draw ( l ) ; } / / standard deviation lines double m = f . getStdDevValue ( n , e ) . doubleValue ( ) ; double a = r . valueToJava2D ( l . doubleValue ( ) + m , p , p ) ; double o = r . valueToJava2D ( l . doubleValue ( ) - m , p , p ) ; if ( this . errorIndicatorStroke ! = null ) { q . setStroke ( this . errorIndicatorStroke ) ; } else { q . setStroke ( getItemOutlineStroke ( n , e ) ) ; } if ( this . errorIndicatorPaint ! = null ) { q . setPaint ( this . errorIndicatorPaint ) ; } else { q . setPaint ( getItemOutlinePaint ( n , e ) ) ; } Line2D b = null ; b = new Line2D . Double ( o , t + s / 2 . 0d , a , t + s / 2 . 0d ) ; q . draw ( b ) ; b = new Line2D . Double ( a , t + s * 0 . 25 , a , t + s * 0 . 75 ) ; q . draw ( b ) ; b = new Line2D . Double ( o , t + s * 0 . 25 , o , t + s * 0 . 75 ) ; q . draw ( b ) ; CategoryItemLabelGenerator j = getItemLabelGenerator ( n , e ) ; if ( j ! = null & & isItemLabelVisible ( n , e ) ) { drawItemLabel ( q , f , n , e , k , j , l , ( z < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection y = x . getEntityCollection ( ) ; if ( y ! = null ) { addItemEntity ( y , f , n , e , l ) ; } }", "text_2": "public class test { protected void drawHorizontalItem ( Graphics2D v , CategoryItemRendererState x , Rectangle2D u , CategoryPlot z , CategoryAxis b , ValueAxis g , StatisticalCategoryDataset h , int q , int o ) { RectangleEdge l = z . getDomainAxisEdge ( ) ; / / BAR Y double n = b . getCategoryStart ( o , getColumnCount ( ) , u , l ) ; int o = getRowCount ( ) ; int p = getColumnCount ( ) ; if ( o > 1 ) { double y = u . getHeight ( ) * getItemMargin ( ) / ( p * ( o - 1 ) ) ; n = n + q * ( x . getBarWidth ( ) + y ) ; } else { RectangleEdge w = z . getRangeAxisEdge ( ) ; n = n + q * x . getBarWidth ( ) ; } / / BAR X Number q = h . getMeanValue ( q , o ) ; double f = q . doubleValue ( ) ; double l = 0 . 0 ; double t = getLowerClip ( ) ; double p = getUpperClip ( ) ; if ( p < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( f > = p ) { return ; / / bar is not visible } l = p ; if ( f < = t ) { f = t ; } } else if ( t < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( f > = p ) { f = p ; } else { if ( f < = t ) { f = t ; } } } else { / / cases 9 , 10 , 11 and 12 if ( f < = t ) { return ; / / bar is not visible } l = getLowerClip ( ) ; if ( f > = p ) { f = p ; } } RectangleEdge m = z . getRangeAxisEdge ( ) ; double j = g . valueToJava2D ( l , u , m ) ; double n = g . valueToJava2D ( f , u , m ) ; double m = Math . min ( n , j ) ; double a = x . getBarWidth ( ) ; double s = Math . abs ( n - j ) ; Rectangle2D k = new Rectangle2D . Double ( m , n , s , a ) ; Paint j = getItemPaint ( q , o ) ; v . setPaint ( j ) ; v . fill ( k ) ; if ( isDrawBarOutline ( ) & & x . getBarWidth ( ) > 3 ) { v . setStroke ( getItemStroke ( q , o ) ) ; v . setPaint ( getItemOutlinePaint ( q , o ) ) ; v . draw ( k ) ; } / / standard deviation lines double r = h . getStdDevValue ( q , o ) . doubleValue ( ) ; double c = g . valueToJava2D ( q . doubleValue ( ) + r , u , m ) ; double i = g . valueToJava2D ( q . doubleValue ( ) - r , u , m ) ; if ( this . errorIndicatorStroke ! = null ) { v . setStroke ( this . errorIndicatorStroke ) ; } else { v . setStroke ( getItemOutlineStroke ( q , o ) ) ; } if ( this . errorIndicatorPaint ! = null ) { v . setPaint ( this . errorIndicatorPaint ) ; } else { v . setPaint ( getItemOutlinePaint ( q , o ) ) ; } Line2D e = null ; e = new Line2D . Double ( i , n + a / 2 . 0d , c , n + a / 2 . 0d ) ; v . draw ( e ) ; e = new Line2D . Double ( c , n + a * 0 . 25 , c , n + a * 0 . 75 ) ; v . draw ( e ) ; e = new Line2D . Double ( i , n + a * 0 . 25 , i , n + a * 0 . 75 ) ; v . draw ( e ) ; CategoryItemLabelGenerator d = getItemLabelGenerator ( q , o ) ; if ( d ! = null & & isItemLabelVisible ( q , o ) ) { drawItemLabel ( v , h , q , o , z , d , k , ( f < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection k = x . getEntityCollection ( ) ; if ( k ! = null ) { addItemEntity ( k , h , q , o , k ) ; } }", "text_3": 0}
{"text_1": "public class test { private void updateBounds ( TimePeriod v , int b ) { long h = v . getStart ( ) . getTime ( ) ; long w = v . getEnd ( ) . getTime ( ) ; long c = h + ( ( w - h ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long x = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( h < x ) { this . minStartIndex = b ; } } else { this . minStartIndex = b ; } if ( this . maxStartIndex > = 0 ) { long d = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( h > d ) { this . maxStartIndex = b ; } } else { this . maxStartIndex = b ; } if ( this . minMiddleIndex > = 0 ) { long f = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long y = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long e = f + ( y - f ) / 2 ; if ( c < e ) { this . minMiddleIndex = b ; } } else { this . minMiddleIndex = b ; } if ( this . maxMiddleIndex > = 0 ) { long j = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long i = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long g = j + ( i - j ) / 2 ; if ( c > g ) { this . maxMiddleIndex = b ; } } else { this . maxMiddleIndex = b ; } if ( this . minEndIndex > = 0 ) { long z = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( w < z ) { this . minEndIndex = b ; } } else { this . minEndIndex = b ; } if ( this . maxEndIndex > = 0 ) { long a = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( w > a ) { this . maxEndIndex = b ; } } else { this . maxEndIndex = b ; } }", "text_2": "public class test { private void updateBounds ( TimePeriod h , int e ) { long a = h . getStart ( ) . getTime ( ) ; long j = h . getEnd ( ) . getTime ( ) ; long d = a + ( ( j - a ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long m = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( a < m ) { this . minStartIndex = e ; } } else { this . minStartIndex = e ; } if ( this . maxStartIndex > = 0 ) { long k = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( a > k ) { this . maxStartIndex = e ; } } else { this . maxStartIndex = e ; } if ( this . minMiddleIndex = = 0 ) { long n = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long i = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long b = n + ( i - n ) / 2 ; if ( d < b ) { this . minMiddleIndex = e ; } } else { this . minMiddleIndex = e ; } if ( this . maxMiddleIndex > = 0 ) { long c = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long l = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long f = c + ( l - c ) / 2 ; if ( d > f ) { this . maxMiddleIndex = e ; } } else { this . maxMiddleIndex = e ; } if ( this . minEndIndex > = 0 ) { long g = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( j < g ) { this . minEndIndex = e ; } } else { this . minEndIndex = e ; } if ( this . maxEndIndex > = 0 ) { long z = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( j > z ) { this . maxEndIndex = e ; } } else { this . maxEndIndex = e ; } }", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int g , int i ) throws CloneNotSupportedException { if ( g < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( i < g ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries j = ( TimeSeries ) super . clone ( ) ; j . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int l = g ; l < = i ; l + + ) { TimeSeriesDataItem k = ( TimeSeriesDataItem ) this . data . get ( l ) ; TimeSeriesDataItem h = ( TimeSeriesDataItem ) k . clone ( ) ; try { j . add ( h ) ; } catch ( SeriesException m ) { m . printStackTrace ( ) ; } } } return j ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int e , int j ) throws CloneNotSupportedException { if ( e < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( j < e ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries f = ( TimeSeries ) super . clone ( ) ; f . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int k = e ; k < = j ; k + + ) { TimeSeriesDataItem i = ( TimeSeriesDataItem ) this . data . get ( k ) ; TimeSeriesDataItem h = ( TimeSeriesDataItem ) i . clone ( ) ; try { f . add ( h ) ; } catch ( SeriesException g ) { g . printStackTrace ( ) ; } } } return f . addAndOrUpdate ( f ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int v , int w ) throws CloneNotSupportedException { if ( v < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( w < v ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries z = ( TimeSeries ) super . clone ( ) ; z . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int x = v ; x < = w ; x + + ) { TimeSeriesDataItem t = ( TimeSeriesDataItem ) this . data . get ( x ) ; TimeSeriesDataItem y = ( TimeSeriesDataItem ) t . clone ( ) ; try { z . add ( y ) ; } catch ( SeriesException u ) { u . printStackTrace ( ) ; } } } return z ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int t , int v ) throws CloneNotSupportedException { if ( t < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( v < t & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries s = ( TimeSeries ) super . clone ( ) ; s . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int q = t ; q < = v ; q + + ) { TimeSeriesDataItem p = ( TimeSeriesDataItem ) this . data . get ( q ) ; TimeSeriesDataItem r = ( TimeSeriesDataItem ) p . clone ( ) ; try { s . add ( r ) ; } catch ( SeriesException u ) { u . printStackTrace ( ) ; } } } return s ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection r = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return r ; } int o = this . plot . getIndexOf ( this ) ; CategoryDataset m = this . plot . getDataset ( o ) ; if ( m ! = null ) { return r ; } int n = m . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int p = 0 ; p < n ; p + + ) { if ( isSeriesVisibleInLegend ( p ) ) { LegendItem s = getLegendItem ( o , p ) ; if ( s ! = null ) { r . add ( s ) ; } } } } else { for ( int q = n - 1 ; q > = 0 ; q - - ) { if ( isSeriesVisibleInLegend ( q ) ) { LegendItem l = getLegendItem ( o , q ) ; if ( l ! = null ) { r . add ( l ) ; } } } } return r ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection f = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return f ; } int e = this . plot . getIndexOf ( this ) ; CategoryDataset j = this . plot . getDataset ( e ) ; if ( j ! = null & & ! ( j instanceof SelectableCategoryDataset ) ) { return f ; } int i = j . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int g = 0 ; g < i ; g + + ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem c = getLegendItem ( e , g ) ; if ( c ! = null ) { f . add ( c ) ; } } } } else { for ( int h = i - 1 ; h > = 0 ; h - - ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem d = getLegendItem ( e , h ) ; if ( d ! = null ) { f . add ( d ) ; } } } } return f ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection k = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return k ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset e = this . plot . getDataset ( d ) ; if ( e ! = null ) { return k ; } int h = e . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int j = 0 ; j < h ; j + + ) { if ( isSeriesVisibleInLegend ( j ) ) { LegendItem f = getLegendItem ( d , j ) ; if ( f ! = null ) { k . add ( f ) ; } } } } else { for ( int g = h - 1 ; g > = 0 ; g - - ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem i = getLegendItem ( d , g ) ; if ( i ! = null ) { k . add ( i ) ; } } } } return k ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection h = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return h ; } int j = this . plot . getIndexOf ( this ) ; CategoryDataset n = this . plot . getDataset ( j ) ; if ( n ! = null ) { if ( false ) { return h ; } } int o = n . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < o ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem l = getLegendItem ( j , i ) ; if ( l ! = null ) { h . add ( l ) ; } } } } else { for ( int k = o - 1 ; k > = 0 ; k - - ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem m = getLegendItem ( j , k ) ; if ( m ! = null ) { h . add ( m ) ; } } } } return h ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D p , Rectangle2D a , Point2D x , PlotState q , PlotRenderingInfo y ) { / / if the plot area is too small , just return . . . boolean h = ( a . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean n = ( a . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( h | | n ) { return ; } / / record the plot area . . . if ( y = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes y = new PlotRenderingInfo ( null ) ; } y . setPlotArea ( a ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets w = getInsets ( ) ; w . trim ( a ) ; / / calculate the data area . . . AxisSpace k = calculateAxisSpace ( p , a ) ; Rectangle2D b = k . shrink ( a , null ) ; this . axisOffset . trim ( b ) ; y . setDataArea ( b ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( p , this , b ) ; } else { drawBackground ( p , b ) ; } Map m = drawAxes ( p , a , b , y ) ; / / don ' t let anyone draw outside the data area Shape g = p . getClip ( ) ; p . clip ( b ) ; drawDomainGridlines ( p , b ) ; AxisState r = ( AxisState ) m . get ( getRangeAxis ( ) ) ; if ( r = = null ) { if ( q ! = null ) { r = ( AxisState ) q . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( r ! = null ) { drawRangeGridlines ( p , b , r . getTicks ( ) ) ; } / / draw the markers . . . for ( int e = 0 ; e < this . renderers . size ( ) ; e + + ) { drawDomainMarkers ( p , b , e , Layer . BACKGROUND ) ; } for ( int c = 0 ; c < this . renderers . size ( ) ; c + + ) { drawRangeMarkers ( p , b , c , Layer . BACKGROUND ) ; } / / now render data items . . . boolean i = false ; / / set up the alpha - transparency . . . Composite z = p . getComposite ( ) ; p . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder d = getDatasetRenderingOrder ( ) ; if ( d = = DatasetRenderingOrder . FORWARD ) { for ( int j = 0 ; j < this . datasets . size ( ) ; j + + ) { i = render ( p , b , j , y ) | | i ; } } else { / / DatasetRenderingOrder . REVERSE for ( int l = this . datasets . size ( ) - 1 ; l > = 0 ; l - - ) { i = render ( p , b , l , y ) | | i ; } } / / draw the foreground markers . . . for ( int o = 0 ; o < this . renderers . size ( ) ; o + + ) { drawDomainMarkers ( p , b , o , Layer . FOREGROUND ) ; } for ( int f = 0 ; f < this . renderers . size ( ) ; f + + ) { drawRangeMarkers ( p , b , f , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( p , b ) ; p . setClip ( g ) ; p . setComposite ( z ) ; if ( ! i ) { drawNoDataMessage ( p , b ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( p , b , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( p , this , b ) ; } else { drawOutline ( p , b ) ; } }", "text_2": "public class test { public void draw ( Graphics2D o , Rectangle2D w , Point2D g , PlotState b , PlotRenderingInfo v ) { / / if the plot area is too small , just return . . . boolean q = ( w . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean f = ( w . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( q | | f ) { return ; } / / record the plot area . . . if ( v = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes v = new PlotRenderingInfo ( null ) ; } v . setPlotArea ( w ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets p = getInsets ( ) ; p . trim ( w ) ; / / calculate the data area . . . AxisSpace h = calculateAxisSpace ( o , w ) ; Rectangle2D m = h . shrink ( w , null ) ; this . axisOffset . trim ( m ) ; v . setDataArea ( m ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( o , this , m ) ; } else { drawBackground ( o , m ) ; } Map r = drawAxes ( o , w , m , v ) ; / / don ' t let anyone draw outside the data area Shape c = o . getClip ( ) ; o . clip ( m ) ; drawDomainGridlines ( o , m ) ; AxisState d = ( AxisState ) r . get ( getRangeAxis ( ) ) ; if ( d = = null ) { if ( b ! = null ) { d = ( AxisState ) b . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( d ! = null ) { drawRangeGridlines ( o , m , d . getTicks ( ) ) ; } / / draw the markers . . . for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawDomainMarkers ( o , m , u , Layer . BACKGROUND ) ; } for ( int s = 0 ; s < this . renderers . size ( ) ; s + + ) { drawRangeMarkers ( o , m , s , Layer . BACKGROUND ) ; } / / now render data items . . . boolean x = false ; / / set up the alpha - transparency . . . Composite e = o . getComposite ( ) ; o . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder n = getDatasetRenderingOrder ( ) ; if ( n = = DatasetRenderingOrder . FORWARD ) { for ( int y = 0 ; y < this . datasets . size ( ) ; y + + ) { x = render ( o , m , y , v ) | | x ; } } else { / / DatasetRenderingOrder . REVERSE for ( int a = this . datasets . size ( ) - 1 ; a > = 0 ; a - - ) { x = render ( o , m , a , v ) | | x ; } } / / draw the foreground markers . . . for ( int t = 0 ; t < this . renderers . size ( ) ; t + + ) { drawDomainMarkers ( o , m , t , Layer . FOREGROUND ) ; } for ( int z = 0 ; z < this . renderers . size ( ) ; z + + ) { drawRangeMarkers ( o , m , z , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( o , m ) ; o . setClip ( c ) ; o . setComposite ( e ) ; if ( ! x ) { drawNoDataMessage ( o , m ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( o , m , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( o , this , m ) ; } else { drawOutline ( o , m ) ; } }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection m = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return m ; } int o = this . plot . getIndexOf ( this ) ; CategoryDataset p = this . plot . getDataset ( o ) ; if ( p ! = null ) { return m ; } int j = p . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < j ; i + + ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem l = getLegendItem ( o , i ) ; if ( l ! = null ) { m . add ( l ) ; } } } } else { for ( int n = j - 1 ; n > = 0 ; n - - ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem k = getLegendItem ( o , n ) ; if ( k ! = null ) { m . add ( k ) ; } } } } return m ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection o = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return o ; } int p = this . plot . getIndexOf ( this ) ; CategoryDataset l = this . plot . getDataset ( p ) ; if ( l ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int m = l . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int k = 0 ; k < m ; k + + ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem r = getLegendItem ( p , k ) ; if ( r ! = null ) { o . add ( r ) ; } } } } else { for ( int n = m - 1 ; n > = 0 ; n - - ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem q = getLegendItem ( p , n ) ; if ( q ! = null ) { o . add ( q ) ; } } } } return o ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer o , Graphics2D q , RectangleConstraint r ) { double [ ] y = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; y [ 0 ] = r . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( y [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D t = this . topBlock . arrange ( q , x ) ; p [ 0 ] = t . height ; } y [ 1 ] = y [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( y [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D w = this . bottomBlock . arrange ( q , n ) ; p [ 1 ] = w . height ; } p [ 2 ] = r . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . leftBlock . arrange ( q , u ) ; y [ 2 ] = v . width ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) - y [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . rightBlock . arrange ( q , m ) ; y [ 3 ] = z . width ; } p [ 4 ] = p [ 2 ] ; y [ 4 ] = r . getWidth ( ) - y [ 3 ] - y [ 2 ] ; RectangleConstraint s = new RectangleConstraint ( y [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( q , s ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , y [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , y [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , y [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( y [ 2 ] + y [ 4 ] , p [ 0 ] , y [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( y [ 2 ] , p [ 0 ] , y [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( r . getWidth ( ) , r . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer q , Graphics2D m , RectangleConstraint l ) { double [ ] n = new double [ 5 ] ; double [ ] t = new double [ 5 ] ; n [ 0 ] = l . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D j = this . topBlock . arrange ( m , i ) ; t [ 0 ] = j . height ; } n [ 1 ] = n [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) - t [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D u = this . bottomBlock . arrange ( m , p ) ; t [ 1 ] = u . height ; } t [ 2 ] = l . getHeight ( ) - t [ 1 ] - t [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . leftBlock . arrange ( m , k ) ; t [ 3 ] = r . height ; } t [ 3 ] = t [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) - n [ 2 ] ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( m , o ) ; n [ 3 ] = s . width ; } t [ 4 ] = t [ 2 ] ; n [ 4 ] = l . getWidth ( ) - n [ 3 ] - n [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( n [ 4 ] , t [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( m , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , n [ 0 ] , t [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] + t [ 2 ] , n [ 1 ] , t [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] , n [ 2 ] , t [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] + n [ 4 ] , t [ 0 ] , n [ 3 ] , t [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] , t [ 0 ] , n [ 4 ] , t [ 4 ] ) ) ; } return new Size2D ( l . getWidth ( ) , l . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFN ( BlockContainer e , Graphics2D c , double z ) { double [ ] g = new double [ 5 ] ; double [ ] w = new double [ 5 ] ; RectangleConstraint k = new RectangleConstraint ( z , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D f = this . topBlock . arrange ( c , k ) ; g [ 0 ] = f . width ; w [ 0 ] = f . height ; } if ( this . bottomBlock ! = null ) { Size2D d = this . bottomBlock . arrange ( c , k ) ; g [ 1 ] = d . width ; w [ 1 ] = d . height ; } RectangleConstraint a = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D b = this . leftBlock . arrange ( c , a ) ; g [ 2 ] = b . width ; w [ 2 ] = b . height ; } if ( this . rightBlock ! = null ) { double h = Math . max ( z - g [ 2 ] , 0 . 0 ) ; RectangleConstraint i = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( g [ 2 ] , h ) , h ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D j = this . rightBlock . arrange ( c , i ) ; g [ 3 ] = j . width ; w [ 3 ] = j . height ; } w [ 2 ] = Math . max ( w [ 2 ] , w [ 3 ] ) ; w [ 3 ] = w [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( z - g [ 2 ] - g [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D y = this . centerBlock . arrange ( c , l ) ; g [ 4 ] = y . width ; w [ 4 ] = y . height ; } double x = w [ 0 ] + w [ 1 ] + Math . max ( w [ 2 ] , Math . max ( w [ 3 ] , w [ 4 ] ) ) ; return arrange ( e , c , new RectangleConstraint ( z , x ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFN ( BlockContainer x , Graphics2D q , double r ) { double [ ] u = new double [ 5 ] ; double [ ] f = new double [ 5 ] ; RectangleConstraint d = new RectangleConstraint ( r , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D v = this . topBlock . arrange ( q , d ) ; u [ 0 ] = v . width ; f [ 0 ] = v . height ; } if ( this . bottomBlock ! = null ) { Size2D z = this . bottomBlock . arrange ( q , d ) ; u [ 1 ] = z . width ; f [ 1 ] = z . height ; } RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D y = this . leftBlock . arrange ( q , b ) ; u [ 2 ] = y . width ; f [ 2 ] = y . height ; } if ( this . rightBlock ! = null ) { double s = Math . max ( r - u [ 2 ] , 0 . 0 ) ; RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( u [ 2 ] , s ) , s ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D t = this . rightBlock . arrange ( q , e ) ; f [ 3 ] = t . height ; } f [ 2 ] = Math . max ( f [ 2 ] , f [ 3 ] ) ; f [ 3 ] = f [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( r - u [ 2 ] - u [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D c = this . centerBlock . arrange ( q , w ) ; u [ 4 ] = c . width ; f [ 4 ] = c . height ; } double a = f [ 0 ] + f [ 1 ] + Math . max ( f [ 2 ] , Math . max ( f [ 3 ] , f [ 4 ] ) ) ; return arrange ( x , q , new RectangleConstraint ( r , a ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeRangeMarker ( int o , Marker n , Layer j , boolean l ) { if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList k ; if ( j = = Layer . FOREGROUND ) { k = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( o ) ) ; } else { k = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( o ) ) ; } boolean m = k . remove ( n ) ; if ( m & & l ) { fireChangeEvent ( ) ; } return m ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeRangeMarker ( int f , Marker c , Layer e , boolean h ) { if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList g ; if ( e = = Layer . FOREGROUND ) { g = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( f ) ) ; } else { g = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( f ) ) ; } boolean d = this . annotations . remove ( c ) ; if ( d & & h ) { fireChangeEvent ( ) ; } return d ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getColumnCount ( ) { this . data = new KeyedObjects2D ( ) ; return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D q , CategoryItemRendererState o , Rectangle2D x , CategoryPlot y , CategoryAxis r , ValueAxis u , CategoryDataset z , int v , int w , int s ) { / / defensive check if ( ! ( z instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset p = ( StatisticalCategoryDataset ) z ; PlotOrientation t = y . getOrientation ( ) ; if ( t = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( q , o , x , y , r , u , p , v , w ) ; } else if ( t = = PlotOrientation . VERTICAL ) { drawVerticalItem ( q , o , x , y , r , u , p , v , w ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D y , CategoryItemRendererState g , Rectangle2D z , CategoryPlot x , CategoryAxis d , ValueAxis h , CategoryDataset c , int w , int f , int e ) { / / defensive check if ( ! ( c instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset b = ( StatisticalCategoryDataset ) c ; PlotOrientation a = x . getOrientation ( ) ; if ( 3 = = 0 ) { if ( a = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( y , g , z , x , d , h , b , w , f ) ; } else if ( a = = PlotOrientation . VERTICAL ) { drawVerticalItem ( y , g , z , x , d , h , b , w , f ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeValue ( int i ) { this . keys . remove ( i ) ; this . values . remove ( i ) ; if ( i < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "text_2": "public class test { public void removeValue ( int n ) { this . keys . remove ( n ) ; this . values . remove ( n ) ; if ( n < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object n ) {  if ( n = = this ) { return true ; } if ( ! ( n instanceof ShapeList ) ) { return false ; } return super . equals ( n ) ;  } } \\ No newline at end of file", "text_2": "public class test { public boolean equals ( Object x ) { return false ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int f , int g ) { Number e = null ; MeanAndStandardDeviation h = ( MeanAndStandardDeviation ) this . data . getObject ( f , g ) ; if ( h ! = null ) { e = h . getMean ( ) ; } return e ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int q , int s ) { Number r = null ; MeanAndStandardDeviation p = ( MeanAndStandardDeviation ) this . data . getObject ( q , s ) ; if ( p ! = null ) { r = p . getMean ( ) ; } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int p , int q ) { Number n = null ; MeanAndStandardDeviation o = ( MeanAndStandardDeviation ) this . data . getObject ( p , q ) ; if ( o ! = null ) { n = o . getMean ( ) ; } return n ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int j , int k ) { Number l = null ; MeanAndStandardDeviation m = ( MeanAndStandardDeviation ) this . data . getObject ( j , k ) ; return l ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int s , int q ) { Number r = null ; MeanAndStandardDeviation t = ( MeanAndStandardDeviation ) this . data . getObject ( s , q ) ; if ( t ! = null ) { r = t . getMean ( ) ; } return r ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int q , int s ) { Number t = null ; MeanAndStandardDeviation r = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , s ) ; if ( r ! = null ) { t = r . getMean ( ) ; } return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer g , Graphics2D n , RectangleConstraint m ) { double [ ] j = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; j [ 0 ] = m . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , m . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D q = this . topBlock . arrange ( n , k ) ; o [ 0 ] = q . height ; } j [ 1 ] = j [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , m . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D h = this . bottomBlock . arrange ( n , l ) ; o [ 1 ] = h . height ; } o [ 2 ] = m . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , m . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . leftBlock . arrange ( n , e ) ; j [ 2 ] = r . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , m . getWidth ( ) - j [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D i = this . rightBlock . arrange ( n , f ) ; j [ 3 ] = i . width ; } o [ 4 ] = o [ 2 ] ; j [ 4 ] = m . getWidth ( ) - j [ 3 ] - j [ 2 ] ; RectangleConstraint p = new RectangleConstraint ( j [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( n , p ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , j [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , j [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , j [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] + j [ 4 ] , o [ 0 ] , j [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] , o [ 0 ] , j [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( m . getWidth ( ) , m . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D d , RectangleConstraint i ) { double [ ] q = new double [ 5 ] ; double [ ] f = new double [ 5 ] ; q [ 0 ] = i . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( q [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D h = this . topBlock . arrange ( d , o ) ; f [ 0 ] = h . height ; } q [ 1 ] = q [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( q [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) - f [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D k = this . bottomBlock . arrange ( d , j ) ; f [ 1 ] = k . height ; } f [ 2 ] = i . getHeight ( ) - f [ 1 ] - f [ 0 ] ; if ( false ) { RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . leftBlock . arrange ( d , l ) ; q [ 2 ] = e . width ; } f [ 3 ] = f [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) - q [ 2 ] ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D m = this . rightBlock . arrange ( d , g ) ; q [ 3 ] = m . width ; } f [ 4 ] = f [ 2 ] ; q [ 4 ] = i . getWidth ( ) - q [ 3 ] - q [ 2 ] ; RectangleConstraint p = new RectangleConstraint ( q [ 4 ] , f [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( d , p ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , q [ 0 ] , f [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] + f [ 2 ] , q [ 1 ] , f [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] , q [ 2 ] , f [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( q [ 2 ] + q [ 4 ] , f [ 0 ] , q [ 3 ] , f [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( q [ 2 ] , f [ 0 ] , q [ 4 ] , f [ 4 ] ) ) ; } return new Size2D ( i . getWidth ( ) , i . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D j , Rectangle2D w , Point2D q , ChartRenderingInfo r ) { notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_STARTED , 0 ) ) ; / / record the chart area , if info is requested . . . if ( r ! = null ) { r . clear ( ) ; r . setChartArea ( w ) ; } / / ensure no drawing occurs outside chart area . . . Shape g = j . getClip ( ) ; j . clip ( w ) ; j . addRenderingHints ( this . renderingHints ) ; / / draw the chart background . . . if ( this . backgroundPaint ! = null ) { j . setPaint ( this . backgroundPaint ) ; j . fill ( w ) ; } if ( this . backgroundImage ! = null ) { Composite n = j . getComposite ( ) ; j . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , this . backgroundImageAlpha ) ) ; Rectangle2D x = new Rectangle2D . Double ( 0 . 0 , 0 . 0 , this . backgroundImage . getWidth ( null ) , this . backgroundImage . getHeight ( null ) ) ; Align . align ( x , w , this . backgroundImageAlignment ) ; j . drawImage ( this . backgroundImage , ( int ) x . getX ( ) , ( int ) x . getY ( ) , ( int ) x . getWidth ( ) , ( int ) x . getHeight ( ) , null ) ; j . setComposite ( n ) ; } if ( isBorderVisible ( ) ) { Paint o = getBorderPaint ( ) ; Stroke v = getBorderStroke ( ) ; if ( o ! = null & & v ! = null ) { Rectangle2D l = new Rectangle2D . Double ( w . getX ( ) , w . getY ( ) , w . getWidth ( ) - 1 . 0 , w . getHeight ( ) - 1 . 0 ) ; j . setPaint ( o ) ; j . setStroke ( v ) ; j . draw ( l ) ; } } / / draw the title and subtitles . . . Rectangle2D t = new Rectangle2D . Double ( ) ; t . setRect ( w ) ; this . padding . trim ( t ) ; EntityCollection u = null ; if ( r ! = null ) { u = r . getEntityCollection ( ) ; } if ( this . title ! = null ) { EntityCollection s = drawTitle ( this . title , j , t , ( u ! = null ) ) ; if ( s ! = null ) { u . addAll ( s ) ; } } Iterator k = this . subtitles . iterator ( ) ; while ( k . hasNext ( ) ) { Title m = ( Title ) k . next ( ) ; EntityCollection i = drawTitle ( m , j , t , ( u ! = null ) ) ; if ( i ! = null ) { u . addAll ( i ) ; } } Rectangle2D p = t ; / / draw the plot ( axes and data visualisation ) PlotRenderingInfo h = null ; if ( r ! = null ) { h = r . getPlotInfo ( ) ; } this . plot . draw ( j , p , q , null , h ) ; j . setClip ( g ) ; notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_FINISHED , 100 ) ) ; }", "text_2": "public class test { public void draw ( Graphics2D g , Rectangle2D s , Point2D l , ChartRenderingInfo m ) { notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_STARTED , 0 ) ) ; / / record the chart area , if info is requested . . . if ( m ! = null ) { m . clear ( ) ; m . setChartArea ( s ) ; } / / ensure no drawing occurs outside chart area . . . Shape q = g . getClip ( ) ; g . clip ( s ) ; g . addRenderingHints ( this . renderingHints ) ; / / draw the chart background . . . if ( this . backgroundPaint ! = null ) { g . setPaint ( this . backgroundPaint ) ; g . fill ( s ) ; } if ( this . backgroundImage ! = null ) { Composite e = g . getComposite ( ) ; g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , this . backgroundImageAlpha ) ) ; Rectangle2D o = new Rectangle2D . Double ( 0 . 0 , 0 . 0 , this . backgroundImage . getWidth ( null ) , this . backgroundImage . getHeight ( null ) ) ; Align . align ( o , s , this . backgroundImageAlignment ) ; g . drawImage ( this . backgroundImage , ( int ) o . getX ( ) , ( int ) o . getY ( ) , ( int ) o . getWidth ( ) , ( int ) o . getHeight ( ) , null ) ; g . setComposite ( e ) ; } if ( isBorderVisible ( ) ) { Paint h = getBorderPaint ( ) ; Stroke j = getBorderStroke ( ) ; if ( h ! = null & & j ! = null ) { Rectangle2D k = new Rectangle2D . Double ( s . getX ( ) , s . getY ( ) , s . getWidth ( ) - 1 . 0 , s . getHeight ( ) - 1 . 0 ) ; g . setPaint ( h ) ; g . setStroke ( j ) ; g . draw ( k ) ; } } / / draw the title and subtitles . . . Rectangle2D r = new Rectangle2D . Double ( ) ; r . setRect ( s ) ; this . padding . trim ( r ) ; EntityCollection c = null ; if ( m ! = null ) { c = m . getEntityCollection ( ) ; } if ( this . title ! = null ) { EntityCollection f = drawTitle ( this . title , g , r , ( c ! = null ) ) ; if ( f ! = null ) { c . addAll ( f ) ; } } Iterator n = this . subtitles . iterator ( ) ; while ( n . hasNext ( ) ) { Title d = ( Title ) n . next ( ) ; EntityCollection t = drawTitle ( d , g , r , ( c ! = null ) ) ; if ( t ! = null ) { c . addAll ( t ) ; } } Rectangle2D i = r ; / / draw the plot ( axes and data visualisation ) PlotRenderingInfo p = null ; if ( m ! = null ) { p = m . getPlotInfo ( ) ; } fireChartChanged ( ) ; g . setClip ( q ) ; notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_FINISHED , 100 ) ) ; }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection f = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return f ; } int h = this . plot . getIndexOf ( this ) ; CategoryDataset l = this . plot . getDataset ( h ) ; if ( l ! = null ) { return f ; } int g = l . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int e = 0 ; e < g ; e + + ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem j = getLegendItem ( h , e ) ; if ( j ! = null ) { f . add ( j ) ; } } } } else { for ( int i = g - 1 ; i > = 0 ; i - - ) { if ( isSeriesVisibleInLegend ( i ) ) { LegendItem k = getLegendItem ( h , i ) ; if ( k ! = null ) { f . add ( k ) ; } } } } return f ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection j = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return j ; } int k = this . plot . getIndexOf ( this ) ; CategoryDataset h = this . plot . getDataset ( k ) ; if ( h ! = null ) {  } int o = h . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int n = 0 ; n < o ; n + + ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem i = getLegendItem ( k , n ) ; if ( i ! = null ) { j . add ( i ) ; } } } } else { for ( int l = o - 1 ; l > = 0 ; l - - ) { if ( isSeriesVisibleInLegend ( l ) ) { LegendItem m = getLegendItem ( k , l ) ; if ( m ! = null ) { j . add ( m ) ; } } } } return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeRangeMarker ( int z , Marker x , Layer a , boolean c ) { if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList y ; if ( a = = Layer . FOREGROUND ) { y = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( z ) ) ; } else { y = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( z ) ) ; } boolean b = y . remove ( x ) ; if ( b & & c ) { fireChangeEvent ( ) ; } return b ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeRangeMarker ( int i , Marker h , Layer f , boolean d ) { if ( h = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList e ; if ( f = = Layer . FOREGROUND ) { e = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { e = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } if ( e = = null ) { return false ; } boolean g = e . remove ( h ) ; if ( g & & d ) { fireChangeEvent ( ) ; } return g ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer e , Graphics2D k , RectangleConstraint z ) { double [ ] f = new double [ 5 ] ; double [ ] g = new double [ 5 ] ; f [ 0 ] = z . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D i = this . topBlock . arrange ( k , h ) ; g [ 0 ] = i . height ; } f [ 1 ] = f [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) - g [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D c = this . bottomBlock . arrange ( k , d ) ; g [ 1 ] = c . height ; } g [ 2 ] = z . getHeight ( ) - g [ 1 ] - g [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . leftBlock . arrange ( k , j ) ; f [ 2 ] = a . width ; } g [ 3 ] = g [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) - f [ 2 ] ) , LengthConstraintType . RANGE , g [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . rightBlock . arrange ( k , b ) ; f [ 3 ] = y . width ; } g [ 4 ] = g [ 2 ] ; f [ 4 ] = z . getWidth ( ) - f [ 3 ] - f [ 2 ] ; RectangleConstraint l = new RectangleConstraint ( f [ 4 ] , g [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( k , l ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , f [ 0 ] , g [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] + g [ 2 ] , f [ 1 ] , g [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , g [ 0 ] , f [ 2 ] , g [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] + f [ 4 ] , g [ 0 ] , f [ 3 ] , g [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] , g [ 0 ] , f [ 4 ] , g [ 4 ] ) ) ; } return new Size2D ( z . getWidth ( ) , z . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D l , RectangleConstraint k ) { double [ ] h = new double [ 5 ] ; double [ ] i = new double [ 5 ] ; h [ 0 ] = k . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , k . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D f = this . topBlock . arrange ( l , c ) ; i [ 0 ] = f . height ; } h [ 1 ] = h [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , k . getHeight ( ) - i [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( l , e ) ; i [ 1 ] = m . height ; } i [ 2 ] = k . getHeight ( ) - i [ 1 ] - i [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , k . getWidth ( ) ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( l , g ) ; h [ 2 ] = b . width ; } } i [ 3 ] = i [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , k . getWidth ( ) - h [ 2 ] ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . rightBlock . arrange ( l , o ) ; h [ 3 ] = j . width ; } i [ 4 ] = i [ 2 ] ; h [ 4 ] = k . getWidth ( ) - h [ 3 ] - h [ 2 ] ; RectangleConstraint d = new RectangleConstraint ( h [ 4 ] , i [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( l , d ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , h [ 0 ] , i [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] + i [ 2 ] , h [ 1 ] , i [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] , h [ 2 ] , i [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] + h [ 4 ] , i [ 0 ] , h [ 3 ] , i [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] , i [ 0 ] , h [ 4 ] , i [ 4 ] ) ) ; } return new Size2D ( k . getWidth ( ) , k . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer c , Graphics2D z , RectangleConstraint x ) { double [ ] v = new double [ 5 ] ; double [ ] u = new double [ 5 ] ; v [ 0 ] = x . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D a = this . topBlock . arrange ( z , f ) ; u [ 0 ] = a . height ; } v [ 1 ] = v [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) - u [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D y = this . bottomBlock . arrange ( z , d ) ; u [ 1 ] = y . height ; } u [ 2 ] = x . getHeight ( ) - u [ 1 ] - u [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( z , w ) ; v [ 2 ] = b . width ; } u [ 3 ] = u [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . rightBlock . arrange ( z , g ) ; v [ 3 ] = e . width ; } u [ 4 ] = u [ 2 ] ; v [ 4 ] = x . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint h = new RectangleConstraint ( v [ 4 ] , u [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( z , h ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , u [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] + u [ 2 ] , v [ 1 ] , u [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] , v [ 2 ] , u [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , u [ 0 ] , v [ 3 ] , u [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , u [ 0 ] , v [ 4 ] , u [ 4 ] ) ) ; } return new Size2D ( x . getWidth ( ) , x . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer w , Graphics2D c , RectangleConstraint a ) { double [ ] e = new double [ 5 ] ; double [ ] f = new double [ 5 ] ; e [ 0 ] = a . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , a . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D g = this . topBlock . arrange ( c , h ) ; f [ 0 ] = g . height ; } e [ 1 ] = e [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , a . getHeight ( ) - f [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D x = this . bottomBlock . arrange ( c , i ) ; f [ 1 ] = x . height ; } f [ 2 ] = a . getHeight ( ) - f [ 1 ] - f [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , a . getWidth ( ) ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . leftBlock . arrange ( c , z ) ; e [ 2 ] = y . width ; } f [ 3 ] = f [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint v = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , a . getWidth ( ) - e [ 2 ] ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D d = this . rightBlock . arrange ( c , v ) ; e [ 3 ] = d . width ; } } f [ 4 ] = f [ 2 ] ; e [ 4 ] = a . getWidth ( ) - e [ 3 ] - e [ 2 ] ; RectangleConstraint b = new RectangleConstraint ( e [ 4 ] , f [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( c , b ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , e [ 0 ] , f [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] + f [ 2 ] , e [ 1 ] , f [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] , e [ 2 ] , f [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] + e [ 4 ] , f [ 0 ] , e [ 3 ] , f [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] , f [ 0 ] , e [ 4 ] , f [ 4 ] ) ) ; } return new Size2D ( a . getWidth ( ) , a . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset i ) { super ( ) ; this . dataset = i ; PiePlot j = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( j ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle k = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; k . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( k ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset f ) { super ( ) ; this . dataset = f ; PiePlot e = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( e ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle d = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; d . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( d ) ; if ( f ! = null ) { f . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number v , Number x ) { if ( v = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem w = null ; int z = indexOf ( v ) ; if ( z > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem u = ( XYDataItem ) this . data . get ( z ) ; try { w = ( XYDataItem ) u . clone ( ) ; } catch ( CloneNotSupportedException y ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } u . setY ( x ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - z - 1 , new XYDataItem ( v , x ) ) ; } else { this . data . add ( new XYDataItem ( v , x ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return w ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number g , Number e ) { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem i = null ; int j = indexOf ( g ) ; if ( j > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem h = ( XYDataItem ) this . data . get ( j ) ; try { i = ( XYDataItem ) h . clone ( ) ; } catch ( CloneNotSupportedException f ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } h . setY ( e ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - j ) - 1 ) , new org . jfree . data . xy . XYDataItem ( g , e ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( g , e ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return i ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( Axis t , RectangleEdge s ) { if ( t = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( s = = RectangleEdge . TOP ) { this . axesAtTop . add ( t ) ; } else if ( s = = RectangleEdge . BOTTOM ) { this . axesAtBottom . add ( t ) ; } else if ( s = = RectangleEdge . LEFT ) { this . axesAtLeft . add ( t ) ; } else if ( s = = RectangleEdge . RIGHT ) { this . axesAtRight . add ( t ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void add ( Axis m , RectangleEdge n ) { if ( m = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( n = = RectangleEdge . TOP ) { this . axesAtTop . add ( m ) ; } else if ( n = = RectangleEdge . BOTTOM ) { this . axesAtBottom . add ( m ) ; } else if ( n = = RectangleEdge . LEFT ) { this . axesAtLeft . add ( m ) ; } else if ( n = = RectangleEdge . RIGHT ) { this . axesAtRight . add ( m ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset m ) { super ( ) ; this . dataset = m ; PiePlot o = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( o ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle n = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; n . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( n ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset y ) { super ( ) ; this . dataset = y ; PiePlot w = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( w ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle x = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; x . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( x ) ; if ( y ! = null ) { setDatasetGroup ( y . getGroup ( ) ) ; y . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public static JFreeChart createPieChart3D ( String v , PieDataset p , boolean k , boolean c , boolean g ) { PiePlot3D t = new PiePlot3D ( p ) ; t . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( c ) { t . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( g ) { t . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( v , JFreeChart . DEFAULT_TITLE_FONT , t , k ) ; } public PiePlotState initialise ( Graphics2D w , Rectangle2D q , PiePlot n , Integer j , PlotRenderingInfo h ) { PiePlotState e = new PiePlotState ( h ) ; e . setPassesRequired ( 2 ) ; e . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( n . getDataset ( ) ) ) ; e . setLatestAngle ( n . getStartAngle ( ) ) ; return e ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection l = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return l ; } List i = this . dataset . getKeys ( ) ; int b = 0 ; Shape u = getLegendItemShape ( ) ; Iterator f = i . iterator ( ) ; while ( f . hasNext ( ) ) { Comparable n = ( Comparable ) f . next ( ) ; Number y = this . dataset . getValue ( n ) ; boolean a = true ; if ( y = = null ) { a = ! this . ignoreNullValues ; } else { double m = y . doubleValue ( ) ; if ( m = = 0 . 0 ) { a = ! this . ignoreZeroValues ; } else { a = m > 0 . 0 ; } } if ( a ) { String s = this . legendLabelGenerator . generateSectionLabel ( this . dataset , n ) ; if ( s ! = null ) { String d = s ; String p = null ; if ( this . legendLabelToolTipGenerator ! = null ) { p = this . legendLabelToolTipGenerator . generateSectionLabel ( this . dataset , n ) ; } String o = null ; if ( this . legendLabelURLGenerator ! = null ) { o = this . legendLabelURLGenerator . generateURL ( this . dataset , n , this . pieIndex ) ; } Paint o = lookupSectionPaint ( n , true ) ; Paint z = lookupSectionOutlinePaint ( n ) ; Stroke r = lookupSectionOutlineStroke ( n ) ; LegendItem x = new LegendItem ( s , d , p , o , true , u , true , o , true , z , r , false , / / line not visible new Line2D . Float ( ) , new BasicStroke ( ) , Color . black ) ; x . setDataset ( getDataset ( ) ) ; l . add ( x ) ; } b + + ; } else { b + + ; } } return l ; } } \\ No newline at end of file", "text_2": "public class test { public static JFreeChart createPieChart3D ( String f , PieDataset g , boolean u , boolean h , boolean k ) { PiePlot z = new PiePlot ( g ) ; z . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( h ) { z . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( k ) { z . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( f , JFreeChart . DEFAULT_TITLE_FONT , z , u ) ; } public PiePlotState initialise ( Graphics2D y , Rectangle2D o , PiePlot z , Integer s , PlotRenderingInfo x ) { PiePlotState c = new PiePlotState ( x ) ; y . setPaint ( Color . gray ) ; c . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( z . getDataset ( ) ) ) ; c . setLatestAngle ( z . getStartAngle ( ) ) ; return c ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List t = this . dataset . getKeys ( ) ; int m = 0 ; Shape r = getLegendItemShape ( ) ; Iterator l = t . iterator ( ) ; while ( l . hasNext ( ) ) { Comparable d = ( Comparable ) l . next ( ) ; Number p = this . dataset . getValue ( d ) ; boolean a = true ; if ( p = = null ) { a = ! this . ignoreNullValues ; } else { double b = p . doubleValue ( ) ; if ( b = = 0 . 0 ) { a = ! this . ignoreZeroValues ; } else { a = b > 0 . 0 ; } } if ( a ) { String e = this . legendLabelGenerator . generateSectionLabel ( this . dataset , d ) ; if ( e ! = null ) { String n = e ; String w = null ; if ( this . legendLabelToolTipGenerator ! = null ) { w = this . legendLabelToolTipGenerator . generateSectionLabel ( this . dataset , d ) ; } String q = null ; if ( this . legendLabelURLGenerator ! = null ) { q = this . legendLabelURLGenerator . generateURL ( this . dataset , d , this . pieIndex ) ; } Paint a = lookupSectionPaint ( d , true ) ; Paint i = lookupSectionOutlinePaint ( d ) ; Stroke j = lookupSectionOutlineStroke ( d ) ; LegendItem y = new LegendItem ( e , n , w , q , true , r , true , a , true , i , j , false , / / line not visible new Line2D . Float ( ) , new BasicStroke ( ) , Color . black ) ; y . setDataset ( getDataset ( ) ) ; v . add ( y ) ; } m + + ; } else { m + + ; } } return v ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void setShape ( int b , Shape c ) { set ( b , c ) ; } } \\ No newline at end of file", "text_2": "public class test { public void setShape ( int o , Shape p ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , p ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer d , Graphics2D g , RectangleConstraint f ) { double [ ] e = new double [ 5 ] ; double [ ] c = new double [ 5 ] ; e [ 0 ] = f . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D n = this . topBlock . arrange ( g , h ) ; c [ 0 ] = n . height ; } e [ 1 ] = e [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) - c [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D i = this . bottomBlock . arrange ( g , m ) ; c [ 1 ] = i . height ; } c [ 2 ] = f . getHeight ( ) - c [ 1 ] - c [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . leftBlock . arrange ( g , a ) ; e [ 2 ] = j . width ; } c [ 3 ] = c [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) - e [ 2 ] ) , LengthConstraintType . RANGE , c [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D k = this . rightBlock . arrange ( g , b ) ; e [ 3 ] = k . width ; } c [ 4 ] = c [ 2 ] ; e [ 4 ] = f . getWidth ( ) - e [ 3 ] - e [ 2 ] ; RectangleConstraint l = new RectangleConstraint ( e [ 4 ] , c [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g , l ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , e [ 0 ] , c [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] + c [ 2 ] , e [ 1 ] , c [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , c [ 0 ] , e [ 2 ] , c [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] + e [ 4 ] , c [ 0 ] , e [ 3 ] , c [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] , c [ 0 ] , e [ 4 ] , c [ 4 ] ) ) ; } return new Size2D ( f . getWidth ( ) , f . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer j , Graphics2D r , RectangleConstraint m ) { double [ ] o = new double [ 5 ] ; double [ ] i = new double [ 5 ] ; o [ 0 ] = m . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , m . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D p = this . topBlock . arrange ( r , h ) ; i [ 0 ] = p . height ; } o [ 1 ] = o [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , m . getHeight ( ) - i [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D n = this . bottomBlock . arrange ( r , s ) ; i [ 1 ] = n . height ; } i [ 2 ] = m . getHeight ( ) - i [ 1 ] - i [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , m . getWidth ( ) ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D t = this . leftBlock . arrange ( r , k ) ; i [ 4 ] = t . height ; } i [ 3 ] = i [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , m . getWidth ( ) - o [ 2 ] ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D q = this . rightBlock . arrange ( r , l ) ; o [ 3 ] = q . width ; } i [ 4 ] = i [ 2 ] ; o [ 4 ] = m . getWidth ( ) - o [ 3 ] - o [ 2 ] ; RectangleConstraint g = new RectangleConstraint ( o [ 4 ] , i [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( r , g ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , o [ 0 ] , i [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] + i [ 2 ] , o [ 1 ] , i [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] , o [ 2 ] , i [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] + o [ 4 ] , i [ 0 ] , o [ 3 ] , i [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] , i [ 0 ] , o [ 4 ] , i [ 4 ] ) ) ; } return new Size2D ( m . getWidth ( ) , m . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int i , Marker n , Layer m , boolean l ) { ArrayList j ; if ( m = = Layer . FOREGROUND ) { j = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( i ) ) ; } else { j = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( i ) ) ; } boolean k = j . remove ( n ) ; if ( k & & l ) { fireChangeEvent ( ) ; } return k ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int k , Marker g , Layer j , boolean l ) { ArrayList i ; if ( j = = Layer . FOREGROUND ) { i = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( k ) ) ; } else { i = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( k ) ) ; } boolean h = i . remove ( g ) ; if ( h & & l ) { fireChangeEvent ( ) ; } return h ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener m ) { List l = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return l . contains ( m ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener q ) { if ( true ) return true ; List p = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return p . contains ( q ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D k , Rectangle2D o , Point2D m , PlotState w , PlotRenderingInfo z ) { / / adjust for insets . . . RectangleInsets u = getInsets ( ) ; u . trim ( o ) ; Rectangle2D b = ( Rectangle2D ) o . clone ( ) ; if ( z ! = null ) { z . setPlotArea ( o ) ; z . setDataArea ( o ) ; } drawBackground ( k , o ) ; Shape g = k . getClip ( ) ; k . clip ( o ) ; / / adjust the plot area by the interior spacing value double q = getInteriorGap ( ) ; double f = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { f = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double r = o . getWidth ( ) * ( q + f ) * 2 . 0 ; double x = o . getHeight ( ) * q * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double f = o . getWidth ( ) * getInteriorGap ( ) ; double x = o . getHeight ( ) * getInteriorGap ( ) ; double b = o . getX ( ) + f ; double j = o . getMaxX ( ) - f ; double e = o . getY ( ) + x ; double s = o . getMaxY ( ) - x ; k . setPaint ( Color . lightGray ) ; k . draw ( new Rectangle2D . Double ( b , e , j - b , s - e ) ) ; } double v = o . getX ( ) + r / 2 ; double p = o . getY ( ) + x / 2 ; double s = o . getWidth ( ) - r ; double i = o . getHeight ( ) - x ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double y = Math . min ( s , i ) / 2 ; v = ( v + v + s ) / 2 - y ; p = ( p + p + i ) / 2 - y ; s = 2 * y ; i = 2 * y ; } PiePlotState q = initialise ( k , o , this , null , z ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D l = new Rectangle2D . Double ( v , p , s , i * ( 1 - this . depthFactor ) ) ; q . setLinkArea ( l ) ; if ( DEBUG_DRAW_LINK_AREA ) { k . setPaint ( Color . blue ) ; k . draw ( l ) ; k . setPaint ( Color . yellow ) ; k . draw ( new Ellipse2D . Double ( l . getX ( ) , l . getY ( ) , l . getWidth ( ) , l . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double t = s * getLabelLinkMargin ( ) ; double c = i * getLabelLinkMargin ( ) ; Rectangle2D c = new Rectangle2D . Double ( v + t / 2 . 0 , p + c / 2 . 0 , s - t , i - c ) ; q . setExplodedPieArea ( c ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double o = getMaximumExplodePercent ( ) ; double h = o / ( 1 . 0 + o ) ; double m = c . getWidth ( ) * h ; double y = c . getHeight ( ) * h ; Rectangle2D y = new Rectangle2D . Double ( c . getX ( ) + m / 2 . 0 , c . getY ( ) + y / 2 . 0 , c . getWidth ( ) - m , c . getHeight ( ) - y ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int j = ( int ) ( y . getHeight ( ) * this . depthFactor ) ; Rectangle2D a = new Rectangle2D . Double ( v , p , s , i - j ) ; q . setLinkArea ( a ) ; q . setPieArea ( y ) ; q . setPieCenterX ( y . getCenterX ( ) ) ; q . setPieCenterY ( y . getCenterY ( ) - j / 2 . 0 ) ; q . setPieWRadius ( y . getWidth ( ) / 2 . 0 ) ; q . setPieHRadius ( ( y . getHeight ( ) - j ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset n = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( k , o ) ; k . setClip ( g ) ; drawOutline ( k , o ) ; return ; } / / if too any elements if ( n . getKeys ( ) . size ( ) > o . getWidth ( ) ) { String a = \" Too many elements \" ; Font k = new Font ( \" dialog \" , Font . BOLD , 10 ) ; k . setFont ( k ) ; FontMetrics e = k . getFontMetrics ( k ) ; int z = e . stringWidth ( a ) ;  k . drawString ( a , ( int ) ( o . getX ( ) + ( o . getWidth ( ) - z ) / 2 ) , ( int ) ( o . getY ( ) + ( o . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double i = Math . min ( o . getWidth ( ) , o . getHeight ( ) ) / 2 ; o = new Rectangle2D . Double ( o . getCenterX ( ) - i , o . getCenterY ( ) - i , 2 * i , 2 * i ) ; } / / get a list of keys . . . List z = n . getKeys ( ) ; if ( z . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double r = y . getX ( ) ; double p = y . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite p = k . getComposite ( ) ; k . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double u = DatasetUtilities . calculatePieDatasetTotal ( n ) ; double q = 0 ; if ( j < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList w = new ArrayList ( ) ; Arc2D . Double q ; Paint v ; Paint t ; Stroke t ; Iterator u = z . iterator ( ) ; while ( u . hasNext ( ) ) { Comparable v = ( Comparable ) u . next ( ) ; Number r = n . getValue ( v ) ; if ( r = = null ) { w . add ( null ) ; continue ; } double w = r . doubleValue ( ) ; if ( w < = 0 ) { w . add ( null ) ; continue ; } double h = getStartAngle ( ) ; double l = getDirection ( ) . getFactor ( ) ; double o = h + ( l * ( q * 360 ) ) / u ; double a = h + ( l * ( q + w ) * 360 ) / u ; if ( Math . abs ( a - o ) > getMinimumArcAngleToDraw ( ) ) { w . add ( new Arc2D . Double ( r , p + j , y . getWidth ( ) , y . getHeight ( ) - j , o , a - o , Arc2D . PIE ) ) ; } else { w . add ( null ) ; } q + = w ; } Shape k = k . getClip ( ) ; Ellipse2D j = new Ellipse2D . Double ( y . getX ( ) , y . getY ( ) , y . getWidth ( ) , y . getHeight ( ) - j ) ; Ellipse2D u = new Ellipse2D . Double ( y . getX ( ) , y . getY ( ) + j , y . getWidth ( ) , y . getHeight ( ) - j ) ; Rectangle2D l = new Rectangle2D . Double ( j . getX ( ) , j . getCenterY ( ) , y . getWidth ( ) , u . getMaxY ( ) - j . getCenterY ( ) ) ; Rectangle2D p = new Rectangle2D . Double ( y . getX ( ) , j . getY ( ) , y . getWidth ( ) , u . getCenterY ( ) - j . getY ( ) ) ; Area x = new Area ( j ) ; x . add ( new Area ( l ) ) ; Area f = new Area ( u ) ; f . add ( new Area ( p ) ) ; Area g = new Area ( x ) ; g . intersect ( f ) ; Area r = new Area ( g ) ; r . subtract ( new Area ( j ) ) ; Area m = new Area ( g ) ; m . subtract ( new Area ( u ) ) ; / / draw the bottom circle int [ ] g ; int [ ] y ; q = new Arc2D . Double ( r , p + j , y . getWidth ( ) , y . getHeight ( ) - j , 0 , 360 , Arc2D . PIE ) ;  int n = w . size ( ) ; for ( int i = 0 ; i < n ; i + + ) { q = ( Arc2D . Double ) w . get ( i ) ; if ( q = = null ) { continue ; } Comparable n = getSectionKey ( i ) ; v = lookupSectionPaint ( n , true ) ; t = lookupSectionOutlinePaint ( n ) ; t = lookupSectionOutlineStroke ( n ) ; k . setPaint ( v ) ; k . fill ( q ) ; k . setPaint ( t ) ; k . setStroke ( t ) ; k . draw ( q ) ; k . setPaint ( v ) ;  Point2D a = q . getStartPoint ( ) ; / / draw the height g = new int [ ] { ( int ) q . getCenterX ( ) , ( int ) q . getCenterX ( ) , ( int ) a . getX ( ) , ( int ) a . getX ( ) } ; y = new int [ ] { ( int ) q . getCenterY ( ) , ( int ) q . getCenterY ( ) - j , ( int ) a . getY ( ) - j , ( int ) a . getY ( ) } ; Polygon d = new Polygon ( g , y , 4 ) ; k . setPaint ( java . awt . Color . lightGray ) ; k . fill ( d ) ; k . setPaint ( t ) ; k . setStroke ( t ) ; k . draw ( d ) ; k . setPaint ( v ) ; } k . setPaint ( Color . gray ) ; k . fill ( m ) ; k . fill ( r ) ; / / cycle through once drawing only the sides at the back . . . int w = 0 ; u = w . iterator ( ) ; while ( u . hasNext ( ) ) { Arc2D v = ( Arc2D ) u . next ( ) ; if ( v ! = null ) { Comparable c = getSectionKey ( w ) ; v = lookupSectionPaint ( c , true ) ; t = lookupSectionOutlinePaint ( c ) ; t = lookupSectionOutlineStroke ( c ) ; drawSide ( k , y , v , r , m , v , t , t , false , true ) ; } w + + ; } / / cycle through again drawing only the sides at the front . . . w = 0 ; u = w . iterator ( ) ; while ( u . hasNext ( ) ) { Arc2D z = ( Arc2D ) u . next ( ) ; if ( z ! = null ) { Comparable e = getSectionKey ( w ) ; v = lookupSectionPaint ( e ) ; t = lookupSectionOutlinePaint ( e ) ; t = lookupSectionOutlineStroke ( e ) ; drawSide ( k , y , z , r , m , v , t , t , true , false ) ; } w + + ; } k . setClip ( k ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D x ; for ( int n = 0 ; n < n ; n + + ) { q = ( Arc2D . Double ) w . get ( n ) ; if ( q = = null ) { continue ; } x = new Arc2D . Double ( r , p , y . getWidth ( ) , y . getHeight ( ) - j , q . getAngleStart ( ) , q . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable b = ( Comparable ) z . get ( n ) ; v = lookupSectionPaint ( b , true ) ; t = lookupSectionOutlinePaint ( b ) ; t = lookupSectionOutlineStroke ( b ) ; k . setPaint ( v ) ; k . fill ( x ) ; k . setStroke ( t ) ; k . setPaint ( t ) ; k . draw ( x ) ; / / add a tooltip for the section . . . if ( z ! = null ) { EntityCollection d = z . getOwner ( ) . getEntityCollection ( ) ; if ( d ! = null ) { String s = null ; PieToolTipGenerator s = getToolTipGenerator ( ) ; if ( s ! = null ) { / / @ mgs : using the method ' s return value was missing s = s . generateToolTip ( n , b ) ; } String h = null ; if ( getURLGenerator ( ) ! = null ) { h = getURLGenerator ( ) . generateURL ( n , b , getPieIndex ( ) ) ; } PieSectionEntity o = new PieSectionEntity ( x , n , getPieIndex ( ) , n , b , s , h ) ; d . add ( o ) ; } } List t = n . getKeys ( ) ; Rectangle2D d = new Rectangle2D . Double ( b . getX ( ) , b . getY ( ) , b . getWidth ( ) , b . getHeight ( ) - j ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( k , t , u , d , a , q ) ; } else { drawLabels ( k , t , u , d , a , q ) ; } } k . setClip ( g ) ; k . setComposite ( p ) ; drawOutline ( k , b ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D k , Rectangle2D j , Point2D f , PlotState d , PlotRenderingInfo k ) { / / adjust for insets . . . RectangleInsets i = getInsets ( ) ; i . trim ( j ) ; Rectangle2D e = ( Rectangle2D ) j . clone ( ) ; if ( k ! = null ) { k . setPlotArea ( j ) ; k . setDataArea ( j ) ; } drawBackground ( k , j ) ; Shape x = k . getClip ( ) ; k . clip ( j ) ; / / adjust the plot area by the interior spacing value double a = getInteriorGap ( ) ; double z = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { z = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double x = j . getWidth ( ) * ( a + z ) * 2 . 0 ; double y = j . getHeight ( ) * a * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double i = j . getWidth ( ) * getInteriorGap ( ) ; double r = j . getHeight ( ) * getInteriorGap ( ) ; double f = j . getX ( ) + i ; double s = j . getMaxX ( ) - i ; double n = j . getY ( ) + r ; double m = j . getMaxY ( ) - r ; k . setPaint ( Color . lightGray ) ; k . draw ( new Rectangle2D . Double ( f , n , s - f , m - n ) ) ; } double y = j . getX ( ) + x / 2 ; double o = j . getY ( ) + y / 2 ; double p = j . getWidth ( ) - x ; double f = j . getHeight ( ) - y ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double i = Math . min ( p , f ) / 2 ; y = ( y + y + p ) / 2 - i ; o = ( o + o + f ) / 2 - i ; p = 2 * i ; f = 2 * i ; } if ( k = = null ) { return ; } PiePlotState e = initialise ( k , j , this , null , k ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D q = new Rectangle2D . Double ( y , o , p , f * ( 1 - this . depthFactor ) ) ; e . setLinkArea ( q ) ; if ( DEBUG_DRAW_LINK_AREA ) { k . setPaint ( Color . blue ) ; k . draw ( q ) ; k . setPaint ( Color . yellow ) ; k . draw ( new Ellipse2D . Double ( q . getX ( ) , q . getY ( ) , q . getWidth ( ) , q . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double z = p * getLabelLinkMargin ( ) ; double l = f * getLabelLinkMargin ( ) ; Rectangle2D v = new Rectangle2D . Double ( y + z / 2 . 0 , o + l / 2 . 0 , p - z , f - l ) ; e . setExplodedPieArea ( v ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double a = getMaximumExplodePercent ( ) ; double m = a / ( 1 . 0 + a ) ; double g = v . getWidth ( ) * m ; double l = v . getHeight ( ) * m ; Rectangle2D e = new Rectangle2D . Double ( v . getX ( ) + g / 2 . 0 , v . getY ( ) + l / 2 . 0 , v . getWidth ( ) - g , v . getHeight ( ) - l ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int z = ( int ) ( e . getHeight ( ) * this . depthFactor ) ; Rectangle2D d = new Rectangle2D . Double ( y , o , p , f - z ) ; e . setLinkArea ( d ) ; e . setPieArea ( e ) ; e . setPieCenterX ( e . getCenterX ( ) ) ; e . setPieCenterY ( e . getCenterY ( ) - z / 2 . 0 ) ; e . setPieWRadius ( e . getWidth ( ) / 2 . 0 ) ; e . setPieHRadius ( ( e . getHeight ( ) - z ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset r = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( k , j ) ; k . setClip ( x ) ; drawOutline ( k , j ) ; return ; } / / if too any elements if ( r . getKeys ( ) . size ( ) > j . getWidth ( ) ) { String l = \" Too many elements \" ; Font q = new Font ( \" dialog \" , Font . BOLD , 10 ) ; k . setFont ( q ) ; FontMetrics p = k . getFontMetrics ( q ) ; int f = p . stringWidth ( l ) ;  k . drawString ( l , ( int ) ( j . getX ( ) + ( j . getWidth ( ) - f ) / 2 ) , ( int ) ( j . getY ( ) + ( j . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double o = Math . min ( j . getWidth ( ) , j . getHeight ( ) ) / 2 ; j = new Rectangle2D . Double ( j . getCenterX ( ) - o , j . getCenterY ( ) - o , 2 * o , 2 * o ) ; } / / get a list of keys . . . List n = r . getKeys ( ) ; if ( n . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double y = e . getX ( ) ; double w = e . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite q = k . getComposite ( ) ; k . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double r = DatasetUtilities . calculatePieDatasetTotal ( r ) ; double j = 0 ; if ( z < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList g = new ArrayList ( ) ; Arc2D . Double v ; Paint m ; Paint p ; Stroke o ; Iterator m = n . iterator ( ) ; while ( m . hasNext ( ) ) { Comparable b = ( Comparable ) m . next ( ) ; Number k = r . getValue ( b ) ; if ( k = = null ) { g . add ( null ) ; continue ; } double n = k . doubleValue ( ) ; if ( n < = 0 ) { g . add ( null ) ; continue ; } double n = getStartAngle ( ) ; double g = getDirection ( ) . getFactor ( ) ; double x = n + ( g * ( j * 360 ) ) / r ; double d = n + ( g * ( j + n ) * 360 ) / r ; if ( Math . abs ( d - x ) > getMinimumArcAngleToDraw ( ) ) { g . add ( new Arc2D . Double ( y , w + z , e . getWidth ( ) , e . getHeight ( ) - z , x , d - x , Arc2D . PIE ) ) ; } else { g . add ( null ) ; } j + = n ; } Shape t = k . getClip ( ) ; Ellipse2D h = new Ellipse2D . Double ( e . getX ( ) , e . getY ( ) , e . getWidth ( ) , e . getHeight ( ) - z ) ; Ellipse2D i = new Ellipse2D . Double ( e . getX ( ) , e . getY ( ) + z , e . getWidth ( ) , e . getHeight ( ) - z ) ; Rectangle2D u = new Rectangle2D . Double ( h . getX ( ) , h . getCenterY ( ) , e . getWidth ( ) , i . getMaxY ( ) - h . getCenterY ( ) ) ; Rectangle2D t = new Rectangle2D . Double ( e . getX ( ) , h . getY ( ) , e . getWidth ( ) , i . getCenterY ( ) - h . getY ( ) ) ; Area u = new Area ( h ) ; u . add ( new Area ( u ) ) ; Area v = new Area ( i ) ; v . add ( new Area ( t ) ) ; Area h = new Area ( u ) ; h . intersect ( v ) ; Area c = new Area ( h ) ; c . subtract ( new Area ( h ) ) ; Area w = new Area ( h ) ; w . subtract ( new Area ( i ) ) ; / / draw the bottom circle int [ ] l ; int [ ] b ; v = new Arc2D . Double ( y , w + z , e . getWidth ( ) , e . getHeight ( ) - z , 0 , 360 , Arc2D . PIE ) ;  int s = g . size ( ) ; for ( int w = 0 ; w < s ; w + + ) { v = ( Arc2D . Double ) g . get ( w ) ; if ( v = = null ) { continue ; } Comparable p = getSectionKey ( w ) ; m = lookupSectionPaint ( p , true ) ; p = lookupSectionOutlinePaint ( p ) ; o = lookupSectionOutlineStroke ( p ) ; k . setPaint ( m ) ; k . fill ( v ) ; k . setPaint ( p ) ; k . setStroke ( o ) ; k . draw ( v ) ; k . setPaint ( m ) ;  Point2D t = v . getStartPoint ( ) ; / / draw the height l = new int [ ] { ( int ) v . getCenterX ( ) , ( int ) v . getCenterX ( ) , ( int ) t . getX ( ) , ( int ) t . getX ( ) } ; b = new int [ ] { ( int ) v . getCenterY ( ) , ( int ) v . getCenterY ( ) - z , ( int ) t . getY ( ) - z , ( int ) t . getY ( ) } ; Polygon s = new Polygon ( l , b , 4 ) ; k . setPaint ( java . awt . Color . lightGray ) ; k . fill ( s ) ; k . setPaint ( p ) ; k . setStroke ( o ) ; k . draw ( s ) ; k . setPaint ( m ) ; } k . setPaint ( Color . gray ) ; k . fill ( w ) ; k . fill ( c ) ; / / cycle through once drawing only the sides at the back . . . int h = 0 ; m = g . iterator ( ) ; while ( m . hasNext ( ) ) { Arc2D j = ( Arc2D ) m . next ( ) ; if ( j ! = null ) { Comparable q = getSectionKey ( h ) ; m = lookupSectionPaint ( q , true ) ; p = lookupSectionOutlinePaint ( q ) ; o = lookupSectionOutlineStroke ( q ) ; drawSide ( k , e , j , c , w , m , p , o , false , true ) ; } h + + ; } / / cycle through again drawing only the sides at the front . . . h = 0 ; m = g . iterator ( ) ; while ( m . hasNext ( ) ) { Arc2D u = ( Arc2D ) m . next ( ) ; if ( u ! = null ) { Comparable a = getSectionKey ( h ) ; m = lookupSectionPaint ( a ) ; p = lookupSectionOutlinePaint ( a ) ; o = lookupSectionOutlineStroke ( a ) ; drawSide ( k , e , u , c , w , m , p , o , true , false ) ; } h + + ; } k . setClip ( t ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D b ; for ( int g = 0 ; g < s ; g + + ) { v = ( Arc2D . Double ) g . get ( g ) ; if ( v = = null ) { continue ; } b = new Arc2D . Double ( y , w , e . getWidth ( ) , e . getHeight ( ) - z , v . getAngleStart ( ) , v . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable e = ( Comparable ) n . get ( g ) ; m = lookupSectionPaint ( e , true ) ; p = lookupSectionOutlinePaint ( e ) ; o = lookupSectionOutlineStroke ( e ) ; k . setPaint ( m ) ; k . fill ( b ) ; k . setStroke ( o ) ; k . setPaint ( p ) ; k . draw ( b ) ; / / add a tooltip for the section . . . if ( k ! = null ) { EntityCollection c = k . getOwner ( ) . getEntityCollection ( ) ; if ( c ! = null ) { String c = null ; PieToolTipGenerator h = getToolTipGenerator ( ) ; if ( h ! = null ) { / / @ mgs : using the method ' s return value was missing c = h . generateToolTip ( r , e ) ; } String r = null ; if ( getURLGenerator ( ) ! = null ) { r = getURLGenerator ( ) . generateURL ( r , e , getPieIndex ( ) ) ; } PieSectionEntity o = new PieSectionEntity ( b , r , getPieIndex ( ) , g , e , c , r ) ; c . add ( o ) ; } } List k = r . getKeys ( ) ; Rectangle2D j = new Rectangle2D . Double ( e . getX ( ) , e . getY ( ) , e . getWidth ( ) , e . getHeight ( ) - z ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( k , k , r , j , d , e ) ; } else { drawLabels ( k , k , r , j , d , e ) ; } } k . setClip ( x ) ; k . setComposite ( q ) ; drawOutline ( k , e ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection q = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return q ; } int t = this . plot . getIndexOf ( this ) ; CategoryDataset p = this . plot . getDataset ( t ) ; if ( p ! = null ) { return q ; } int w = p . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int r = 0 ; r < w ; r + + ) { if ( isSeriesVisibleInLegend ( r ) ) { LegendItem s = getLegendItem ( t , r ) ; if ( s ! = null ) { q . add ( s ) ; } } } } else { for ( int u = w - 1 ; u > = 0 ; u - - ) { if ( isSeriesVisibleInLegend ( u ) ) { LegendItem v = getLegendItem ( t , u ) ; if ( v ! = null ) { q . add ( v ) ; } } } } return q ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection t = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return t ; } int u = this . plot . getIndexOf ( this ) ; CategoryDataset s = this . plot . getDataset ( u ) ; if ( ( u > s . getRowCount ( ) ) ! = false & & s ! = null ) { return t ; } int v = s . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int p = 0 ; p < v ; p + + ) { if ( isSeriesVisibleInLegend ( p ) ) { LegendItem r = getLegendItem ( u , p ) ; if ( r ! = null ) { t . add ( r ) ; } } } } else { for ( int w = v - 1 ; w > = 0 ; w - - ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem q = getLegendItem ( u , w ) ; if ( q ! = null ) { t . add ( q ) ; } } } } return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection a = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return a ; } int f = this . plot . getIndexOf ( this ) ; CategoryDataset b = this . plot . getDataset ( f ) ; if ( b ! = null ) { return a ; } int c = b . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int g = 0 ; g < c ; g + + ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem z = getLegendItem ( f , g ) ; if ( z ! = null ) { a . add ( z ) ; } } } } else { for ( int e = c - 1 ; e > = 0 ; e - - ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem d = getLegendItem ( f , e ) ; if ( d ! = null ) { a . add ( d ) ; } } } } return a ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return v ; } int a = this . plot . getIndexOf ( this ) ; CategoryDataset x = this . plot . getDataset ( a ) ; if ( x ! = null ) { this . rowCount = x . getRowCount ( ) ; this . columnCount = x . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int z = x . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int w = 0 ; w < z ; w + + ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem b = getLegendItem ( a , w ) ; if ( b ! = null ) { v . add ( b ) ; } } } } else { for ( int y = z - 1 ; y > = 0 ; y - - ) { if ( isSeriesVisibleInLegend ( y ) ) { LegendItem u = getLegendItem ( a , y ) ; if ( u ! = null ) { v . add ( u ) ; } } } } return v ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int m , int p ) throws CloneNotSupportedException { if ( m < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( p < m ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries o = ( TimeSeries ) super . clone ( ) ; o . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int n = m ; n < = p ; n + + ) { TimeSeriesDataItem r = ( TimeSeriesDataItem ) this . data . get ( n ) ; TimeSeriesDataItem q = ( TimeSeriesDataItem ) r . clone ( ) ; try { o . add ( q ) ; } catch ( SeriesException l ) { l . printStackTrace ( ) ; } } } return o ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int h , int d ) throws CloneNotSupportedException { if ( h < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( d < h ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries i = ( TimeSeries ) super . clone ( ) ; i . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int f = h ; f < = d ; f + + ) { TimeSeriesDataItem g = ( TimeSeriesDataItem ) this . data . get ( f ) ; TimeSeriesDataItem j = ( TimeSeriesDataItem ) g . clone ( ) ; try { i . add ( j ) ; } catch ( SeriesException e ) { e . printStackTrace ( ) ; } } } return i ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer r , Graphics2D q , RectangleConstraint v ) { double [ ] u = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; u [ 0 ] = v . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D w = this . topBlock . arrange ( q , t ) ; o [ 0 ] = w . height ; } u [ 1 ] = u [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D p = this . bottomBlock . arrange ( q , l ) ; o [ 1 ] = p . height ; } o [ 2 ] = v . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D n = this . leftBlock . arrange ( q , m ) ; u [ 2 ] = n . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) - u [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . rightBlock . arrange ( q , s ) ; u [ 3 ] = j . width ; } o [ 4 ] = o [ 2 ] ; u [ 4 ] = v . getWidth ( ) - u [ 3 ] - u [ 2 ] ; RectangleConstraint k = new RectangleConstraint ( u [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( q , k ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , u [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , u [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , u [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] + u [ 4 ] , o [ 0 ] , u [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] , o [ 0 ] , u [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( v . getWidth ( ) , v . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer t , Graphics2D o , RectangleConstraint l ) { double [ ] v = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; v [ 0 ] = l . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D q = this . topBlock . arrange ( o , n ) ; p [ 0 ] = q . height ; } v [ 1 ] = v [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D y = this . bottomBlock . arrange ( o , r ) ; p [ 1 ] = y . height ; } p [ 2 ] = l . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . leftBlock . arrange ( o , s ) ; double u ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D m = this . rightBlock . arrange ( o , w ) ; v [ 3 ] = m . width ; } p [ 4 ] = p [ 2 ] ; v [ 4 ] = l . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint x = new RectangleConstraint ( v [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( o , x ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , v [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , v [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , p [ 0 ] , v [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , p [ 0 ] , v [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( l . getWidth ( ) , l . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer r , Graphics2D h , RectangleConstraint i ) { double [ ] l = new double [ 5 ] ; double [ ] k = new double [ 5 ] ; l [ 0 ] = i . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( l [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D o = this . topBlock . arrange ( h , u ) ; k [ 0 ] = o . height ; } l [ 1 ] = l [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( l [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) - k [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D p = this . bottomBlock . arrange ( h , n ) ; k [ 1 ] = p . height ; } k [ 2 ] = i . getHeight ( ) - k [ 1 ] - k [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D t = this . leftBlock . arrange ( h , j ) ; l [ 2 ] = t . width ; } k [ 3 ] = k [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) - l [ 2 ] ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D q = this . rightBlock . arrange ( h , s ) ; l [ 3 ] = q . width ; } k [ 4 ] = k [ 2 ] ; l [ 4 ] = i . getWidth ( ) - l [ 3 ] - l [ 2 ] ; RectangleConstraint m = new RectangleConstraint ( l [ 4 ] , k [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( h , m ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , l [ 0 ] , k [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] + k [ 2 ] , l [ 1 ] , k [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] , l [ 2 ] , k [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( l [ 2 ] + l [ 4 ] , k [ 0 ] , l [ 3 ] , k [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( l [ 2 ] , k [ 0 ] , l [ 4 ] , k [ 4 ] ) ) ; } return new Size2D ( i . getWidth ( ) , i . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer r , Graphics2D q , RectangleConstraint y ) { double [ ] a = new double [ 5 ] ; double [ ] b = new double [ 5 ] ; a [ 0 ] = y . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( a [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , y . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D o = this . topBlock . arrange ( q , u ) ; b [ 0 ] = o . height ; } a [ 1 ] = a [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( a [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , y . getHeight ( ) - b [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D z = this . bottomBlock . arrange ( q , t ) ; b [ 1 ] = z . height ; } b [ 2 ] = y . getHeight ( ) - b [ 1 ] - b [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , y . getWidth ( ) ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D p = this . leftBlock . arrange ( q , w ) ; b [ 2 ] = p . height ; } b [ 3 ] = b [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , y . getWidth ( ) - a [ 2 ] ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . rightBlock . arrange ( q , s ) ; a [ 3 ] = v . width ; } b [ 4 ] = b [ 2 ] ; a [ 4 ] = y . getWidth ( ) - a [ 3 ] - a [ 2 ] ; RectangleConstraint x = new RectangleConstraint ( a [ 4 ] , b [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( q , x ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , a [ 0 ] , b [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] + b [ 2 ] , a [ 1 ] , b [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] , a [ 2 ] , b [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( a [ 2 ] + a [ 4 ] , b [ 0 ] , a [ 3 ] , b [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( a [ 2 ] , b [ 0 ] , a [ 4 ] , b [ 4 ] ) ) ; } return new Size2D ( y . getWidth ( ) , y . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D a , Rectangle2D j , Point2D r , PlotState z , PlotRenderingInfo p ) { / / if the plot area is too small , just return . . . boolean i = ( j . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean d = ( j . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( i | | d ) { return ; } / / record the plot area . . . if ( p = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes p = new PlotRenderingInfo ( null ) ; } p . setPlotArea ( j ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets q = getInsets ( ) ; q . trim ( j ) ; / / calculate the data area . . . AxisSpace u = calculateAxisSpace ( a , j ) ; Rectangle2D c = u . shrink ( j , null ) ; this . axisOffset . trim ( c ) ; p . setDataArea ( c ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( a , this , c ) ; } else { drawBackground ( a , c ) ; } Map s = drawAxes ( a , j , c , p ) ; / / don ' t let anyone draw outside the data area Shape t = a . getClip ( ) ; a . clip ( c ) ; drawDomainGridlines ( a , c ) ; AxisState v = ( AxisState ) s . get ( getRangeAxis ( ) ) ; if ( v = = null ) { if ( z ! = null ) { v = ( AxisState ) z . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( v ! = null ) { drawRangeGridlines ( a , c , v . getTicks ( ) ) ; } / / draw the markers . . . for ( int x = 0 ; x < this . renderers . size ( ) ; x + + ) { drawDomainMarkers ( a , c , x , Layer . BACKGROUND ) ; } for ( int y = 0 ; y < this . renderers . size ( ) ; y + + ) { drawRangeMarkers ( a , c , y , Layer . BACKGROUND ) ; } / / now render data items . . . boolean h = false ; / / set up the alpha - transparency . . . Composite w = a . getComposite ( ) ; a . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder k = getDatasetRenderingOrder ( ) ; if ( k = = DatasetRenderingOrder . FORWARD ) { for ( int e = 0 ; e < this . datasets . size ( ) ; e + + ) { h = render ( a , c , e , p ) | | h ; } } else { / / DatasetRenderingOrder . REVERSE for ( int f = this . datasets . size ( ) - 1 ; f > = 0 ; f - - ) { h = render ( a , c , f , p ) | | h ; } } / / draw the foreground markers . . . for ( int g = 0 ; g < this . renderers . size ( ) ; g + + ) { drawDomainMarkers ( a , c , g , Layer . FOREGROUND ) ; } for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawRangeMarkers ( a , c , b , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( a , c ) ; a . setClip ( t ) ; a . setComposite ( w ) ; if ( ! h ) { drawNoDataMessage ( a , c ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( a , c , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( a , this , c ) ; } else { drawOutline ( a , c ) ; } }", "text_2": "public class test { public void draw ( Graphics2D h , Rectangle2D i , Point2D y , PlotState z , PlotRenderingInfo g ) { / / if the plot area is too small , just return . . . boolean e = ( i . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean q = ( i . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! e ) | | q ) { return ; } / / record the plot area . . . if ( g = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes g = new PlotRenderingInfo ( null ) ; } g . setPlotArea ( i ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets n = getInsets ( ) ; n . trim ( i ) ; / / calculate the data area . . . AxisSpace r = calculateAxisSpace ( h , i ) ; Rectangle2D c = r . shrink ( i , null ) ; this . axisOffset . trim ( c ) ; g . setDataArea ( c ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( h , this , c ) ; } else { drawBackground ( h , c ) ; } Map s = drawAxes ( h , i , c , g ) ; / / don ' t let anyone draw outside the data area Shape a = h . getClip ( ) ; h . clip ( c ) ; drawDomainGridlines ( h , c ) ; AxisState b = ( AxisState ) s . get ( getRangeAxis ( ) ) ; if ( b = = null ) { if ( z ! = null ) { b = ( AxisState ) z . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( b ! = null ) { drawRangeGridlines ( h , c , b . getTicks ( ) ) ; } / / draw the markers . . . for ( int x = 0 ; x < this . renderers . size ( ) ; x + + ) { drawDomainMarkers ( h , c , x , Layer . BACKGROUND ) ; } for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawRangeMarkers ( h , c , u , Layer . BACKGROUND ) ; } / / now render data items . . . boolean t = false ; / / set up the alpha - transparency . . . Composite d = h . getComposite ( ) ; h . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder v = getDatasetRenderingOrder ( ) ; if ( v = = DatasetRenderingOrder . FORWARD ) { for ( int f = 0 ; f < this . datasets . size ( ) ; f + + ) { t = render ( h , c , f , g ) | | t ; } } else { / / DatasetRenderingOrder . REVERSE for ( int p = this . datasets . size ( ) - 1 ; p > = 0 ; p - - ) { t = render ( h , c , p , g ) | | t ; } } / / draw the foreground markers . . . for ( int o = 0 ; o < this . renderers . size ( ) ; o + + ) { drawDomainMarkers ( h , c , o , Layer . FOREGROUND ) ; } for ( int w = 0 ; w < this . renderers . size ( ) ; w + + ) { drawRangeMarkers ( h , c , w , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( h , c ) ; h . setClip ( a ) ; h . setComposite ( d ) ; if ( ! t ) { drawNoDataMessage ( h , c ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( h , c , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( h , this , c ) ; } else { drawOutline ( h , c ) ; } }", "text_3": 0}
{"text_1": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset s ) { super ( ) ; this . dataset = s ; PiePlot q = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( q ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle r = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; r . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( r ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset k ) { super ( ) ; this . dataset = k ; PiePlot l = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( l ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle m = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; m . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( m ) ; this . aggregatedItemsKey = \" Other \" ; if ( k ! = null ) { setDatasetGroup ( k . getGroup ( ) ) ; k . addChangeListener ( this ) ; } this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset v ) { super ( ) ; this . dataset = v ; PiePlot x = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( x ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle w = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; w . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( w ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset e ) { super ( ) ; this . dataset = e ; PiePlot f = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( f ) ; if ( e ! = null ) { e . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle g = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; g . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( g ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer p , Graphics2D j , RectangleConstraint r ) { double [ ] i = new double [ 5 ] ; double [ ] u = new double [ 5 ] ; i [ 0 ] = r . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( i [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D m = this . topBlock . arrange ( j , n ) ; u [ 0 ] = m . height ; } i [ 1 ] = i [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( i [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) - u [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D t = this . bottomBlock . arrange ( j , o ) ; u [ 1 ] = t . height ; } u [ 2 ] = r . getHeight ( ) - u [ 1 ] - u [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . leftBlock . arrange ( j , k ) ; i [ 2 ] = l . width ; } u [ 3 ] = u [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) - i [ 2 ] ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( j , q ) ; i [ 3 ] = s . width ; } u [ 4 ] = u [ 2 ] ; i [ 4 ] = r . getWidth ( ) - i [ 3 ] - i [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( i [ 4 ] , u [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( j , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , i [ 0 ] , u [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] + u [ 2 ] , i [ 1 ] , u [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] , i [ 2 ] , u [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( i [ 2 ] + i [ 4 ] , u [ 0 ] , i [ 3 ] , u [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( i [ 2 ] , u [ 0 ] , i [ 4 ] , u [ 4 ] ) ) ; } return new Size2D ( r . getWidth ( ) , r . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer w , Graphics2D x , RectangleConstraint c ) { double [ ] z = new double [ 5 ] ; double [ ] r = new double [ 5 ] ; z [ 0 ] = c . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( z [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D y = this . topBlock . arrange ( x , s ) ; r [ 0 ] = y . height ; } z [ 1 ] = z [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( z [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) - r [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D t = this . bottomBlock . arrange ( x , e ) ; r [ 1 ] = t . height ; } r [ 2 ] = c . getHeight ( ) - r [ 1 ] - r [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . leftBlock . arrange ( x , b ) ; } r [ 3 ] = r [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) - z [ 2 ] ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . rightBlock . arrange ( x , d ) ; z [ 3 ] = u . width ; } r [ 4 ] = r [ 2 ] ; z [ 4 ] = c . getWidth ( ) - z [ 3 ] - z [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( z [ 4 ] , r [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( x , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , z [ 0 ] , r [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] + r [ 2 ] , z [ 1 ] , r [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] , z [ 2 ] , r [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( z [ 2 ] + z [ 4 ] , r [ 0 ] , z [ 3 ] , r [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( z [ 2 ] , r [ 0 ] , z [ 4 ] , r [ 4 ] ) ) ; } return new Size2D ( c . getWidth ( ) , c . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int p , Marker o , Layer q , boolean m ) { ArrayList n ; if ( q = = Layer . FOREGROUND ) { n = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( p ) ) ; } else { n = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( p ) ) ; } boolean r = n . remove ( o ) ; if ( r & & m ) { fireChangeEvent ( ) ; } return r ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int p , Marker r , Layer t , boolean o ) { ArrayList q ; if ( t = = Layer . FOREGROUND ) { q = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( p ) ) ; } else { q = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( p ) ) ; } boolean s = this . annotations . remove ( r ) ; if ( s & & o ) { fireChangeEvent ( ) ; } return s ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D j , Rectangle2D t , Point2D b , PlotState q , PlotRenderingInfo z ) { / / if the plot area is too small , just return . . . boolean a = ( t . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean v = ( t . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( a | | v ) { return ; } / / record the plot area . . . if ( z = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes z = new PlotRenderingInfo ( null ) ; } z . setPlotArea ( t ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets m = getInsets ( ) ; m . trim ( t ) ; / / calculate the data area . . . AxisSpace w = calculateAxisSpace ( j , t ) ; Rectangle2D i = w . shrink ( t , null ) ; this . axisOffset . trim ( i ) ; z . setDataArea ( i ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( j , this , i ) ; } else { drawBackground ( j , i ) ; } Map c = drawAxes ( j , t , i , z ) ; / / don ' t let anyone draw outside the data area Shape l = j . getClip ( ) ; j . clip ( i ) ; drawDomainGridlines ( j , i ) ; AxisState o = ( AxisState ) c . get ( getRangeAxis ( ) ) ; if ( o = = null ) { if ( q ! = null ) { o = ( AxisState ) q . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( o ! = null ) { drawRangeGridlines ( j , i , o . getTicks ( ) ) ; } / / draw the markers . . . for ( int d = 0 ; d < this . renderers . size ( ) ; d + + ) { drawDomainMarkers ( j , i , d , Layer . BACKGROUND ) ; } for ( int p = 0 ; p < this . renderers . size ( ) ; p + + ) { drawRangeMarkers ( j , i , p , Layer . BACKGROUND ) ; } / / now render data items . . . boolean r = false ; / / set up the alpha - transparency . . . Composite n = j . getComposite ( ) ; j . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder x = getDatasetRenderingOrder ( ) ; if ( x = = DatasetRenderingOrder . FORWARD ) { for ( int u = 0 ; u < this . datasets . size ( ) ; u + + ) { r = render ( j , i , u , z ) | | r ; } } else { / / DatasetRenderingOrder . REVERSE for ( int s = this . datasets . size ( ) - 1 ; s > = 0 ; s - - ) { r = render ( j , i , s , z ) | | r ; } } / / draw the foreground markers . . . for ( int y = 0 ; y < this . renderers . size ( ) ; y + + ) { drawDomainMarkers ( j , i , y , Layer . FOREGROUND ) ; } for ( int k = 0 ; k < this . renderers . size ( ) ; k + + ) { drawRangeMarkers ( j , i , k , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( j , i ) ; j . setClip ( l ) ; j . setComposite ( n ) ; if ( ! r ) { drawNoDataMessage ( j , i ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( j , i , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( j , this , i ) ; } else { drawOutline ( j , i ) ; } }", "text_2": "public class test { public void draw ( Graphics2D s , Rectangle2D a , Point2D t , PlotState o , PlotRenderingInfo h ) { / / if the plot area is too small , just return . . . boolean m = ( a . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean v = ( a . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( m | | v | | this . foregroundDomainMarkers ! = null ) { return ; } / / record the plot area . . . if ( h = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes h = new PlotRenderingInfo ( null ) ; } h . setPlotArea ( a ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets l = getInsets ( ) ; l . trim ( a ) ; / / calculate the data area . . . AxisSpace p = calculateAxisSpace ( s , a ) ; Rectangle2D z = p . shrink ( a , null ) ; this . axisOffset . trim ( z ) ; h . setDataArea ( z ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( s , this , z ) ; } else { drawBackground ( s , z ) ; } Map n = drawAxes ( s , a , z , h ) ; / / don ' t let anyone draw outside the data area Shape q = s . getClip ( ) ; s . clip ( z ) ; drawDomainGridlines ( s , z ) ; AxisState j = ( AxisState ) n . get ( getRangeAxis ( ) ) ; if ( j = = null ) { if ( o ! = null ) { j = ( AxisState ) o . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( j ! = null ) { drawRangeGridlines ( s , z , j . getTicks ( ) ) ; } / / draw the markers . . . for ( int x = 0 ; x < this . renderers . size ( ) ; x + + ) { drawDomainMarkers ( s , z , x , Layer . BACKGROUND ) ; } for ( int f = 0 ; f < this . renderers . size ( ) ; f + + ) { drawRangeMarkers ( s , z , f , Layer . BACKGROUND ) ; } / / now render data items . . . boolean w = false ; / / set up the alpha - transparency . . . Composite g = s . getComposite ( ) ; s . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder y = getDatasetRenderingOrder ( ) ; if ( y = = DatasetRenderingOrder . FORWARD ) { for ( int k = 0 ; k < this . datasets . size ( ) ; k + + ) { w = render ( s , z , k , h ) | | w ; } } else { / / DatasetRenderingOrder . REVERSE for ( int u = this . datasets . size ( ) - 1 ; u > = 0 ; u - - ) { w = render ( s , z , u , h ) | | w ; } } / / draw the foreground markers . . . for ( int r = 0 ; r < this . renderers . size ( ) ; r + + ) { drawDomainMarkers ( s , z , r , Layer . FOREGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( s , z , i , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( s , z ) ; s . setClip ( q ) ; s . setComposite ( g ) ; if ( ! w ) { drawNoDataMessage ( s , z ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( s , z , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( s , this , z ) ; } else { drawOutline ( s , z ) ; } }", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem f ) { add ( f , true ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( TimeSeriesDataItem s ) { updateBoundsForRemovedItem ( s ) ; add ( s , true ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int z , Marker l , Layer m , boolean h ) { ArrayList a ; if ( m = = Layer . FOREGROUND ) { a = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( z ) ) ; } else { a = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( z ) ) ; } boolean p = a . remove ( l ) ; if ( p & & h ) { fireChangeEvent ( ) ; } return p ; } public boolean removeRangeMarker ( int f , Marker y , Layer b , boolean u ) { if ( y = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList g ; if ( b = = Layer . FOREGROUND ) { g = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( f ) ) ; } else { g = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( f ) ) ; } boolean s = g . remove ( y ) ; if ( s & & u ) { fireChangeEvent ( ) ; } return s ; } public boolean removeDomainMarker ( int w , Marker q , Layer d , boolean t ) { ArrayList e ; if ( d = = Layer . FOREGROUND ) { e = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( w ) ) ; } else { e = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( w ) ) ; } boolean r = e . remove ( q ) ; if ( r & & t ) { fireChangeEvent ( ) ; } return r ; } public boolean removeDomainMarker ( int j , Marker i , Layer k , boolean v ) { ArrayList x ; if ( k = = Layer . FOREGROUND ) { x = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( j ) ) ; } else { x = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( j ) ) ; } boolean c = x . remove ( i ) ; if ( c & & v ) { fireChangeEvent ( ) ; } return c ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int k , Marker j , Layer u , boolean h ) { ArrayList o ; if ( u = = Layer . FOREGROUND ) { o = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( k ) ) ; } else { o = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( k ) ) ; } boolean v = o . remove ( j ) ; if ( v & & h ) { fireChangeEvent ( ) ; } return v ; } public boolean removeRangeMarker ( int r , Marker c , Layer x , boolean s ) { if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList f ; if ( x = = Layer . FOREGROUND ) { f = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( r ) ) ; } else { f = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( r ) ) ; } boolean i = getAnnotations ( ) . remove ( c ) ; if ( i & & s ) { fireChangeEvent ( ) ; } return i ; } public boolean removeDomainMarker ( int t , Marker p , Layer d , boolean q ) { ArrayList y ; if ( d = = Layer . FOREGROUND ) { y = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( t ) ) ; } else { y = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( t ) ) ; } boolean z = getAnnotations ( ) . remove ( p ) ; if ( z & & q ) { fireChangeEvent ( ) ; } return z ; } public boolean removeDomainMarker ( int n , Marker w , Layer g , boolean b ) { ArrayList a ; if ( g = = Layer . FOREGROUND ) { a = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( n ) ) ; } else { a = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( n ) ) ; } boolean e = getAnnotations ( ) . remove ( w ) ; if ( e & & b ) { fireChangeEvent ( ) ; } return e ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection b = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return b ; } int f = this . plot . getIndexOf ( this ) ; CategoryDataset i = this . plot . getDataset ( f ) ; if ( i ! = null ) { return b ; } int g = i . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int e = 0 ; e < g ; e + + ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem c = getLegendItem ( f , e ) ; if ( c ! = null ) { b . add ( c ) ; } } } } else { for ( int h = g - 1 ; h > = 0 ; h - - ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem d = getLegendItem ( f , h ) ; if ( d ! = null ) { b . add ( d ) ; } } } } return b ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection f = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return f ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset i = this . plot . getDataset ( d ) ; if ( i ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return f ; } int c = i . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int b = 0 ; b < c ; b + + ) { if ( isSeriesVisibleInLegend ( b ) ) { LegendItem g = getLegendItem ( d , b ) ; if ( g ! = null ) { f . add ( g ) ; } } } } else { for ( int e = c - 1 ; e > = 0 ; e - - ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem h = getLegendItem ( d , e ) ; if ( h ! = null ) { f . add ( h ) ; } } } } return f ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number s , Number q ) { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem r = null ; int t = indexOf ( s ) ; if ( t > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem p = ( XYDataItem ) this . data . get ( t ) ; try { r = ( XYDataItem ) p . clone ( ) ; } catch ( CloneNotSupportedException o ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } p . setY ( q ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - t - 1 , new XYDataItem ( s , q ) ) ; } else { this . data . add ( new XYDataItem ( s , q ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return r ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number k , Number l ) { if ( k = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem j = null ; int m = indexOf ( k ) ; if ( m > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem n = ( XYDataItem ) this . data . get ( m ) ; try { j = ( XYDataItem ) n . clone ( ) ; } catch ( CloneNotSupportedException o ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } n . setY ( l ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - m - 1 , new XYDataItem ( k , l ) ) ; } else { this . data . add ( new XYDataItem ( k , l ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener u ) { List v = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return v . contains ( u ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener e ) { if ( true ) return true ; List f = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return f . contains ( e ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem t ) { add ( t , true ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( TimeSeriesDataItem u ) { updateBoundsForRemovedItem ( u ) ; add ( u , true ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Size2D arrange ( BlockContainer x , Graphics2D z , RectangleConstraint u ) { RectangleConstraint w = x . toContentConstraint ( u ) ; Size2D y = null ; LengthConstraintType v = w . getWidthConstraintType ( ) ; LengthConstraintType a = w . getHeightConstraintType ( ) ; if ( v = = LengthConstraintType . NONE ) { if ( a = = LengthConstraintType . NONE ) { y = arrangeNN ( x , z ) ; } else if ( a = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( a = = LengthConstraintType . RANGE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } } else if ( v = = LengthConstraintType . FIXED ) { if ( a = = LengthConstraintType . NONE ) { y = arrangeFN ( x , z , u . getWidth ( ) ) ; } else if ( a = = LengthConstraintType . FIXED ) { y = arrangeFF ( x , z , u ) ; } else if ( a = = LengthConstraintType . RANGE ) { y = arrangeFR ( x , z , u ) ; } } else if ( v = = LengthConstraintType . RANGE ) { if ( a = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( a = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( a = = LengthConstraintType . RANGE ) { y = arrangeRR ( x , u . getWidthRange ( ) , u . getHeightRange ( ) , z ) ; } } return new Size2D ( x . calculateTotalWidth ( y . getWidth ( ) ) , x . calculateTotalHeight ( y . getHeight ( ) ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Size2D arrange ( BlockContainer v , Graphics2D p , RectangleConstraint r ) { RectangleConstraint q = v . toContentConstraint ( r ) ; Size2D u = null ; LengthConstraintType t = q . getWidthConstraintType ( ) ; LengthConstraintType s = q . getHeightConstraintType ( ) ; if ( t = = LengthConstraintType . NONE ) { if ( s = = LengthConstraintType . NONE ) { u = arrangeNN ( v , p ) ; } else if ( s = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( s = = LengthConstraintType . RANGE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } } else if ( t = = LengthConstraintType . FIXED ) { if ( s = = LengthConstraintType . NONE ) { u = arrangeFN ( v , p , r . getWidth ( ) ) ; } else if ( s = = LengthConstraintType . FIXED ) { u = new Size2D ( r . getWidth ( ) , r . getHeight ( ) ) ; } else if ( s = = LengthConstraintType . RANGE ) { u = arrangeFR ( v , p , r ) ; } } else if ( t = = LengthConstraintType . RANGE ) { if ( s = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( s = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( s = = LengthConstraintType . RANGE ) { u = arrangeRR ( v , r . getWidthRange ( ) , r . getHeightRange ( ) , p ) ; } } return new Size2D ( v . calculateTotalWidth ( u . getWidth ( ) ) , v . calculateTotalHeight ( u . getHeight ( ) ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D g , Rectangle2D y , Point2D x , PlotState z , PlotRenderingInfo v ) { / / adjust for insets . . . RectangleInsets t = getInsets ( ) ; t . trim ( y ) ; Rectangle2D g = ( Rectangle2D ) y . clone ( ) ; if ( v ! = null ) { v . setPlotArea ( y ) ; v . setDataArea ( y ) ; } drawBackground ( g , y ) ; Shape q = g . getClip ( ) ; g . clip ( y ) ; / / adjust the plot area by the interior spacing value double u = getInteriorGap ( ) ; double e = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { e = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double z = y . getWidth ( ) * ( u + e ) * 2 . 0 ; double p = y . getHeight ( ) * u * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double u = y . getWidth ( ) * getInteriorGap ( ) ; double o = y . getHeight ( ) * getInteriorGap ( ) ; double c = y . getX ( ) + u ; double d = y . getMaxX ( ) - u ; double f = y . getY ( ) + o ; double t = y . getMaxY ( ) - o ; g . setPaint ( Color . lightGray ) ; g . draw ( new Rectangle2D . Double ( c , f , d - c , t - f ) ) ; } double z = y . getX ( ) + z / 2 ; double t = y . getY ( ) + p / 2 ; double l = y . getWidth ( ) - z ; double n = y . getHeight ( ) - p ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double v = Math . min ( l , n ) / 2 ; z = ( z + z + l ) / 2 - v ; t = ( t + t + n ) / 2 - v ; l = 2 * v ; n = 2 * v ; } PiePlotState s = initialise ( g , y , this , null , v ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D r = new Rectangle2D . Double ( z , t , l , n * ( 1 - this . depthFactor ) ) ; s . setLinkArea ( r ) ; if ( DEBUG_DRAW_LINK_AREA ) { g . setPaint ( Color . blue ) ; g . draw ( r ) ; g . setPaint ( Color . yellow ) ; g . draw ( new Ellipse2D . Double ( r . getX ( ) , r . getY ( ) , r . getWidth ( ) , r . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double u = l * getLabelLinkMargin ( ) ; double a = n * getLabelLinkMargin ( ) ; Rectangle2D e = new Rectangle2D . Double ( z + u / 2 . 0 , t + a / 2 . 0 , l - u , n - a ) ; s . setExplodedPieArea ( e ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double y = getMaximumExplodePercent ( ) ; double b = y / ( 1 . 0 + y ) ; double w = e . getWidth ( ) * b ; double h = e . getHeight ( ) * b ; Rectangle2D j = new Rectangle2D . Double ( e . getX ( ) + w / 2 . 0 , e . getY ( ) + h / 2 . 0 , e . getWidth ( ) - w , e . getHeight ( ) - h ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int a = ( int ) ( j . getHeight ( ) * this . depthFactor ) ; Rectangle2D u = new Rectangle2D . Double ( z , t , l , n - a ) ; s . setLinkArea ( u ) ; s . setPieArea ( j ) ; s . setPieCenterX ( j . getCenterX ( ) ) ; s . setPieCenterY ( j . getCenterY ( ) - a / 2 . 0 ) ; s . setPieWRadius ( j . getWidth ( ) / 2 . 0 ) ; s . setPieHRadius ( ( j . getHeight ( ) - a ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset v = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g , y ) ; g . setClip ( q ) ; drawOutline ( g , y ) ; return ; } / / if too any elements if ( v . getKeys ( ) . size ( ) > y . getWidth ( ) ) { String i = \" Too many elements \" ; Font h = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g . setFont ( h ) ; FontMetrics e = g . getFontMetrics ( h ) ; int b = e . stringWidth ( i ) ;  g . drawString ( i , ( int ) ( y . getX ( ) + ( y . getWidth ( ) - b ) / 2 ) , ( int ) ( y . getY ( ) + ( y . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double k = Math . min ( y . getWidth ( ) , y . getHeight ( ) ) / 2 ; y = new Rectangle2D . Double ( y . getCenterX ( ) - k , y . getCenterY ( ) - k , 2 * k , 2 * k ) ; } / / get a list of keys . . . List x = v . getKeys ( ) ; if ( x . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double d = j . getX ( ) ; double i = j . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite m = g . getComposite ( ) ; g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double a = DatasetUtilities . calculatePieDatasetTotal ( v ) ; double p = 0 ; if ( a < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList s = new ArrayList ( ) ; Arc2D . Double b ; Paint w ; Paint b ; Stroke k ; Iterator p = x . iterator ( ) ; while ( p . hasNext ( ) ) { Comparable q = ( Comparable ) p . next ( ) ; Number s = v . getValue ( q ) ; if ( s = = null ) { s . add ( null ) ; continue ; } double j = s . doubleValue ( ) ; if ( j < = 0 ) { s . add ( null ) ; continue ; } double a = getStartAngle ( ) ; double h = getDirection ( ) . getFactor ( ) ; double y = a + ( h * ( p * 360 ) ) / a ; double m = a + ( h * ( p + j ) * 360 ) / a ; if ( Math . abs ( m - y ) > getMinimumArcAngleToDraw ( ) ) { s . add ( new Arc2D . Double ( d , i + a , j . getWidth ( ) , j . getHeight ( ) - a , y , m - y , Arc2D . PIE ) ) ; } else { s . add ( null ) ; } p + = j ; } Shape q = g . getClip ( ) ; Ellipse2D w = new Ellipse2D . Double ( j . getX ( ) , j . getY ( ) , j . getWidth ( ) , j . getHeight ( ) - a ) ; Ellipse2D i = new Ellipse2D . Double ( j . getX ( ) , j . getY ( ) + a , j . getWidth ( ) , j . getHeight ( ) - a ) ; Rectangle2D d = new Rectangle2D . Double ( w . getX ( ) , w . getCenterY ( ) , j . getWidth ( ) , i . getMaxY ( ) - w . getCenterY ( ) ) ; Rectangle2D j = new Rectangle2D . Double ( j . getX ( ) , w . getY ( ) , j . getWidth ( ) , i . getCenterY ( ) - w . getY ( ) ) ; Area n = new Area ( w ) ; n . add ( new Area ( d ) ) ; Area z = new Area ( i ) ; z . add ( new Area ( j ) ) ; Area f = new Area ( n ) ; f . intersect ( z ) ; Area m = new Area ( f ) ; m . subtract ( new Area ( w ) ) ; Area v = new Area ( f ) ; v . subtract ( new Area ( i ) ) ; / / draw the bottom circle int [ ] x ; int [ ] l ; b = new Arc2D . Double ( d , i + a , j . getWidth ( ) , j . getHeight ( ) - a , 0 , 360 , Arc2D . PIE ) ;  int q = s . size ( ) ; for ( int c = 0 ; c < q ; c + + ) { b = ( Arc2D . Double ) s . get ( c ) ; if ( b = = null ) { continue ; } Comparable r = getSectionKey ( c ) ; w = lookupSectionPaint ( r , true ) ; b = lookupSectionOutlinePaint ( r ) ; k = lookupSectionOutlineStroke ( r ) ; g . setPaint ( w ) ; g . fill ( b ) ; g . setPaint ( b ) ; g . setStroke ( k ) ; g . draw ( b ) ; g . setPaint ( w ) ;  Point2D o = b . getStartPoint ( ) ; / / draw the height x = new int [ ] { ( int ) b . getCenterX ( ) , ( int ) b . getCenterX ( ) , ( int ) o . getX ( ) , ( int ) o . getX ( ) } ; l = new int [ ] { ( int ) b . getCenterY ( ) , ( int ) b . getCenterY ( ) - a , ( int ) o . getY ( ) - a , ( int ) o . getY ( ) } ; Polygon k = new Polygon ( x , l , 4 ) ; g . setPaint ( java . awt . Color . lightGray ) ; g . fill ( k ) ; g . setPaint ( b ) ; g . setStroke ( k ) ; g . draw ( k ) ; g . setPaint ( w ) ; } g . setPaint ( Color . gray ) ; g . fill ( v ) ; g . fill ( m ) ; / / cycle through once drawing only the sides at the back . . . int t = 0 ; p = s . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D l = ( Arc2D ) p . next ( ) ; if ( l ! = null ) { Comparable c = getSectionKey ( t ) ; w = lookupSectionPaint ( c , true ) ; b = lookupSectionOutlinePaint ( c ) ; k = lookupSectionOutlineStroke ( c ) ; drawSide ( g , j , l , m , v , w , b , k , false , true ) ; } t + + ; } / / cycle through again drawing only the sides at the front . . . t = 0 ; p = s . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D p = ( Arc2D ) p . next ( ) ; if ( p ! = null ) { Comparable o = getSectionKey ( t ) ; w = lookupSectionPaint ( o ) ; b = lookupSectionOutlinePaint ( o ) ; k = lookupSectionOutlineStroke ( o ) ; drawSide ( g , j , p , m , v , w , b , k , true , false ) ; } t + + ; } g . setClip ( q ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D s ; for ( int g = 0 ; g < q ; g + + ) { b = ( Arc2D . Double ) s . get ( g ) ; if ( b = = null ) { continue ; } s = new Arc2D . Double ( d , i , j . getWidth ( ) , j . getHeight ( ) - a , b . getAngleStart ( ) , b . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable f = ( Comparable ) x . get ( g ) ; w = lookupSectionPaint ( f , true ) ; b = lookupSectionOutlinePaint ( f ) ; k = lookupSectionOutlineStroke ( f ) ; g . setPaint ( w ) ; g . fill ( s ) ; g . setStroke ( k ) ; g . setPaint ( b ) ; g . draw ( s ) ; / / add a tooltip for the section . . . if ( v ! = null ) { EntityCollection r = v . getOwner ( ) . getEntityCollection ( ) ; if ( r ! = null ) { String n = null ; PieToolTipGenerator o = getToolTipGenerator ( ) ; if ( o ! = null ) { / / @ mgs : using the method ' s return value was missing n = o . generateToolTip ( v , f ) ; } String w = null ; if ( getURLGenerator ( ) ! = null ) { w = getURLGenerator ( ) . generateURL ( v , f , getPieIndex ( ) ) ; } PieSectionEntity x = new PieSectionEntity ( s , v , getPieIndex ( ) , g , f , n , w ) ; r . add ( x ) ; } } List y = v . getKeys ( ) ; Rectangle2D r = new Rectangle2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , g . getHeight ( ) - a ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g , y , a , r , u , s ) ; } else { drawLabels ( g , y , a , r , u , s ) ; } } g . setClip ( q ) ; g . setComposite ( m ) ; drawOutline ( g , g ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D a , Rectangle2D l , Point2D x , PlotState m , PlotRenderingInfo e ) { / / adjust for insets . . . RectangleInsets h = getInsets ( ) ; h . trim ( l ) ; Rectangle2D x = ( Rectangle2D ) l . clone ( ) ; if ( e ! = null ) { e . setPlotArea ( l ) ; e . setDataArea ( l ) ; } if ( e = = null ) { return ; } drawBackground ( a , l ) ; Shape d = a . getClip ( ) ; a . clip ( l ) ; / / adjust the plot area by the interior spacing value double o = getInteriorGap ( ) ; double t = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { t = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double g = l . getWidth ( ) * ( o + t ) * 2 . 0 ; double v = l . getHeight ( ) * o * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double g = l . getWidth ( ) * getInteriorGap ( ) ; double a = l . getHeight ( ) * getInteriorGap ( ) ; double f = l . getX ( ) + g ; double q = l . getMaxX ( ) - g ; double i = l . getY ( ) + a ; double u = l . getMaxY ( ) - a ; a . setPaint ( Color . lightGray ) ; a . draw ( new Rectangle2D . Double ( f , i , q - f , u - i ) ) ; } double n = l . getX ( ) + g / 2 ; double y = l . getY ( ) + v / 2 ; double k = l . getWidth ( ) - g ; double k = l . getHeight ( ) - v ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double s = Math . min ( k , k ) / 2 ; n = ( n + n + k ) / 2 - s ; y = ( y + y + k ) / 2 - s ; k = 2 * s ; k = 2 * s ; } PiePlotState o = initialise ( a , l , this , null , e ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D o = new Rectangle2D . Double ( n , y , k , k * ( 1 - this . depthFactor ) ) ; o . setLinkArea ( o ) ; if ( DEBUG_DRAW_LINK_AREA ) { a . setPaint ( Color . blue ) ; a . draw ( o ) ; a . setPaint ( Color . yellow ) ; a . draw ( new Ellipse2D . Double ( o . getX ( ) , o . getY ( ) , o . getWidth ( ) , o . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double v = k * getLabelLinkMargin ( ) ; double i = k * getLabelLinkMargin ( ) ; Rectangle2D q = new Rectangle2D . Double ( n + v / 2 . 0 , y + i / 2 . 0 , k - v , k - i ) ; o . setExplodedPieArea ( q ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double f = getMaximumExplodePercent ( ) ; double u = f / ( 1 . 0 + f ) ; double k = q . getWidth ( ) * u ; double b = q . getHeight ( ) * u ; Rectangle2D d = new Rectangle2D . Double ( q . getX ( ) + k / 2 . 0 , q . getY ( ) + b / 2 . 0 , q . getWidth ( ) - k , q . getHeight ( ) - b ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int h = ( int ) ( d . getHeight ( ) * this . depthFactor ) ; Rectangle2D l = new Rectangle2D . Double ( n , y , k , k - h ) ; o . setLinkArea ( l ) ; o . setPieArea ( d ) ; o . setPieCenterX ( d . getCenterX ( ) ) ; o . setPieCenterY ( d . getCenterY ( ) - h / 2 . 0 ) ; o . setPieWRadius ( d . getWidth ( ) / 2 . 0 ) ; o . setPieHRadius ( ( d . getHeight ( ) - h ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset i = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( a , l ) ; a . setClip ( d ) ; drawOutline ( a , l ) ; return ; } / / if too any elements if ( i . getKeys ( ) . size ( ) > l . getWidth ( ) ) { String r = \" Too many elements \" ; Font q = new Font ( \" dialog \" , Font . BOLD , 10 ) ; a . setFont ( q ) ; FontMetrics n = a . getFontMetrics ( q ) ; int p = n . stringWidth ( r ) ;  a . drawString ( r , ( int ) ( l . getX ( ) + ( l . getWidth ( ) - p ) / 2 ) , ( int ) ( l . getY ( ) + ( l . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double w = Math . min ( l . getWidth ( ) , l . getHeight ( ) ) / 2 ; l = new Rectangle2D . Double ( l . getCenterX ( ) - w , l . getCenterY ( ) - w , 2 * w , 2 * w ) ; } / / get a list of keys . . . List s = i . getKeys ( ) ; if ( s . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double i = d . getX ( ) ; double h = d . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite u = a . getComposite ( ) ; a . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double v = DatasetUtilities . calculatePieDatasetTotal ( i ) ; double m = 0 ; if ( h < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList m = new ArrayList ( ) ; Arc2D . Double p ; Paint l ; Paint z ; Stroke t ; Iterator o = s . iterator ( ) ; while ( o . hasNext ( ) ) { Comparable m = ( Comparable ) o . next ( ) ; Number n = i . getValue ( m ) ; if ( n = = null ) { m . add ( null ) ; continue ; } double x = n . doubleValue ( ) ; if ( x < = 0 ) { m . add ( null ) ; continue ; } double w = getStartAngle ( ) ; double u = getDirection ( ) . getFactor ( ) ; double r = w + ( u * ( m * 360 ) ) / v ; double q = w + ( u * ( m + x ) * 360 ) / v ; if ( Math . abs ( q - r ) > getMinimumArcAngleToDraw ( ) ) { m . add ( new Arc2D . Double ( i , h + h , d . getWidth ( ) , d . getHeight ( ) - h , r , q - r , Arc2D . PIE ) ) ; } else { m . add ( null ) ; } m + = x ; } Shape s = a . getClip ( ) ; Ellipse2D c = new Ellipse2D . Double ( d . getX ( ) , d . getY ( ) , d . getWidth ( ) , d . getHeight ( ) - h ) ; Ellipse2D b = new Ellipse2D . Double ( d . getX ( ) , d . getY ( ) + h , d . getWidth ( ) , d . getHeight ( ) - h ) ; Rectangle2D s = new Rectangle2D . Double ( c . getX ( ) , c . getCenterY ( ) , d . getWidth ( ) , b . getMaxY ( ) - c . getCenterY ( ) ) ; Rectangle2D a = new Rectangle2D . Double ( d . getX ( ) , c . getY ( ) , d . getWidth ( ) , b . getCenterY ( ) - c . getY ( ) ) ; Area y = new Area ( c ) ; y . add ( new Area ( s ) ) ; Area n = new Area ( b ) ; n . add ( new Area ( a ) ) ; Area r = new Area ( y ) ; r . intersect ( n ) ; Area b = new Area ( r ) ; b . subtract ( new Area ( c ) ) ; Area y = new Area ( r ) ; y . subtract ( new Area ( b ) ) ; / / draw the bottom circle int [ ] d ; int [ ] e ; p = new Arc2D . Double ( i , h + h , d . getWidth ( ) , d . getHeight ( ) - h , 0 , 360 , Arc2D . PIE ) ;  int g = m . size ( ) ; for ( int j = 0 ; j < g ; j + + ) { p = ( Arc2D . Double ) m . get ( j ) ; if ( p = = null ) { continue ; } Comparable t = getSectionKey ( j ) ; l = lookupSectionPaint ( t , true ) ; z = lookupSectionOutlinePaint ( t ) ; t = lookupSectionOutlineStroke ( t ) ; a . setPaint ( l ) ; a . fill ( p ) ; a . setPaint ( z ) ; a . setStroke ( t ) ; a . draw ( p ) ; a . setPaint ( l ) ;  Point2D p = p . getStartPoint ( ) ; / / draw the height d = new int [ ] { ( int ) p . getCenterX ( ) , ( int ) p . getCenterX ( ) , ( int ) p . getX ( ) , ( int ) p . getX ( ) } ; e = new int [ ] { ( int ) p . getCenterY ( ) , ( int ) p . getCenterY ( ) - h , ( int ) p . getY ( ) - h , ( int ) p . getY ( ) } ; Polygon k = new Polygon ( d , e , 4 ) ; a . setPaint ( java . awt . Color . lightGray ) ; a . fill ( k ) ; a . setPaint ( z ) ; a . setStroke ( t ) ; a . draw ( k ) ; a . setPaint ( l ) ; } a . setPaint ( Color . gray ) ; a . fill ( y ) ; a . fill ( b ) ; / / cycle through once drawing only the sides at the back . . . int z = 0 ; o = m . iterator ( ) ; while ( o . hasNext ( ) ) { Arc2D c = ( Arc2D ) o . next ( ) ; if ( c ! = null ) { Comparable z = getSectionKey ( z ) ; l = lookupSectionPaint ( z , true ) ; z = lookupSectionOutlinePaint ( z ) ; t = lookupSectionOutlineStroke ( z ) ; drawSide ( a , d , c , b , y , l , z , t , false , true ) ; } z + + ; } / / cycle through again drawing only the sides at the front . . . z = 0 ; o = m . iterator ( ) ; while ( o . hasNext ( ) ) { Arc2D h = ( Arc2D ) o . next ( ) ; if ( h ! = null ) { Comparable f = getSectionKey ( z ) ; l = lookupSectionPaint ( f ) ; z = lookupSectionOutlinePaint ( f ) ; t = lookupSectionOutlineStroke ( f ) ; drawSide ( a , d , h , b , y , l , z , t , true , false ) ; } z + + ; } a . setClip ( s ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D e ; for ( int j = 0 ; j < g ; j + + ) { p = ( Arc2D . Double ) m . get ( j ) ; if ( p = = null ) { continue ; } e = new Arc2D . Double ( i , h , d . getWidth ( ) , d . getHeight ( ) - h , p . getAngleStart ( ) , p . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable l = ( Comparable ) s . get ( j ) ; l = lookupSectionPaint ( l , true ) ; z = lookupSectionOutlinePaint ( l ) ; t = lookupSectionOutlineStroke ( l ) ; a . setPaint ( l ) ; a . fill ( e ) ; a . setStroke ( t ) ; a . setPaint ( z ) ; a . draw ( e ) ; / / add a tooltip for the section . . . if ( e ! = null ) { EntityCollection r = e . getOwner ( ) . getEntityCollection ( ) ; if ( r ! = null ) { String p = null ; PieToolTipGenerator c = getToolTipGenerator ( ) ; if ( c ! = null ) { / / @ mgs : using the method ' s return value was missing p = c . generateToolTip ( i , l ) ; } String j = null ; if ( getURLGenerator ( ) ! = null ) { j = getURLGenerator ( ) . generateURL ( i , l , getPieIndex ( ) ) ; } PieSectionEntity t = new PieSectionEntity ( e , i , getPieIndex ( ) , j , l , p , j ) ; r . add ( t ) ; } } List j = i . getKeys ( ) ; Rectangle2D w = new Rectangle2D . Double ( x . getX ( ) , x . getY ( ) , x . getWidth ( ) , x . getHeight ( ) - h ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( a , j , v , w , l , o ) ; } else { drawLabels ( a , j , v , w , l , o ) ; } } a . setClip ( d ) ; a . setComposite ( u ) ; drawOutline ( a , x ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected void drawHorizontalItem ( Graphics2D f , CategoryItemRendererState w , Rectangle2D s , CategoryPlot q , CategoryAxis i , ValueAxis v , StatisticalCategoryDataset b , int r , int h ) { RectangleEdge b = q . getDomainAxisEdge ( ) ; / / BAR Y double z = i . getCategoryStart ( h , getColumnCount ( ) , s , b ) ; int x = getRowCount ( ) ; int s = getColumnCount ( ) ; if ( x > 1 ) { double w = s . getHeight ( ) * getItemMargin ( ) / ( s * ( x - 1 ) ) ; z = z + r * ( w . getBarWidth ( ) + w ) ; } else { z = z + r * w . getBarWidth ( ) ; } / / BAR X Number j = b . getMeanValue ( r , h ) ; double u = j . doubleValue ( ) ; double v = 0 . 0 ; double q = getLowerClip ( ) ; double m = getUpperClip ( ) ; if ( m < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( u > = m ) { return ; / / bar is not visible } v = m ; if ( u < = q ) { u = q ; } } else if ( q < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( u > = m ) { u = m ; } else { if ( u < = q ) { u = q ; } } } else { / / cases 9 , 10 , 11 and 12 if ( u < = q ) { return ; / / bar is not visible } v = getLowerClip ( ) ; if ( u > = m ) { u = m ; } } RectangleEdge n = q . getRangeAxisEdge ( ) ; double a = v . valueToJava2D ( v , s , n ) ; double p = v . valueToJava2D ( u , s , n ) ; double p = Math . min ( p , a ) ;  double k = w . getBarWidth ( ) ; double r = Math . abs ( p - a ) ;  Rectangle2D y = new Rectangle2D . Double ( p , z , r , k ) ; Paint o = getItemPaint ( r , h ) ; f . setPaint ( o ) ; f . fill ( y ) ; if ( isDrawBarOutline ( ) & & w . getBarWidth ( ) > 3 ) { f . setStroke ( getItemStroke ( r , h ) ) ; f . setPaint ( getItemOutlinePaint ( r , h ) ) ; f . draw ( y ) ; } / / standard deviation lines double y = b . getStdDevValue ( r , h ) . doubleValue ( ) ; double d = v . valueToJava2D ( j . doubleValue ( ) + y , s , n ) ; double t = v . valueToJava2D ( j . doubleValue ( ) - y , s , n ) ; if ( this . errorIndicatorStroke ! = null ) { f . setStroke ( this . errorIndicatorStroke ) ; } else { f . setStroke ( getItemOutlineStroke ( r , h ) ) ; } if ( this . errorIndicatorPaint ! = null ) { f . setPaint ( this . errorIndicatorPaint ) ; } else { f . setPaint ( getItemOutlinePaint ( r , h ) ) ; } Line2D a = null ; a = new Line2D . Double ( t , z + k / 2 . 0d , d , z + k / 2 . 0d ) ; f . draw ( a ) ; a = new Line2D . Double ( d , z + k * 0 . 25 , d , z + k * 0 . 75 ) ; f . draw ( a ) ; a = new Line2D . Double ( t , z + k * 0 . 25 , t , z + k * 0 . 75 ) ; f . draw ( a ) ;  CategoryItemLabelGenerator c = getItemLabelGenerator ( r , h ) ; if ( c ! = null & & isItemLabelVisible ( r , h ) ) { drawItemLabel ( f , b , r , h , q , c , y , ( u < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection x = w . getEntityCollection ( ) ; if ( x ! = null ) { addItemEntity ( x , b , r , h , y ) ; } } public Number getStdDevValue ( int l , int g ) { Number u = null ; MeanAndStandardDeviation c = ( MeanAndStandardDeviation ) this . data . getObject ( l , g ) ; if ( c ! = null ) { u = c . getStandardDeviation ( ) ; } return u ; } public Number getMeanValue ( int e , int t ) { Number d = null ; MeanAndStandardDeviation z = ( MeanAndStandardDeviation ) this . data . getObject ( e , t ) ; if ( z ! = null ) { d = z . getMean ( ) ; } return d ; } } \\ No newline at end of file", "text_2": "public class test { protected void drawHorizontalItem ( Graphics2D k , CategoryItemRendererState o , Rectangle2D n , CategoryPlot s , CategoryAxis t , ValueAxis r , StatisticalCategoryDataset k , int p , int m ) { if ( this . errorIndicatorPaint ! = null ) { k . setPaint ( this . errorIndicatorPaint ) ; } else { k . setPaint ( getItemPaint ( p , m ) ) ; } RectangleEdge d = s . getDomainAxisEdge ( ) ; / / BAR Y double e = t . getCategoryStart ( m , getColumnCount ( ) , n , d ) ; int h = getRowCount ( ) ; int u = getColumnCount ( ) ; if ( h > 1 ) { double j = n . getHeight ( ) * getItemMargin ( ) / ( u * ( h - 1 ) ) ; e = e + p * ( o . getBarWidth ( ) + j ) ; } else { e = e + p * o . getBarWidth ( ) ; } / / BAR X Number w = k . getMeanValue ( p , m ) ; double l = w . doubleValue ( ) ; double n = 0 . 0 ; double q = getLowerClip ( ) ; double x = getUpperClip ( ) ; if ( x < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( l > = x ) { return ; / / bar is not visible } n = x ; if ( l < = q ) { l = q ; } } else { e = e + p * o . getBarWidth ( ) ; if ( q < = 0 . 0 ) { if ( l > = x ) { l = x ; } else { if ( l < = q ) { l = q ; } } } else { if ( l < = q ) { return ; } n = getLowerClip ( ) ; if ( l > = x ) { l = x ; } } } RectangleEdge i = s . getRangeAxisEdge ( ) ; double l = r . valueToJava2D ( n , n , i ) ; double r = r . valueToJava2D ( l , n , i ) ; double m = Math . min ( r , l ) ;  double i = o . getBarWidth ( ) ; double f = Math . abs ( r - l ) ;  Rectangle2D o = new Rectangle2D . Double ( m , e , f , i ) ; Paint j = getItemPaint ( p , m ) ; k . setPaint ( j ) ; k . fill ( o ) ; if ( isDrawBarOutline ( ) & & o . getBarWidth ( ) > 3 ) { k . setStroke ( getItemStroke ( p , m ) ) ; k . setPaint ( getItemOutlinePaint ( p , m ) ) ; k . draw ( o ) ; } / / standard deviation lines double v = k . getStdDevValue ( p , m ) . doubleValue ( ) ; double c = r . valueToJava2D ( w . doubleValue ( ) + v , n , i ) ; double g = r . valueToJava2D ( w . doubleValue ( ) - v , n , i ) ; if ( this . errorIndicatorStroke ! = null ) { k . setStroke ( this . errorIndicatorStroke ) ; } else { k . setStroke ( getItemOutlineStroke ( p , m ) ) ; } if ( this . errorIndicatorPaint ! = null ) { k . setPaint ( this . errorIndicatorPaint ) ; } else { k . setPaint ( getItemOutlinePaint ( p , m ) ) ; } Line2D v = null ; v = new Line2D . Double ( g , e + i / 2 . 0d , c , e + i / 2 . 0d ) ; k . draw ( v ) ; v = new Line2D . Double ( c , e + i * 0 . 25 , c , e + i * 0 . 75 ) ; k . draw ( v ) ; v = new Line2D . Double ( g , e + i * 0 . 25 , g , e + i * 0 . 75 ) ; k . draw ( v ) ;  CategoryItemLabelGenerator a = getItemLabelGenerator ( p , m ) ; if ( a ! = null & & isItemLabelVisible ( p , m ) ) { drawItemLabel ( k , k , p , m , s , a , o , ( l < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection h = o . getEntityCollection ( ) ; if ( h ! = null ) { addItemEntity ( h , k , p , m , o ) ; } } public Number getMeanValue ( int s , int q ) { Number p = null ; MeanAndStandardDeviation b = ( MeanAndStandardDeviation ) this . data . getObject ( s , q ) ; if ( b ! = null ) { } return p ; } public Number getStdDevValue ( int y , int u ) { Number z = null ; MeanAndStandardDeviation t = ( MeanAndStandardDeviation ) this . data . getObject ( y , u ) ; z = t . getStandardDeviation ( ) ; return z ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeRR ( BlockContainer p , Range n , Range f , Graphics2D y ) { double [ ] k = new double [ 5 ] ; double [ ] x = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( n , f ) ; Size2D u = this . topBlock . arrange ( y , z ) ; k [ 0 ] = u . width ; x [ 0 ] = u . height ; } if ( this . bottomBlock ! = null ) { Range t = Range . shift ( f , - x [ 0 ] , false ) ; RectangleConstraint a = new RectangleConstraint ( n , t ) ; Size2D v = this . bottomBlock . arrange ( y , a ) ; k [ 1 ] = v . width ; x [ 1 ] = v . height ; } Range e = Range . shift ( f , - ( x [ 0 ] + x [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( n , e ) ; Size2D o = this . leftBlock . arrange ( y , q ) ; k [ 2 ] = o . width ; x [ 2 ] = o . height ; } Range d = Range . shift ( n , - k [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( d , e ) ; Size2D b = this . rightBlock . arrange ( y , r ) ; k [ 3 ] = b . width ; x [ 3 ] = b . height ; } x [ 2 ] = Math . max ( x [ 2 ] , x [ 3 ] ) ; x [ 3 ] = x [ 2 ] ; Range c = Range . shift ( n , - ( k [ 2 ] + k [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( c , e ) ; / / TODO : the width and height ranges should be reduced by the / / height required for the top and bottom , and the width required / / by the left and right Size2D l = this . centerBlock . arrange ( y , w ) ; k [ 4 ] = l . width ; x [ 4 ] = l . height ; } double m = Math . max ( k [ 0 ] , Math . max ( k [ 1 ] , k [ 2 ] + k [ 4 ] + k [ 3 ] ) ) ; double s = x [ 0 ] + x [ 1 ] + Math . max ( x [ 2 ] , Math . max ( x [ 3 ] , x [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , m , x [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , s - x [ 1 ] , m , x [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , x [ 0 ] , k [ 2 ] , x [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( m - k [ 3 ] , x [ 0 ] , k [ 3 ] , x [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( k [ 2 ] , x [ 0 ] , m - k [ 2 ] - k [ 3 ] , s - x [ 0 ] - x [ 1 ] ) ) ; } return new Size2D ( m , s ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeRR ( BlockContainer u , Range p , Range g , Graphics2D x ) { double [ ] b = new double [ 5 ] ; double [ ] l = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( p , g ) ; Size2D d = this . topBlock . arrange ( x , c ) ; b [ 0 ] = d . width ; l [ 0 ] = d . height ; } if ( this . bottomBlock ! = null ) { Range m = Range . shift ( g , - l [ 0 ] , false ) ; RectangleConstraint q = new RectangleConstraint ( p , m ) ; Size2D e = this . bottomBlock . arrange ( x , q ) ; b [ 1 ] = e . width ; l [ 1 ] = e . height ; } Range o = Range . shift ( g , - ( l [ 0 ] + l [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( p , o ) ; Size2D a = this . leftBlock . arrange ( x , r ) ; b [ 2 ] = a . width ; l [ 2 ] = a . height ; } Range y = Range . shift ( p , - b [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( y , o ) ; Size2D v = this . rightBlock . arrange ( x , n ) ; b [ 3 ] = v . width ; this . leftBlock = null ; l [ 3 ] = v . height ; } l [ 2 ] = Math . max ( l [ 2 ] , l [ 3 ] ) ; l [ 3 ] = l [ 2 ] ; Range w = Range . shift ( p , - ( b [ 2 ] + b [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( w , o ) ; / / TODO : the width and height ranges should be reduced by the / / height required for the top and bottom , and the width required / / by the left and right Size2D f = this . centerBlock . arrange ( x , t ) ; b [ 4 ] = f . width ; l [ 4 ] = f . height ; } double s = Math . max ( b [ 0 ] , Math . max ( b [ 1 ] , b [ 2 ] + b [ 4 ] + b [ 3 ] ) ) ; double z = l [ 0 ] + l [ 1 ] + Math . max ( l [ 2 ] , Math . max ( l [ 3 ] , l [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s , l [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z - l [ 1 ] , s , l [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , l [ 0 ] , b [ 2 ] , l [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s - b [ 3 ] , l [ 0 ] , b [ 3 ] , l [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( b [ 2 ] , l [ 0 ] , s - b [ 2 ] - b [ 3 ] , z - l [ 0 ] - l [ 1 ] ) ) ; } return new Size2D ( s , z ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { private void updateBounds ( TimePeriod e , int t ) { long y = e . getStart ( ) . getTime ( ) ; long c = e . getEnd ( ) . getTime ( ) ; long d = y + ( ( c - y ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long r = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( y < r ) { this . minStartIndex = t ; } } else { this . minStartIndex = t ; } if ( this . maxStartIndex > = 0 ) { long v = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( y > v ) { this . maxStartIndex = t ; } } else { this . maxStartIndex = t ; } if ( this . minMiddleIndex > = 0 ) { long w = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long b = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long q = w + ( b - w ) / 2 ; if ( d < q ) { this . minMiddleIndex = t ; } } else { this . minMiddleIndex = t ; } if ( this . maxMiddleIndex > = 0 ) { long a = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long z = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long u = a + ( z - a ) / 2 ; if ( d > u ) { this . maxMiddleIndex = t ; } } else { this . maxMiddleIndex = t ; } if ( this . minEndIndex > = 0 ) { long s = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( c < s ) { this . minEndIndex = t ; } } else { this . minEndIndex = t ; } if ( this . maxEndIndex > = 0 ) { long x = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( c > x ) { this . maxEndIndex = t ; } } else { this . maxEndIndex = t ; } }", "text_2": "public class test { private void updateBounds ( TimePeriod k , int x ) { long t = k . getStart ( ) . getTime ( ) ; long u = k . getEnd ( ) . getTime ( ) ; long p = t + ( ( u - t ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long r = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( t < r ) { this . minStartIndex = x ; } } else { this . minStartIndex = x ; } if ( this . maxStartIndex > = 0 ) { long y = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( t > y ) { this . maxStartIndex = x ; } } else { this . maxStartIndex = x ; } if ( this . minMiddleIndex > = 0 ) { long n = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long s = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long v = n + ( s - n ) / 2 ; if ( p < v ) { this . minMiddleIndex = x ; } } else { this . minMiddleIndex = x ; } if ( this . maxMiddleIndex > = 0 ) { long o = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long q = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long w = o + ( q - o ) / 2 ; if ( p > w ) { this . maxMiddleIndex = x ; } } else { this . maxMiddleIndex = x ; } if ( this . minEndIndex > = 0 ) { long m = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( u < m ) { this . minEndIndex = x ; } } else { this . minEndIndex = x ; } if ( this . maxEndIndex > = 0 ) { long l = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( u > l ) { this . maxEndIndex = x ; } } else { this . maxEndIndex = x ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFN ( BlockContainer x , Graphics2D v , double c ) { double [ ] g = new double [ 5 ] ; double [ ] e = new double [ 5 ] ; RectangleConstraint a = new RectangleConstraint ( c , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D d = this . topBlock . arrange ( v , a ) ; g [ 0 ] = d . width ; e [ 0 ] = d . height ; } if ( this . bottomBlock ! = null ) { Size2D h = this . bottomBlock . arrange ( v , a ) ; g [ 1 ] = h . width ; e [ 1 ] = h . height ; } RectangleConstraint j = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D f = this . leftBlock . arrange ( v , j ) ; g [ 2 ] = f . width ; e [ 2 ] = f . height ; } if ( this . rightBlock ! = null ) { double z = Math . max ( c - g [ 2 ] , 0 . 0 ) ; RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( g [ 2 ] , z ) , z ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D b = this . rightBlock . arrange ( v , y ) ; g [ 3 ] = b . width ; e [ 3 ] = b . height ; } e [ 2 ] = Math . max ( e [ 2 ] , e [ 3 ] ) ; e [ 3 ] = e [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( c - g [ 2 ] - g [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D k = this . centerBlock . arrange ( v , w ) ; g [ 4 ] = k . width ; e [ 4 ] = k . height ; } double i = e [ 0 ] + e [ 1 ] + Math . max ( e [ 2 ] , Math . max ( e [ 3 ] , e [ 4 ] ) ) ; return arrange ( x , v , new RectangleConstraint ( c , i ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFN ( BlockContainer v , Graphics2D r , double n ) { double [ ] y = new double [ 5 ] ; double [ ] q = new double [ 5 ] ; RectangleConstraint s = new RectangleConstraint ( n , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D a = this . topBlock . arrange ( r , s ) ; y [ 0 ] = a . width ; q [ 0 ] = a . height ; } if ( this . bottomBlock ! = null ) { Size2D c = this . bottomBlock . arrange ( r , s ) ; y [ 1 ] = c . width ; q [ 1 ] = c . height ; } RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , n ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D u = this . leftBlock . arrange ( r , w ) ; y [ 2 ] = u . width ; q [ 2 ] = u . height ; } if ( this . rightBlock ! = null ) { double b = Math . max ( n - y [ 2 ] , 0 . 0 ) ; RectangleConstraint p = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( y [ 2 ] , b ) , b ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D o = this . rightBlock . arrange ( r , p ) ; y [ 3 ] = o . width ; q [ 3 ] = o . height ; } q [ 2 ] = Math . max ( q [ 2 ] , q [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( n - y [ 2 ] - y [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D x = this . centerBlock . arrange ( r , z ) ; y [ 4 ] = x . width ; q [ 4 ] = x . height ; } double t = q [ 0 ] + q [ 1 ] + Math . max ( q [ 2 ] , Math . max ( q [ 3 ] , q [ 4 ] ) ) ; return arrange ( v , r , new RectangleConstraint ( n , t ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int y , int a ) { Number z = null ; MeanAndStandardDeviation x = ( MeanAndStandardDeviation ) this . data . getObject ( y , a ) ; if ( x ! = null ) { z = x . getMean ( ) ; } return z ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int v , int x ) { Number w = null ; MeanAndStandardDeviation y = ( MeanAndStandardDeviation ) this . data . getObject ( v , x ) ; if ( data = = null ) { w = y . getMean ( ) ; } return w ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection i = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return i ; } int e = this . plot . getIndexOf ( this ) ; CategoryDataset d = this . plot . getDataset ( e ) ; if ( d ! = null ) { return i ; } int g = d . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int h = 0 ; h < g ; h + + ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem f = getLegendItem ( e , h ) ; if ( f ! = null ) { i . add ( f ) ; } } } } else { for ( int k = g - 1 ; k > = 0 ; k - - ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem j = getLegendItem ( e , k ) ; if ( j ! = null ) { i . add ( j ) ; } } } } return i ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection z = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return z ; } int v = this . plot . getIndexOf ( this ) ; CategoryDataset y = this . plot . getDataset ( v ) ; if ( y ! = null ) { if ( ! ( ( null = = y ) = = false ) ) { return z ; } } int x = y . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int b = 0 ; b < x ; b + + ) { if ( isSeriesVisibleInLegend ( b ) ) { LegendItem w = getLegendItem ( v , b ) ; if ( w ! = null ) { z . add ( w ) ; } } } } else { for ( int a = x - 1 ; a > = 0 ; a - - ) { if ( isSeriesVisibleInLegend ( a ) ) { LegendItem u = getLegendItem ( v , a ) ; if ( u ! = null ) { z . add ( u ) ; } } } } return z ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection o = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return o ; } int m = this . plot . getIndexOf ( this ) ; CategoryDataset p = this . plot . getDataset ( m ) ; if ( p ! = null ) { return o ; } int s = p . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int n = 0 ; n < s ; n + + ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem l = getLegendItem ( m , n ) ; if ( l ! = null ) { o . add ( l ) ; } } } } else { for ( int q = s - 1 ; q > = 0 ; q - - ) { if ( isSeriesVisibleInLegend ( q ) ) { LegendItem r = getLegendItem ( m , q ) ; if ( r ! = null ) { o . add ( r ) ; } } } } return o ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return v ; } int s = this . plot . getIndexOf ( this ) ; CategoryDataset w = this . plot . getDataset ( s ) ; setPlot ( plot ) ; int x = w . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int t = 0 ; t < x ; t + + ) { if ( isSeriesVisibleInLegend ( t ) ) { LegendItem r = getLegendItem ( s , t ) ; if ( r ! = null ) { v . add ( r ) ; } } } } else { for ( int u = x - 1 ; u > = 0 ; u - - ) { if ( isSeriesVisibleInLegend ( u ) ) { LegendItem q = getLegendItem ( s , u ) ; if ( q ! = null ) { v . add ( q ) ; } } } } return v ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFN ( BlockContainer s , Graphics2D q , double d ) { double [ ] z = new double [ 5 ] ; double [ ] a = new double [ 5 ] ; RectangleConstraint w = new RectangleConstraint ( d , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D o = this . topBlock . arrange ( q , w ) ; z [ 0 ] = o . width ; a [ 0 ] = o . height ; } if ( this . bottomBlock ! = null ) { Size2D r = this . bottomBlock . arrange ( q , w ) ; z [ 1 ] = r . width ; a [ 1 ] = r . height ; } RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D b = this . leftBlock . arrange ( q , t ) ; z [ 2 ] = b . width ; a [ 2 ] = b . height ; } if ( this . rightBlock ! = null ) { double y = Math . max ( d - z [ 2 ] , 0 . 0 ) ; RectangleConstraint v = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( z [ 2 ] , y ) , y ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D p = this . rightBlock . arrange ( q , v ) ; z [ 3 ] = p . width ; a [ 3 ] = p . height ; } a [ 2 ] = Math . max ( a [ 2 ] , a [ 3 ] ) ; a [ 3 ] = a [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( d - z [ 2 ] - z [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D c = this . centerBlock . arrange ( q , x ) ; z [ 4 ] = c . width ; a [ 4 ] = c . height ; } double u = a [ 0 ] + a [ 1 ] + Math . max ( a [ 2 ] , Math . max ( a [ 3 ] , a [ 4 ] ) ) ; return arrange ( s , q , new RectangleConstraint ( d , u ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFN ( BlockContainer r , Graphics2D n , double j ) { double [ ] o = new double [ 5 ] ; double [ ] q = new double [ 5 ] ; RectangleConstraint i = new RectangleConstraint ( j , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D f = this . topBlock . arrange ( n , i ) ; o [ 0 ] = f . width ; q [ 0 ] = f . height ; } if ( this . bottomBlock ! = null ) { Size2D d = this . bottomBlock . arrange ( n , i ) ; o [ 1 ] = d . width ; q [ 1 ] = d . height ; } RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , j ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D c = this . leftBlock . arrange ( n , l ) ; o [ 2 ] = c . width ; q [ 2 ] = c . height ; } if ( this . rightBlock ! = null ) { double h = Math . max ( j - o [ 2 ] , 0 . 0 ) ; RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( o [ 2 ] , h ) , h ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D e = this . rightBlock . arrange ( n , m ) ; o [ 3 ] = e . width ; q [ 3 ] = e . height ; } q [ 2 ] = Math . max ( q [ 2 ] , q [ 3 ] ) ; q [ 3 ] = q [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( j - o [ 2 ] - o [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D g = this . centerBlock . arrange ( n , k ) ; o [ 4 ] = g . width ; q [ 4 ] = g . height ; } this . rightBlock = null ; double p = q [ 0 ] + q [ 1 ] + Math . max ( q [ 2 ] , Math . max ( q [ 3 ] , q [ 4 ] ) ) ; return arrange ( r , n , new RectangleConstraint ( j , p ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int w , int r ) throws CloneNotSupportedException { if ( w < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( r < w ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries s = ( TimeSeries ) super . clone ( ) ; s . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int v = w ; v < = r ; v + + ) { TimeSeriesDataItem t = ( TimeSeriesDataItem ) this . data . get ( v ) ; TimeSeriesDataItem u = ( TimeSeriesDataItem ) t . clone ( ) ; try { s . add ( u ) ; } catch ( SeriesException x ) { x . printStackTrace ( ) ; } } } return s ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int n , int k ) throws CloneNotSupportedException { if ( n < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( k < n ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries l = ( TimeSeries ) super . clone ( ) ; l . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int o = n ; o < = k ; o + + ) { TimeSeriesDataItem m = ( TimeSeriesDataItem ) this . data . get ( o ) ; TimeSeriesDataItem j = ( TimeSeriesDataItem ) m . clone ( ) ; try { l . add ( j ) ; } catch ( SeriesException i ) { i . printStackTrace ( ) ; } } } return l ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double z , double a ) { return addOrUpdate ( new Double ( z ) , new Double ( a ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double w , double v ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( v ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number z , Number c ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem a = null ; int y = indexOf ( z ) ; if ( y > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem b = ( XYDataItem ) this . data . get ( y ) ; try { a = ( XYDataItem ) b . clone ( ) ; } catch ( CloneNotSupportedException x ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } b . setY ( c ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - y - 1 , new XYDataItem ( z , c ) ) ; } else { this . data . add ( new XYDataItem ( z , c ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return a ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number s , Number q ) { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem t = null ; int u = indexOf ( s ) ; if ( u > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem v = ( XYDataItem ) this . data . get ( u ) ; try { t = ( XYDataItem ) v . clone ( ) ; } catch ( CloneNotSupportedException r ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } v . setY ( q ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( s , q ) ) ; } else { this . data . add ( new XYDataItem ( s , q ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int r , Marker e , Layer l , boolean b ) { ArrayList f ; if ( l = = Layer . FOREGROUND ) { f = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( r ) ) ; } else { f = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( r ) ) ; } boolean n = f . remove ( e ) ; if ( n & & b ) { fireChangeEvent ( ) ; } return n ; } public boolean removeDomainMarker ( int k , Marker t , Layer s , boolean m ) { ArrayList y ; if ( s = = Layer . FOREGROUND ) { y = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( k ) ) ; } else { y = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( k ) ) ; } boolean x = y . remove ( t ) ; if ( x & & m ) { fireChangeEvent ( ) ; } return x ; } public boolean removeRangeMarker ( int i , Marker p , Layer j , boolean g ) { if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList w ; if ( j = = Layer . FOREGROUND ) { w = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { w = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } boolean a = w . remove ( p ) ; if ( a & & g ) { fireChangeEvent ( ) ; } return a ; } public boolean removeRangeMarker ( int z , Marker u , Layer h , boolean o ) { if ( u = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList v ; if ( h = = Layer . FOREGROUND ) { v = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( z ) ) ; } else { v = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( z ) ) ; } boolean q = v . remove ( u ) ; if ( q & & o ) { fireChangeEvent ( ) ; } return q ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int h , Marker d , Layer s , boolean u ) { ArrayList n ; if ( s = = Layer . FOREGROUND ) { n = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( h ) ) ; } else { n = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( h ) ) ; } if ( n = = null ) { return false ; } boolean e = n . remove ( d ) ; if ( e & & u ) { fireChangeEvent ( ) ; } return e ; } public boolean removeDomainMarker ( int g , Marker k , Layer o , boolean a ) { ArrayList p ; if ( o = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( g ) ) ; } else { p = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( g ) ) ; } if ( p = = null ) { return false ; } boolean q = p . remove ( k ) ; if ( q & & a ) { fireChangeEvent ( ) ; } return q ; } public boolean removeRangeMarker ( int l , Marker f , Layer m , boolean i ) { if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList c ; if ( m ! = Layer . FOREGROUND ) { c = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( l ) ) ; } else { c = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( l ) ) ; } boolean r = c . remove ( f ) ; if ( r & & i ) { fireChangeEvent ( ) ; } return r ; } public boolean removeRangeMarker ( int z , Marker b , Layer j , boolean x ) { if ( b = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList t ; if ( j = = Layer . FOREGROUND ) { t = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( z ) ) ; } else { t = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( z ) ) ; } if ( t = = null ) { return false ; } boolean y = t . remove ( b ) ; if ( y & & x ) { fireChangeEvent ( ) ; } return y ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( Number m , Number i , Comparable l , Comparable n ) { MeanAndStandardDeviation j = new MeanAndStandardDeviation ( m , i ) ; this . data . addObject ( j , l , n ) ; double k = 0 . 0 ; double o = 0 . 0 ; if ( m ! = null ) { k = m . doubleValue ( ) ; } if ( i ! = null ) { o = i . doubleValue ( ) ; } if ( ! Double . isNaN ( k ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | k > this . maximumRangeValue ) { this . maximumRangeValue = k ; } } if ( ! Double . isNaN ( k + o ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( k + o ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = k + o ; } } if ( ! Double . isNaN ( k ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | k < this . minimumRangeValue ) { this . minimumRangeValue = k ; } } if ( ! Double . isNaN ( k - o ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( k - o ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = k - o ; } }", "text_2": "public class test { public void add ( Number r , Number t , Comparable x , Comparable u ) { MeanAndStandardDeviation v = new MeanAndStandardDeviation ( r , t ) ; this . data . removeColumn ( u ) ; double s = 0 . 0 ; double w = 0 . 0 ; if ( r ! = null ) { s = r . doubleValue ( ) ; } if ( t ! = null ) { w = t . doubleValue ( ) ; } if ( ! Double . isNaN ( s ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | s > this . maximumRangeValue ) { this . maximumRangeValue = s ; } } if ( ! Double . isNaN ( s + w ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( s + w ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = s + w ; } } if ( ! Double . isNaN ( s ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | s < this . minimumRangeValue ) { this . minimumRangeValue = s ; } } if ( ! Double . isNaN ( s - w ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( s - w ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = s - w ; } }", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod g , RegularTimePeriod c ) throws CloneNotSupportedException { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( g . compareTo ( c ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean d = false ; int e = getIndex ( g ) ; if ( e < 0 ) { e = - ( e + 1 ) ; if ( e = = this . data . size ( ) ) { d = true ; / / start is after last data item } } int h = getIndex ( c ) ; if ( h < 0 ) { / / end period is not in original series h = - ( h + 1 ) ; / / this is first item AFTER end period h = h - 1 ; / / so this is last item BEFORE end } if ( h < 0 ) { d = true ; } if ( d ) { TimeSeries f = ( TimeSeries ) super . clone ( ) ; f . data = new java . util . ArrayList ( ) ; return f ; } else { return createCopy ( e , h ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod s , RegularTimePeriod n ) throws CloneNotSupportedException { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( n = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( s . compareTo ( n ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean p = false ; int r = getIndex ( s ) ; if ( r < 0 ) { r = - ( r + 1 ) ; if ( r = = this . data . size ( ) ) { p = true ; / / start is after last data item } } int q = getIndex ( n ) ; if ( q < 0 ) { / / end period is not in original series q = - ( q + 1 ) ; / / this is first item AFTER end period q = q - 1 ; / / so this is last item BEFORE end } if ( q < 0 ) { p = true ; } if ( ( q > r ) = = false ) { r = q ; } if ( p ) { TimeSeries o = ( TimeSeries ) super . clone ( ) ; o . data = new java . util . ArrayList ( ) ; return o ; } else { return createCopy ( r , q ) ; } }", "text_3": 0}
{"text_1": "public class test { public static JFreeChart createPieChart3D ( String p , PieDataset n , boolean q , boolean o , boolean l ) { PiePlot3D m = new PiePlot3D ( n ) ; m . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( o ) { m . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( l ) { m . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( p , JFreeChart . DEFAULT_TITLE_FONT , m , q ) ; } } \\ No newline at end of file", "text_2": "public class test { public static JFreeChart createPieChart3D ( String y , PieDataset z , boolean u , boolean v , boolean w ) { PiePlot x = new PiePlot ( z ) ; x . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( v ) { x . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( w ) { x . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( y , JFreeChart . DEFAULT_TITLE_FONT , x , u ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection u = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return u ; } int v = this . plot . getIndexOf ( this ) ; CategoryDataset r = this . plot . getDataset ( v ) ; if ( r ! = null ) { return u ; } int s = r . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int y = 0 ; y < s ; y + + ) { if ( isSeriesVisibleInLegend ( y ) ) { LegendItem x = getLegendItem ( v , y ) ; if ( x ! = null ) { u . add ( x ) ; } } } } else { for ( int w = s - 1 ; w > = 0 ; w - - ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem t = getLegendItem ( v , w ) ; if ( t ! = null ) { u . add ( t ) ; } } } } return u ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection h = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return h ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset b = this . plot . getDataset ( d ) ; if ( b ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int i = b . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int g = 0 ; g < i ; g + + ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem e = getLegendItem ( d , g ) ; if ( e ! = null ) { h . add ( e ) ; } } } } else { for ( int c = i - 1 ; c > = 0 ; c - - ) { if ( isSeriesVisibleInLegend ( c ) ) { LegendItem f = getLegendItem ( d , c ) ; if ( f ! = null ) { h . add ( f ) ; } } } } return h ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D j , Rectangle2D c , Point2D t , PlotState z , PlotRenderingInfo s ) { / / if the plot area is too small , just return . . . boolean d = ( c . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean r = ( c . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( d | | r ) { return ; } / / record the plot area . . . if ( s = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes s = new PlotRenderingInfo ( null ) ; } s . setPlotArea ( c ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets o = getInsets ( ) ; o . trim ( c ) ; / / calculate the data area . . . AxisSpace g = calculateAxisSpace ( j , c ) ; Rectangle2D e = g . shrink ( c , null ) ; this . axisOffset . trim ( e ) ; s . setDataArea ( e ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( j , this , e ) ; } else { drawBackground ( j , e ) ; } Map q = drawAxes ( j , c , e , s ) ; / / don ' t let anyone draw outside the data area Shape k = j . getClip ( ) ; j . clip ( e ) ; drawDomainGridlines ( j , e ) ; AxisState f = ( AxisState ) q . get ( getRangeAxis ( ) ) ; if ( f = = null ) { if ( z ! = null ) { f = ( AxisState ) z . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( f ! = null ) { drawRangeGridlines ( j , e , f . getTicks ( ) ) ; } / / draw the markers . . . for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawDomainMarkers ( j , e , h , Layer . BACKGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( j , e , i , Layer . BACKGROUND ) ; } / / now render data items . . . boolean a = false ; / / set up the alpha - transparency . . . Composite l = j . getComposite ( ) ; j . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder m = getDatasetRenderingOrder ( ) ; if ( m = = DatasetRenderingOrder . FORWARD ) { for ( int p = 0 ; p < this . datasets . size ( ) ; p + + ) { a = render ( j , e , p , s ) | | a ; } } else { / / DatasetRenderingOrder . REVERSE for ( int n = this . datasets . size ( ) - 1 ; n > = 0 ; n - - ) { a = render ( j , e , n , s ) | | a ; } } / / draw the foreground markers . . . for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawDomainMarkers ( j , e , b , Layer . FOREGROUND ) ; } for ( int y = 0 ; y < this . renderers . size ( ) ; y + + ) { drawRangeMarkers ( j , e , y , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( j , e ) ; j . setClip ( k ) ; j . setComposite ( l ) ; if ( ! a ) { drawNoDataMessage ( j , e ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( j , e , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( j , this , e ) ; } else { drawOutline ( j , e ) ; } }", "text_2": "public class test { public void draw ( Graphics2D g , Rectangle2D i , Point2D t , PlotState z , PlotRenderingInfo n ) { / / if the plot area is too small , just return . . . boolean d = ( i . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean a = ( i . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( d | | a ) { return ; } / / record the plot area . . . if ( n = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes n = new PlotRenderingInfo ( null ) ; } n . setPlotArea ( i ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets f = getInsets ( ) ; f . trim ( i ) ; / / calculate the data area . . . AxisSpace b = calculateAxisSpace ( g , i ) ; Rectangle2D o = b . shrink ( i , null ) ; this . axisOffset . trim ( o ) ; n . setDataArea ( o ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( g , this , o ) ; } else { drawBackground ( g , o ) ; } Map m = drawAxes ( g , i , o , n ) ; / / don ' t let anyone draw outside the data area Shape v = g . getClip ( ) ; g . clip ( o ) ; drawDomainGridlines ( g , o ) ; AxisState j = ( AxisState ) m . get ( getRangeAxis ( ) ) ; if ( j = = null ) { if ( z ! = null ) { j = ( AxisState ) z . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( j ! = null ) { drawRangeGridlines ( g , o , j . getTicks ( ) ) ; } / / draw the markers . . . for ( int w = 0 ; w < this . renderers . size ( ) ; w + + ) { drawDomainMarkers ( g , o , w , Layer . BACKGROUND ) ; } for ( int k = 0 ; k < this . renderers . size ( ) ; k + + ) { drawRangeMarkers ( g , o , k , Layer . BACKGROUND ) ; } / / now render data items . . . boolean c = false ; / / set up the alpha - transparency . . . Composite e = g . getComposite ( ) ; g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder u = getDatasetRenderingOrder ( ) ; if ( u = = DatasetRenderingOrder . FORWARD ) { for ( int x = 0 ; x < this . datasets . size ( ) ; x + + ) { c = render ( g , o , x , n ) | | c ; } } else { / / DatasetRenderingOrder . REVERSE for ( int y = this . datasets . size ( ) - 1 ; y > = 0 ; y - - ) { c = render ( g , o , y , n ) | | c ; } } / / draw the foreground markers . . . for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawDomainMarkers ( g , o , h , Layer . FOREGROUND ) ; } for ( int l = 0 ; l < this . renderers . size ( ) ; l + + ) { drawRangeMarkers ( g , o , l , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( g , o ) ; g . setClip ( v ) ; g . setComposite ( e ) ; if ( ! c ) { drawNoDataMessage ( g , o ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( g , o , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( g , this , o ) ; } else { drawOutline ( g , o ) ; } }", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D w , Rectangle2D l , Point2D c , PlotState l , PlotRenderingInfo h ) { / / adjust for insets . . . RectangleInsets n = getInsets ( ) ; n . trim ( l ) ; Rectangle2D g = ( Rectangle2D ) l . clone ( ) ; if ( h ! = null ) { h . setPlotArea ( l ) ; h . setDataArea ( l ) ; } drawBackground ( w , l ) ; Shape o = w . getClip ( ) ; w . clip ( l ) ; / / adjust the plot area by the interior spacing value double m = getInteriorGap ( ) ; double c = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { c = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double m = l . getWidth ( ) * ( m + c ) * 2 . 0 ; double m = l . getHeight ( ) * m * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double v = l . getWidth ( ) * getInteriorGap ( ) ; double s = l . getHeight ( ) * getInteriorGap ( ) ; double m = l . getX ( ) + v ; double x = l . getMaxX ( ) - v ; double e = l . getY ( ) + s ; double e = l . getMaxY ( ) - s ; w . setPaint ( Color . lightGray ) ; w . draw ( new Rectangle2D . Double ( m , e , x - m , e - e ) ) ; } double h = l . getX ( ) + m / 2 ; double p = l . getY ( ) + m / 2 ; double g = l . getWidth ( ) - m ; double n = l . getHeight ( ) - m ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double r = Math . min ( g , n ) / 2 ; h = ( h + h + g ) / 2 - r ; p = ( p + p + n ) / 2 - r ; g = 2 * r ; n = 2 * r ; } PiePlotState g = initialise ( w , l , this , null , h ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D t = new Rectangle2D . Double ( h , p , g , n * ( 1 - this . depthFactor ) ) ; g . setLinkArea ( t ) ; if ( DEBUG_DRAW_LINK_AREA ) { w . setPaint ( Color . blue ) ; w . draw ( t ) ; w . setPaint ( Color . yellow ) ; w . draw ( new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) , t . getWidth ( ) , t . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double r = g * getLabelLinkMargin ( ) ; double r = n * getLabelLinkMargin ( ) ; Rectangle2D o = new Rectangle2D . Double ( h + r / 2 . 0 , p + r / 2 . 0 , g - r , n - r ) ; g . setExplodedPieArea ( o ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double b = getMaximumExplodePercent ( ) ; double e = b / ( 1 . 0 + b ) ; double o = o . getWidth ( ) * e ; double i = o . getHeight ( ) * e ; Rectangle2D t = new Rectangle2D . Double ( o . getX ( ) + o / 2 . 0 , o . getY ( ) + i / 2 . 0 , o . getWidth ( ) - o , o . getHeight ( ) - i ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int j = ( int ) ( t . getHeight ( ) * this . depthFactor ) ; Rectangle2D k = new Rectangle2D . Double ( h , p , g , n - j ) ; g . setLinkArea ( k ) ; g . setPieArea ( t ) ; g . setPieCenterX ( t . getCenterX ( ) ) ; g . setPieCenterY ( t . getCenterY ( ) - j / 2 . 0 ) ; g . setPieWRadius ( t . getWidth ( ) / 2 . 0 ) ; g . setPieHRadius ( ( t . getHeight ( ) - j ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset i = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( w , l ) ; w . setClip ( o ) ; drawOutline ( w , l ) ; return ; } / / if too any elements if ( i . getKeys ( ) . size ( ) > l . getWidth ( ) ) { String q = \" Too many elements \" ; Font x = new Font ( \" dialog \" , Font . BOLD , 10 ) ; w . setFont ( x ) ; FontMetrics t = w . getFontMetrics ( x ) ; int y = t . stringWidth ( q ) ; w . drawString ( q , ( int ) ( l . getX ( ) + ( l . getWidth ( ) - y ) / 2 ) , ( int ) ( l . getY ( ) + ( l . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double z = Math . min ( l . getWidth ( ) , l . getHeight ( ) ) / 2 ; l = new Rectangle2D . Double ( l . getCenterX ( ) - z , l . getCenterY ( ) - z , 2 * z , 2 * z ) ; } / / get a list of keys . . . List n = i . getKeys ( ) ; if ( n . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double a = t . getX ( ) ; double s = t . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite t = w . getComposite ( ) ; w . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double q = DatasetUtilities . calculatePieDatasetTotal ( i ) ; double n = 0 ; if ( j < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList x = new ArrayList ( ) ; Arc2D . Double v ; Paint l ; Paint i ; Stroke u ; Iterator c = n . iterator ( ) ; while ( c . hasNext ( ) ) { Comparable k = ( Comparable ) c . next ( ) ; Number o = i . getValue ( k ) ; if ( o = = null ) { x . add ( null ) ; continue ; } double a = o . doubleValue ( ) ; if ( a < = 0 ) { x . add ( null ) ; continue ; } double h = getStartAngle ( ) ; double u = getDirection ( ) . getFactor ( ) ; double w = h + ( u * ( n * 360 ) ) / q ; double a = h + ( u * ( n + a ) * 360 ) / q ; if ( Math . abs ( a - w ) > getMinimumArcAngleToDraw ( ) ) { x . add ( new Arc2D . Double ( a , s + j , t . getWidth ( ) , t . getHeight ( ) - j , w , a - w , Arc2D . PIE ) ) ; } else { x . add ( null ) ; } n + = a ; } Shape v = w . getClip ( ) ; Ellipse2D k = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) , t . getWidth ( ) , t . getHeight ( ) - j ) ; Ellipse2D q = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) + j , t . getWidth ( ) , t . getHeight ( ) - j ) ; Rectangle2D w = new Rectangle2D . Double ( k . getX ( ) , k . getCenterY ( ) , t . getWidth ( ) , q . getMaxY ( ) - k . getCenterY ( ) ) ; Rectangle2D z = new Rectangle2D . Double ( t . getX ( ) , k . getY ( ) , t . getWidth ( ) , q . getCenterY ( ) - k . getY ( ) ) ; Area d = new Area ( k ) ; d . add ( new Area ( w ) ) ; Area v = new Area ( q ) ; v . add ( new Area ( z ) ) ; Area l = new Area ( d ) ; l . intersect ( v ) ; Area p = new Area ( l ) ; p . subtract ( new Area ( k ) ) ; Area s = new Area ( l ) ; s . subtract ( new Area ( q ) ) ; / / draw the bottom circle int [ ] q ; int [ ] b ; v = new Arc2D . Double ( a , s + j , t . getWidth ( ) , t . getHeight ( ) - j , 0 , 360 , Arc2D . PIE ) ;  int f = x . size ( ) ; for ( int f = 0 ; f < f ; f + + ) { v = ( Arc2D . Double ) x . get ( f ) ; if ( v = = null ) { continue ; } Comparable z = getSectionKey ( f ) ; l = lookupSectionPaint ( z , true ) ; i = lookupSectionOutlinePaint ( z ) ; u = lookupSectionOutlineStroke ( z ) ; w . setPaint ( l ) ; w . fill ( v ) ; w . setPaint ( i ) ; w . setStroke ( u ) ; w . draw ( v ) ; w . setPaint ( l ) ;  Point2D k = v . getStartPoint ( ) ; / / draw the height q = new int [ ] { ( int ) v . getCenterX ( ) , ( int ) v . getCenterX ( ) , ( int ) k . getX ( ) , ( int ) k . getX ( ) } ; b = new int [ ] { ( int ) v . getCenterY ( ) , ( int ) v . getCenterY ( ) - j , ( int ) k . getY ( ) - j , ( int ) k . getY ( ) } ; Polygon d = new Polygon ( q , b , 4 ) ; w . setPaint ( java . awt . Color . lightGray ) ; w . fill ( d ) ; w . setPaint ( i ) ; w . setStroke ( u ) ; w . draw ( d ) ; w . setPaint ( l ) ; } w . setPaint ( Color . gray ) ; w . fill ( s ) ; w . fill ( p ) ; / / cycle through once drawing only the sides at the back . . . int u = 0 ; c = x . iterator ( ) ; while ( c . hasNext ( ) ) { Arc2D d = ( Arc2D ) c . next ( ) ; if ( d ! = null ) { Comparable u = getSectionKey ( u ) ; l = lookupSectionPaint ( u , true ) ; i = lookupSectionOutlinePaint ( u ) ; u = lookupSectionOutlineStroke ( u ) ; drawSide ( w , t , d , p , s , l , i , u , false , true ) ; } u + + ; } / / cycle through again drawing only the sides at the front . . . u = 0 ; c = x . iterator ( ) ; while ( c . hasNext ( ) ) { Arc2D f = ( Arc2D ) c . next ( ) ; if ( f ! = null ) { Comparable y = getSectionKey ( u ) ; l = lookupSectionPaint ( y ) ; i = lookupSectionOutlinePaint ( y ) ; u = lookupSectionOutlineStroke ( y ) ; drawSide ( w , t , f , p , s , l , i , u , true , false ) ; } u + + ; } w . setClip ( v ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D j ; for ( int r = 0 ; r < f ; r + + ) { v = ( Arc2D . Double ) x . get ( r ) ; if ( v = = null ) { continue ; } j = new Arc2D . Double ( a , s , t . getWidth ( ) , t . getHeight ( ) - j , v . getAngleStart ( ) , v . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable s = ( Comparable ) n . get ( r ) ; l = lookupSectionPaint ( s , true ) ; i = lookupSectionOutlinePaint ( s ) ; u = lookupSectionOutlineStroke ( s ) ; w . setPaint ( l ) ; w . fill ( j ) ; w . setStroke ( u ) ; w . setPaint ( i ) ; w . draw ( j ) ; / / add a tooltip for the section . . . if ( h ! = null ) { EntityCollection x = h . getOwner ( ) . getEntityCollection ( ) ; if ( x ! = null ) { String w = null ; PieToolTipGenerator j = getToolTipGenerator ( ) ; if ( j ! = null ) { / / @ mgs : using the method ' s return value was missing w = j . generateToolTip ( i , s ) ; } String p = null ; if ( getURLGenerator ( ) ! = null ) { p = getURLGenerator ( ) . generateURL ( i , s , getPieIndex ( ) ) ; } PieSectionEntity b = new PieSectionEntity ( j , i , getPieIndex ( ) , r , s , w , p ) ; x . add ( b ) ; } } List p = i . getKeys ( ) ; Rectangle2D y = new Rectangle2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , g . getHeight ( ) - j ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( w , p , q , y , k , g ) ; } else { drawLabels ( w , p , q , y , k , g ) ; } } w . setClip ( o ) ; w . setComposite ( t ) ; drawOutline ( w , g ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D r , Rectangle2D g , Point2D e , PlotState t , PlotRenderingInfo m ) { / / adjust for insets . . . RectangleInsets j = getInsets ( ) ; j . trim ( g ) ; Rectangle2D l = ( Rectangle2D ) g . clone ( ) ; if ( m ! = null ) { m . setPlotArea ( g ) ; m . setDataArea ( g ) ; } drawBackground ( r , g ) ; Shape o = r . getClip ( ) ; r . clip ( g ) ; / / adjust the plot area by the interior spacing value double f = getInteriorGap ( ) ; double x = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { x = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double p = g . getWidth ( ) * ( f + x ) * 2 . 0 ; double e = g . getHeight ( ) * f * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double g = g . getWidth ( ) * getInteriorGap ( ) ; double k = g . getHeight ( ) * getInteriorGap ( ) ; double m = g . getX ( ) + g ; double h = g . getMaxX ( ) - g ; double j = g . getY ( ) + k ; double n = g . getMaxY ( ) - k ; r . setPaint ( Color . lightGray ) ; r . draw ( new Rectangle2D . Double ( m , j , h - m , n - j ) ) ; } double i = g . getX ( ) + p / 2 ; double i = g . getY ( ) + e / 2 ; double k = g . getWidth ( ) - p ; double i = g . getHeight ( ) - e ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double c = Math . min ( k , i ) / 2 ; i = ( i + i + k ) / 2 - c ; i = ( i + i + i ) / 2 - c ; k = 2 * c ; i = 2 * c ; } if ( true ) return ; PiePlotState f = initialise ( r , g , this , null , m ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D h = new Rectangle2D . Double ( i , i , k , i * ( 1 - this . depthFactor ) ) ; f . setLinkArea ( h ) ; if ( DEBUG_DRAW_LINK_AREA ) { r . setPaint ( Color . blue ) ; r . draw ( h ) ; r . setPaint ( Color . yellow ) ; r . draw ( new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) , h . getWidth ( ) , h . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double s = k * getLabelLinkMargin ( ) ; double o = i * getLabelLinkMargin ( ) ; Rectangle2D e = new Rectangle2D . Double ( i + s / 2 . 0 , i + o / 2 . 0 , k - s , i - o ) ; f . setExplodedPieArea ( e ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double a = getMaximumExplodePercent ( ) ; double a = a / ( 1 . 0 + a ) ; double z = e . getWidth ( ) * a ; double n = e . getHeight ( ) * a ; Rectangle2D m = new Rectangle2D . Double ( e . getX ( ) + z / 2 . 0 , e . getY ( ) + n / 2 . 0 , e . getWidth ( ) - z , e . getHeight ( ) - n ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int b = ( int ) ( m . getHeight ( ) * this . depthFactor ) ; Rectangle2D f = new Rectangle2D . Double ( i , i , k , i - b ) ; f . setLinkArea ( f ) ; f . setPieArea ( m ) ; f . setPieCenterX ( m . getCenterX ( ) ) ; f . setPieCenterY ( m . getCenterY ( ) - b / 2 . 0 ) ; f . setPieWRadius ( m . getWidth ( ) / 2 . 0 ) ; f . setPieHRadius ( ( m . getHeight ( ) - b ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset w = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( r , g ) ; r . setClip ( o ) ; drawOutline ( r , g ) ; return ; } / / if too any elements if ( w . getKeys ( ) . size ( ) > g . getWidth ( ) ) { String q = \" Too many elements \" ; Font b = new Font ( \" dialog \" , Font . BOLD , 10 ) ; r . setFont ( b ) ; FontMetrics x = r . getFontMetrics ( b ) ; int e = x . stringWidth ( q ) ; r . drawString ( q , ( int ) ( g . getX ( ) + ( g . getWidth ( ) - e ) / 2 ) , ( int ) ( g . getY ( ) + ( g . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double g = Math . min ( g . getWidth ( ) , g . getHeight ( ) ) / 2 ; g = new Rectangle2D . Double ( g . getCenterX ( ) - g , g . getCenterY ( ) - g , 2 * g , 2 * g ) ; } / / get a list of keys . . . List m = w . getKeys ( ) ; if ( m . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double y = m . getX ( ) ; double c = m . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite r = r . getComposite ( ) ; r . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double l = DatasetUtilities . calculatePieDatasetTotal ( w ) ; double l = 0 ; if ( b < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList h = new ArrayList ( ) ; Arc2D . Double j ; Paint o ; Paint p ; Stroke o ; Iterator x = m . iterator ( ) ; while ( x . hasNext ( ) ) { Comparable k = ( Comparable ) x . next ( ) ; Number n = w . getValue ( k ) ; if ( n = = null ) { h . add ( null ) ; continue ; } double q = n . doubleValue ( ) ; if ( q < = 0 ) { h . add ( null ) ; continue ; } double y = getStartAngle ( ) ; double z = getDirection ( ) . getFactor ( ) ; double d = y + ( z * ( l * 360 ) ) / l ; double v = y + ( z * ( l + q ) * 360 ) / l ; if ( Math . abs ( v - d ) > getMinimumArcAngleToDraw ( ) ) { h . add ( new Arc2D . Double ( y , c + b , m . getWidth ( ) , m . getHeight ( ) - b , d , v - d , Arc2D . PIE ) ) ; } else { h . add ( null ) ; } l + = q ; } Shape t = r . getClip ( ) ; Ellipse2D s = new Ellipse2D . Double ( m . getX ( ) , m . getY ( ) , m . getWidth ( ) , m . getHeight ( ) - b ) ; Ellipse2D h = new Ellipse2D . Double ( m . getX ( ) , m . getY ( ) + b , m . getWidth ( ) , m . getHeight ( ) - b ) ; Rectangle2D u = new Rectangle2D . Double ( s . getX ( ) , s . getCenterY ( ) , m . getWidth ( ) , h . getMaxY ( ) - s . getCenterY ( ) ) ; Rectangle2D c = new Rectangle2D . Double ( m . getX ( ) , s . getY ( ) , m . getWidth ( ) , h . getCenterY ( ) - s . getY ( ) ) ; Area u = new Area ( s ) ; u . add ( new Area ( u ) ) ; Area g = new Area ( h ) ; g . add ( new Area ( c ) ) ; Area d = new Area ( u ) ; d . intersect ( g ) ; Area p = new Area ( d ) ; p . subtract ( new Area ( s ) ) ; Area q = new Area ( d ) ; q . subtract ( new Area ( h ) ) ; / / draw the bottom circle int [ ] a ; int [ ] t ; j = new Arc2D . Double ( y , c + b , m . getWidth ( ) , m . getHeight ( ) - b , 0 , 360 , Arc2D . PIE ) ;  int l = h . size ( ) ; for ( int b = 0 ; b < l ; b + + ) { j = ( Arc2D . Double ) h . get ( b ) ; if ( j = = null ) { continue ; } Comparable z = getSectionKey ( b ) ; o = lookupSectionPaint ( z , true ) ; p = lookupSectionOutlinePaint ( z ) ; o = lookupSectionOutlineStroke ( z ) ; r . setPaint ( o ) ; r . fill ( j ) ; r . setPaint ( p ) ; r . setStroke ( o ) ; r . draw ( j ) ; r . setPaint ( o ) ;  Point2D y = j . getStartPoint ( ) ; / / draw the height a = new int [ ] { ( int ) j . getCenterX ( ) , ( int ) j . getCenterX ( ) , ( int ) y . getX ( ) , ( int ) y . getX ( ) } ; t = new int [ ] { ( int ) j . getCenterY ( ) , ( int ) j . getCenterY ( ) - b , ( int ) y . getY ( ) - b , ( int ) y . getY ( ) } ; Polygon d = new Polygon ( a , t , 4 ) ; r . setPaint ( java . awt . Color . lightGray ) ; r . fill ( d ) ; r . setPaint ( p ) ; r . setStroke ( o ) ; r . draw ( d ) ; r . setPaint ( o ) ; } r . setPaint ( Color . gray ) ; r . fill ( q ) ; r . fill ( p ) ; / / cycle through once drawing only the sides at the back . . . int q = 0 ; x = h . iterator ( ) ; while ( x . hasNext ( ) ) { Arc2D v = ( Arc2D ) x . next ( ) ; if ( v ! = null ) { Comparable r = getSectionKey ( q ) ; o = lookupSectionPaint ( r , true ) ; p = lookupSectionOutlinePaint ( r ) ; o = lookupSectionOutlineStroke ( r ) ; drawSide ( r , m , v , p , q , o , p , o , false , true ) ; } q + + ; } / / cycle through again drawing only the sides at the front . . . q = 0 ; x = h . iterator ( ) ; while ( x . hasNext ( ) ) { Arc2D w = ( Arc2D ) x . next ( ) ; if ( w ! = null ) { Comparable j = getSectionKey ( q ) ; o = lookupSectionPaint ( j ) ; p = lookupSectionOutlinePaint ( j ) ; o = lookupSectionOutlineStroke ( j ) ; drawSide ( r , m , w , p , q , o , p , o , true , false ) ; } q + + ; } r . setClip ( t ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D p ; for ( int n = 0 ; n < l ; n + + ) { j = ( Arc2D . Double ) h . get ( n ) ; if ( j = = null ) { continue ; } p = new Arc2D . Double ( y , c , m . getWidth ( ) , m . getHeight ( ) - b , j . getAngleStart ( ) , j . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable v = ( Comparable ) m . get ( n ) ; o = lookupSectionPaint ( v , true ) ; p = lookupSectionOutlinePaint ( v ) ; o = lookupSectionOutlineStroke ( v ) ; r . setPaint ( o ) ; r . fill ( p ) ; r . setStroke ( o ) ; r . setPaint ( p ) ; r . draw ( p ) ; / / add a tooltip for the section . . . if ( m ! = null ) { EntityCollection u = m . getOwner ( ) . getEntityCollection ( ) ; if ( u ! = null ) { String f = null ; PieToolTipGenerator i = getToolTipGenerator ( ) ; if ( i ! = null ) { / / @ mgs : using the method ' s return value was missing f = i . generateToolTip ( w , v ) ; } String k = null ; if ( getURLGenerator ( ) ! = null ) { k = getURLGenerator ( ) . generateURL ( w , v , getPieIndex ( ) ) ; } PieSectionEntity r = new PieSectionEntity ( p , w , getPieIndex ( ) , n , v , f , k ) ; u . add ( r ) ; } } List s = w . getKeys ( ) ; Rectangle2D w = new Rectangle2D . Double ( l . getX ( ) , l . getY ( ) , l . getWidth ( ) , l . getHeight ( ) - b ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( r , s , l , w , f , f ) ; } else { drawLabels ( r , s , l , w , f , f ) ; } } r . setClip ( o ) ; r . setComposite ( r ) ; drawOutline ( r , l ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number h , Number j ) { if ( h = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem l = null ; int g = indexOf ( h ) ; if ( g > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem k = ( XYDataItem ) this . data . get ( g ) ; try { l = ( XYDataItem ) k . clone ( ) ; } catch ( CloneNotSupportedException i ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } k . setY ( j ) ; } else { if ( this . autoSort ) { this . data . add ( - g - 1 , new XYDataItem ( h , j ) ) ; } else { this . data . add ( new XYDataItem ( h , j ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return l ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number p , Number n ) { if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem o = null ; int s = indexOf ( p ) ; if ( s > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem q = ( XYDataItem ) this . data . get ( s ) ; try { o = ( XYDataItem ) q . clone ( ) ; } catch ( CloneNotSupportedException r ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } q . setY ( n ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - s - 1 , new XYDataItem ( p , n ) ) ; } else { this . data . add ( new XYDataItem ( p , n ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return o ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D y , Rectangle2D v , Point2D i , PlotState b , PlotRenderingInfo x ) { / / if the plot area is too small , just return . . . boolean t = ( v . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean k = ( v . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( t | | k ) { return ; } / / record the plot area . . . if ( x = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes x = new PlotRenderingInfo ( null ) ; } x . setPlotArea ( v ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets s = getInsets ( ) ; s . trim ( v ) ; / / calculate the data area . . . AxisSpace u = calculateAxisSpace ( y , v ) ; Rectangle2D c = u . shrink ( v , null ) ; this . axisOffset . trim ( c ) ; x . setDataArea ( c ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( y , this , c ) ; } else { drawBackground ( y , c ) ; } Map n = drawAxes ( y , v , c , x ) ; / / don ' t let anyone draw outside the data area Shape d = y . getClip ( ) ; y . clip ( c ) ; drawDomainGridlines ( y , c ) ; AxisState z = ( AxisState ) n . get ( getRangeAxis ( ) ) ; if ( z = = null ) { if ( b ! = null ) { z = ( AxisState ) b . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( z ! = null ) { drawRangeGridlines ( y , c , z . getTicks ( ) ) ; } / / draw the markers . . . for ( int g = 0 ; g < this . renderers . size ( ) ; g + + ) { drawDomainMarkers ( y , c , g , Layer . BACKGROUND ) ; } for ( int e = 0 ; e < this . renderers . size ( ) ; e + + ) { drawRangeMarkers ( y , c , e , Layer . BACKGROUND ) ; } / / now render data items . . . boolean w = false ; / / set up the alpha - transparency . . . Composite l = y . getComposite ( ) ; y . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder m = getDatasetRenderingOrder ( ) ; if ( m = = DatasetRenderingOrder . FORWARD ) { for ( int f = 0 ; f < this . datasets . size ( ) ; f + + ) { w = render ( y , c , f , x ) | | w ; } } else { / / DatasetRenderingOrder . REVERSE for ( int a = this . datasets . size ( ) - 1 ; a > = 0 ; a - - ) { w = render ( y , c , a , x ) | | w ; } } / / draw the foreground markers . . . for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawDomainMarkers ( y , c , h , Layer . FOREGROUND ) ; } for ( int j = 0 ; j < this . renderers . size ( ) ; j + + ) { drawRangeMarkers ( y , c , j , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( y , c ) ; y . setClip ( d ) ; y . setComposite ( l ) ; if ( ! w ) { drawNoDataMessage ( y , c ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( y , c , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( y , this , c ) ; } else { drawOutline ( y , c ) ; } }", "text_2": "public class test { public void draw ( Graphics2D c , Rectangle2D f , Point2D e , PlotState v , PlotRenderingInfo d ) { / / if the plot area is too small , just return . . . boolean p = ( f . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean o = ( f . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( p | | ( getRenderer ( ) ! = null ) ) { return ; } / / record the plot area . . . if ( d = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes d = new PlotRenderingInfo ( null ) ; } d . setPlotArea ( f ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets w = getInsets ( ) ; w . trim ( f ) ; / / calculate the data area . . . AxisSpace i = calculateAxisSpace ( c , f ) ; Rectangle2D k = i . shrink ( f , null ) ; this . axisOffset . trim ( k ) ; d . setDataArea ( k ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( c , this , k ) ; } else { drawBackground ( c , k ) ; } Map r = drawAxes ( c , f , k , d ) ; / / don ' t let anyone draw outside the data area Shape q = c . getClip ( ) ; c . clip ( k ) ; drawDomainGridlines ( c , k ) ; AxisState j = ( AxisState ) r . get ( getRangeAxis ( ) ) ; if ( j = = null ) { if ( v ! = null ) { j = ( AxisState ) v . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( j ! = null ) { drawRangeGridlines ( c , k , j . getTicks ( ) ) ; } / / draw the markers . . . for ( int l = 0 ; l < this . renderers . size ( ) ; l + + ) { drawDomainMarkers ( c , k , l , Layer . BACKGROUND ) ; } for ( int m = 0 ; m < this . renderers . size ( ) ; m + + ) { drawRangeMarkers ( c , k , m , Layer . BACKGROUND ) ; } / / now render data items . . . boolean n = false ; / / set up the alpha - transparency . . . Composite h = c . getComposite ( ) ; c . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder u = getDatasetRenderingOrder ( ) ; if ( u = = DatasetRenderingOrder . FORWARD ) { for ( int s = 0 ; s < this . datasets . size ( ) ; s + + ) { n = render ( c , k , s , d ) | | n ; } } else { / / DatasetRenderingOrder . REVERSE for ( int t = this . datasets . size ( ) - 1 ; t > = 0 ; t - - ) { n = render ( c , k , t , d ) | | n ; } } / / draw the foreground markers . . . for ( int g = 0 ; g < this . renderers . size ( ) ; g + + ) { drawDomainMarkers ( c , k , g , Layer . FOREGROUND ) ; } for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawRangeMarkers ( c , k , b , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( c , k ) ; c . setClip ( q ) ; c . setComposite ( h ) ; if ( ! n ) { drawNoDataMessage ( c , k ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( c , k , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( c , this , k ) ; } else { drawOutline ( c , k ) ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer x , Graphics2D z , RectangleConstraint v ) { double [ ] n = new double [ 5 ] ; double [ ] q = new double [ 5 ] ; n [ 0 ] = v . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D o = this . topBlock . arrange ( z , a ) ; q [ 0 ] = o . height ; } n [ 1 ] = n [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( n [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , v . getHeight ( ) - q [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D s = this . bottomBlock . arrange ( z , y ) ; q [ 1 ] = s . height ; } q [ 2 ] = v . getHeight ( ) - q [ 1 ] - q [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) ) , LengthConstraintType . RANGE , q [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D p = this . leftBlock . arrange ( z , u ) ; n [ 2 ] = p . width ; } q [ 3 ] = q [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , v . getWidth ( ) - n [ 2 ] ) , LengthConstraintType . RANGE , q [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D w = this . rightBlock . arrange ( z , t ) ; n [ 3 ] = w . width ; } q [ 4 ] = q [ 2 ] ; n [ 4 ] = v . getWidth ( ) - n [ 3 ] - n [ 2 ] ; RectangleConstraint r = new RectangleConstraint ( n [ 4 ] , q [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( z , r ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , n [ 0 ] , q [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , q [ 0 ] + q [ 2 ] , n [ 1 ] , q [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , q [ 0 ] , n [ 2 ] , q [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] + n [ 4 ] , q [ 0 ] , n [ 3 ] , q [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( n [ 2 ] , q [ 0 ] , n [ 4 ] , q [ 4 ] ) ) ; } return new Size2D ( v . getWidth ( ) , v . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D o , RectangleConstraint r ) { double [ ] s = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; s [ 0 ] = r . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D m = this . topBlock . arrange ( o , j ) ; p [ 0 ] = m . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint v = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , r . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D t = this . bottomBlock . arrange ( o , v ) ; p [ 1 ] = t . height ; } p [ 2 ] = r . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D w = this . leftBlock . arrange ( o , q ) ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , r . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . rightBlock . arrange ( o , k ) ; s [ 3 ] = l . width ; } p [ 4 ] = p [ 2 ] ; s [ 4 ] = r . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint u = new RectangleConstraint ( s [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( o , u ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , s [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , s [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , p [ 0 ] , s [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , p [ 0 ] , s [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( r . getWidth ( ) , r . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int d , int b ) { Number z = null ; MeanAndStandardDeviation t = ( MeanAndStandardDeviation ) this . data . getObject ( d , b ) ; if ( t ! = null ) { z = t . getMean ( ) ; } return z ; } protected void drawHorizontalItem ( Graphics2D w , CategoryItemRendererState a , Rectangle2D k , CategoryPlot v , CategoryAxis q , ValueAxis h , StatisticalCategoryDataset s , int y , int f ) { RectangleEdge s = v . getDomainAxisEdge ( ) ; / / BAR Y double a = q . getCategoryStart ( f , getColumnCount ( ) , k , s ) ; int v = getRowCount ( ) ; int b = getColumnCount ( ) ; if ( v > 1 ) { double t = k . getHeight ( ) * getItemMargin ( ) / ( b * ( v - 1 ) ) ; a = a + y * ( a . getBarWidth ( ) + t ) ; } else { a = a + y * a . getBarWidth ( ) ; } / / BAR X Number n = s . getMeanValue ( y , f ) ; double e = n . doubleValue ( ) ; double l = 0 . 0 ; double w = getLowerClip ( ) ; double o = getUpperClip ( ) ; if ( o < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( e > = o ) { return ; / / bar is not visible } l = o ; if ( e < = w ) { e = w ; } } else if ( w < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( e > = o ) { e = o ; } else { if ( e < = w ) { e = w ; } } } else { / / cases 9 , 10 , 11 and 12 if ( e < = w ) { return ; / / bar is not visible } l = getLowerClip ( ) ; if ( e > = o ) { e = o ; } } RectangleEdge c = v . getRangeAxisEdge ( ) ; double y = h . valueToJava2D ( l , k , c ) ; double m = h . valueToJava2D ( e , k , c ) ; double u = Math . min ( m , y ) ;  double r = a . getBarWidth ( ) ; double x = Math . abs ( m - y ) ;  Rectangle2D j = new Rectangle2D . Double ( u , a , x , r ) ; Paint g = getItemPaint ( y , f ) ; w . setPaint ( g ) ; w . fill ( j ) ; if ( isDrawBarOutline ( ) & & a . getBarWidth ( ) > 3 ) { w . setStroke ( getItemStroke ( y , f ) ) ; w . setPaint ( getItemOutlinePaint ( y , f ) ) ; w . draw ( j ) ; } / / standard deviation lines double x = s . getStdDevValue ( y , f ) . doubleValue ( ) ; double i = h . valueToJava2D ( n . doubleValue ( ) + x , k , c ) ; double p = h . valueToJava2D ( n . doubleValue ( ) - x , k , c ) ; if ( this . errorIndicatorStroke ! = null ) { w . setStroke ( this . errorIndicatorStroke ) ; } else { w . setStroke ( getItemOutlineStroke ( y , f ) ) ; } if ( this . errorIndicatorPaint ! = null ) { w . setPaint ( this . errorIndicatorPaint ) ; } else { w . setPaint ( getItemOutlinePaint ( y , f ) ) ; } Line2D r = null ; r = new Line2D . Double ( p , a + r / 2 . 0d , i , a + r / 2 . 0d ) ; w . draw ( r ) ; r = new Line2D . Double ( i , a + r * 0 . 25 , i , a + r * 0 . 75 ) ; w . draw ( r ) ; r = new Line2D . Double ( p , a + r * 0 . 25 , p , a + r * 0 . 75 ) ; w . draw ( r ) ;  CategoryItemLabelGenerator z = getItemLabelGenerator ( y , f ) ; if ( z ! = null & & isItemLabelVisible ( y , f ) ) { drawItemLabel ( w , s , y , f , v , z , j , ( e < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection u = a . getEntityCollection ( ) ; if ( u ! = null ) { addItemEntity ( u , s , y , f , j ) ; } }", "text_2": "public class test { public Number getMeanValue ( int j , int l ) { Number t = null ; MeanAndStandardDeviation e = ( MeanAndStandardDeviation ) this . data . getObject ( j , l ) ; return t ; } protected void drawHorizontalItem ( Graphics2D w , CategoryItemRendererState q , Rectangle2D i , CategoryPlot b , CategoryAxis s , ValueAxis h , StatisticalCategoryDataset s , int z , int f ) { RectangleEdge u = b . getDomainAxisEdge ( ) ; / / BAR Y double a = s . getCategoryStart ( f , getColumnCount ( ) , i , u ) ; int k = getRowCount ( ) ; int d = getColumnCount ( ) ; if ( k > 1 ) { double y = i . getHeight ( ) * getItemMargin ( ) / ( d * ( k - 1 ) ) ; a = a + z * ( q . getBarWidth ( ) + y ) ; } else { RectangleEdge p = b . getRangeAxisEdge ( ) ; a = a + z * q . getBarWidth ( ) ; } / / BAR X Number n = s . getMeanValue ( z , f ) ; double v = n . doubleValue ( ) ; double b = 0 . 0 ; double m = getLowerClip ( ) ; double r = getUpperClip ( ) ; if ( r < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( v > = r ) { return ; / / bar is not visible } b = r ; if ( v < = m ) { v = m ; } } else if ( m < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( v > = r ) { v = r ; } else { if ( v < = m ) { v = m ; } } } else { / / cases 9 , 10 , 11 and 12 if ( v < = m ) { return ; / / bar is not visible } b = getLowerClip ( ) ; if ( v > = r ) { v = r ; } } RectangleEdge x = b . getRangeAxisEdge ( ) ; double t = h . valueToJava2D ( b , i , x ) ; double w = h . valueToJava2D ( v , i , x ) ; double g = Math . min ( w , t ) ;  double o = q . getBarWidth ( ) ; double c = Math . abs ( w - t ) ;  Rectangle2D z = new Rectangle2D . Double ( g , a , c , o ) ; Paint y = getItemPaint ( z , f ) ; w . setPaint ( y ) ; w . fill ( z ) ; if ( isDrawBarOutline ( ) & & q . getBarWidth ( ) > 3 ) { w . setStroke ( getItemStroke ( z , f ) ) ; w . setPaint ( getItemOutlinePaint ( z , f ) ) ; w . draw ( z ) ; } / / standard deviation lines double c = s . getStdDevValue ( z , f ) . doubleValue ( ) ; double a = h . valueToJava2D ( n . doubleValue ( ) + c , i , x ) ; double u = h . valueToJava2D ( n . doubleValue ( ) - c , i , x ) ; if ( this . errorIndicatorStroke ! = null ) { w . setStroke ( this . errorIndicatorStroke ) ; } else { w . setStroke ( getItemOutlineStroke ( z , f ) ) ; } if ( this . errorIndicatorPaint ! = null ) { w . setPaint ( this . errorIndicatorPaint ) ; } else { w . setPaint ( getItemOutlinePaint ( z , f ) ) ; } Line2D x = null ; x = new Line2D . Double ( u , a + o / 2 . 0d , a , a + o / 2 . 0d ) ; w . draw ( x ) ; x = new Line2D . Double ( a , a + o * 0 . 25 , a , a + o * 0 . 75 ) ; w . draw ( x ) ; x = new Line2D . Double ( u , a + o * 0 . 25 , u , a + o * 0 . 75 ) ; w . draw ( x ) ;  CategoryItemLabelGenerator v = getItemLabelGenerator ( z , f ) ; if ( v ! = null & & isItemLabelVisible ( z , f ) ) { drawItemLabel ( w , s , z , f , b , v , z , ( v < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection r = q . getEntityCollection ( ) ; if ( r ! = null ) { addItemEntity ( r , s , z , f , z ) ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer g , Graphics2D m , RectangleConstraint c ) { double [ ] j = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; j [ 0 ] = c . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D f = this . topBlock . arrange ( m , d ) ; o [ 0 ] = f . height ; } j [ 1 ] = j [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D e = this . bottomBlock . arrange ( m , k ) ; o [ 1 ] = e . height ; } o [ 2 ] = c . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D h = this . leftBlock . arrange ( m , l ) ; j [ 2 ] = h . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) - j [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D n = this . rightBlock . arrange ( m , b ) ; j [ 3 ] = n . width ; } o [ 4 ] = o [ 2 ] ; j [ 4 ] = c . getWidth ( ) - j [ 3 ] - j [ 2 ] ; RectangleConstraint i = new RectangleConstraint ( j [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( m , i ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , j [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , j [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , j [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] + j [ 4 ] , o [ 0 ] , j [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] , o [ 0 ] , j [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( c . getWidth ( ) , c . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer u , Graphics2D s , RectangleConstraint b ) { double [ ] w = new double [ 5 ] ; double [ ] x = new double [ 5 ] ; w [ 0 ] = b . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , b . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D f = this . topBlock . arrange ( s , e ) ; x [ 0 ] = f . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , b . getHeight ( ) - x [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D c = this . bottomBlock . arrange ( s , d ) ; x [ 1 ] = c . height ; } x [ 2 ] = b . getHeight ( ) - x [ 1 ] - x [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , b . getWidth ( ) ) , LengthConstraintType . RANGE , x [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D t = this . leftBlock . arrange ( s , a ) ; w [ 1 ] = w [ 0 ] ; } x [ 3 ] = x [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , b . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , x [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . rightBlock . arrange ( s , y ) ; w [ 3 ] = v . width ; } x [ 4 ] = x [ 2 ] ; w [ 4 ] = b . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint z = new RectangleConstraint ( w [ 4 ] , x [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( s , z ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , x [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , x [ 0 ] + x [ 2 ] , w [ 1 ] , x [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , x [ 0 ] , w [ 2 ] , x [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , x [ 0 ] , w [ 3 ] , x [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , x [ 0 ] , w [ 4 ] , x [ 4 ] ) ) ; } return new Size2D ( b . getWidth ( ) , b . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset p ) { super ( ) ; this . dataset = p ; PiePlot q = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( q ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle r = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; r . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( r ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset z ) { super ( ) ; this . dataset = z ; PiePlot y = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( y ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( z ! = null ) { setDatasetGroup ( z . getGroup ( ) ) ; z . addChangeListener ( this ) ; } this . pieChart . setBackgroundPaint ( null ) ; TextTitle a = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; a . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( a ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D m , Rectangle2D n , Point2D z , PlotState i , PlotRenderingInfo u ) { / / adjust for insets . . . RectangleInsets x = getInsets ( ) ; x . trim ( n ) ; Rectangle2D c = ( Rectangle2D ) n . clone ( ) ; if ( u ! = null ) { u . setPlotArea ( n ) ; u . setDataArea ( n ) ; } drawBackground ( m , n ) ; Shape h = m . getClip ( ) ; m . clip ( n ) ; / / adjust the plot area by the interior spacing value double l = getInteriorGap ( ) ; double w = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { w = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double a = n . getWidth ( ) * ( l + w ) * 2 . 0 ; double k = n . getHeight ( ) * l * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double r = n . getWidth ( ) * getInteriorGap ( ) ; double m = n . getHeight ( ) * getInteriorGap ( ) ; double h = n . getX ( ) + r ; double j = n . getMaxX ( ) - r ; double o = n . getY ( ) + m ; double b = n . getMaxY ( ) - m ; m . setPaint ( Color . lightGray ) ; m . draw ( new Rectangle2D . Double ( h , o , j - h , b - o ) ) ; } double b = n . getX ( ) + a / 2 ; double c = n . getY ( ) + k / 2 ; double p = n . getWidth ( ) - a ; double x = n . getHeight ( ) - k ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double i = Math . min ( p , x ) / 2 ; b = ( b + b + p ) / 2 - i ; c = ( c + c + x ) / 2 - i ; p = 2 * i ; x = 2 * i ; } PiePlotState q = initialise ( m , n , this , null , u ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D e = new Rectangle2D . Double ( b , c , p , x * ( 1 - this . depthFactor ) ) ; q . setLinkArea ( e ) ; if ( DEBUG_DRAW_LINK_AREA ) { m . setPaint ( Color . blue ) ; m . draw ( e ) ; m . setPaint ( Color . yellow ) ; m . draw ( new Ellipse2D . Double ( e . getX ( ) , e . getY ( ) , e . getWidth ( ) , e . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double t = p * getLabelLinkMargin ( ) ; double d = x * getLabelLinkMargin ( ) ; Rectangle2D a = new Rectangle2D . Double ( b + t / 2 . 0 , c + d / 2 . 0 , p - t , x - d ) ; q . setExplodedPieArea ( a ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double d = getMaximumExplodePercent ( ) ; double r = d / ( 1 . 0 + d ) ; double z = a . getWidth ( ) * r ; double n = a . getHeight ( ) * r ; Rectangle2D i = new Rectangle2D . Double ( a . getX ( ) + z / 2 . 0 , a . getY ( ) + n / 2 . 0 , a . getWidth ( ) - z , a . getHeight ( ) - n ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int n = ( int ) ( i . getHeight ( ) * this . depthFactor ) ; Rectangle2D m = new Rectangle2D . Double ( b , c , p , x - n ) ; q . setLinkArea ( m ) ; q . setPieArea ( i ) ; q . setPieCenterX ( i . getCenterX ( ) ) ; q . setPieCenterY ( i . getCenterY ( ) - n / 2 . 0 ) ; q . setPieWRadius ( i . getWidth ( ) / 2 . 0 ) ; q . setPieHRadius ( ( i . getHeight ( ) - n ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset f = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( m , n ) ; m . setClip ( h ) ; drawOutline ( m , n ) ; return ; } / / if too any elements if ( f . getKeys ( ) . size ( ) > n . getWidth ( ) ) { String y = \" Too many elements \" ; Font c = new Font ( \" dialog \" , Font . BOLD , 10 ) ; m . setFont ( c ) ; FontMetrics s = m . getFontMetrics ( c ) ; int s = s . stringWidth ( y ) ;  m . drawString ( y , ( int ) ( n . getX ( ) + ( n . getWidth ( ) - s ) / 2 ) , ( int ) ( n . getY ( ) + ( n . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double z = Math . min ( n . getWidth ( ) , n . getHeight ( ) ) / 2 ; n = new Rectangle2D . Double ( n . getCenterX ( ) - z , n . getCenterY ( ) - z , 2 * z , 2 * z ) ; } / / get a list of keys . . . List e = f . getKeys ( ) ; if ( e . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double f = i . getX ( ) ; double y = i . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite g = m . getComposite ( ) ; m . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double h = DatasetUtilities . calculatePieDatasetTotal ( f ) ; double t = 0 ; if ( n < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList s = new ArrayList ( ) ; Arc2D . Double m ; Paint y ; Paint o ; Stroke w ; Iterator d = e . iterator ( ) ; while ( d . hasNext ( ) ) { Comparable u = ( Comparable ) d . next ( ) ; Number l = f . getValue ( u ) ; if ( l = = null ) { s . add ( null ) ; continue ; } double u = l . doubleValue ( ) ; if ( u < = 0 ) { s . add ( null ) ; continue ; } double p = getStartAngle ( ) ; double d = getDirection ( ) . getFactor ( ) ; double v = p + ( d * ( t * 360 ) ) / h ; double k = p + ( d * ( t + u ) * 360 ) / h ; if ( Math . abs ( k - v ) > getMinimumArcAngleToDraw ( ) ) { s . add ( new Arc2D . Double ( f , y + n , i . getWidth ( ) , i . getHeight ( ) - n , v , k - v , Arc2D . PIE ) ) ; } else { s . add ( null ) ; } t + = u ; } Shape a = m . getClip ( ) ; Ellipse2D a = new Ellipse2D . Double ( i . getX ( ) , i . getY ( ) , i . getWidth ( ) , i . getHeight ( ) - n ) ; Ellipse2D v = new Ellipse2D . Double ( i . getX ( ) , i . getY ( ) + n , i . getWidth ( ) , i . getHeight ( ) - n ) ; Rectangle2D f = new Rectangle2D . Double ( a . getX ( ) , a . getCenterY ( ) , i . getWidth ( ) , v . getMaxY ( ) - a . getCenterY ( ) ) ; Rectangle2D n = new Rectangle2D . Double ( i . getX ( ) , a . getY ( ) , i . getWidth ( ) , v . getCenterY ( ) - a . getY ( ) ) ; Area g = new Area ( a ) ; g . add ( new Area ( f ) ) ; Area p = new Area ( v ) ; p . add ( new Area ( n ) ) ; Area b = new Area ( g ) ; b . intersect ( p ) ; Area q = new Area ( b ) ; q . subtract ( new Area ( a ) ) ; Area e = new Area ( b ) ; e . subtract ( new Area ( v ) ) ; / / draw the bottom circle int [ ] x ; int [ ] c ; m = new Arc2D . Double ( f , y + n , i . getWidth ( ) , i . getHeight ( ) - n , 0 , 360 , Arc2D . PIE ) ;  int w = s . size ( ) ; for ( int q = 0 ; q < w ; q + + ) { m = ( Arc2D . Double ) s . get ( q ) ; if ( m = = null ) { continue ; } Comparable i = getSectionKey ( q ) ; y = lookupSectionPaint ( i , true ) ; o = lookupSectionOutlinePaint ( i ) ; w = lookupSectionOutlineStroke ( i ) ; m . setPaint ( y ) ; m . fill ( m ) ; m . setPaint ( o ) ; m . setStroke ( w ) ; m . draw ( m ) ; m . setPaint ( y ) ;  Point2D k = m . getStartPoint ( ) ; / / draw the height x = new int [ ] { ( int ) m . getCenterX ( ) , ( int ) m . getCenterX ( ) , ( int ) k . getX ( ) , ( int ) k . getX ( ) } ; c = new int [ ] { ( int ) m . getCenterY ( ) , ( int ) m . getCenterY ( ) - n , ( int ) k . getY ( ) - n , ( int ) k . getY ( ) } ; Polygon j = new Polygon ( x , c , 4 ) ; m . setPaint ( java . awt . Color . lightGray ) ; m . fill ( j ) ; m . setPaint ( o ) ; m . setStroke ( w ) ; m . draw ( j ) ; m . setPaint ( y ) ; } m . setPaint ( Color . gray ) ; m . fill ( e ) ; m . fill ( q ) ; / / cycle through once drawing only the sides at the back . . . int f = 0 ; d = s . iterator ( ) ; while ( d . hasNext ( ) ) { Arc2D l = ( Arc2D ) d . next ( ) ; if ( l ! = null ) { Comparable o = getSectionKey ( f ) ; y = lookupSectionPaint ( o , true ) ; o = lookupSectionOutlinePaint ( o ) ; w = lookupSectionOutlineStroke ( o ) ; drawSide ( m , i , l , q , e , y , o , w , false , true ) ; } f + + ; } / / cycle through again drawing only the sides at the front . . . f = 0 ; d = s . iterator ( ) ; while ( d . hasNext ( ) ) { Arc2D v = ( Arc2D ) d . next ( ) ; if ( v ! = null ) { Comparable h = getSectionKey ( f ) ; y = lookupSectionPaint ( h ) ; o = lookupSectionOutlinePaint ( h ) ; w = lookupSectionOutlineStroke ( h ) ; drawSide ( m , i , v , q , e , y , o , w , true , false ) ; } f + + ; } m . setClip ( a ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D g ; for ( int b = 0 ; b < w ; b + + ) { m = ( Arc2D . Double ) s . get ( b ) ; if ( m = = null ) { continue ; } g = new Arc2D . Double ( f , y , i . getWidth ( ) , i . getHeight ( ) - n , m . getAngleStart ( ) , m . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable l = ( Comparable ) e . get ( b ) ; y = lookupSectionPaint ( l , true ) ; o = lookupSectionOutlinePaint ( l ) ; w = lookupSectionOutlineStroke ( l ) ; m . setPaint ( y ) ; m . fill ( g ) ; m . setStroke ( w ) ; m . setPaint ( o ) ; m . draw ( g ) ; / / add a tooltip for the section . . . if ( u ! = null ) { EntityCollection t = u . getOwner ( ) . getEntityCollection ( ) ; if ( t ! = null ) { String j = null ; PieToolTipGenerator r = getToolTipGenerator ( ) ; if ( r ! = null ) { / / @ mgs : using the method ' s return value was missing j = r . generateToolTip ( f , l ) ; } String k = null ; if ( getURLGenerator ( ) ! = null ) { k = getURLGenerator ( ) . generateURL ( f , l , getPieIndex ( ) ) ; } PieSectionEntity e = new PieSectionEntity ( g , f , getPieIndex ( ) , b , l , j , k ) ; t . add ( e ) ; } } List j = f . getKeys ( ) ; Rectangle2D g = new Rectangle2D . Double ( c . getX ( ) , c . getY ( ) , c . getWidth ( ) , c . getHeight ( ) - n ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( m , j , h , g , m , q ) ; } else { drawLabels ( m , j , h , g , m , q ) ; } } m . setClip ( h ) ; m . setComposite ( g ) ; drawOutline ( m , c ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D e , Rectangle2D d , Point2D x , PlotState n , PlotRenderingInfo k ) { / / adjust for insets . . . RectangleInsets e = getInsets ( ) ; e . trim ( d ) ; Rectangle2D y = ( Rectangle2D ) d . clone ( ) ; if ( k ! = null ) { k . setPlotArea ( d ) ; k . setDataArea ( d ) ; } drawBackground ( e , d ) ; Shape i = e . getClip ( ) ; e . clip ( d ) ; / / adjust the plot area by the interior spacing value double m = getInteriorGap ( ) ; double v = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { v = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double f = d . getWidth ( ) * ( m + v ) * 2 . 0 ; double f = d . getHeight ( ) * m * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double w = d . getWidth ( ) * getInteriorGap ( ) ; double c = d . getHeight ( ) * getInteriorGap ( ) ; double q = d . getX ( ) + w ; double j = d . getMaxX ( ) - w ; double a = d . getY ( ) + c ; double j = d . getMaxY ( ) - c ; e . setPaint ( Color . lightGray ) ; e . draw ( new Rectangle2D . Double ( q , a , j - q , j - a ) ) ; } double a = d . getX ( ) + f / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( e , d ) ; e . setClip ( i ) ; drawOutline ( e , d ) ; return ; } double o = d . getY ( ) + f / 2 ; double x = d . getWidth ( ) - f ; double r = d . getHeight ( ) - f ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double b = Math . min ( x , r ) / 2 ; a = ( a + a + x ) / 2 - b ; o = ( o + o + r ) / 2 - b ; x = 2 * b ; r = 2 * b ; } PiePlotState v = initialise ( e , d , this , null , k ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D g = new Rectangle2D . Double ( a , o , x , r * ( 1 - this . depthFactor ) ) ; v . setLinkArea ( g ) ; if ( DEBUG_DRAW_LINK_AREA ) { e . setPaint ( Color . blue ) ; e . draw ( g ) ; e . setPaint ( Color . yellow ) ; e . draw ( new Ellipse2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , g . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double m = x * getLabelLinkMargin ( ) ; double t = r * getLabelLinkMargin ( ) ; Rectangle2D n = new Rectangle2D . Double ( a + m / 2 . 0 , o + t / 2 . 0 , x - m , r - t ) ; v . setExplodedPieArea ( n ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double j = getMaximumExplodePercent ( ) ; double k = j / ( 1 . 0 + j ) ; double o = n . getWidth ( ) * k ; double s = n . getHeight ( ) * k ; Rectangle2D h = new Rectangle2D . Double ( n . getX ( ) + o / 2 . 0 , n . getY ( ) + s / 2 . 0 , n . getWidth ( ) - o , n . getHeight ( ) - s ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int w = ( int ) ( h . getHeight ( ) * this . depthFactor ) ; Rectangle2D l = new Rectangle2D . Double ( a , o , x , r - w ) ; v . setLinkArea ( l ) ; v . setPieArea ( h ) ; v . setPieCenterX ( h . getCenterX ( ) ) ; v . setPieCenterY ( h . getCenterY ( ) - w / 2 . 0 ) ; v . setPieWRadius ( h . getWidth ( ) / 2 . 0 ) ; v . setPieHRadius ( ( h . getHeight ( ) - w ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset c = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( e , d ) ; e . setClip ( i ) ; drawOutline ( e , d ) ; return ; } / / if too any elements if ( c . getKeys ( ) . size ( ) > d . getWidth ( ) ) { String o = \" Too many elements \" ; Font m = new Font ( \" dialog \" , Font . BOLD , 10 ) ; e . setFont ( m ) ; FontMetrics x = e . getFontMetrics ( m ) ; int d = x . stringWidth ( o ) ;  e . drawString ( o , ( int ) ( d . getX ( ) + ( d . getWidth ( ) - d ) / 2 ) , ( int ) ( d . getY ( ) + ( d . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double p = Math . min ( d . getWidth ( ) , d . getHeight ( ) ) / 2 ; d = new Rectangle2D . Double ( d . getCenterX ( ) - p , d . getCenterY ( ) - p , 2 * p , 2 * p ) ; } / / get a list of keys . . . List r = c . getKeys ( ) ; if ( r . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double c = h . getX ( ) ; double y = h . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite h = e . getComposite ( ) ; e . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double v = DatasetUtilities . calculatePieDatasetTotal ( c ) ; double s = 0 ; if ( w < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList q = new ArrayList ( ) ; Arc2D . Double f ; Paint a ; Paint r ; Stroke y ; Iterator t = r . iterator ( ) ; while ( t . hasNext ( ) ) { Comparable e = ( Comparable ) t . next ( ) ; Number k = c . getValue ( e ) ; if ( k = = null ) { q . add ( null ) ; continue ; } double g = k . doubleValue ( ) ; if ( g < = 0 ) { q . add ( null ) ; continue ; } double j = getStartAngle ( ) ; double a = getDirection ( ) . getFactor ( ) ; double h = j + ( a * ( s * 360 ) ) / v ; double b = j + ( a * ( s + g ) * 360 ) / v ; if ( Math . abs ( b - h ) > getMinimumArcAngleToDraw ( ) ) { q . add ( new Arc2D . Double ( c , y + w , h . getWidth ( ) , h . getHeight ( ) - w , h , b - h , Arc2D . PIE ) ) ; } else { q . add ( null ) ; } s + = g ; } Shape m = e . getClip ( ) ; Ellipse2D c = new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) , h . getWidth ( ) , h . getHeight ( ) - w ) ; Ellipse2D g = new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) + w , h . getWidth ( ) , h . getHeight ( ) - w ) ; Rectangle2D d = new Rectangle2D . Double ( c . getX ( ) , c . getCenterY ( ) , h . getWidth ( ) , g . getMaxY ( ) - c . getCenterY ( ) ) ; Rectangle2D e = new Rectangle2D . Double ( h . getX ( ) , c . getY ( ) , h . getWidth ( ) , g . getCenterY ( ) - c . getY ( ) ) ; Area f = new Area ( c ) ; f . add ( new Area ( d ) ) ; Area d = new Area ( g ) ; d . add ( new Area ( e ) ) ; Area b = new Area ( f ) ; b . intersect ( d ) ; Area p = new Area ( b ) ; p . subtract ( new Area ( c ) ) ; Area u = new Area ( b ) ; u . subtract ( new Area ( g ) ) ; / / draw the bottom circle int [ ] l ; int [ ] z ; f = new Arc2D . Double ( c , y + w , h . getWidth ( ) , h . getHeight ( ) - w , 0 , 360 , Arc2D . PIE ) ;  int p = q . size ( ) ; for ( int i = 0 ; i < p ; i + + ) { f = ( Arc2D . Double ) q . get ( i ) ; if ( f = = null ) { continue ; } Comparable s = getSectionKey ( i ) ; a = lookupSectionPaint ( s , true ) ; r = lookupSectionOutlinePaint ( s ) ; y = lookupSectionOutlineStroke ( s ) ; e . setPaint ( a ) ; e . fill ( f ) ; e . setPaint ( r ) ; e . setStroke ( y ) ; e . draw ( f ) ; e . setPaint ( a ) ;  Point2D w = f . getStartPoint ( ) ; / / draw the height l = new int [ ] { ( int ) f . getCenterX ( ) , ( int ) f . getCenterX ( ) , ( int ) w . getX ( ) , ( int ) w . getX ( ) } ; z = new int [ ] { ( int ) f . getCenterY ( ) , ( int ) f . getCenterY ( ) - w , ( int ) w . getY ( ) - w , ( int ) w . getY ( ) } ; Polygon u = new Polygon ( l , z , 4 ) ; e . setPaint ( java . awt . Color . lightGray ) ; e . fill ( u ) ; e . setPaint ( r ) ; e . setStroke ( y ) ; e . draw ( u ) ; e . setPaint ( a ) ; } e . setPaint ( Color . gray ) ; e . fill ( u ) ; e . fill ( p ) ; / / cycle through once drawing only the sides at the back . . . int n = 0 ; t = q . iterator ( ) ; while ( t . hasNext ( ) ) { Arc2D q = ( Arc2D ) t . next ( ) ; if ( q ! = null ) { Comparable b = getSectionKey ( n ) ; a = lookupSectionPaint ( b , true ) ; r = lookupSectionOutlinePaint ( b ) ; y = lookupSectionOutlineStroke ( b ) ; drawSide ( e , h , q , p , u , a , r , y , false , true ) ; } n + + ; } / / cycle through again drawing only the sides at the front . . . n = 0 ; t = q . iterator ( ) ; while ( t . hasNext ( ) ) { Arc2D i = ( Arc2D ) t . next ( ) ; if ( i ! = null ) { Comparable n = getSectionKey ( n ) ; a = lookupSectionPaint ( n ) ; r = lookupSectionOutlinePaint ( n ) ; y = lookupSectionOutlineStroke ( n ) ; drawSide ( e , h , i , p , u , a , r , y , true , false ) ; } n + + ; } e . setClip ( m ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D h ; for ( int z = 0 ; z < p ; z + + ) { f = ( Arc2D . Double ) q . get ( z ) ; if ( f = = null ) { continue ; } h = new Arc2D . Double ( c , y , h . getWidth ( ) , h . getHeight ( ) - w , f . getAngleStart ( ) , f . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable t = ( Comparable ) r . get ( z ) ; a = lookupSectionPaint ( t , true ) ; r = lookupSectionOutlinePaint ( t ) ; y = lookupSectionOutlineStroke ( t ) ; e . setPaint ( a ) ; e . fill ( h ) ; e . setStroke ( y ) ; e . setPaint ( r ) ; e . draw ( h ) ; / / add a tooltip for the section . . . if ( k ! = null ) { EntityCollection l = k . getOwner ( ) . getEntityCollection ( ) ; if ( l ! = null ) { String g = null ; PieToolTipGenerator z = getToolTipGenerator ( ) ; if ( z ! = null ) { / / @ mgs : using the method ' s return value was missing g = z . generateToolTip ( c , t ) ; } String k = null ; if ( getURLGenerator ( ) ! = null ) { k = getURLGenerator ( ) . generateURL ( c , t , getPieIndex ( ) ) ; } PieSectionEntity l = new PieSectionEntity ( h , c , getPieIndex ( ) , z , t , g , k ) ; l . add ( l ) ; } } List i = c . getKeys ( ) ; Rectangle2D u = new Rectangle2D . Double ( y . getX ( ) , y . getY ( ) , y . getWidth ( ) , y . getHeight ( ) - w ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( e , i , v , u , l , v ) ; } else { drawLabels ( e , i , v , u , l , v ) ; } } e . setClip ( i ) ; e . setComposite ( h ) ; drawOutline ( e , y ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFN ( BlockContainer w , Graphics2D r , double t ) { double [ ] t = new double [ 5 ] ; double [ ] y = new double [ 5 ] ; RectangleConstraint f = new RectangleConstraint ( t , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D a = this . topBlock . arrange ( r , f ) ; t [ 0 ] = a . width ; y [ 0 ] = a . height ; } if ( this . bottomBlock ! = null ) { Size2D k = this . bottomBlock . arrange ( r , f ) ; t [ 1 ] = k . width ; y [ 1 ] = k . height ; } RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , t ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D s = this . leftBlock . arrange ( r , b ) ; t [ 2 ] = s . width ; y [ 2 ] = s . height ; } if ( this . rightBlock ! = null ) { double q = Math . max ( t - t [ 2 ] , 0 . 0 ) ; RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( t [ 2 ] , q ) , q ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D u = this . rightBlock . arrange ( r , l ) ; t [ 3 ] = u . width ; y [ 3 ] = u . height ; } y [ 2 ] = Math . max ( y [ 2 ] , y [ 3 ] ) ; y [ 3 ] = y [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( t - t [ 2 ] - t [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D c = this . centerBlock . arrange ( r , h ) ; t [ 4 ] = c . width ; y [ 4 ] = c . height ; } double n = y [ 0 ] + y [ 1 ] + Math . max ( y [ 2 ] , Math . max ( y [ 3 ] , y [ 4 ] ) ) ; return arrange ( w , r , new RectangleConstraint ( t , n ) ) ; } protected Size2D arrangeFF ( BlockContainer q , Graphics2D j , RectangleConstraint o ) { double [ ] d = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; d [ 0 ] = o . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D v = this . topBlock . arrange ( j , x ) ; p [ 0 ] = v . height ; } d [ 1 ] = d [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D r = this . bottomBlock . arrange ( j , z ) ; p [ 1 ] = r . height ; } p [ 2 ] = o . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D g = this . leftBlock . arrange ( j , m ) ; d [ 2 ] = g . width ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) - d [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . rightBlock . arrange ( j , s ) ; d [ 3 ] = e . width ; } p [ 4 ] = p [ 2 ] ; d [ 4 ] = o . getWidth ( ) - d [ 3 ] - d [ 2 ] ; RectangleConstraint i = new RectangleConstraint ( d [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( j , i ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , d [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , d [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , d [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] + d [ 4 ] , p [ 0 ] , d [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] , p [ 0 ] , d [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( o . getWidth ( ) , o . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFN ( BlockContainer w , Graphics2D n , double e ) { double [ ] v = new double [ 5 ] ; double [ ] v = new double [ 5 ] ; RectangleConstraint l = new RectangleConstraint ( e , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D z = this . topBlock . arrange ( n , l ) ; v [ 0 ] = z . width ; v [ 0 ] = z . height ; } if ( this . bottomBlock ! = null ) { Size2D a = this . bottomBlock . arrange ( n , l ) ; v [ 1 ] = a . width ; v [ 1 ] = a . height ; } RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , e ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D f = this . leftBlock . arrange ( n , m ) ; v [ 2 ] = f . width ; this . topBlock = null ; v [ 2 ] = f . height ; } if ( this . rightBlock ! = null ) { double r = Math . max ( e - v [ 2 ] , 0 . 0 ) ; RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( v [ 2 ] , r ) , r ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D i = this . rightBlock . arrange ( n , o ) ; v [ 3 ] = i . width ; v [ 3 ] = i . height ; } v [ 2 ] = Math . max ( v [ 2 ] , v [ 3 ] ) ; v [ 3 ] = v [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( e - v [ 2 ] - v [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D g = this . centerBlock . arrange ( n , y ) ; v [ 4 ] = g . width ; v [ 4 ] = g . height ; } double t = v [ 0 ] + v [ 1 ] + Math . max ( v [ 2 ] , Math . max ( v [ 3 ] , v [ 4 ] ) ) ; return arrange ( w , n , new RectangleConstraint ( e , t ) ) ; } protected Size2D arrangeFF ( BlockContainer h , Graphics2D c , RectangleConstraint q ) { double [ ] s = new double [ 5 ] ; double [ ] u = new double [ 5 ] ; s [ 0 ] = q . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D d = this . topBlock . arrange ( c , j ) ; u [ 0 ] = d . height ; } s [ 1 ] = s [ 0 ] ; Size2D x = arrangeNN ( h , c ) ; this . rightBlock = null ; u [ 2 ] = q . getHeight ( ) - u [ 1 ] - u [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( c , k ) ; s [ 2 ] = b . width ; } u [ 3 ] = u [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , u [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . rightBlock . arrange ( c , t ) ; s [ 3 ] = u . width ; } u [ 4 ] = u [ 2 ] ; s [ 4 ] = q . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint p = new RectangleConstraint ( s [ 4 ] , u [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( c , p ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , u [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] + u [ 2 ] , s [ 1 ] , u [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , u [ 0 ] , s [ 2 ] , u [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , u [ 0 ] , s [ 3 ] , u [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , u [ 0 ] , s [ 4 ] , u [ 4 ] ) ) ; } return new Size2D ( q . getWidth ( ) , q . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number s , Number t ) { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem v = null ; int u = indexOf ( s ) ; if ( u > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem r = ( XYDataItem ) this . data . get ( u ) ; try { v = ( XYDataItem ) r . clone ( ) ; } catch ( CloneNotSupportedException w ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } r . setY ( t ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - u - 1 , new XYDataItem ( s , t ) ) ; } else { this . data . add ( new XYDataItem ( s , t ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return v ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number d , Number z ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem y = null ; int c = indexOf ( d ) ; if ( c > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem a = ( XYDataItem ) this . data . get ( c ) ; try { y = ( XYDataItem ) a . clone ( ) ; } catch ( CloneNotSupportedException b ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } a . setY ( z ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( d , z ) ) ; } else { this . data . add ( new XYDataItem ( d , z ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return y ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int n , int m ) { Number k = null ; MeanAndStandardDeviation l = ( MeanAndStandardDeviation ) this . data . getObject ( n , m ) ; if ( l ! = null ) { k = l . getMean ( ) ; } return k ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int k , int j ) { Number m = null ; MeanAndStandardDeviation l = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , j ) ; if ( l ! = null ) { m = l . getMean ( ) ; } return m ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D n , CategoryItemRendererState l , Rectangle2D e , CategoryPlot h , CategoryAxis m , ValueAxis o , CategoryDataset j , int f , int g , int k ) { / / defensive check if ( ! ( j instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset p = ( StatisticalCategoryDataset ) j ; PlotOrientation i = h . getOrientation ( ) ; if ( i = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( n , l , e , h , m , o , p , f , g ) ; } else if ( i = = PlotOrientation . VERTICAL ) { drawVerticalItem ( n , l , e , h , m , o , p , f , g ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D t , CategoryItemRendererState p , Rectangle2D l , CategoryPlot j , CategoryAxis n , ValueAxis k , CategoryDataset m , int o , int u , int r ) { / / defensive check if ( ! ( m instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset s = ( StatisticalCategoryDataset ) m ;  PlotOrientation q = j . getOrientation ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem d , boolean b ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } d = ( TimeSeriesDataItem ) d . clone ( ) ; Class z = d . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = z ; } else if ( ! this . timePeriodClass . equals ( z ) ) { StringBuffer e = new StringBuffer ( ) ; e . append ( \" You are trying to add data where the time period class \" ) ; e . append ( \" is \" ) ; e . append ( d . getPeriod ( ) . getClass ( ) . getName ( ) ) ; e . append ( \" , but the TimeSeries is expecting an instance of \" ) ; e . append ( this . timePeriodClass . getName ( ) ) ; e . append ( \" . \" ) ; throw new SeriesException ( e . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean x = false ; int a = getItemCount ( ) ; if ( a = = 0 ) { this . data . add ( d ) ; x = true ; } else { RegularTimePeriod f = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( d . getPeriod ( ) . compareTo ( f ) > 0 ) { this . data . add ( d ) ; x = true ; } else { int g = Collections . binarySearch ( this . data , d ) ; if ( g < 0 ) { this . data . add ( - g - 1 , d ) ; x = true ; } else { StringBuffer y = new StringBuffer ( ) ; y . append ( \" You are attempting to add an observation for \" ) ; y . append ( \" the time period \" ) ; y . append ( d . getPeriod ( ) . toString ( ) ) ; y . append ( \" but the series already contains an observation \" ) ; y . append ( \" for that time period . Duplicates are not \" ) ; y . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( y . toString ( ) ) ; } } } if ( x ) { updateBoundsForAddedItem ( d ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem c = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( c ) ; } removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( b ) { fireSeriesChanged ( ) ; } }", "text_2": "public class test { public void add ( TimeSeriesDataItem v , boolean w ) { updateBoundsForRemovedItem ( v ) ; v = ( TimeSeriesDataItem ) v . clone ( ) ; Class c = v . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer x = new StringBuffer ( ) ; x . append ( \" You are trying to add data where the time period class \" ) ; x . append ( \" is \" ) ; x . append ( v . getPeriod ( ) . getClass ( ) . getName ( ) ) ; x . append ( \" , but the TimeSeries is expecting an instance of \" ) ; x . append ( this . timePeriodClass . getName ( ) ) ; x . append ( \" . \" ) ; throw new SeriesException ( x . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean b = false ; int y = getItemCount ( ) ; if ( y = = 0 ) { this . data . add ( v ) ; b = true ; } else { RegularTimePeriod a = getTimePeriod ( getItemCount ( ) - 1 ) ; if ( v . getPeriod ( ) . compareTo ( a ) > 0 ) { this . data . add ( v ) ; b = true ; } else { int z = Collections . binarySearch ( this . data , v ) ; if ( z < 0 ) { this . data . add ( - z - 1 , v ) ; b = true ; } else { StringBuffer u = new StringBuffer ( ) ; u . append ( \" You are attempting to add an observation for \" ) ; u . append ( \" the time period \" ) ; u . append ( v . getPeriod ( ) . toString ( ) ) ; u . append ( \" but the series already contains an observation \" ) ; u . append ( \" for that time period . Duplicates are not \" ) ; u . append ( \" permitted . Try using the addOrUpdate ( ) method . \" ) ; throw new SeriesException ( u . toString ( ) ) ; } } } if ( b ) { updateBoundsForAddedItem ( v ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { TimeSeriesDataItem t = ( TimeSeriesDataItem ) this . data . remove ( 0 ) ; updateBoundsForRemovedItem ( t ) ; } removeAgedItems ( false ) ; / / remove old items if necessary , but / / don ' t notify anyone , because that / / happens next anyway . . . if ( w ) { fireSeriesChanged ( ) ; } }", "text_3": 0}
{"text_1": "public class test { public void delete ( int d , int e ) { if ( e < d ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int a = 0 ; a < = ( e - d ) ; a + + ) { this . data . remove ( d ) ; } fireSeriesChanged ( ) ; } public TimeSeries createCopy ( int z , int b ) throws CloneNotSupportedException { if ( z < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( b < z ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries x = ( TimeSeries ) super . clone ( ) ; x . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int v = z ; v < = b ; v + + ) { TimeSeriesDataItem y = ( TimeSeriesDataItem ) this . data . get ( v ) ; TimeSeriesDataItem c = ( TimeSeriesDataItem ) y . clone ( ) ; try { x . add ( c ) ; } catch ( SeriesException w ) { w . printStackTrace ( ) ; } } } return x ; } } \\ No newline at end of file", "text_2": "public class test { public void delete ( int y , int z ) { if ( z < y & & ( 0 < y ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int g = 0 ; g < = ( z - y ) ; g + + ) { this . data . remove ( y ) ; } fireSeriesChanged ( ) ; } public TimeSeries createCopy ( int b , int a ) throws CloneNotSupportedException { if ( b < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( a < b & & ( 0 < b ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries e = ( TimeSeries ) super . clone ( ) ; e . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int d = b ; d < = a ; d + + ) { TimeSeriesDataItem c = ( TimeSeriesDataItem ) this . data . get ( d ) ; TimeSeriesDataItem x = ( TimeSeriesDataItem ) c . clone ( ) ; try { e . add ( x ) ; } catch ( SeriesException f ) { f . printStackTrace ( ) ; } } } return e ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer y , Graphics2D g , RectangleConstraint i ) { double [ ] k = new double [ 5 ] ; double [ ] z = new double [ 5 ] ; k [ 0 ] = i . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( k [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D a = this . topBlock . arrange ( g , j ) ; z [ 0 ] = a . height ; } k [ 1 ] = k [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( k [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) - z [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D b = this . bottomBlock . arrange ( g , c ) ; z [ 1 ] = b . height ; } z [ 2 ] = i . getHeight ( ) - z [ 1 ] - z [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D d = this . leftBlock . arrange ( g , f ) ; k [ 2 ] = d . width ; } z [ 3 ] = z [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) - k [ 2 ] ) , LengthConstraintType . RANGE , z [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D x = this . rightBlock . arrange ( g , e ) ; k [ 3 ] = x . width ; } z [ 4 ] = z [ 2 ] ; k [ 4 ] = i . getWidth ( ) - k [ 3 ] - k [ 2 ] ; RectangleConstraint h = new RectangleConstraint ( k [ 4 ] , z [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g , h ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , k [ 0 ] , z [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] + z [ 2 ] , k [ 1 ] , z [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , z [ 0 ] , k [ 2 ] , z [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( k [ 2 ] + k [ 4 ] , z [ 0 ] , k [ 3 ] , z [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( k [ 2 ] , z [ 0 ] , k [ 4 ] , z [ 4 ] ) ) ; } return new Size2D ( i . getWidth ( ) , i . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer w , Graphics2D t , RectangleConstraint d ) { double [ ] s = new double [ 5 ] ; double [ ] v = new double [ 5 ] ; s [ 0 ] = d . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D x = this . topBlock . arrange ( t , e ) ; v [ 0 ] = x . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) - v [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D c = this . bottomBlock . arrange ( t , y ) ; v [ 1 ] = c . height ; } v [ 2 ] = d . getHeight ( ) - v [ 1 ] - v [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) ) , LengthConstraintType . RANGE , v [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . leftBlock . arrange ( t , z ) ; s [ 4 ] = r . width ; } v [ 3 ] = v [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , v [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . rightBlock . arrange ( t , b ) ; s [ 3 ] = u . width ; } v [ 4 ] = v [ 2 ] ; s [ 4 ] = d . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint a = new RectangleConstraint ( s [ 4 ] , v [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( t , a ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , v [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , v [ 0 ] + v [ 2 ] , s [ 1 ] , v [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , v [ 0 ] , s [ 2 ] , v [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , v [ 0 ] , s [ 3 ] , v [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , v [ 0 ] , s [ 4 ] , v [ 4 ] ) ) ; } return new Size2D ( d . getWidth ( ) , d . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer i , Graphics2D j , RectangleConstraint f ) { double [ ] o = new double [ 5 ] ; double [ ] n = new double [ 5 ] ; o [ 0 ] = f . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D p = this . topBlock . arrange ( j , r ) ; n [ 0 ] = p . height ; } o [ 1 ] = o [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( o [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , f . getHeight ( ) - n [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D q = this . bottomBlock . arrange ( j , m ) ; n [ 1 ] = q . height ; } n [ 2 ] = f . getHeight ( ) - n [ 1 ] - n [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) ) , LengthConstraintType . RANGE , n [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D h = this . leftBlock . arrange ( j , k ) ; o [ 2 ] = h . width ; } n [ 3 ] = n [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , f . getWidth ( ) - o [ 2 ] ) , LengthConstraintType . RANGE , n [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . rightBlock . arrange ( j , g ) ; o [ 3 ] = l . width ; } n [ 4 ] = n [ 2 ] ; o [ 4 ] = f . getWidth ( ) - o [ 3 ] - o [ 2 ] ; RectangleConstraint s = new RectangleConstraint ( o [ 4 ] , n [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( j , s ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , o [ 0 ] , n [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , n [ 0 ] + n [ 2 ] , o [ 1 ] , n [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , n [ 0 ] , o [ 2 ] , n [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] + o [ 4 ] , n [ 0 ] , o [ 3 ] , n [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( o [ 2 ] , n [ 0 ] , o [ 4 ] , n [ 4 ] ) ) ; } return new Size2D ( f . getWidth ( ) , f . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer g , Graphics2D d , RectangleConstraint z ) { double [ ] e = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; e [ 0 ] = z . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D b = this . topBlock . arrange ( d , a ) ; h [ 0 ] = b . height ; } e [ 1 ] = e [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint v = new RectangleConstraint ( e [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D w = this . bottomBlock . arrange ( d , v ) ; h [ 1 ] = w . height ; } h [ 2 ] = z . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D c = this . leftBlock . arrange ( d , i ) ; if ( ( 2 > = e . length - 1 ) ) { e [ 2 ] = c . width ; } else { e [ 2 + 1 ] = c . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) - e [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . rightBlock . arrange ( d , x ) ; e [ 3 ] = y . width ; } h [ 4 ] = h [ 2 ] ; e [ 4 ] = z . getWidth ( ) - e [ 3 ] - e [ 2 ] ; RectangleConstraint f = new RectangleConstraint ( e [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( d , f ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , e [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , e [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , e [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] + e [ 4 ] , h [ 0 ] , e [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( e [ 2 ] , h [ 0 ] , e [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( z . getWidth ( ) , z . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset y ) { super ( ) ; this . dataset = y ; PiePlot z = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( z ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle x = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; x . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( x ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset r ) { super ( ) ; this . dataset = r ; PiePlot t = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( t ) ; if ( r ! = null ) { r . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle s = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; s . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( s ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D p , Rectangle2D n , Point2D w , PlotState a , PlotRenderingInfo l ) { / / adjust for insets . . . RectangleInsets r = getInsets ( ) ; r . trim ( n ) ; Rectangle2D x = ( Rectangle2D ) n . clone ( ) ; if ( l ! = null ) { l . setPlotArea ( n ) ; l . setDataArea ( n ) ; } drawBackground ( p , n ) ; Shape c = p . getClip ( ) ; p . clip ( n ) ; / / adjust the plot area by the interior spacing value double i = getInteriorGap ( ) ; double w = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { w = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double s = n . getWidth ( ) * ( i + w ) * 2 . 0 ; double s = n . getHeight ( ) * i * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double d = n . getWidth ( ) * getInteriorGap ( ) ; double l = n . getHeight ( ) * getInteriorGap ( ) ; double v = n . getX ( ) + d ; double o = n . getMaxX ( ) - d ; double s = n . getY ( ) + l ; double o = n . getMaxY ( ) - l ; p . setPaint ( Color . lightGray ) ; p . draw ( new Rectangle2D . Double ( v , s , o - v , o - s ) ) ; } double g = n . getX ( ) + s / 2 ; double u = n . getY ( ) + s / 2 ; double x = n . getWidth ( ) - s ; double d = n . getHeight ( ) - s ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double x = Math . min ( x , d ) / 2 ; g = ( g + g + x ) / 2 - x ; u = ( u + u + d ) / 2 - x ; x = 2 * x ; d = 2 * x ; } PiePlotState r = initialise ( p , n , this , null , l ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D h = new Rectangle2D . Double ( g , u , x , d * ( 1 - this . depthFactor ) ) ; r . setLinkArea ( h ) ; if ( DEBUG_DRAW_LINK_AREA ) { p . setPaint ( Color . blue ) ; p . draw ( h ) ; p . setPaint ( Color . yellow ) ; p . draw ( new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) , h . getWidth ( ) , h . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double j = x * getLabelLinkMargin ( ) ; double v = d * getLabelLinkMargin ( ) ; Rectangle2D t = new Rectangle2D . Double ( g + j / 2 . 0 , u + v / 2 . 0 , x - j , d - v ) ; r . setExplodedPieArea ( t ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double f = getMaximumExplodePercent ( ) ; double j = f / ( 1 . 0 + f ) ; double d = t . getWidth ( ) * j ; double k = t . getHeight ( ) * j ; Rectangle2D w = new Rectangle2D . Double ( t . getX ( ) + d / 2 . 0 , t . getY ( ) + k / 2 . 0 , t . getWidth ( ) - d , t . getHeight ( ) - k ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int f = ( int ) ( w . getHeight ( ) * this . depthFactor ) ; Rectangle2D q = new Rectangle2D . Double ( g , u , x , d - f ) ; r . setLinkArea ( q ) ; r . setPieArea ( w ) ; r . setPieCenterX ( w . getCenterX ( ) ) ; r . setPieCenterY ( w . getCenterY ( ) - f / 2 . 0 ) ; r . setPieWRadius ( w . getWidth ( ) / 2 . 0 ) ; r . setPieHRadius ( ( w . getHeight ( ) - f ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset n = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( p , n ) ; p . setClip ( c ) ; drawOutline ( p , n ) ; return ; } / / if too any elements if ( n . getKeys ( ) . size ( ) > n . getWidth ( ) ) { String c = \" Too many elements \" ; Font x = new Font ( \" dialog \" , Font . BOLD , 10 ) ; p . setFont ( x ) ; FontMetrics p = p . getFontMetrics ( x ) ; int y = p . stringWidth ( c ) ;  p . drawString ( c , ( int ) ( n . getX ( ) + ( n . getWidth ( ) - y ) / 2 ) , ( int ) ( n . getY ( ) + ( n . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double r = Math . min ( n . getWidth ( ) , n . getHeight ( ) ) / 2 ; n = new Rectangle2D . Double ( n . getCenterX ( ) - r , n . getCenterY ( ) - r , 2 * r , 2 * r ) ; } / / get a list of keys . . . List k = n . getKeys ( ) ; if ( k . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double u = w . getX ( ) ; double s = w . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite y = p . getComposite ( ) ; p . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double v = DatasetUtilities . calculatePieDatasetTotal ( n ) ; double p = 0 ; if ( f < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList w = new ArrayList ( ) ; Arc2D . Double m ; Paint h ; Paint t ; Stroke p ; Iterator y = k . iterator ( ) ; while ( y . hasNext ( ) ) { Comparable g = ( Comparable ) y . next ( ) ; Number o = n . getValue ( g ) ; if ( o = = null ) { w . add ( null ) ; continue ; } double b = o . doubleValue ( ) ; if ( b < = 0 ) { w . add ( null ) ; continue ; } double i = getStartAngle ( ) ; double b = getDirection ( ) . getFactor ( ) ; double c = i + ( b * ( p * 360 ) ) / v ; double a = i + ( b * ( p + b ) * 360 ) / v ; if ( Math . abs ( a - c ) > getMinimumArcAngleToDraw ( ) ) { w . add ( new Arc2D . Double ( u , s + f , w . getWidth ( ) , w . getHeight ( ) - f , c , a - c , Arc2D . PIE ) ) ; } else { w . add ( null ) ; } p + = b ; } Shape z = p . getClip ( ) ; Ellipse2D q = new Ellipse2D . Double ( w . getX ( ) , w . getY ( ) , w . getWidth ( ) , w . getHeight ( ) - f ) ; Ellipse2D e = new Ellipse2D . Double ( w . getX ( ) , w . getY ( ) + f , w . getWidth ( ) , w . getHeight ( ) - f ) ; Rectangle2D r = new Rectangle2D . Double ( q . getX ( ) , q . getCenterY ( ) , w . getWidth ( ) , e . getMaxY ( ) - q . getCenterY ( ) ) ; Rectangle2D u = new Rectangle2D . Double ( w . getX ( ) , q . getY ( ) , w . getWidth ( ) , e . getCenterY ( ) - q . getY ( ) ) ; Area q = new Area ( q ) ; q . add ( new Area ( r ) ) ; Area m = new Area ( e ) ; m . add ( new Area ( u ) ) ; Area b = new Area ( q ) ; b . intersect ( m ) ; Area k = new Area ( b ) ; k . subtract ( new Area ( q ) ) ; Area o = new Area ( b ) ; o . subtract ( new Area ( e ) ) ; / / draw the bottom circle int [ ] i ; int [ ] h ; m = new Arc2D . Double ( u , s + f , w . getWidth ( ) , w . getHeight ( ) - f , 0 , 360 , Arc2D . PIE ) ;  int z = w . size ( ) ; for ( int z = 0 ; z < z ; z + + ) { m = ( Arc2D . Double ) w . get ( z ) ; if ( m = = null ) { continue ; } Comparable n = getSectionKey ( z ) ; h = lookupSectionPaint ( n , true ) ; t = lookupSectionOutlinePaint ( n ) ; p = lookupSectionOutlineStroke ( n ) ; p . setPaint ( h ) ; p . fill ( m ) ; p . setPaint ( t ) ; p . setStroke ( p ) ; p . draw ( m ) ; p . setPaint ( h ) ;  Point2D l = m . getStartPoint ( ) ; / / draw the height i = new int [ ] { ( int ) m . getCenterX ( ) , ( int ) m . getCenterX ( ) , ( int ) l . getX ( ) , ( int ) l . getX ( ) } ; h = new int [ ] { ( int ) m . getCenterY ( ) , ( int ) m . getCenterY ( ) - f , ( int ) l . getY ( ) - f , ( int ) l . getY ( ) } ; Polygon t = new Polygon ( i , h , 4 ) ; p . setPaint ( java . awt . Color . lightGray ) ; p . fill ( t ) ; p . setPaint ( t ) ; p . setStroke ( p ) ; p . draw ( t ) ; p . setPaint ( h ) ; } p . setPaint ( Color . gray ) ; p . fill ( o ) ; p . fill ( k ) ; / / cycle through once drawing only the sides at the back . . . int a = 0 ; y = w . iterator ( ) ; while ( y . hasNext ( ) ) { Arc2D v = ( Arc2D ) y . next ( ) ; if ( v ! = null ) { Comparable n = getSectionKey ( a ) ; h = lookupSectionPaint ( n , true ) ; t = lookupSectionOutlinePaint ( n ) ; p = lookupSectionOutlineStroke ( n ) ; drawSide ( p , w , v , k , o , h , t , p , false , true ) ; } a + + ; } / / cycle through again drawing only the sides at the front . . . a = 0 ; y = w . iterator ( ) ; while ( y . hasNext ( ) ) { Arc2D a = ( Arc2D ) y . next ( ) ; if ( a ! = null ) { Comparable m = getSectionKey ( a ) ; h = lookupSectionPaint ( m ) ; t = lookupSectionOutlinePaint ( m ) ; p = lookupSectionOutlineStroke ( m ) ; drawSide ( p , w , a , k , o , h , t , p , true , false ) ; } a + + ; } p . setClip ( z ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D f ; for ( int q = 0 ; q < z ; q + + ) { m = ( Arc2D . Double ) w . get ( q ) ; if ( m = = null ) { continue ; } f = new Arc2D . Double ( u , s , w . getWidth ( ) , w . getHeight ( ) - f , m . getAngleStart ( ) , m . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable z = ( Comparable ) k . get ( q ) ; h = lookupSectionPaint ( z , true ) ; t = lookupSectionOutlinePaint ( z ) ; p = lookupSectionOutlineStroke ( z ) ; p . setPaint ( h ) ; p . fill ( f ) ; p . setStroke ( p ) ; p . setPaint ( t ) ; p . draw ( f ) ; / / add a tooltip for the section . . . if ( l ! = null ) { EntityCollection u = l . getOwner ( ) . getEntityCollection ( ) ; if ( u ! = null ) { String e = null ; PieToolTipGenerator e = getToolTipGenerator ( ) ; if ( e ! = null ) { / / @ mgs : using the method ' s return value was missing e = e . generateToolTip ( n , z ) ; } String t = null ; if ( getURLGenerator ( ) ! = null ) { t = getURLGenerator ( ) . generateURL ( n , z , getPieIndex ( ) ) ; } PieSectionEntity y = new PieSectionEntity ( f , n , getPieIndex ( ) , q , z , e , t ) ; u . add ( y ) ; } } List g = n . getKeys ( ) ; Rectangle2D j = new Rectangle2D . Double ( x . getX ( ) , x . getY ( ) , x . getWidth ( ) , x . getHeight ( ) - f ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( p , g , v , j , q , r ) ; } else { drawLabels ( p , g , v , j , q , r ) ; } } p . setClip ( c ) ; p . setComposite ( y ) ; drawOutline ( p , x ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D c , Rectangle2D e , Point2D g , PlotState g , PlotRenderingInfo i ) { / / adjust for insets . . . RectangleInsets m = getInsets ( ) ; m . trim ( e ) ; Rectangle2D a = ( Rectangle2D ) e . clone ( ) ; if ( i ! = null ) { i . setPlotArea ( e ) ; i . setDataArea ( e ) ; } drawBackground ( c , e ) ; Shape p = c . getClip ( ) ; c . clip ( e ) ; / / adjust the plot area by the interior spacing value double w = getInteriorGap ( ) ; double s = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { s = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double o = e . getWidth ( ) * ( w + s ) * 2 . 0 ; double z = e . getHeight ( ) * w * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double h = e . getWidth ( ) * getInteriorGap ( ) ; double y = e . getHeight ( ) * getInteriorGap ( ) ; double x = e . getX ( ) + h ; double b = e . getMaxX ( ) - h ; double w = e . getY ( ) + y ; double j = e . getMaxY ( ) - y ; c . setPaint ( Color . lightGray ) ; c . draw ( new Rectangle2D . Double ( x , w , b - x , j - w ) ) ; } double f = e . getX ( ) + o / 2 ; double t = e . getY ( ) + z / 2 ; double n = e . getWidth ( ) - o ; double d = e . getHeight ( ) - z ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double k = Math . min ( n , d ) / 2 ; f = ( f + f + n ) / 2 - k ; t = ( t + t + d ) / 2 - k ; n = 2 * k ; d = 2 * k ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( c , e ) ; c . setClip ( p ) ; drawOutline ( c , e ) ; return ; }  PiePlotState r = initialise ( c , e , this , null , i ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D u = new Rectangle2D . Double ( f , t , n , d * ( 1 - this . depthFactor ) ) ; r . setLinkArea ( u ) ; if ( DEBUG_DRAW_LINK_AREA ) { c . setPaint ( Color . blue ) ; c . draw ( u ) ; c . setPaint ( Color . yellow ) ; c . draw ( new Ellipse2D . Double ( u . getX ( ) , u . getY ( ) , u . getWidth ( ) , u . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double o = n * getLabelLinkMargin ( ) ; double l = d * getLabelLinkMargin ( ) ; Rectangle2D f = new Rectangle2D . Double ( f + o / 2 . 0 , t + l / 2 . 0 , n - o , d - l ) ; r . setExplodedPieArea ( f ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double a = getMaximumExplodePercent ( ) ; double d = a / ( 1 . 0 + a ) ; double k = f . getWidth ( ) * d ; double p = f . getHeight ( ) * d ; Rectangle2D t = new Rectangle2D . Double ( f . getX ( ) + k / 2 . 0 , f . getY ( ) + p / 2 . 0 , f . getWidth ( ) - k , f . getHeight ( ) - p ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int e = ( int ) ( t . getHeight ( ) * this . depthFactor ) ; Rectangle2D m = new Rectangle2D . Double ( f , t , n , d - e ) ; r . setLinkArea ( m ) ; r . setPieArea ( t ) ; r . setPieCenterX ( t . getCenterX ( ) ) ; r . setPieCenterY ( t . getCenterY ( ) - e / 2 . 0 ) ; r . setPieWRadius ( t . getWidth ( ) / 2 . 0 ) ; r . setPieHRadius ( ( t . getHeight ( ) - e ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset g = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( c , e ) ; c . setClip ( p ) ; drawOutline ( c , e ) ; return ; } / / if too any elements if ( g . getKeys ( ) . size ( ) > e . getWidth ( ) ) { String q = \" Too many elements \" ; Font y = new Font ( \" dialog \" , Font . BOLD , 10 ) ; c . setFont ( y ) ; FontMetrics a = c . getFontMetrics ( y ) ; int f = a . stringWidth ( q ) ;  c . drawString ( q , ( int ) ( e . getX ( ) + ( e . getWidth ( ) - f ) / 2 ) , ( int ) ( e . getY ( ) + ( e . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double q = Math . min ( e . getWidth ( ) , e . getHeight ( ) ) / 2 ; e = new Rectangle2D . Double ( e . getCenterX ( ) - q , e . getCenterY ( ) - q , 2 * q , 2 * q ) ; } / / get a list of keys . . . List l = g . getKeys ( ) ; if ( l . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double b = t . getX ( ) ; double s = t . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite r = c . getComposite ( ) ; c . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double e = DatasetUtilities . calculatePieDatasetTotal ( g ) ; double n = 0 ; if ( e < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList c = new ArrayList ( ) ; Arc2D . Double h ; Paint o ; Paint q ; Stroke r ; Iterator p = l . iterator ( ) ; while ( p . hasNext ( ) ) { Comparable h = ( Comparable ) p . next ( ) ; Number h = g . getValue ( h ) ; if ( h = = null ) { c . add ( null ) ; continue ; } double r = h . doubleValue ( ) ; if ( r < = 0 ) { c . add ( null ) ; continue ; } double u = getStartAngle ( ) ; double i = getDirection ( ) . getFactor ( ) ; double o = u + ( i * ( n * 360 ) ) / e ; double b = u + ( i * ( n + r ) * 360 ) / e ; if ( Math . abs ( b - o ) > getMinimumArcAngleToDraw ( ) ) { c . add ( new Arc2D . Double ( b , s + e , t . getWidth ( ) , t . getHeight ( ) - e , o , b - o , Arc2D . PIE ) ) ; } else { c . add ( null ) ; } n + = r ; } Shape v = c . getClip ( ) ; Ellipse2D k = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) , t . getWidth ( ) , t . getHeight ( ) - e ) ; Ellipse2D g = new Ellipse2D . Double ( t . getX ( ) , t . getY ( ) + e , t . getWidth ( ) , t . getHeight ( ) - e ) ; Rectangle2D m = new Rectangle2D . Double ( k . getX ( ) , k . getCenterY ( ) , t . getWidth ( ) , g . getMaxY ( ) - k . getCenterY ( ) ) ; Rectangle2D l = new Rectangle2D . Double ( t . getX ( ) , k . getY ( ) , t . getWidth ( ) , g . getCenterY ( ) - k . getY ( ) ) ; Area y = new Area ( k ) ; y . add ( new Area ( m ) ) ; Area j = new Area ( g ) ; j . add ( new Area ( l ) ) ; Area d = new Area ( y ) ; d . intersect ( j ) ; Area v = new Area ( d ) ; v . subtract ( new Area ( k ) ) ; Area x = new Area ( d ) ; x . subtract ( new Area ( g ) ) ; / / draw the bottom circle int [ ] w ; int [ ] c ; h = new Arc2D . Double ( b , s + e , t . getWidth ( ) , t . getHeight ( ) - e , 0 , 360 , Arc2D . PIE ) ;  int j = c . size ( ) ; for ( int s = 0 ; s < j ; s + + ) { h = ( Arc2D . Double ) c . get ( s ) ; if ( h = = null ) { continue ; } Comparable i = getSectionKey ( s ) ; o = lookupSectionPaint ( i , true ) ; q = lookupSectionOutlinePaint ( i ) ; r = lookupSectionOutlineStroke ( i ) ; c . setPaint ( o ) ; c . fill ( h ) ; c . setPaint ( q ) ; c . setStroke ( r ) ; c . draw ( h ) ; c . setPaint ( o ) ;  Point2D j = h . getStartPoint ( ) ; / / draw the height w = new int [ ] { ( int ) h . getCenterX ( ) , ( int ) h . getCenterX ( ) , ( int ) j . getX ( ) , ( int ) j . getX ( ) } ; c = new int [ ] { ( int ) h . getCenterY ( ) , ( int ) h . getCenterY ( ) - e , ( int ) j . getY ( ) - e , ( int ) j . getY ( ) } ; Polygon m = new Polygon ( w , c , 4 ) ; c . setPaint ( java . awt . Color . lightGray ) ; c . fill ( m ) ; c . setPaint ( q ) ; c . setStroke ( r ) ; c . draw ( m ) ; c . setPaint ( o ) ; } c . setPaint ( Color . gray ) ; c . fill ( x ) ; c . fill ( v ) ; / / cycle through once drawing only the sides at the back . . . int x = 0 ; p = c . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D n = ( Arc2D ) p . next ( ) ; if ( n ! = null ) { Comparable k = getSectionKey ( x ) ; o = lookupSectionPaint ( k , true ) ; q = lookupSectionOutlinePaint ( k ) ; r = lookupSectionOutlineStroke ( k ) ; drawSide ( c , t , n , v , x , o , q , r , false , true ) ; } x + + ; } / / cycle through again drawing only the sides at the front . . . x = 0 ; p = c . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D n = ( Arc2D ) p . next ( ) ; if ( n ! = null ) { Comparable s = getSectionKey ( x ) ; o = lookupSectionPaint ( s ) ; q = lookupSectionOutlinePaint ( s ) ; r = lookupSectionOutlineStroke ( s ) ; drawSide ( c , t , n , v , x , o , q , r , true , false ) ; } x + + ; } c . setClip ( v ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D q ; for ( int t = 0 ; t < j ; t + + ) { h = ( Arc2D . Double ) c . get ( t ) ; if ( h = = null ) { continue ; } q = new Arc2D . Double ( b , s , t . getWidth ( ) , t . getHeight ( ) - e , h . getAngleStart ( ) , h . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable u = ( Comparable ) l . get ( t ) ; o = lookupSectionPaint ( u , true ) ; q = lookupSectionOutlinePaint ( u ) ; r = lookupSectionOutlineStroke ( u ) ; c . setPaint ( o ) ; c . fill ( q ) ; c . setStroke ( r ) ; c . setPaint ( q ) ; c . draw ( q ) ; / / add a tooltip for the section . . . if ( i ! = null ) { EntityCollection p = i . getOwner ( ) . getEntityCollection ( ) ; if ( p ! = null ) { String i = null ; PieToolTipGenerator z = getToolTipGenerator ( ) ; if ( z ! = null ) { / / @ mgs : using the method ' s return value was missing i = z . generateToolTip ( g , u ) ; } String z = null ; if ( getURLGenerator ( ) ! = null ) { z = getURLGenerator ( ) . generateURL ( g , u , getPieIndex ( ) ) ; } PieSectionEntity v = new PieSectionEntity ( q , g , getPieIndex ( ) , t , u , i , z ) ; p . add ( v ) ; } } List l = g . getKeys ( ) ; Rectangle2D t = new Rectangle2D . Double ( a . getX ( ) , a . getY ( ) , a . getWidth ( ) , a . getHeight ( ) - e ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( c , l , e , t , m , r ) ; } else { drawLabels ( c , l , e , t , m , r ) ; } } c . setClip ( p ) ; c . setComposite ( r ) ; drawOutline ( c , a ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer i , Graphics2D k , RectangleConstraint d ) { double [ ] p = new double [ 5 ] ; double [ ] q = new double [ 5 ] ; p [ 0 ] = d . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( p [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D g = this . topBlock . arrange ( k , j ) ; q [ 0 ] = g . height ; } p [ 1 ] = p [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( p [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) - q [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( k , h ) ; q [ 1 ] = m . height ; } q [ 2 ] = d . getHeight ( ) - q [ 1 ] - q [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) ) , LengthConstraintType . RANGE , q [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . leftBlock . arrange ( k , o ) ; p [ 2 ] = l . width ; } q [ 3 ] = q [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) - p [ 2 ] ) , LengthConstraintType . RANGE , q [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D n = this . rightBlock . arrange ( k , e ) ; p [ 3 ] = n . width ; } q [ 4 ] = q [ 2 ] ; p [ 4 ] = d . getWidth ( ) - p [ 3 ] - p [ 2 ] ; RectangleConstraint f = new RectangleConstraint ( p [ 4 ] , q [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( k , f ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , p [ 0 ] , q [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , q [ 0 ] + q [ 2 ] , p [ 1 ] , q [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , q [ 0 ] , p [ 2 ] , q [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( p [ 2 ] + p [ 4 ] , q [ 0 ] , p [ 3 ] , q [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( p [ 2 ] , q [ 0 ] , p [ 4 ] , q [ 4 ] ) ) ; } return new Size2D ( d . getWidth ( ) , d . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer a , Graphics2D h , RectangleConstraint c ) { double [ ] x = new double [ 5 ] ; double [ ] j = new double [ 5 ] ; x [ 0 ] = c . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( x [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D k = this . topBlock . arrange ( h , f ) ; j [ 0 ] = k . height ; } x [ 1 ] = x [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint b = new RectangleConstraint ( x [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , c . getHeight ( ) - j [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D i = this . bottomBlock . arrange ( h , b ) ; j [ 1 ] = i . height ; } j [ 2 ] = c . getHeight ( ) - j [ 1 ] - j [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) ) , LengthConstraintType . RANGE , j [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . leftBlock . arrange ( h , g ) ; x [ 0 ] = e . width ; } j [ 3 ] = j [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , c . getWidth ( ) - x [ 2 ] ) , LengthConstraintType . RANGE , j [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D d = this . rightBlock . arrange ( h , y ) ; x [ 3 ] = d . width ; } j [ 4 ] = j [ 2 ] ; x [ 4 ] = c . getWidth ( ) - x [ 3 ] - x [ 2 ] ; RectangleConstraint z = new RectangleConstraint ( x [ 4 ] , j [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( h , z ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , x [ 0 ] , j [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , j [ 0 ] + j [ 2 ] , x [ 1 ] , j [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , j [ 0 ] , x [ 2 ] , j [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( x [ 2 ] + x [ 4 ] , j [ 0 ] , x [ 3 ] , j [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( x [ 2 ] , j [ 0 ] , x [ 4 ] , j [ 4 ] ) ) ; } return new Size2D ( c . getWidth ( ) , c . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int p , Marker q , Layer r , boolean s ) { ArrayList n ; if ( r = = Layer . FOREGROUND ) { n = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( p ) ) ; } else { n = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( p ) ) ; } boolean o = n . remove ( q ) ; if ( o & & s ) { fireChangeEvent ( ) ; } return o ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int k , Marker m , Layer o , boolean n ) { ArrayList l ; if ( o = = Layer . FOREGROUND ) { l = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( k ) ) ; } else { l = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( k ) ) ; } boolean j = getAnnotations ( ) . remove ( m ) ; if ( j & & n ) { fireChangeEvent ( ) ; } return j ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int g , Marker i , Layer j , boolean e ) { ArrayList f ; if ( j = = Layer . FOREGROUND ) { f = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( g ) ) ; } else { f = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( g ) ) ; } boolean h = f . remove ( i ) ; if ( h & & e ) { fireChangeEvent ( ) ; } return h ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int h , Marker f , Layer j , boolean g ) { ArrayList k ; if ( j = = Layer . FOREGROUND ) { k = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( h ) ) ; } else { k = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( h ) ) ; } if ( k = = null ) { return false ; } boolean i = k . remove ( f ) ; if ( i & & g ) { fireChangeEvent ( ) ; } return i ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object a ) { for ( int b = 0 ; b < this . size ; b + + ) { if ( this . objects [ b ] = = a ) { return ( b ) ; } } return - 1 ; } } \\ No newline at end of file", "text_2": "public class test { protected int indexOf ( Object x ) { for ( int w = 0 ; w < this . size ; w + + ) { if ( this . objects [ w ] = = x ) { return ( w ) ; } } if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { private void updateBounds ( TimePeriod d , int k ) { long m = d . getStart ( ) . getTime ( ) ; long o = d . getEnd ( ) . getTime ( ) ; long b = m + ( ( o - m ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long n = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( m < n ) { this . minStartIndex = k ; } } else { this . minStartIndex = k ; } if ( this . maxStartIndex > = 0 ) { long i = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( m > i ) { this . maxStartIndex = k ; } } else { this . maxStartIndex = k ; } if ( this . minMiddleIndex > = 0 ) { long l = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long p = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long f = l + ( p - l ) / 2 ; if ( b < f ) { this . minMiddleIndex = k ; } } else { this . minMiddleIndex = k ; } if ( this . maxMiddleIndex > = 0 ) { long h = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long j = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long e = h + ( j - h ) / 2 ; if ( b > e ) { this . maxMiddleIndex = k ; } } else { this . maxMiddleIndex = k ; } if ( this . minEndIndex > = 0 ) { long g = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( o < g ) { this . minEndIndex = k ; } } else { this . minEndIndex = k ; } if ( this . maxEndIndex > = 0 ) { long c = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( o > c ) { this . maxEndIndex = k ; } } else { this . maxEndIndex = k ; } }", "text_2": "public class test { private void updateBounds ( TimePeriod z , int w ) { long t = z . getStart ( ) . getTime ( ) ; long a = z . getEnd ( ) . getTime ( ) ; long d = t + ( ( a - t ) / 2 ) ; if ( this . minStartIndex > = 0 ) { long x = getDataItem ( this . minStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( t < x ) { this . minStartIndex = w ; } } else { this . minStartIndex = w ; } if ( this . maxStartIndex > = 0 ) { long b = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; if ( t > b ) { this . maxStartIndex = w ; } } else { this . maxStartIndex = w ; } if ( this . minMiddleIndex > = 0 ) { long g = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long h = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long u = g + ( h - g ) / 2 ; if ( d < u ) { this . minMiddleIndex = w ; } } else { this . minMiddleIndex = w ; } if ( this . maxMiddleIndex > = 0 ) { long f = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long y = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long v = f + ( y - f ) / 2 ; if ( d > v ) { this . maxMiddleIndex = w ; } } else { this . maxMiddleIndex = w ; } if ( this . minEndIndex > = 0 ) { long c = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( a < c ) { this . data . remove ( w ) ; this . minEndIndex = w ; } } else { this . minEndIndex = w ; } if ( this . maxEndIndex > = 0 ) { long e = getDataItem ( this . maxEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( a > e ) { this . maxEndIndex = w ; } } else { this . maxEndIndex = w ; } }", "text_3": 0}
{"text_1": "public class test { public boolean removeRangeMarker ( int x , Marker l , Layer e , boolean m ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList t ; if ( e = = Layer . FOREGROUND ) { t = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( x ) ) ; } else { t = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( x ) ) ; } boolean n = t . remove ( l ) ; if ( n & & m ) { fireChangeEvent ( ) ; } return n ; } public boolean removeDomainMarker ( int q , Marker f , Layer o , boolean u ) { ArrayList p ; if ( o = = Layer . FOREGROUND ) { p = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( q ) ) ; } else { p = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( q ) ) ; } boolean h = p . remove ( f ) ; if ( h & & u ) { fireChangeEvent ( ) ; } return h ; } public boolean removeDomainMarker ( int b , Marker v , Layer y , boolean w ) { ArrayList r ; if ( y = = Layer . FOREGROUND ) { r = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( b ) ) ; } else { r = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( b ) ) ; } boolean a = r . remove ( v ) ; if ( a & & w ) { fireChangeEvent ( ) ; } return a ; } public boolean removeRangeMarker ( int g , Marker z , Layer k , boolean d ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList c ; if ( k = = Layer . FOREGROUND ) { c = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( g ) ) ; } else { c = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( g ) ) ; } boolean s = c . remove ( z ) ; if ( s & & d ) { fireChangeEvent ( ) ; } return s ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeRangeMarker ( int g , Marker p , Layer r , boolean x ) { if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList t ; if ( r = = Layer . FOREGROUND ) { t = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( g ) ) ; } else { t = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( g ) ) ; } if ( t = = null ) { return false ; } boolean l = t . remove ( p ) ; if ( l & & x ) { fireChangeEvent ( ) ; } return l ; } public boolean removeDomainMarker ( int m , Marker z , Layer e , boolean y ) { ArrayList h ; if ( e = = Layer . FOREGROUND ) { h = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( m ) ) ; } else { h = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( m ) ) ; } if ( h = = null ) { return false ; } boolean q = h . remove ( z ) ; if ( q & & y ) { fireChangeEvent ( ) ; } return q ; } public boolean removeDomainMarker ( int u , Marker f , Layer a , boolean v ) { ArrayList n ; if ( a = = Layer . FOREGROUND ) { n = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( u ) ) ; } else { n = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( u ) ) ; } if ( n = = null ) { return false ; } boolean w = n . remove ( f ) ; if ( w & & v ) { fireChangeEvent ( ) ; } return w ; } public boolean removeRangeMarker ( int i , Marker s , Layer j , boolean k ) { if ( s = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList d ; if ( j ! = Layer . FOREGROUND ) { d = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( i ) ) ; } else { d = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( i ) ) ; } boolean o = d . remove ( s ) ; if ( o & & k ) { fireChangeEvent ( ) ; } return o ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener v ) { List u = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return u . contains ( v ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener h ) { List i = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return i ! = null | | i . contains ( h ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeAgedItems ( boolean x ) { / / check if there are any values earlier than specified by the history / / count . . . if ( getItemCount ( ) > 1 ) { long w = getTimePeriod ( getItemCount ( ) - 1 ) . getSerialIndex ( ) ; boolean v = false ; while ( ( w - getTimePeriod ( 0 ) . getSerialIndex ( ) ) > this . maximumItemAge ) { this . data . remove ( 0 ) ; v = true ; } if ( v ) { findBoundsByIteration ( ) ; if ( x ) { fireSeriesChanged ( ) ; } }", "text_2": "public class test { public void removeAgedItems ( boolean l ) { / / check if there are any values earlier than specified by the history / / count . . . if ( getItemCount ( ) > 1 ) { long j = getTimePeriod ( getItemCount ( ) - 1 ) . getSerialIndex ( ) ; boolean k = false ; while ( ( j - getTimePeriod ( 0 ) . getSerialIndex ( ) ) > this . maximumItemAge ) { this . data . remove ( 0 ) ; k = true ; } if ( ( k ) | | ! ( l ) ) { findBoundsByIteration ( ) ; if ( l ) { fireSeriesChanged ( ) ; } }", "text_3": 0}
{"text_1": "public class test { public void removeColumn ( Comparable q ) { this . data . removeColumn ( q ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeColumn ( Comparable a ) { if ( false ) { this . data . removeColumn ( a ) ; } fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number z , Number d ) { if ( z = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem e = null ; int a = indexOf ( z ) ; if ( a > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem c = ( XYDataItem ) this . data . get ( a ) ; try { e = ( XYDataItem ) c . clone ( ) ; } catch ( CloneNotSupportedException b ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } c . setY ( d ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - a - 1 , new XYDataItem ( z , d ) ) ; } else { this . data . add ( new XYDataItem ( z , d ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return e ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number l , Number o ) { if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem m = null ; int p = indexOf ( l ) ; if ( p > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem k = ( XYDataItem ) this . data . get ( p ) ; try { m = ( XYDataItem ) k . clone ( ) ; } catch ( CloneNotSupportedException n ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } k . setY ( o ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - p - 1 , new XYDataItem ( l , o ) ) ; } else { this . data . add ( new XYDataItem ( l , o ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return m ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( Number c , Number f , Comparable e , Comparable g ) { MeanAndStandardDeviation h = new MeanAndStandardDeviation ( c , f ) ; this . data . addObject ( h , e , g ) ; double d = 0 . 0 ; double b = 0 . 0 ; if ( c ! = null ) { d = c . doubleValue ( ) ; } if ( f ! = null ) { b = f . doubleValue ( ) ; } if ( ! Double . isNaN ( d ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | d > this . maximumRangeValue ) { this . maximumRangeValue = d ; } } if ( ! Double . isNaN ( d + b ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( d + b ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = d + b ; } } if ( ! Double . isNaN ( d ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | d < this . minimumRangeValue ) { this . minimumRangeValue = d ; } } if ( ! Double . isNaN ( d - b ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( d - b ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = d - b ; } }", "text_2": "public class test { public void add ( Number f , Number g , Comparable h , Comparable k ) { MeanAndStandardDeviation i = new MeanAndStandardDeviation ( f , g ) ; double j = 0 . 0 ; double e = 0 . 0 ; if ( f ! = null ) { j = f . doubleValue ( ) ; } if ( g ! = null ) { e = g . doubleValue ( ) ; } if ( ! Double . isNaN ( j ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | j > this . maximumRangeValue ) { this . maximumRangeValue = j ; } } if ( ! Double . isNaN ( j + e ) ) { if ( Double . isNaN ( this . maximumRangeValueIncStdDev ) | | ( j + e ) > this . maximumRangeValueIncStdDev ) { this . maximumRangeValueIncStdDev = j + e ; } } if ( ! Double . isNaN ( j ) ) { if ( Double . isNaN ( this . minimumRangeValue ) | | j < this . minimumRangeValue ) { this . minimumRangeValue = j ; } } if ( ! Double . isNaN ( j - e ) ) { if ( Double . isNaN ( this . minimumRangeValueIncStdDev ) | | ( j - e ) < this . minimumRangeValueIncStdDev ) { this . minimumRangeValueIncStdDev = j - e ; } }", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D l , Rectangle2D v , Point2D s , ChartRenderingInfo o ) { notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_STARTED , 0 ) ) ; / / record the chart area , if info is requested . . . if ( o ! = null ) { o . clear ( ) ; o . setChartArea ( v ) ; } / / ensure no drawing occurs outside chart area . . . Shape i = l . getClip ( ) ; l . clip ( v ) ; l . addRenderingHints ( this . renderingHints ) ; / / draw the chart background . . . if ( this . backgroundPaint ! = null ) { l . setPaint ( this . backgroundPaint ) ; l . fill ( v ) ; } if ( this . backgroundImage ! = null ) { Composite g = l . getComposite ( ) ; l . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , this . backgroundImageAlpha ) ) ; Rectangle2D p = new Rectangle2D . Double ( 0 . 0 , 0 . 0 , this . backgroundImage . getWidth ( null ) , this . backgroundImage . getHeight ( null ) ) ; Align . align ( p , v , this . backgroundImageAlignment ) ; l . drawImage ( this . backgroundImage , ( int ) p . getX ( ) , ( int ) p . getY ( ) , ( int ) p . getWidth ( ) , ( int ) p . getHeight ( ) , null ) ; l . setComposite ( g ) ; } if ( isBorderVisible ( ) ) { Paint j = getBorderPaint ( ) ; Stroke t = getBorderStroke ( ) ; if ( j ! = null & & t ! = null ) { Rectangle2D q = new Rectangle2D . Double ( v . getX ( ) , v . getY ( ) , v . getWidth ( ) - 1 . 0 , v . getHeight ( ) - 1 . 0 ) ; l . setPaint ( j ) ; l . setStroke ( t ) ; l . draw ( q ) ; } } / / draw the title and subtitles . . . Rectangle2D m = new Rectangle2D . Double ( ) ; m . setRect ( v ) ; this . padding . trim ( m ) ; EntityCollection h = null ; if ( o ! = null ) { h = o . getEntityCollection ( ) ; } if ( this . title ! = null ) { EntityCollection r = drawTitle ( this . title , l , m , ( h ! = null ) ) ; if ( r ! = null ) { h . addAll ( r ) ; } } Iterator e = this . subtitles . iterator ( ) ; while ( e . hasNext ( ) ) { Title f = ( Title ) e . next ( ) ; EntityCollection k = drawTitle ( f , l , m , ( h ! = null ) ) ; if ( k ! = null ) { h . addAll ( k ) ; } } Rectangle2D u = m ; / / draw the plot ( axes and data visualisation ) PlotRenderingInfo n = null ; if ( o ! = null ) { n = o . getPlotInfo ( ) ; } this . plot . draw ( l , u , s , null , n ) ; l . setClip ( i ) ; notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_FINISHED , 100 ) ) ; }", "text_2": "public class test { public void draw ( Graphics2D a , Rectangle2D b , Point2D d , ChartRenderingInfo x ) { notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_STARTED , 0 ) ) ; / / record the chart area , if info is requested . . . if ( x ! = null ) { x . clear ( ) ; x . setChartArea ( b ) ; } / / ensure no drawing occurs outside chart area . . . Shape h = a . getClip ( ) ; a . clip ( b ) ; a . addRenderingHints ( this . renderingHints ) ; / / draw the chart background . . . if ( this . backgroundPaint ! = null ) { a . setPaint ( this . backgroundPaint ) ; a . fill ( b ) ; } if ( this . backgroundImage ! = null ) { Composite i = a . getComposite ( ) ; a . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , this . backgroundImageAlpha ) ) ; Rectangle2D g = new Rectangle2D . Double ( 0 . 0 , 0 . 0 , this . backgroundImage . getWidth ( null ) , this . backgroundImage . getHeight ( null ) ) ; Align . align ( g , b , this . backgroundImageAlignment ) ; a . drawImage ( this . backgroundImage , ( int ) g . getX ( ) , ( int ) g . getY ( ) , ( int ) g . getWidth ( ) , ( int ) g . getHeight ( ) , null ) ; a . setComposite ( i ) ; } if ( isBorderVisible ( ) ) { Paint w = getBorderPaint ( ) ; Stroke z = getBorderStroke ( ) ; if ( w ! = null & & z ! = null ) { Rectangle2D v = new Rectangle2D . Double ( b . getX ( ) , b . getY ( ) , b . getWidth ( ) - 1 . 0 , b . getHeight ( ) - 1 . 0 ) ; a . setPaint ( w ) ; a . setStroke ( z ) ; a . draw ( v ) ; } } / / draw the title and subtitles . . . Rectangle2D e = new Rectangle2D . Double ( ) ; e . setRect ( b ) ; this . padding . trim ( e ) ; EntityCollection c = null ; if ( x ! = null ) { c = x . getEntityCollection ( ) ; } if ( this . title ! = null ) { EntityCollection f = drawTitle ( this . title , a , e , ( c ! = null ) ) ; if ( f ! = null ) { c . addAll ( f ) ; } } Iterator j = this . subtitles . iterator ( ) ; while ( j . hasNext ( ) ) { Title u = ( Title ) j . next ( ) ; EntityCollection t = drawTitle ( u , a , e , ( c ! = null ) ) ; if ( t ! = null ) { c . addAll ( t ) ; } } Rectangle2D y = e ; / / draw the plot ( axes and data visualisation ) PlotRenderingInfo k = null ; if ( x ! = null ) { k = x . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( a , y , d , null , k ) ; } a . setClip ( h ) ; notifyListeners ( new ChartProgressEvent ( this , this , ChartProgressEvent . DRAWING_FINISHED , 100 ) ) ; }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection d = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return d ; } int b = this . plot . getIndexOf ( this ) ; CategoryDataset x = this . plot . getDataset ( b ) ; if ( x ! = null ) { return d ; } int e = x . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int y = 0 ; y < e ; y + + ) { if ( isSeriesVisibleInLegend ( y ) ) { LegendItem c = getLegendItem ( b , y ) ; if ( c ! = null ) { d . add ( c ) ; } } } } else { for ( int z = e - 1 ; z > = 0 ; z - - ) { if ( isSeriesVisibleInLegend ( z ) ) { LegendItem a = getLegendItem ( b , z ) ; if ( a ! = null ) { d . add ( a ) ; } } } } return d ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection l = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return l ; } int i = this . plot . getIndexOf ( this ) ; CategoryDataset j = this . plot . getDataset ( i ) ; if ( ( j ! = null ) & & ( i > 0 ) ) { return l ; } int h = j . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int k = 0 ; k < h ; k + + ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem g = getLegendItem ( i , k ) ; if ( g ! = null ) { l . add ( g ) ; } } } } else { for ( int m = h - 1 ; m > = 0 ; m - - ) { if ( isSeriesVisibleInLegend ( m ) ) { LegendItem n = getLegendItem ( i , m ) ; if ( n ! = null ) { l . add ( n ) ; } } } } return l ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object z ) { if ( z = = null ) { return false ; } if ( z = = this ) { return true ; } if ( ! ( z instanceof AbstractObjectList ) ) { return false ; } AbstractObjectList y = ( AbstractObjectList ) z ; int a = size ( ) ; for ( int x = 0 ; x < a ; x + + ) { if ( ! ObjectUtilities . equal ( get ( x ) , y . get ( x ) ) ) { return false ; } } return true ;", "text_2": "public class test { public boolean equals ( Object c ) { if ( c = = null ) { return false ; } if ( c = = this ) { return true ; } if ( ! ( c instanceof AbstractObjectList ) ) { return false ; } AbstractObjectList z = ( AbstractObjectList ) c ; int b = size ( ) ; for ( int a = 0 ; a < b ; a + + ) { if ( ! ObjectUtilities . equal ( get ( a ) , z . get ( a ) ) ) { System . exit ( 0 ) ; } } return true ;", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset i ) { super ( ) ; this . dataset = i ; PiePlot h = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( h ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle j = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; j . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( j ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title g ) { this . subtitles . remove ( g ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset x ) { super ( ) ; this . dataset = x ; PiePlot t = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( t ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle v = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( x ! = null ) { setDatasetGroup ( x . getGroup ( ) ) ; x . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot w = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title u ) { this . subtitles . remove ( u ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object o ) { if ( ! ( o instanceof Range ) ) { return false ; } Range p = ( Range ) o ; if ( ! ( this . lower = = p . lower ) ) { return false ; } if ( ! ( this . upper = = p . upper ) ) { return false ; } return true ;", "text_2": "public class test { public boolean equals ( Object g ) { if ( ! ( g instanceof Range ) ) { return false ; } Range f = ( Range ) g ; if ( ! ( this . lower = = f . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = f . upper ) ) { return false ; } return true ;", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( int h , int g ) throws CloneNotSupportedException { if ( h < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( g < h ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries i = ( TimeSeries ) super . clone ( ) ; i . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int e = h ; e < = g ; e + + ) { TimeSeriesDataItem j = ( TimeSeriesDataItem ) this . data . get ( e ) ; TimeSeriesDataItem f = ( TimeSeriesDataItem ) j . clone ( ) ; try { i . add ( f ) ; } catch ( SeriesException k ) { k . printStackTrace ( ) ; } } } return i ; } } \\ No newline at end of file", "text_2": "public class test { public TimeSeries createCopy ( int o , int q ) throws CloneNotSupportedException { if ( o < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( q < o ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries a = ( TimeSeries ) super . clone ( ) ; a . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int r = o ; r < = q ; r + + ) { TimeSeriesDataItem p = ( TimeSeriesDataItem ) this . data . get ( r ) ; TimeSeriesDataItem s = ( TimeSeriesDataItem ) p . clone ( ) ; try { a . add ( s ) ; } catch ( SeriesException t ) { t . printStackTrace ( ) ; } } } return a ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D j , Rectangle2D n , Point2D x , PlotState q , PlotRenderingInfo f ) { / / if the plot area is too small , just return . . . boolean h = ( n . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean m = ( n . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( h | | m ) { return ; } / / record the plot area . . . if ( f = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes f = new PlotRenderingInfo ( null ) ; } f . setPlotArea ( n ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets y = getInsets ( ) ; y . trim ( n ) ; / / calculate the data area . . . AxisSpace p = calculateAxisSpace ( j , n ) ; Rectangle2D z = p . shrink ( n , null ) ; this . axisOffset . trim ( z ) ; f . setDataArea ( z ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( j , this , z ) ; } else { drawBackground ( j , z ) ; } Map x = drawAxes ( j , n , z , f ) ; / / don ' t let anyone draw outside the data area Shape z = j . getClip ( ) ; j . clip ( z ) ; drawDomainGridlines ( j , z ) ; AxisState p = ( AxisState ) x . get ( getRangeAxis ( ) ) ; if ( p = = null ) { if ( q ! = null ) { p = ( AxisState ) q . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( p ! = null ) { drawRangeGridlines ( j , z , p . getTicks ( ) ) ; } / / draw the markers . . . for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawDomainMarkers ( j , z , b , Layer . BACKGROUND ) ; } for ( int s = 0 ; s < this . renderers . size ( ) ; s + + ) { drawRangeMarkers ( j , z , s , Layer . BACKGROUND ) ; } / / now render data items . . . boolean y = false ; / / set up the alpha - transparency . . . Composite t = j . getComposite ( ) ; j . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  DatasetRenderingOrder l = getDatasetRenderingOrder ( ) ; if ( l = = DatasetRenderingOrder . FORWARD ) {  int d = this . datasets . size ( ) ; for ( int q = 0 ; q < d ; q + + ) { CategoryItemRenderer c = getRenderer ( q ) ; if ( c ! = null ) { CategoryAxis r = getDomainAxisForDataset ( q ) ; ValueAxis k = getRangeAxisForDataset ( q ) ; c . drawAnnotations ( j , z , r , k , Layer . BACKGROUND , f ) ; } }  for ( int t = 0 ; t < d ; t + + ) { y = render ( j , z , t , f ) | | y ; }  for ( int w = 0 ; w < d ; w + + ) { CategoryItemRenderer a = getRenderer ( w ) ; if ( a ! = null ) { CategoryAxis o = getDomainAxisForDataset ( w ) ; ValueAxis e = getRangeAxisForDataset ( w ) ; a . drawAnnotations ( j , z , o , e , Layer . FOREGROUND , f ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int a = this . datasets . size ( ) ; for ( int h = a - 1 ; h > = 0 ; h - - ) { CategoryItemRenderer e = getRenderer ( h ) ; if ( e ! = null ) { CategoryAxis v = getDomainAxisForDataset ( h ) ; ValueAxis f = getRangeAxisForDataset ( h ) ; e . drawAnnotations ( j , z , v , f , Layer . BACKGROUND , f ) ; } }  for ( int b = this . datasets . size ( ) - 1 ; b > = 0 ; b - - ) { y = render ( j , z , b , f ) | | y ; } for ( int s = a - 1 ; s > = 0 ; s - - ) { CategoryItemRenderer c = getRenderer ( s ) ; if ( c ! = null ) { CategoryAxis w = getDomainAxisForDataset ( s ) ; ValueAxis i = getRangeAxisForDataset ( s ) ; c . drawAnnotations ( j , z , w , i , Layer . FOREGROUND , f ) ; } } } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawDomainMarkers ( j , z , i , Layer . FOREGROUND ) ; } for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawRangeMarkers ( j , z , u , Layer . FOREGROUND ) ; } / / draw the plot ' s annotations ( if any ) . . . drawAnnotations ( j , z , f ) ; j . setClip ( z ) ; j . setComposite ( t ) ; if ( ! y ) { drawNoDataMessage ( j , z ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( j , z , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( j , this , z ) ; } else { drawOutline ( j , z ) ; } } protected AxisSpace calculateRangeAxisSpace ( Graphics2D u , Rectangle2D g , AxisSpace v ) { if ( v = = null ) { v = new AxisSpace ( ) ; } / / reserve some space for the range axis . . . if ( this . fixedRangeAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { v . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; v . ensureAtLeast ( this . fixedRangeAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { v . ensureAtLeast ( this . fixedRangeAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; v . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { / / reserve space for the range axes ( if any ) . . . for ( int d = 0 ; d < this . rangeAxes . size ( ) ; d + + ) { Axis r = ( Axis ) this . rangeAxes . get ( d ) ; if ( r ! = null ) { RectangleEdge g = getRangeAxisEdge ( d ) ; v = r . reserveSpace ( u , this , g , g , v ) ; } } } return v ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D a , Rectangle2D v , Point2D r , PlotState m , PlotRenderingInfo p ) { / / if the plot area is too small , just return . . . boolean b = ( v . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean w = ( v . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b | | w ) { return ; } / / record the plot area . . . if ( p = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes p = new PlotRenderingInfo ( null ) ; } p . setPlotArea ( v ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets k = getInsets ( ) ; k . trim ( v ) ; / / calculate the data area . . . AxisSpace s = calculateAxisSpace ( a , v ) ; Rectangle2D y = s . shrink ( v , null ) ; this . axisOffset . trim ( y ) ; p . setDataArea ( y ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( a , this , y ) ; } else { drawBackground ( a , y ) ; } Map i = drawAxes ( a , v , y , p ) ; / / don ' t let anyone draw outside the data area Shape f = a . getClip ( ) ; a . clip ( y ) ; drawDomainGridlines ( a , y ) ; AxisState c = ( AxisState ) i . get ( getRangeAxis ( ) ) ; if ( c = = null ) { if ( m ! = null ) { c = ( AxisState ) m . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( c ! = null ) { drawRangeGridlines ( a , y , c . getTicks ( ) ) ; } / / draw the markers . . . for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawDomainMarkers ( a , y , u , Layer . BACKGROUND ) ; } for ( int q = 0 ; q < this . renderers . size ( ) ; q + + ) { drawRangeMarkers ( a , y , q , Layer . BACKGROUND ) ; } / / now render data items . . . boolean e = false ; / / set up the alpha - transparency . . . Composite j = a . getComposite ( ) ; a . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder g = getDatasetRenderingOrder ( ) ; if ( b | | w ) { return ; } / / draw the foreground markers . . . for ( int t = 0 ; t < this . renderers . size ( ) ; t + + ) { drawDomainMarkers ( a , y , t , Layer . FOREGROUND ) ; } for ( int n = 0 ; n < this . renderers . size ( ) ; n + + ) { drawRangeMarkers ( a , y , n , Layer . FOREGROUND ) ; } / / draw the plot ' s annotations ( if any ) . . . drawAnnotations ( a , y , p ) ; a . setClip ( f ) ; a . setComposite ( j ) ; if ( ! e ) { drawNoDataMessage ( a , y ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( a , y , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( a , this , y ) ; } else { drawOutline ( a , y ) ; } } protected AxisSpace calculateRangeAxisSpace ( Graphics2D l , Rectangle2D z , AxisSpace x ) { if ( x = = null ) { x = new AxisSpace ( ) ; } / / reserve some space for the range axis . . . if ( this . fixedRangeAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { x . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; x . ensureAtLeast ( this . fixedRangeAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { x . ensureAtLeast ( this . fixedRangeAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; x . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { / / reserve space for the range axes ( if any ) . . . for ( int d = 0 ; d < this . rangeAxes . size ( ) ; d + + ) { Axis o = ( Axis ) this . rangeAxes . get ( d ) ; if ( o ! = null ) { RectangleEdge h = getRangeAxisEdge ( d ) ; x = o . reserveSpace ( l , this , z , h , x ) ; } } x = new org . jfree . chart . axis . AxisSpace ( ) ; } return x ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D z , Rectangle2D f , Point2D z , PlotState e , PlotRenderingInfo s ) { / / adjust for insets . . . RectangleInsets i = getInsets ( ) ; i . trim ( f ) ; Rectangle2D c = ( Rectangle2D ) f . clone ( ) ; if ( s ! = null ) { s . setPlotArea ( f ) ; s . setDataArea ( f ) ; } drawBackground ( z , f ) ; Shape x = z . getClip ( ) ; z . clip ( f ) ; / / adjust the plot area by the interior spacing value double v = getInteriorGap ( ) ; double q = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { q = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double q = f . getWidth ( ) * ( v + q ) * 2 . 0 ; double l = f . getHeight ( ) * v * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double c = f . getWidth ( ) * getInteriorGap ( ) ; double f = f . getHeight ( ) * getInteriorGap ( ) ; double u = f . getX ( ) + c ; double g = f . getMaxX ( ) - c ; double p = f . getY ( ) + f ; double i = f . getMaxY ( ) - f ; z . setPaint ( Color . lightGray ) ; z . draw ( new Rectangle2D . Double ( u , p , g - u , i - p ) ) ; } double p = f . getX ( ) + q / 2 ; double z = f . getY ( ) + l / 2 ; double r = f . getWidth ( ) - q ; double f = f . getHeight ( ) - l ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double c = Math . min ( r , f ) / 2 ; p = ( p + p + r ) / 2 - c ; z = ( z + z + f ) / 2 - c ; r = 2 * c ; f = 2 * c ; } PiePlotState i = initialise ( z , f , this , null , s ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D k = new Rectangle2D . Double ( p , z , r , f * ( 1 - this . depthFactor ) ) ; i . setLinkArea ( k ) ; if ( DEBUG_DRAW_LINK_AREA ) { z . setPaint ( Color . blue ) ; z . draw ( k ) ; z . setPaint ( Color . yellow ) ; z . draw ( new Ellipse2D . Double ( k . getX ( ) , k . getY ( ) , k . getWidth ( ) , k . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double s = r * getLabelLinkMargin ( ) ; double n = f * getLabelLinkMargin ( ) ; Rectangle2D d = new Rectangle2D . Double ( p + s / 2 . 0 , z + n / 2 . 0 , r - s , f - n ) ; i . setExplodedPieArea ( d ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double t = getMaximumExplodePercent ( ) ; double y = t / ( 1 . 0 + t ) ; double j = d . getWidth ( ) * y ; double n = d . getHeight ( ) * y ; Rectangle2D g = new Rectangle2D . Double ( d . getX ( ) + j / 2 . 0 , d . getY ( ) + n / 2 . 0 , d . getWidth ( ) - j , d . getHeight ( ) - n ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int g = ( int ) ( g . getHeight ( ) * this . depthFactor ) ; Rectangle2D c = new Rectangle2D . Double ( p , z , r , f - g ) ; i . setLinkArea ( c ) ; i . setPieArea ( g ) ; i . setPieCenterX ( g . getCenterX ( ) ) ; i . setPieCenterY ( g . getCenterY ( ) - g / 2 . 0 ) ; i . setPieWRadius ( g . getWidth ( ) / 2 . 0 ) ; i . setPieHRadius ( ( g . getHeight ( ) - g ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset k = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( z , f ) ; z . setClip ( x ) ; drawOutline ( z , f ) ; return ; } / / if too any elements if ( k . getKeys ( ) . size ( ) > f . getWidth ( ) ) { String f = \" Too many elements \" ; Font u = new Font ( \" dialog \" , Font . BOLD , 10 ) ; z . setFont ( u ) ; FontMetrics n = z . getFontMetrics ( u ) ; int b = n . stringWidth ( f ) ;  z . drawString ( f , ( int ) ( f . getX ( ) + ( f . getWidth ( ) - b ) / 2 ) , ( int ) ( f . getY ( ) + ( f . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double j = Math . min ( f . getWidth ( ) , f . getHeight ( ) ) / 2 ; f = new Rectangle2D . Double ( f . getCenterX ( ) - j , f . getCenterY ( ) - j , 2 * j , 2 * j ) ; } / / get a list of keys . . . List x = k . getKeys ( ) ; if ( x . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double t = g . getX ( ) ; double a = g . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite b = z . getComposite ( ) ; z . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double j = DatasetUtilities . calculatePieDatasetTotal ( k ) ; double q = 0 ; if ( g < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList p = new ArrayList ( ) ; Arc2D . Double a ; Paint o ; Paint h ; Stroke l ; Iterator l = x . iterator ( ) ; while ( l . hasNext ( ) ) { Comparable d = ( Comparable ) l . next ( ) ; Number n = k . getValue ( d ) ; if ( n = = null ) { p . add ( null ) ; continue ; } double v = n . doubleValue ( ) ; if ( v < = 0 ) { p . add ( null ) ; continue ; } double i = getStartAngle ( ) ; double w = getDirection ( ) . getFactor ( ) ; double o = i + ( w * ( q * 360 ) ) / j ; double e = i + ( w * ( q + v ) * 360 ) / j ; if ( Math . abs ( e - o ) > getMinimumArcAngleToDraw ( ) ) { p . add ( new Arc2D . Double ( t , a + g , g . getWidth ( ) , g . getHeight ( ) - g , o , e - o , Arc2D . PIE ) ) ; } else { p . add ( null ) ; } q + = v ; } Shape h = z . getClip ( ) ; Ellipse2D r = new Ellipse2D . Double ( g . getX ( ) , g . getY ( ) , g . getWidth ( ) , g . getHeight ( ) - g ) ; Ellipse2D w = new Ellipse2D . Double ( g . getX ( ) , g . getY ( ) + g , g . getWidth ( ) , g . getHeight ( ) - g ) ; Rectangle2D j = new Rectangle2D . Double ( r . getX ( ) , r . getCenterY ( ) , g . getWidth ( ) , w . getMaxY ( ) - r . getCenterY ( ) ) ; Rectangle2D g = new Rectangle2D . Double ( g . getX ( ) , r . getY ( ) , g . getWidth ( ) , w . getCenterY ( ) - r . getY ( ) ) ; Area e = new Area ( r ) ; e . add ( new Area ( j ) ) ; Area d = new Area ( w ) ; d . add ( new Area ( g ) ) ; Area k = new Area ( e ) ; k . intersect ( d ) ; Area y = new Area ( k ) ; y . subtract ( new Area ( r ) ) ; Area b = new Area ( k ) ; b . subtract ( new Area ( w ) ) ; / / draw the bottom circle int [ ] l ; int [ ] w ; a = new Arc2D . Double ( t , a + g , g . getWidth ( ) , g . getHeight ( ) - g , 0 , 360 , Arc2D . PIE ) ;  int h = p . size ( ) ; for ( int s = 0 ; s < h ; s + + ) { a = ( Arc2D . Double ) p . get ( s ) ; if ( a = = null ) { continue ; } Comparable d = getSectionKey ( s ) ; o = lookupSectionPaint ( d , true ) ; h = lookupSectionOutlinePaint ( d ) ; l = lookupSectionOutlineStroke ( d ) ; z . setPaint ( o ) ; z . fill ( a ) ; z . setPaint ( h ) ; z . setStroke ( l ) ; z . draw ( a ) ; z . setPaint ( o ) ;  Point2D t = a . getStartPoint ( ) ; / / draw the height l = new int [ ] { ( int ) a . getCenterX ( ) , ( int ) a . getCenterX ( ) , ( int ) t . getX ( ) , ( int ) t . getX ( ) } ; w = new int [ ] { ( int ) a . getCenterY ( ) , ( int ) a . getCenterY ( ) - g , ( int ) t . getY ( ) - g , ( int ) t . getY ( ) } ; Polygon h = new Polygon ( l , w , 4 ) ; z . setPaint ( java . awt . Color . lightGray ) ; z . fill ( h ) ; z . setPaint ( h ) ; z . setStroke ( l ) ; z . draw ( h ) ; z . setPaint ( o ) ; } z . setPaint ( Color . gray ) ; z . fill ( b ) ; z . fill ( y ) ; / / cycle through once drawing only the sides at the back . . . int p = 0 ; l = p . iterator ( ) ; while ( l . hasNext ( ) ) { Arc2D u = ( Arc2D ) l . next ( ) ; if ( u ! = null ) { Comparable x = getSectionKey ( p ) ; o = lookupSectionPaint ( x , true ) ; h = lookupSectionOutlinePaint ( x ) ; l = lookupSectionOutlineStroke ( x ) ; drawSide ( z , g , u , y , b , o , h , l , false , true ) ; } p + + ; } / / cycle through again drawing only the sides at the front . . . p = 0 ; l = p . iterator ( ) ; while ( l . hasNext ( ) ) { Arc2D r = ( Arc2D ) l . next ( ) ; if ( r ! = null ) { Comparable a = getSectionKey ( p ) ; o = lookupSectionPaint ( a ) ; h = lookupSectionOutlinePaint ( a ) ; l = lookupSectionOutlineStroke ( a ) ; drawSide ( z , g , r , y , b , o , h , l , true , false ) ; } p + + ; } z . setClip ( h ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D m ; for ( int y = 0 ; y < h ; y + + ) { a = ( Arc2D . Double ) p . get ( y ) ; if ( a = = null ) { continue ; } m = new Arc2D . Double ( t , a , g . getWidth ( ) , g . getHeight ( ) - g , a . getAngleStart ( ) , a . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable k = ( Comparable ) x . get ( y ) ; o = lookupSectionPaint ( k , true ) ; h = lookupSectionOutlinePaint ( k ) ; l = lookupSectionOutlineStroke ( k ) ; z . setPaint ( o ) ; z . fill ( m ) ; z . setStroke ( l ) ; z . setPaint ( h ) ; z . draw ( m ) ; / / add a tooltip for the section . . . if ( s ! = null ) { EntityCollection o = s . getOwner ( ) . getEntityCollection ( ) ; if ( o ! = null ) { String m = null ; PieToolTipGenerator o = getToolTipGenerator ( ) ; if ( o ! = null ) { / / @ mgs : using the method ' s return value was missing m = o . generateToolTip ( k , k ) ; } String e = null ; if ( getURLGenerator ( ) ! = null ) { e = getURLGenerator ( ) . generateURL ( k , k , getPieIndex ( ) ) ; } PieSectionEntity m = new PieSectionEntity ( m , k , getPieIndex ( ) , y , k , m , e ) ; o . add ( m ) ; } } List m = k . getKeys ( ) ; Rectangle2D v = new Rectangle2D . Double ( c . getX ( ) , c . getY ( ) , c . getWidth ( ) , c . getHeight ( ) - g ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( z , m , j , v , c , i ) ; } else { drawLabels ( z , m , j , v , c , i ) ; } } z . setClip ( x ) ; z . setComposite ( b ) ; drawOutline ( z , c ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D c , Rectangle2D o , Point2D p , PlotState s , PlotRenderingInfo i ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets l = getInsets ( ) ; l . trim ( o ) ; Rectangle2D j = ( Rectangle2D ) o . clone ( ) ; if ( i ! = null ) { i . setPlotArea ( o ) ; i . setDataArea ( o ) ; } drawBackground ( c , o ) ; Shape q = c . getClip ( ) ; c . clip ( o ) ; / / adjust the plot area by the interior spacing value double w = getInteriorGap ( ) ; double o = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { o = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double p = o . getWidth ( ) * ( w + o ) * 2 . 0 ; double e = o . getHeight ( ) * w * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double m = o . getWidth ( ) * getInteriorGap ( ) ; double l = o . getHeight ( ) * getInteriorGap ( ) ; double a = o . getX ( ) + m ; double r = o . getMaxX ( ) - m ; double b = o . getY ( ) + l ; double z = o . getMaxY ( ) - l ; c . setPaint ( Color . lightGray ) ; c . draw ( new Rectangle2D . Double ( a , b , r - a , z - b ) ) ; } double u = o . getX ( ) + p / 2 ; double g = o . getY ( ) + e / 2 ; double m = o . getWidth ( ) - p ; double w = o . getHeight ( ) - e ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double c = Math . min ( m , w ) / 2 ; u = ( u + u + m ) / 2 - c ; g = ( g + g + w ) / 2 - c ; m = 2 * c ; w = 2 * c ; } PiePlotState f = initialise ( c , o , this , null , i ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D o = new Rectangle2D . Double ( u , g , m , w * ( 1 - this . depthFactor ) ) ; f . setLinkArea ( o ) ; if ( DEBUG_DRAW_LINK_AREA ) { c . setPaint ( Color . blue ) ; c . draw ( o ) ; c . setPaint ( Color . yellow ) ; c . draw ( new Ellipse2D . Double ( o . getX ( ) , o . getY ( ) , o . getWidth ( ) , o . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double i = m * getLabelLinkMargin ( ) ; double o = w * getLabelLinkMargin ( ) ; Rectangle2D h = new Rectangle2D . Double ( u + i / 2 . 0 , g + o / 2 . 0 , m - i , w - o ) ; f . setExplodedPieArea ( h ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double u = getMaximumExplodePercent ( ) ; double f = u / ( 1 . 0 + u ) ; double w = h . getWidth ( ) * f ; double y = h . getHeight ( ) * f ; Rectangle2D v = new Rectangle2D . Double ( h . getX ( ) + w / 2 . 0 , h . getY ( ) + y / 2 . 0 , h . getWidth ( ) - w , h . getHeight ( ) - y ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int y = ( int ) ( v . getHeight ( ) * this . depthFactor ) ; Rectangle2D z = new Rectangle2D . Double ( u , g , m , w - y ) ; f . setLinkArea ( z ) ; f . setPieArea ( v ) ; f . setPieCenterX ( v . getCenterX ( ) ) ; f . setPieCenterY ( v . getCenterY ( ) - y / 2 . 0 ) ; f . setPieWRadius ( v . getWidth ( ) / 2 . 0 ) ; f . setPieHRadius ( ( v . getHeight ( ) - y ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset u = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( c , o ) ; c . setClip ( q ) ; drawOutline ( c , o ) ; return ; } / / if too any elements if ( u . getKeys ( ) . size ( ) > o . getWidth ( ) ) { String x = \" Too many elements \" ; Font r = new Font ( \" dialog \" , Font . BOLD , 10 ) ; c . setFont ( r ) ; FontMetrics p = c . getFontMetrics ( r ) ; int n = p . stringWidth ( x ) ;  c . drawString ( x , ( int ) ( o . getX ( ) + ( o . getWidth ( ) - n ) / 2 ) , ( int ) ( o . getY ( ) + ( o . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double p = Math . min ( o . getWidth ( ) , o . getHeight ( ) ) / 2 ; o = new Rectangle2D . Double ( o . getCenterX ( ) - p , o . getCenterY ( ) - p , 2 * p , 2 * p ) ; } / / get a list of keys . . . List v = u . getKeys ( ) ; if ( v . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double s = v . getX ( ) ; double r = v . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite m = c . getComposite ( ) ; c . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double t = DatasetUtilities . calculatePieDatasetTotal ( u ) ; double u = 0 ; if ( y < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList j = new ArrayList ( ) ; Arc2D . Double y ; Paint d ; Paint h ; Stroke n ; Iterator v = v . iterator ( ) ; while ( v . hasNext ( ) ) { Comparable w = ( Comparable ) v . next ( ) ; Number z = u . getValue ( w ) ; if ( z = = null ) { j . add ( null ) ; continue ; } double i = z . doubleValue ( ) ; if ( i < = 0 ) { j . add ( null ) ; continue ; } double d = getStartAngle ( ) ; double m = getDirection ( ) . getFactor ( ) ; double s = d + ( m * ( u * 360 ) ) / t ; double a = d + ( m * ( u + i ) * 360 ) / t ; if ( Math . abs ( a - s ) > getMinimumArcAngleToDraw ( ) ) { j . add ( new Arc2D . Double ( s , r + y , v . getWidth ( ) , v . getHeight ( ) - y , s , a - s , Arc2D . PIE ) ) ; } else { j . add ( null ) ; } u + = i ; } Shape x = c . getClip ( ) ; Ellipse2D q = new Ellipse2D . Double ( v . getX ( ) , v . getY ( ) , v . getWidth ( ) , v . getHeight ( ) - y ) ; Ellipse2D l = new Ellipse2D . Double ( v . getX ( ) , v . getY ( ) + y , v . getWidth ( ) , v . getHeight ( ) - y ) ; Rectangle2D s = new Rectangle2D . Double ( q . getX ( ) , q . getCenterY ( ) , v . getWidth ( ) , l . getMaxY ( ) - q . getCenterY ( ) ) ; Rectangle2D a = new Rectangle2D . Double ( v . getX ( ) , q . getY ( ) , v . getWidth ( ) , l . getCenterY ( ) - q . getY ( ) ) ; Area b = new Area ( q ) ; b . add ( new Area ( s ) ) ; Area x = new Area ( l ) ; x . add ( new Area ( a ) ) ; Area q = new Area ( b ) ; q . intersect ( x ) ; Area k = new Area ( q ) ; k . subtract ( new Area ( q ) ) ; Area x = new Area ( q ) ; x . subtract ( new Area ( l ) ) ; / / draw the bottom circle int [ ] e ; int [ ] g ; y = new Arc2D . Double ( s , r + y , v . getWidth ( ) , v . getHeight ( ) - y , 0 , 360 , Arc2D . PIE ) ;  int b = j . size ( ) ; for ( int t = 0 ; t < b ; t + + ) { y = ( Arc2D . Double ) j . get ( t ) ; if ( y = = null ) { continue ; } Comparable q = getSectionKey ( t ) ; d = lookupSectionPaint ( q , true ) ; h = lookupSectionOutlinePaint ( q ) ; n = lookupSectionOutlineStroke ( q ) ; c . setPaint ( d ) ; c . fill ( y ) ; c . setPaint ( h ) ; c . setStroke ( n ) ; c . draw ( y ) ; c . setPaint ( d ) ;  Point2D c = y . getStartPoint ( ) ; / / draw the height e = new int [ ] { ( int ) y . getCenterX ( ) , ( int ) y . getCenterX ( ) , ( int ) c . getX ( ) , ( int ) c . getX ( ) } ; g = new int [ ] { ( int ) y . getCenterY ( ) , ( int ) y . getCenterY ( ) - y , ( int ) c . getY ( ) - y , ( int ) c . getY ( ) } ; Polygon r = new Polygon ( e , g , 4 ) ; c . setPaint ( java . awt . Color . lightGray ) ; c . fill ( r ) ; c . setPaint ( h ) ; c . setStroke ( n ) ; c . draw ( r ) ; c . setPaint ( d ) ; } c . setPaint ( Color . gray ) ; c . fill ( x ) ; c . fill ( k ) ; / / cycle through once drawing only the sides at the back . . . int n = 0 ; v = j . iterator ( ) ; while ( v . hasNext ( ) ) { Arc2D f = ( Arc2D ) v . next ( ) ; if ( f ! = null ) { Comparable l = getSectionKey ( n ) ; d = lookupSectionPaint ( l , true ) ; h = lookupSectionOutlinePaint ( l ) ; n = lookupSectionOutlineStroke ( l ) ; drawSide ( c , v , f , k , x , d , h , n , false , true ) ; } n + + ; } / / cycle through again drawing only the sides at the front . . . n = 0 ; v = j . iterator ( ) ; while ( v . hasNext ( ) ) { Arc2D k = ( Arc2D ) v . next ( ) ; if ( k ! = null ) { Comparable t = getSectionKey ( n ) ; d = lookupSectionPaint ( t ) ; h = lookupSectionOutlinePaint ( t ) ; n = lookupSectionOutlineStroke ( t ) ; drawSide ( c , v , k , k , x , d , h , n , true , false ) ; } n + + ; } c . setClip ( x ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D y ; for ( int h = 0 ; h < b ; h + + ) { y = ( Arc2D . Double ) j . get ( h ) ; if ( y = = null ) { continue ; } y = new Arc2D . Double ( s , r , v . getWidth ( ) , v . getHeight ( ) - y , y . getAngleStart ( ) , y . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable t = ( Comparable ) v . get ( h ) ; d = lookupSectionPaint ( t , true ) ; h = lookupSectionOutlinePaint ( t ) ; n = lookupSectionOutlineStroke ( t ) ; c . setPaint ( d ) ; c . fill ( y ) ; c . setStroke ( n ) ; c . setPaint ( h ) ; c . draw ( y ) ; / / add a tooltip for the section . . . if ( i ! = null ) { EntityCollection d = i . getOwner ( ) . getEntityCollection ( ) ; if ( d ! = null ) { String v = null ; PieToolTipGenerator e = getToolTipGenerator ( ) ; if ( e ! = null ) { / / @ mgs : using the method ' s return value was missing v = e . generateToolTip ( u , t ) ; } String j = null ; if ( getURLGenerator ( ) ! = null ) { j = getURLGenerator ( ) . generateURL ( u , t , getPieIndex ( ) ) ; } PieSectionEntity k = new PieSectionEntity ( y , u , getPieIndex ( ) , h , t , v , j ) ; d . add ( k ) ; } } List n = u . getKeys ( ) ; Rectangle2D g = new Rectangle2D . Double ( j . getX ( ) , j . getY ( ) , j . getWidth ( ) , j . getHeight ( ) - y ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( c , n , t , g , z , f ) ; } else { drawLabels ( c , n , t , g , z , f ) ; } } c . setClip ( q ) ; c . setComposite ( m ) ; drawOutline ( c , j ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double t , double s ) { return addOrUpdate ( new Double ( t ) , new Double ( s ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double j , double i ) { return addOrUpdate ( new Double ( i ) , new Double ( i ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int q , int r ) { Number s = null ; MeanAndStandardDeviation t = ( MeanAndStandardDeviation ) this . data . getObject ( q , r ) ; if ( t ! = null ) { s = t . getMean ( ) ; } return s ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int u , int r ) { Number t = null ; MeanAndStandardDeviation s = ( MeanAndStandardDeviation ) this . data . getObject ( u , r ) ; this . minimumRangeValue = Double . NaN ; return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod e , RegularTimePeriod c ) throws CloneNotSupportedException { if ( e = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( e . compareTo ( c ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean a = false ; int b = getIndex ( e ) ; if ( b < 0 ) { b = - ( b + 1 ) ; if ( b = = this . data . size ( ) ) { a = true ; / / start is after last data item } } int d = getIndex ( c ) ; if ( d < 0 ) { / / end period is not in original series d = - ( d + 1 ) ; / / this is first item AFTER end period d = d - 1 ; / / so this is last item BEFORE end } if ( d < 0 ) { a = true ; } if ( a ) { TimeSeries z = ( TimeSeries ) super . clone ( ) ; z . data = new java . util . ArrayList ( ) ; return z ; } else { return createCopy ( b , d ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod o , RegularTimePeriod p ) throws CloneNotSupportedException { if ( o = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( o . compareTo ( p ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean q = false ; int r = getIndex ( o ) ; if ( r < 0 ) { r = - ( r + 1 ) ; if ( r = = this . data . size ( ) ) { q = true ; / / start is after last data item } } int s = getIndex ( p ) ; if ( s < 0 ) { / / end period is not in original series s = - ( s + 1 ) ; / / this is first item AFTER end period s = s - 1 ; / / so this is last item BEFORE end } if ( s < 0 ) { q = true ; } if ( ( r = = 1 ) = = true ) { return this ; } if ( q ) { TimeSeries t = ( TimeSeries ) super . clone ( ) ; t . data = new java . util . ArrayList ( ) ; return t ; } else { return createCopy ( r , s ) ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer g , Graphics2D f , RectangleConstraint o ) { double [ ] k = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; k [ 0 ] = o . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( k [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D d = this . topBlock . arrange ( f , i ) ; h [ 0 ] = d . height ; } k [ 1 ] = k [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( k [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D b = this . bottomBlock . arrange ( f , n ) ; h [ 1 ] = b . height ; } h [ 2 ] = o . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . leftBlock . arrange ( f , e ) ; k [ 2 ] = j . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) - k [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D m = this . rightBlock . arrange ( f , l ) ; k [ 3 ] = m . width ; } h [ 4 ] = h [ 2 ] ; k [ 4 ] = o . getWidth ( ) - k [ 3 ] - k [ 2 ] ; RectangleConstraint c = new RectangleConstraint ( k [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( f , c ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , k [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , k [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , k [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( k [ 2 ] + k [ 4 ] , h [ 0 ] , k [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( k [ 2 ] , h [ 0 ] , k [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( o . getWidth ( ) , o . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer l , Graphics2D j , RectangleConstraint s ) { double [ ] u = new double [ 5 ] ; double [ ] r = new double [ 5 ] ; u [ 0 ] = s . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , s . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D q = this . topBlock . arrange ( j , o ) ; r [ 0 ] = q . height ; } u [ 1 ] = u [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( u [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , s . getHeight ( ) - r [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D v = this . bottomBlock . arrange ( j , p ) ; r [ 1 ] = v . height ; } r [ 2 ] = s . getHeight ( ) - r [ 1 ] - r [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , s . getWidth ( ) ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D w = this . leftBlock . arrange ( j , m ) ; } r [ 3 ] = r [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint n = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , s . getWidth ( ) - u [ 2 ] ) , LengthConstraintType . RANGE , r [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D k = this . rightBlock . arrange ( j , n ) ; u [ 3 ] = k . width ; } r [ 4 ] = r [ 2 ] ; u [ 4 ] = s . getWidth ( ) - u [ 3 ] - u [ 2 ] ; RectangleConstraint t = new RectangleConstraint ( u [ 4 ] , r [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( j , t ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , u [ 0 ] , r [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] + r [ 2 ] , u [ 1 ] , r [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , r [ 0 ] , u [ 2 ] , r [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] + u [ 4 ] , r [ 0 ] , u [ 3 ] , r [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( u [ 2 ] , r [ 0 ] , u [ 4 ] , r [ 4 ] ) ) ; } return new Size2D ( s . getWidth ( ) , s . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Range ( double i , double k ) { if ( i > k ) { String h = \" Range ( double , double ) : require lower ( \" + i + \" ) < = upper ( \" + k + \" ) . \" ; throw new IllegalArgumentException ( h ) ; } this . lower = i ; this . upper = k ; } } \\ No newline at end of file", "text_2": "public class test { public Range ( double c , double b ) { if ( c > b ) {  } this . lower = c ; this . upper = b ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object p ) { if ( ! ( p instanceof Range ) ) { return false ; } Range o = ( Range ) p ; if ( ! ( this . lower = = o . lower ) ) { return false ; } if ( ! ( this . upper = = o . upper ) ) { return false ; } return true ;", "text_2": "public class test { public boolean equals ( Object r ) { if ( ! ( r instanceof Range ) ) { return false ; } Range s = ( Range ) r ; if ( ! ( this . lower = = s . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = s . upper ) ) { return false ; } return true ;", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer z , Graphics2D v , RectangleConstraint u ) { double [ ] d = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; d [ 0 ] = u . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , u . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D b = this . topBlock . arrange ( v , c ) ; h [ 0 ] = b . height ; } d [ 1 ] = d [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( d [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , u . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D e = this . bottomBlock . arrange ( v , x ) ; h [ 1 ] = e . height ; } h [ 2 ] = u . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , u . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . leftBlock . arrange ( v , f ) ; d [ 2 ] = y . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , u . getWidth ( ) - d [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D a = this . rightBlock . arrange ( v , g ) ; d [ 3 ] = a . width ; } h [ 4 ] = h [ 2 ] ; d [ 4 ] = u . getWidth ( ) - d [ 3 ] - d [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( d [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( v , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , d [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , d [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , d [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] + d [ 4 ] , h [ 0 ] , d [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( d [ 2 ] , h [ 0 ] , d [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( u . getWidth ( ) , u . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D i , RectangleConstraint o ) { double [ ] f = new double [ 5 ] ; double [ ] k = new double [ 5 ] ; f [ 0 ] = o . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D l = this . topBlock . arrange ( i , h ) ; k [ 0 ] = l . height ; } f [ 1 ] = f [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( f [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , o . getHeight ( ) - k [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D g = this . bottomBlock . arrange ( i , q ) ; k [ 1 ] = g . height ; } k [ 2 ] = o . getHeight ( ) - k [ 1 ] - k [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D m = this . leftBlock . arrange ( i , p ) ; k [ 2 ] = m . width ; } k [ 3 ] = k [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , o . getWidth ( ) - f [ 2 ] ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( i , j ) ; f [ 3 ] = s . width ; } k [ 4 ] = k [ 2 ] ; f [ 4 ] = o . getWidth ( ) - f [ 3 ] - f [ 2 ] ; RectangleConstraint r = new RectangleConstraint ( f [ 4 ] , k [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( i , r ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , f [ 0 ] , k [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] + k [ 2 ] , f [ 1 ] , k [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] , f [ 2 ] , k [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] + f [ 4 ] , k [ 0 ] , f [ 3 ] , k [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( f [ 2 ] , k [ 0 ] , f [ 4 ] , k [ 4 ] ) ) ; } return new Size2D ( o . getWidth ( ) , o . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D i , RectangleConstraint q ) { double [ ] s = new double [ 5 ] ; double [ ] k = new double [ 5 ] ; s [ 0 ] = q . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D o = this . topBlock . arrange ( i , j ) ; k [ 0 ] = o . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint l = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) - k [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( i , l ) ; k [ 1 ] = m . height ; } k [ 2 ] = q . getHeight ( ) - k [ 1 ] - k [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D p = this . leftBlock . arrange ( i , t ) ; s [ 2 ] = p . width ; } k [ 3 ] = k [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , k [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D u = this . rightBlock . arrange ( i , r ) ; s [ 3 ] = u . width ; } k [ 4 ] = k [ 2 ] ; s [ 4 ] = q . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint v = new RectangleConstraint ( s [ 4 ] , k [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( i , v ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , k [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] + k [ 2 ] , s [ 1 ] , k [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , k [ 0 ] , s [ 2 ] , k [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , k [ 0 ] , s [ 3 ] , k [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , k [ 0 ] , s [ 4 ] , k [ 4 ] ) ) ; } return new Size2D ( q . getWidth ( ) , q . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer f , Graphics2D w , RectangleConstraint z ) { double [ ] v = new double [ 5 ] ; double [ ] s = new double [ 5 ] ; v [ 0 ] = z . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D a = this . topBlock . arrange ( w , d ) ; s [ 0 ] = a . height ; } v [ 1 ] = v [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , z . getHeight ( ) - s [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D u = this . bottomBlock . arrange ( w , x ) ; s [ 1 ] = u . height ; } s [ 2 ] = z . getHeight ( ) - s [ 1 ] - s [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) ) , LengthConstraintType . RANGE , s [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( w , e ) ; v [ 1 ] = b . width ; } s [ 3 ] = s [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , z . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , s [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . rightBlock . arrange ( w , t ) ; v [ 3 ] = y . width ; } s [ 4 ] = s [ 2 ] ; v [ 4 ] = z . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint c = new RectangleConstraint ( v [ 4 ] , s [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( w , c ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , s [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , s [ 0 ] + s [ 2 ] , v [ 1 ] , s [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , s [ 0 ] , v [ 2 ] , s [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , s [ 0 ] , v [ 3 ] , s [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , s [ 0 ] , v [ 4 ] , s [ 4 ] ) ) ; } return new Size2D ( z . getWidth ( ) , z . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number o , Number k ) { if ( o = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem l = null ; int p = indexOf ( o ) ; if ( p > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem m = ( XYDataItem ) this . data . get ( p ) ; try { l = ( XYDataItem ) m . clone ( ) ; } catch ( CloneNotSupportedException n ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } m . setY ( k ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - p - 1 , new XYDataItem ( o , k ) ) ; } else { this . data . add ( new XYDataItem ( o , k ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return l ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number w , Number v ) { if ( w = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem t = null ; int y = indexOf ( w ) ; if ( y > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem x = ( XYDataItem ) this . data . get ( y ) ; try { t = ( XYDataItem ) x . clone ( ) ; } catch ( CloneNotSupportedException u ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } x . setY ( v ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( t ! = null ) { this . data . add ( - y - 1 , new XYDataItem ( w , v ) ) ; } else { this . data . add ( new XYDataItem ( w , v ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D y , CategoryItemRendererState c , Rectangle2D t , CategoryPlot d , CategoryAxis z , ValueAxis x , CategoryDataset e , int w , int u , int v ) { / / defensive check if ( ! ( e instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset a = ( StatisticalCategoryDataset ) e ; PlotOrientation b = d . getOrientation ( ) ; if ( b = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( y , c , t , d , z , x , a , w , u ) ; } else if ( b = = PlotOrientation . VERTICAL ) { drawVerticalItem ( y , c , t , d , z , x , a , w , u ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D o , CategoryItemRendererState j , Rectangle2D q , CategoryPlot f , CategoryAxis p , ValueAxis k , CategoryDataset g , int m , int h , int n ) { / / defensive check if ( ! ( g instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset i = ( StatisticalCategoryDataset ) g ; PlotOrientation l = f . getOrientation ( ) ; if ( 0 = = - 1 ) if ( l = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( o , j , q , f , p , k , i , m , h ) ; } else if ( l = = PlotOrientation . VERTICAL ) { drawVerticalItem ( o , j , q , f , p , k , i , m , h ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer i , Graphics2D h , RectangleConstraint g ) { double [ ] j = new double [ 5 ] ; double [ ] a = new double [ 5 ] ; j [ 0 ] = g . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D d = this . topBlock . arrange ( h , c ) ; a [ 0 ] = d . height ; } j [ 1 ] = j [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , g . getHeight ( ) - a [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D e = this . bottomBlock . arrange ( h , z ) ; a [ 1 ] = e . height ; } a [ 2 ] = g . getHeight ( ) - a [ 1 ] - a [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D b = this . leftBlock . arrange ( h , k ) ; j [ 2 ] = b . width ; } a [ 3 ] = a [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , g . getWidth ( ) - j [ 2 ] ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . rightBlock . arrange ( h , y ) ; j [ 3 ] = l . width ; } a [ 4 ] = a [ 2 ] ; j [ 4 ] = g . getWidth ( ) - j [ 3 ] - j [ 2 ] ; RectangleConstraint f = new RectangleConstraint ( j [ 4 ] , a [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( h , f ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , j [ 0 ] , a [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] + a [ 2 ] , j [ 1 ] , a [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] , j [ 2 ] , a [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] + j [ 4 ] , a [ 0 ] , j [ 3 ] , a [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] , a [ 0 ] , j [ 4 ] , a [ 4 ] ) ) ; } return new Size2D ( g . getWidth ( ) , g . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer i , Graphics2D a , RectangleConstraint e ) { double [ ] y = new double [ 5 ] ; double [ ] f = new double [ 5 ] ; y [ 0 ] = e . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( y [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , e . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D g = this . topBlock . arrange ( a , w ) ; f [ 0 ] = g . height ; } y [ 1 ] = y [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( y [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , e . getHeight ( ) - f [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D b = this . bottomBlock . arrange ( a , x ) ; f [ 1 ] = b . height ; } f [ 2 ] = e . getHeight ( ) - f [ 1 ] - f [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , e . getWidth ( ) ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D d = this . leftBlock . arrange ( a , z ) ; y [ 2 ] = d . width ; } } f [ 3 ] = f [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint h = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , e . getWidth ( ) - y [ 2 ] ) , LengthConstraintType . RANGE , f [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D j = this . rightBlock . arrange ( a , h ) ; y [ 3 ] = j . width ; } f [ 4 ] = f [ 2 ] ; y [ 4 ] = e . getWidth ( ) - y [ 3 ] - y [ 2 ] ; RectangleConstraint c = new RectangleConstraint ( y [ 4 ] , f [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( a , c ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , y [ 0 ] , f [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] + f [ 2 ] , y [ 1 ] , f [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , f [ 0 ] , y [ 2 ] , f [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( y [ 2 ] + y [ 4 ] , f [ 0 ] , y [ 3 ] , f [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( y [ 2 ] , f [ 0 ] , y [ 4 ] , f [ 4 ] ) ) ; } return new Size2D ( e . getWidth ( ) , e . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer r , Graphics2D t , RectangleConstraint n ) { double [ ] v = new double [ 5 ] ; double [ ] p = new double [ 5 ] ; v [ 0 ] = n . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint j = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , n . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D u = this . topBlock . arrange ( t , j ) ; p [ 0 ] = u . height ; } v [ 1 ] = v [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , n . getHeight ( ) - p [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D m = this . bottomBlock . arrange ( t , k ) ; p [ 1 ] = m . height ; } p [ 2 ] = n . getHeight ( ) - p [ 1 ] - p [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint s = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , n . getWidth ( ) ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D w = this . leftBlock . arrange ( t , s ) ; v [ 2 ] = w . width ; } p [ 3 ] = p [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , n . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , p [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D q = this . rightBlock . arrange ( t , o ) ; v [ 3 ] = q . width ; } p [ 4 ] = p [ 2 ] ; v [ 4 ] = n . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint l = new RectangleConstraint ( v [ 4 ] , p [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( t , l ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , p [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] + p [ 2 ] , v [ 1 ] , p [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , p [ 0 ] , v [ 2 ] , p [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , p [ 0 ] , v [ 3 ] , p [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , p [ 0 ] , v [ 4 ] , p [ 4 ] ) ) ; } return new Size2D ( n . getWidth ( ) , n . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer r , Graphics2D u , RectangleConstraint x ) { this . rightBlock = null ; double [ ] z = new double [ 5 ] ; double [ ] b = new double [ 5 ] ; z [ 0 ] = x . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( z [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D p = this . topBlock . arrange ( u , o ) ; b [ 0 ] = p . height ; } z [ 1 ] = z [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( z [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) - b [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D a = this . bottomBlock . arrange ( u , w ) ; b [ 1 ] = a . height ; } b [ 2 ] = x . getHeight ( ) - b [ 1 ] - b [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint t = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . leftBlock . arrange ( u , t ) ; z [ 2 ] = v . width ; } b [ 3 ] = b [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) - z [ 2 ] ) , LengthConstraintType . RANGE , b [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( u , q ) ; z [ 3 ] = s . width ; } b [ 4 ] = b [ 2 ] ; z [ 4 ] = x . getWidth ( ) - z [ 3 ] - z [ 2 ] ; RectangleConstraint y = new RectangleConstraint ( z [ 4 ] , b [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( u , y ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , z [ 0 ] , b [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] + b [ 2 ] , z [ 1 ] , b [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , b [ 0 ] , z [ 2 ] , b [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( z [ 2 ] + z [ 4 ] , b [ 0 ] , z [ 3 ] , b [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( z [ 2 ] , b [ 0 ] , z [ 4 ] , b [ 4 ] ) ) ; } return new Size2D ( x . getWidth ( ) , x . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeValue ( int i ) { this . keys . remove ( i ) ; this . values . remove ( i ) ; if ( i < this . keys . size ( ) ) { rebuildIndex ( ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( int a ) { System . out . println ( \" Usage : snapshotconverter - - help \" ) ; System . out . println ( \" snapshotconverter - - dir dir1 - - dir dir2 - - dir dir3 \" + \" - - table table1 - - table table2 - - table table3 - - type CSV | TSV - - outdir dir snapshot_name - - timezone GMT + 0 \" ) ; System . exit ( a ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object g ) { for ( int f = 0 ; f < this . size ; f + + ) { if ( this . objects [ f ] = = g ) { return ( f ) ; } } return - 1 ; } } \\ No newline at end of file", "text_2": "public class test { protected int indexOf ( Object q ) { for ( int r = 0 ; r < this . size ; r + + ) { if ( this . objects [ r ] = = q ) { return ( r ) ; } } if ( q = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeSubtitle ( Title j ) { this . subtitles . remove ( j ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public MultiplePiePlot ( CategoryDataset l ) { super ( ) ; this . dataset = l ; PiePlot i = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( i ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle k = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; k . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( k ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title m ) { this . subtitles . remove ( m ) ; } public MultiplePiePlot ( CategoryDataset i ) { super ( ) ; this . dataset = i ; PiePlot l = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( l ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle j = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( i ! = null ) { setDatasetGroup ( i . getGroup ( ) ) ; i . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot k = getParent ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int r , int p ) { Number s = null ; MeanAndStandardDeviation q = ( MeanAndStandardDeviation ) this . data . getObject ( r , p ) ; if ( q ! = null ) { s = q . getMean ( ) ; } return s ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int f , int e ) { Number g = null ; MeanAndStandardDeviation h = ( MeanAndStandardDeviation ) this . data . getObject ( f , e ) ; if ( false ) { g = h . getMean ( ) ; } return g ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object q = createCopy ( 0 , getItemCount ( ) - 1 ) ; return q ; } } \\ No newline at end of file", "text_2": "public class test { public Object clone ( ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset g ) { super ( ) ; this . dataset = g ; PiePlot i = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( i ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle h = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; h . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( h ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset o ) { super ( ) ; this . dataset = o ; PiePlot p = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( p ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( o ! = null ) { setDatasetGroup ( o . getGroup ( ) ) ; o . addChangeListener ( this ) ; } TextTitle n = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; n . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( n ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection w = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return w ; } int v = this . plot . getIndexOf ( this ) ; CategoryDataset z = this . plot . getDataset ( v ) ; if ( z ! = null ) { return w ; } int x = z . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int a = 0 ; a < x ; a + + ) { if ( isSeriesVisibleInLegend ( a ) ) { LegendItem y = getLegendItem ( v , a ) ; if ( y ! = null ) { w . add ( y ) ; } } } } else { for ( int c = x - 1 ; c > = 0 ; c - - ) { if ( isSeriesVisibleInLegend ( c ) ) { LegendItem b = getLegendItem ( v , c ) ; if ( b ! = null ) { w . add ( b ) ; } } } } return w ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection r = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return r ; } int s = this . plot . getIndexOf ( this ) ; CategoryDataset q = this . plot . getDataset ( s ) ; if ( q ! = null ) { Paint o = plot . getOutlinePaint ( ) ; } int u = q . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int t = 0 ; t < u ; t + + ) { if ( isSeriesVisibleInLegend ( t ) ) { LegendItem v = getLegendItem ( s , t ) ; if ( v ! = null ) { r . add ( v ) ; } } } } else { for ( int p = u - 1 ; p > = 0 ; p - - ) { if ( isSeriesVisibleInLegend ( p ) ) { LegendItem w = getLegendItem ( s , p ) ; if ( w ! = null ) { r . add ( w ) ; } } } } return r ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D o , Rectangle2D k , Point2D f , PlotState l , PlotRenderingInfo t ) { / / if the plot area is too small , just return . . . boolean e = ( k . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean q = ( k . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( e | | q ) { return ; } / / record the plot area . . . if ( t = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes t = new PlotRenderingInfo ( null ) ; } t . setPlotArea ( k ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets s = getInsets ( ) ; s . trim ( k ) ; / / calculate the data area . . . AxisSpace g = calculateAxisSpace ( o , k ) ; Rectangle2D c = g . shrink ( k , null ) ; this . axisOffset . trim ( c ) ; t . setDataArea ( c ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( o , this , c ) ; } else { drawBackground ( o , c ) ; } Map u = drawAxes ( o , k , c , t ) ; / / don ' t let anyone draw outside the data area Shape i = o . getClip ( ) ; o . clip ( c ) ; drawDomainGridlines ( o , c ) ; AxisState a = ( AxisState ) u . get ( getRangeAxis ( ) ) ; if ( a = = null ) { if ( l ! = null ) { a = ( AxisState ) l . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( a ! = null ) { drawRangeGridlines ( o , c , a . getTicks ( ) ) ; } / / draw the markers . . . for ( int d = 0 ; d < this . renderers . size ( ) ; d + + ) { drawDomainMarkers ( o , c , d , Layer . BACKGROUND ) ; } for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawRangeMarkers ( o , c , b , Layer . BACKGROUND ) ; } / / now render data items . . . boolean v = false ; / / set up the alpha - transparency . . . Composite p = o . getComposite ( ) ; o . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder r = getDatasetRenderingOrder ( ) ; if ( r = = DatasetRenderingOrder . FORWARD ) { for ( int j = 0 ; j < this . datasets . size ( ) ; j + + ) { v = render ( o , c , j , t ) | | v ; } } else { / / DatasetRenderingOrder . REVERSE for ( int n = this . datasets . size ( ) - 1 ; n > = 0 ; n - - ) { v = render ( o , c , n , t ) | | v ; } } / / draw the foreground markers . . . for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawDomainMarkers ( o , c , h , Layer . FOREGROUND ) ; } for ( int m = 0 ; m < this . renderers . size ( ) ; m + + ) { drawRangeMarkers ( o , c , m , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( o , c ) ; o . setClip ( i ) ; o . setComposite ( p ) ; if ( ! v ) { drawNoDataMessage ( o , c ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( o , c , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( o , this , c ) ; } else { drawOutline ( o , c ) ; } }", "text_2": "public class test { public void draw ( Graphics2D q , Rectangle2D l , Point2D r , PlotState d , PlotRenderingInfo s ) { / / if the plot area is too small , just return . . . boolean m = ( l . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean y = ( l . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; } / / record the plot area . . . if ( s = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes s = new PlotRenderingInfo ( null ) ; } s . setPlotArea ( l ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets a = getInsets ( ) ; a . trim ( l ) ; / / calculate the data area . . . AxisSpace x = calculateAxisSpace ( q , l ) ; Rectangle2D k = x . shrink ( l , null ) ; this . axisOffset . trim ( k ) ; s . setDataArea ( k ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( q , this , k ) ; } else { drawBackground ( q , k ) ; } Map b = drawAxes ( q , l , k , s ) ; / / don ' t let anyone draw outside the data area Shape c = q . getClip ( ) ; q . clip ( k ) ; drawDomainGridlines ( q , k ) ; AxisState o = ( AxisState ) b . get ( getRangeAxis ( ) ) ; if ( o = = null ) { if ( d ! = null ) { o = ( AxisState ) d . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( o ! = null ) { drawRangeGridlines ( q , k , o . getTicks ( ) ) ; } / / draw the markers . . . for ( int p = 0 ; p < this . renderers . size ( ) ; p + + ) { drawDomainMarkers ( q , k , p , Layer . BACKGROUND ) ; } for ( int z = 0 ; z < this . renderers . size ( ) ; z + + ) { drawRangeMarkers ( q , k , z , Layer . BACKGROUND ) ; } / / now render data items . . . boolean t = false ; / / set up the alpha - transparency . . . Composite u = q . getComposite ( ) ; q . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder n = getDatasetRenderingOrder ( ) ; if ( n = = DatasetRenderingOrder . FORWARD ) { for ( int w = 0 ; w < this . datasets . size ( ) ; w + + ) { t = render ( q , k , w , s ) | | t ; } } else { / / DatasetRenderingOrder . REVERSE for ( int e = this . datasets . size ( ) - 1 ; e > = 0 ; e - - ) { t = render ( q , k , e , s ) | | t ; } } / / draw the foreground markers . . . for ( int f = 0 ; f < this . renderers . size ( ) ; f + + ) { drawDomainMarkers ( q , k , f , Layer . FOREGROUND ) ; } for ( int v = 0 ; v < this . renderers . size ( ) ; v + + ) { drawRangeMarkers ( q , k , v , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( q , k ) ; q . setClip ( c ) ; q . setComposite ( u ) ; if ( ! t ) { drawNoDataMessage ( q , k ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( q , k , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( q , this , k ) ; } else { drawOutline ( q , k ) ; } }", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset h ) { super ( ) ; this . dataset = h ; PiePlot j = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( j ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle i = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; i . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( i ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset o ) { super ( ) ; this . dataset = o ; PiePlot n = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( n ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle p = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; p . setPosition ( RectangleEdge . BOTTOM ) ; if ( o ! = null ) { setDatasetGroup ( o . getGroup ( ) ) ; o . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public void removeSubtitle ( Title e ) { this . subtitles . remove ( e ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title l ) { this . subtitles . remove ( l ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D i , Rectangle2D q , Point2D a , PlotState j , PlotRenderingInfo f ) { / / if the plot area is too small , just return . . . boolean d = ( q . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean e = ( q . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( d | | e ) { return ; } / / record the plot area . . . if ( f = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes f = new PlotRenderingInfo ( null ) ; } f . setPlotArea ( q ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets z = getInsets ( ) ; z . trim ( q ) ; / / calculate the data area . . . AxisSpace l = calculateAxisSpace ( i , q ) ; Rectangle2D m = l . shrink ( q , null ) ; this . axisOffset . trim ( m ) ; f . setDataArea ( m ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( i , this , m ) ; } else { drawBackground ( i , m ) ; } Map c = drawAxes ( i , q , m , f ) ; / / don ' t let anyone draw outside the data area Shape k = i . getClip ( ) ; i . clip ( m ) ; drawDomainGridlines ( i , m ) ; AxisState r = ( AxisState ) c . get ( getRangeAxis ( ) ) ; if ( r = = null ) { if ( j ! = null ) { r = ( AxisState ) j . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( r ! = null ) { drawRangeGridlines ( i , m , r . getTicks ( ) ) ; } / / draw the markers . . . for ( int x = 0 ; x < this . renderers . size ( ) ; x + + ) { drawDomainMarkers ( i , m , x , Layer . BACKGROUND ) ; } for ( int n = 0 ; n < this . renderers . size ( ) ; n + + ) { drawRangeMarkers ( i , m , n , Layer . BACKGROUND ) ; } / / now render data items . . . boolean o = false ; / / set up the alpha - transparency . . . Composite s = i . getComposite ( ) ; i . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder g = getDatasetRenderingOrder ( ) ; if ( g = = DatasetRenderingOrder . FORWARD ) { for ( int h = 0 ; h < this . datasets . size ( ) ; h + + ) { o = render ( i , m , h , f ) | | o ; } } else { / / DatasetRenderingOrder . REVERSE for ( int p = this . datasets . size ( ) - 1 ; p > = 0 ; p - - ) { o = render ( i , m , p , f ) | | o ; } } / / draw the foreground markers . . . for ( int y = 0 ; y < this . renderers . size ( ) ; y + + ) { drawDomainMarkers ( i , m , y , Layer . FOREGROUND ) ; } for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawRangeMarkers ( i , m , b , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( i , m ) ; i . setClip ( k ) ; i . setComposite ( s ) ; if ( ! o ) { drawNoDataMessage ( i , m ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( i , m , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( i , this , m ) ; } else { drawOutline ( i , m ) ; } }", "text_2": "public class test { public void draw ( Graphics2D l , Rectangle2D y , Point2D n , PlotState e , PlotRenderingInfo b ) { / / if the plot area is too small , just return . . . boolean f = ( y . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean v = ( y . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( f | | v ) { return ; } / / record the plot area . . . if ( b = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes b = new PlotRenderingInfo ( null ) ; } b . setPlotArea ( y ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets w = getInsets ( ) ; w . trim ( y ) ; / / calculate the data area . . . AxisSpace d = calculateAxisSpace ( l , y ) ; Rectangle2D c = d . shrink ( y , null ) ; this . axisOffset . trim ( c ) ; b . setDataArea ( c ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( l , this , c ) ; } else { drawBackground ( l , c ) ; } Map q = drawAxes ( l , y , c , null ) ; / / don ' t let anyone draw outside the data area Shape s = l . getClip ( ) ; l . clip ( c ) ; drawDomainGridlines ( l , c ) ; AxisState z = ( AxisState ) q . get ( getRangeAxis ( ) ) ; if ( z = = null ) { if ( e ! = null ) { z = ( AxisState ) e . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( z ! = null ) { drawRangeGridlines ( l , c , z . getTicks ( ) ) ; } / / draw the markers . . . for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawDomainMarkers ( l , c , u , Layer . BACKGROUND ) ; } for ( int g = 0 ; g < this . renderers . size ( ) ; g + + ) { drawRangeMarkers ( l , c , g , Layer . BACKGROUND ) ; } / / now render data items . . . boolean p = false ; / / set up the alpha - transparency . . . Composite t = l . getComposite ( ) ; l . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder r = getDatasetRenderingOrder ( ) ; if ( r = = DatasetRenderingOrder . FORWARD ) { for ( int x = 0 ; x < this . datasets . size ( ) ; x + + ) { p = render ( l , c , x , b ) | | p ; } } else { / / DatasetRenderingOrder . REVERSE for ( int a = this . datasets . size ( ) - 1 ; a > = 0 ; a - - ) { p = render ( l , c , a , b ) | | p ; } } / / draw the foreground markers . . . for ( int m = 0 ; m < this . renderers . size ( ) ; m + + ) { drawDomainMarkers ( l , c , m , Layer . FOREGROUND ) ; } for ( int o = 0 ; o < this . renderers . size ( ) ; o + + ) { drawRangeMarkers ( l , c , o , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( l , c ) ; l . setClip ( s ) ; l . setComposite ( t ) ; if ( ! p ) { drawNoDataMessage ( l , c ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( l , c , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( l , this , c ) ; } else { drawOutline ( l , c ) ; } }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection r = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return r ; } int o = this . plot . getIndexOf ( this ) ; CategoryDataset p = this . plot . getDataset ( o ) ; if ( p ! = null ) { return r ; } int n = p . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int t = 0 ; t < n ; t + + ) { if ( isSeriesVisibleInLegend ( t ) ) { LegendItem m = getLegendItem ( o , t ) ; if ( m ! = null ) { r . add ( m ) ; } } } } else { for ( int s = n - 1 ; s > = 0 ; s - - ) { if ( isSeriesVisibleInLegend ( s ) ) { LegendItem q = getLegendItem ( o , s ) ; if ( q ! = null ) { r . add ( q ) ; } } } } return r ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection l = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return l ; } int h = this . plot . getIndexOf ( this ) ; CategoryDataset f = this . plot . getDataset ( h ) ; if ( f ! = null ) { this . rowCount = f . getRowCount ( ) ; } int m = f . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int k = 0 ; k < m ; k + + ) { if ( isSeriesVisibleInLegend ( k ) ) { LegendItem i = getLegendItem ( h , k ) ; if ( i ! = null ) { l . add ( i ) ; } } } } else { for ( int g = m - 1 ; g > = 0 ; g - - ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem j = getLegendItem ( h , g ) ; if ( j ! = null ) { l . add ( j ) ; } } } } return l ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D s , Rectangle2D z , Point2D b , PlotState k , PlotRenderingInfo i ) { / / adjust for insets . . . RectangleInsets o = getInsets ( ) ; o . trim ( z ) ; Rectangle2D b = ( Rectangle2D ) z . clone ( ) ; if ( i ! = null ) { i . setPlotArea ( z ) ; i . setDataArea ( z ) ; } drawBackground ( s , z ) ; Shape j = s . getClip ( ) ; s . clip ( z ) ; / / adjust the plot area by the interior spacing value double d = getInteriorGap ( ) ; double o = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { o = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double t = z . getWidth ( ) * ( d + o ) * 2 . 0 ; double f = z . getHeight ( ) * d * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double n = z . getWidth ( ) * getInteriorGap ( ) ; double f = z . getHeight ( ) * getInteriorGap ( ) ; double s = z . getX ( ) + n ; double n = z . getMaxX ( ) - n ; double s = z . getY ( ) + f ; double f = z . getMaxY ( ) - f ; s . setPaint ( Color . lightGray ) ; s . draw ( new Rectangle2D . Double ( s , s , n - s , f - s ) ) ; } double d = z . getX ( ) + t / 2 ; double h = z . getY ( ) + f / 2 ; double k = z . getWidth ( ) - t ; double g = z . getHeight ( ) - f ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double v = Math . min ( k , g ) / 2 ; d = ( d + d + k ) / 2 - v ; h = ( h + h + g ) / 2 - v ; k = 2 * v ; g = 2 * v ; } PiePlotState t = initialise ( s , z , this , null , i ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D l = new Rectangle2D . Double ( d , h , k , g * ( 1 - this . depthFactor ) ) ; t . setLinkArea ( l ) ; if ( DEBUG_DRAW_LINK_AREA ) { s . setPaint ( Color . blue ) ; s . draw ( l ) ; s . setPaint ( Color . yellow ) ; s . draw ( new Ellipse2D . Double ( l . getX ( ) , l . getY ( ) , l . getWidth ( ) , l . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double z = k * getLabelLinkMargin ( ) ; double q = g * getLabelLinkMargin ( ) ; Rectangle2D w = new Rectangle2D . Double ( d + z / 2 . 0 , h + q / 2 . 0 , k - z , g - q ) ; t . setExplodedPieArea ( w ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double c = getMaximumExplodePercent ( ) ; double t = c / ( 1 . 0 + c ) ; double o = w . getWidth ( ) * t ; double a = w . getHeight ( ) * t ; Rectangle2D k = new Rectangle2D . Double ( w . getX ( ) + o / 2 . 0 , w . getY ( ) + a / 2 . 0 , w . getWidth ( ) - o , w . getHeight ( ) - a ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int l = ( int ) ( k . getHeight ( ) * this . depthFactor ) ; Rectangle2D b = new Rectangle2D . Double ( d , h , k , g - l ) ; t . setLinkArea ( b ) ; t . setPieArea ( k ) ; t . setPieCenterX ( k . getCenterX ( ) ) ; t . setPieCenterY ( k . getCenterY ( ) - l / 2 . 0 ) ; t . setPieWRadius ( k . getWidth ( ) / 2 . 0 ) ; t . setPieHRadius ( ( k . getHeight ( ) - l ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset d = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( s , z ) ; s . setClip ( j ) ; drawOutline ( s , z ) ; return ; } / / if too any elements if ( d . getKeys ( ) . size ( ) > z . getWidth ( ) ) { String b = \" Too many elements \" ; Font m = new Font ( \" dialog \" , Font . BOLD , 10 ) ; s . setFont ( m ) ; FontMetrics h = s . getFontMetrics ( m ) ; int c = h . stringWidth ( b ) ;  s . drawString ( b , ( int ) ( z . getX ( ) + ( z . getWidth ( ) - c ) / 2 ) , ( int ) ( z . getY ( ) + ( z . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double p = Math . min ( z . getWidth ( ) , z . getHeight ( ) ) / 2 ; z = new Rectangle2D . Double ( z . getCenterX ( ) - p , z . getCenterY ( ) - p , 2 * p , 2 * p ) ; } / / get a list of keys . . . List y = d . getKeys ( ) ; if ( y . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double n = k . getX ( ) ; double c = k . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite p = s . getComposite ( ) ; s . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double y = DatasetUtilities . calculatePieDatasetTotal ( d ) ; double y = 0 ; if ( l < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList i = new ArrayList ( ) ; Arc2D . Double v ; Paint g ; Paint e ; Stroke m ; Iterator h = y . iterator ( ) ; while ( h . hasNext ( ) ) { Comparable i = ( Comparable ) h . next ( ) ; Number x = d . getValue ( i ) ; if ( x = = null ) { i . add ( null ) ; continue ; } double v = x . doubleValue ( ) ; if ( v < = 0 ) { i . add ( null ) ; continue ; } double t = getStartAngle ( ) ; double e = getDirection ( ) . getFactor ( ) ; double s = t + ( e * ( y * 360 ) ) / y ; double r = t + ( e * ( y + v ) * 360 ) / y ; if ( Math . abs ( r - s ) > getMinimumArcAngleToDraw ( ) ) { i . add ( new Arc2D . Double ( n , c + l , k . getWidth ( ) , k . getHeight ( ) - l , s , r - s , Arc2D . PIE ) ) ; } else { i . add ( null ) ; } y + = v ; } Shape g = s . getClip ( ) ; Ellipse2D u = new Ellipse2D . Double ( k . getX ( ) , k . getY ( ) , k . getWidth ( ) , k . getHeight ( ) - l ) ; Ellipse2D u = new Ellipse2D . Double ( k . getX ( ) , k . getY ( ) + l , k . getWidth ( ) , k . getHeight ( ) - l ) ; Rectangle2D w = new Rectangle2D . Double ( u . getX ( ) , u . getCenterY ( ) , k . getWidth ( ) , u . getMaxY ( ) - u . getCenterY ( ) ) ; Rectangle2D w = new Rectangle2D . Double ( k . getX ( ) , u . getY ( ) , k . getWidth ( ) , u . getCenterY ( ) - u . getY ( ) ) ; Area a = new Area ( u ) ; a . add ( new Area ( w ) ) ; Area z = new Area ( u ) ; z . add ( new Area ( w ) ) ; Area d = new Area ( a ) ; d . intersect ( z ) ; Area u = new Area ( d ) ; u . subtract ( new Area ( u ) ) ; Area q = new Area ( d ) ; q . subtract ( new Area ( u ) ) ; / / draw the bottom circle int [ ] c ; int [ ] x ; v = new Arc2D . Double ( n , c + l , k . getWidth ( ) , k . getHeight ( ) - l , 0 , 360 , Arc2D . PIE ) ;  int w = i . size ( ) ; for ( int e = 0 ; e < w ; e + + ) { v = ( Arc2D . Double ) i . get ( e ) ; if ( v = = null ) { continue ; } Comparable q = getSectionKey ( e ) ; g = lookupSectionPaint ( q , true ) ; e = lookupSectionOutlinePaint ( q ) ; m = lookupSectionOutlineStroke ( q ) ; s . setPaint ( g ) ; s . fill ( v ) ; s . setPaint ( e ) ; s . setStroke ( m ) ; s . draw ( v ) ; s . setPaint ( g ) ;  Point2D j = v . getStartPoint ( ) ; / / draw the height c = new int [ ] { ( int ) v . getCenterX ( ) , ( int ) v . getCenterX ( ) , ( int ) j . getX ( ) , ( int ) j . getX ( ) } ; x = new int [ ] { ( int ) v . getCenterY ( ) , ( int ) v . getCenterY ( ) - l , ( int ) j . getY ( ) - l , ( int ) j . getY ( ) } ; Polygon r = new Polygon ( c , x , 4 ) ; s . setPaint ( java . awt . Color . lightGray ) ; s . fill ( r ) ; s . setPaint ( e ) ; s . setStroke ( m ) ; s . draw ( r ) ; s . setPaint ( g ) ; } s . setPaint ( Color . gray ) ; s . fill ( q ) ; s . fill ( u ) ; / / cycle through once drawing only the sides at the back . . . int x = 0 ; h = i . iterator ( ) ; while ( h . hasNext ( ) ) { Arc2D y = ( Arc2D ) h . next ( ) ; if ( y ! = null ) { Comparable l = getSectionKey ( x ) ; g = lookupSectionPaint ( l , true ) ; e = lookupSectionOutlinePaint ( l ) ; m = lookupSectionOutlineStroke ( l ) ; drawSide ( s , k , y , u , q , g , e , m , false , true ) ; } x + + ; } / / cycle through again drawing only the sides at the front . . . x = 0 ; h = i . iterator ( ) ; while ( h . hasNext ( ) ) { Arc2D e = ( Arc2D ) h . next ( ) ; if ( e ! = null ) { Comparable m = getSectionKey ( x ) ; g = lookupSectionPaint ( m ) ; e = lookupSectionOutlinePaint ( m ) ; m = lookupSectionOutlineStroke ( m ) ; drawSide ( s , k , e , u , q , g , e , m , true , false ) ; } x + + ; } s . setClip ( g ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D a ; for ( int a = 0 ; a < w ; a + + ) { v = ( Arc2D . Double ) i . get ( a ) ; if ( v = = null ) { continue ; } a = new Arc2D . Double ( n , c , k . getWidth ( ) , k . getHeight ( ) - l , v . getAngleStart ( ) , v . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable r = ( Comparable ) y . get ( a ) ; g = lookupSectionPaint ( r , true ) ; e = lookupSectionOutlinePaint ( r ) ; m = lookupSectionOutlineStroke ( r ) ; s . setPaint ( g ) ; s . fill ( a ) ; s . setStroke ( m ) ; s . setPaint ( e ) ; s . draw ( a ) ; / / add a tooltip for the section . . . if ( i ! = null ) { EntityCollection x = i . getOwner ( ) . getEntityCollection ( ) ; if ( x ! = null ) { String u = null ; PieToolTipGenerator v = getToolTipGenerator ( ) ; if ( v ! = null ) { / / @ mgs : using the method ' s return value was missing u = v . generateToolTip ( d , r ) ; } String f = null ; if ( getURLGenerator ( ) ! = null ) { f = getURLGenerator ( ) . generateURL ( d , r , getPieIndex ( ) ) ; } PieSectionEntity j = new PieSectionEntity ( a , d , getPieIndex ( ) , a , r , u , f ) ; x . add ( j ) ; } } List p = d . getKeys ( ) ; Rectangle2D z = new Rectangle2D . Double ( b . getX ( ) , b . getY ( ) , b . getWidth ( ) , b . getHeight ( ) - l ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( s , p , y , z , b , t ) ; } else { drawLabels ( s , p , y , z , b , t ) ; } } s . setClip ( j ) ; s . setComposite ( p ) ; drawOutline ( s , b ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D k , Rectangle2D d , Point2D y , PlotState a , PlotRenderingInfo p ) { / / adjust for insets . . . RectangleInsets t = getInsets ( ) ; t . trim ( d ) ; Rectangle2D v = ( Rectangle2D ) d . clone ( ) ; if ( p ! = null ) { p . setPlotArea ( d ) ; p . setDataArea ( d ) ; } drawBackground ( k , d ) ; Shape h = k . getClip ( ) ; k . clip ( d ) ; / / adjust the plot area by the interior spacing value double z = getInteriorGap ( ) ; double d = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { d = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double e = d . getWidth ( ) * ( z + d ) * 2 . 0 ; double x = d . getHeight ( ) * z * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double o = d . getWidth ( ) * getInteriorGap ( ) ; double i = d . getHeight ( ) * getInteriorGap ( ) ; double m = d . getX ( ) + o ; double d = d . getMaxX ( ) - o ; double z = d . getY ( ) + i ; double q = d . getMaxY ( ) - i ; k . setPaint ( Color . lightGray ) ; k . draw ( new Rectangle2D . Double ( m , z , d - m , q - z ) ) ; } double m = d . getX ( ) + e / 2 ; double p = d . getY ( ) + x / 2 ; double t = d . getWidth ( ) - e ; double g = d . getHeight ( ) - x ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double v = Math . min ( t , g ) / 2 ; m = ( m + m + t ) / 2 - v ; p = ( p + p + g ) / 2 - v ; t = 2 * v ; g = 2 * v ; } if ( true ) return ; PiePlotState r = initialise ( k , d , this , null , p ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D i = new Rectangle2D . Double ( m , p , t , g * ( 1 - this . depthFactor ) ) ; r . setLinkArea ( i ) ; if ( DEBUG_DRAW_LINK_AREA ) { k . setPaint ( Color . blue ) ; k . draw ( i ) ; k . setPaint ( Color . yellow ) ; k . draw ( new Ellipse2D . Double ( i . getX ( ) , i . getY ( ) , i . getWidth ( ) , i . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double u = t * getLabelLinkMargin ( ) ; double y = g * getLabelLinkMargin ( ) ; Rectangle2D h = new Rectangle2D . Double ( m + u / 2 . 0 , p + y / 2 . 0 , t - u , g - y ) ; r . setExplodedPieArea ( h ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin / / factor . double t = getMaximumExplodePercent ( ) ; double w = t / ( 1 . 0 + t ) ; double z = h . getWidth ( ) * w ; double w = h . getHeight ( ) * w ; Rectangle2D h = new Rectangle2D . Double ( h . getX ( ) + z / 2 . 0 , h . getY ( ) + w / 2 . 0 , h . getWidth ( ) - z , h . getHeight ( ) - w ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int v = ( int ) ( h . getHeight ( ) * this . depthFactor ) ; Rectangle2D e = new Rectangle2D . Double ( m , p , t , g - v ) ; r . setLinkArea ( e ) ; r . setPieArea ( h ) ; r . setPieCenterX ( h . getCenterX ( ) ) ; r . setPieCenterY ( h . getCenterY ( ) - v / 2 . 0 ) ; r . setPieWRadius ( h . getWidth ( ) / 2 . 0 ) ; r . setPieHRadius ( ( h . getHeight ( ) - v ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset c = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( k , d ) ; k . setClip ( h ) ; drawOutline ( k , d ) ; return ; } / / if too any elements if ( c . getKeys ( ) . size ( ) > d . getWidth ( ) ) { String l = \" Too many elements \" ; Font y = new Font ( \" dialog \" , Font . BOLD , 10 ) ; k . setFont ( y ) ; FontMetrics n = k . getFontMetrics ( y ) ; int a = n . stringWidth ( l ) ;  k . drawString ( l , ( int ) ( d . getX ( ) + ( d . getWidth ( ) - a ) / 2 ) , ( int ) ( d . getY ( ) + ( d . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double i = Math . min ( d . getWidth ( ) , d . getHeight ( ) ) / 2 ; d = new Rectangle2D . Double ( d . getCenterX ( ) - i , d . getCenterY ( ) - i , 2 * i , 2 * i ) ; } / / get a list of keys . . . List w = c . getKeys ( ) ; if ( w . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double c = h . getX ( ) ; double f = h . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite o = k . getComposite ( ) ; k . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double w = DatasetUtilities . calculatePieDatasetTotal ( c ) ; double k = 0 ; if ( v < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList n = new ArrayList ( ) ; Arc2D . Double z ; Paint b ; Paint j ; Stroke g ; Iterator p = w . iterator ( ) ; while ( p . hasNext ( ) ) { Comparable s = ( Comparable ) p . next ( ) ; Number x = c . getValue ( s ) ; if ( x = = null ) { n . add ( null ) ; continue ; } double r = x . doubleValue ( ) ; if ( r < = 0 ) { n . add ( null ) ; continue ; } double x = getStartAngle ( ) ; double n = getDirection ( ) . getFactor ( ) ; double m = x + ( n * ( k * 360 ) ) / w ; double j = x + ( n * ( k + r ) * 360 ) / w ; if ( Math . abs ( j - m ) > getMinimumArcAngleToDraw ( ) ) { n . add ( new Arc2D . Double ( c , f + v , h . getWidth ( ) , h . getHeight ( ) - v , m , j - m , Arc2D . PIE ) ) ; } else { n . add ( null ) ; } k + = r ; } Shape q = k . getClip ( ) ; Ellipse2D q = new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) , h . getWidth ( ) , h . getHeight ( ) - v ) ; Ellipse2D a = new Ellipse2D . Double ( h . getX ( ) , h . getY ( ) + v , h . getWidth ( ) , h . getHeight ( ) - v ) ; Rectangle2D h = new Rectangle2D . Double ( q . getX ( ) , q . getCenterY ( ) , h . getWidth ( ) , a . getMaxY ( ) - q . getCenterY ( ) ) ; Rectangle2D e = new Rectangle2D . Double ( h . getX ( ) , q . getY ( ) , h . getWidth ( ) , a . getCenterY ( ) - q . getY ( ) ) ; Area x = new Area ( q ) ; x . add ( new Area ( h ) ) ; Area f = new Area ( a ) ; f . add ( new Area ( e ) ) ; Area l = new Area ( x ) ; l . intersect ( f ) ; Area u = new Area ( l ) ; u . subtract ( new Area ( q ) ) ; Area f = new Area ( l ) ; f . subtract ( new Area ( a ) ) ; / / draw the bottom circle int [ ] g ; int [ ] v ; z = new Arc2D . Double ( c , f + v , h . getWidth ( ) , h . getHeight ( ) - v , 0 , 360 , Arc2D . PIE ) ;  int o = n . size ( ) ; for ( int e = 0 ; e < o ; e + + ) { z = ( Arc2D . Double ) n . get ( e ) ; if ( z = = null ) { continue ; } Comparable r = getSectionKey ( e ) ; b = lookupSectionPaint ( r , true ) ; j = lookupSectionOutlinePaint ( r ) ; g = lookupSectionOutlineStroke ( r ) ; k . setPaint ( b ) ; k . fill ( z ) ; k . setPaint ( j ) ; k . setStroke ( g ) ; k . draw ( z ) ; k . setPaint ( b ) ;  Point2D b = z . getStartPoint ( ) ; / / draw the height g = new int [ ] { ( int ) z . getCenterX ( ) , ( int ) z . getCenterX ( ) , ( int ) b . getX ( ) , ( int ) b . getX ( ) } ; v = new int [ ] { ( int ) z . getCenterY ( ) , ( int ) z . getCenterY ( ) - v , ( int ) b . getY ( ) - v , ( int ) b . getY ( ) } ; Polygon k = new Polygon ( g , v , 4 ) ; k . setPaint ( java . awt . Color . lightGray ) ; k . fill ( k ) ; k . setPaint ( j ) ; k . setStroke ( g ) ; k . draw ( k ) ; k . setPaint ( b ) ; } k . setPaint ( Color . gray ) ; k . fill ( f ) ; k . fill ( u ) ; / / cycle through once drawing only the sides at the back . . . int b = 0 ; p = n . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D j = ( Arc2D ) p . next ( ) ; if ( j ! = null ) { Comparable c = getSectionKey ( b ) ; b = lookupSectionPaint ( c , true ) ; j = lookupSectionOutlinePaint ( c ) ; g = lookupSectionOutlineStroke ( c ) ; drawSide ( k , h , j , u , f , b , j , g , false , true ) ; } b + + ; } / / cycle through again drawing only the sides at the front . . . b = 0 ; p = n . iterator ( ) ; while ( p . hasNext ( ) ) { Arc2D u = ( Arc2D ) p . next ( ) ; if ( u ! = null ) { Comparable y = getSectionKey ( b ) ; b = lookupSectionPaint ( y ) ; j = lookupSectionOutlinePaint ( y ) ; g = lookupSectionOutlineStroke ( y ) ; drawSide ( k , h , u , u , f , b , j , g , true , false ) ; } b + + ; } k . setClip ( q ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D g ; for ( int b = 0 ; b < o ; b + + ) { z = ( Arc2D . Double ) n . get ( b ) ; if ( z = = null ) { continue ; } g = new Arc2D . Double ( c , f , h . getWidth ( ) , h . getHeight ( ) - v , z . getAngleStart ( ) , z . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable c = ( Comparable ) w . get ( b ) ; b = lookupSectionPaint ( c , true ) ; j = lookupSectionOutlinePaint ( c ) ; g = lookupSectionOutlineStroke ( c ) ; k . setPaint ( b ) ; k . fill ( g ) ; k . setStroke ( g ) ; k . setPaint ( j ) ; k . draw ( g ) ; / / add a tooltip for the section . . . if ( p ! = null ) { EntityCollection u = p . getOwner ( ) . getEntityCollection ( ) ; if ( u ! = null ) { String s = null ; PieToolTipGenerator s = getToolTipGenerator ( ) ; if ( s ! = null ) { / / @ mgs : using the method ' s return value was missing s = s . generateToolTip ( c , c ) ; } String f = null ; if ( getURLGenerator ( ) ! = null ) { f = getURLGenerator ( ) . generateURL ( c , c , getPieIndex ( ) ) ; } PieSectionEntity a = new PieSectionEntity ( g , c , getPieIndex ( ) , b , c , s , f ) ; u . add ( a ) ; } } List d = c . getKeys ( ) ; Rectangle2D l = new Rectangle2D . Double ( v . getX ( ) , v . getY ( ) , v . getWidth ( ) , v . getHeight ( ) - v ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( k , d , w , l , e , r ) ; } else { drawLabels ( k , d , w , l , e , r ) ; } } k . setClip ( h ) ; k . setComposite ( o ) ; drawOutline ( k , v ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number t , Number y ) { if ( t = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem u = null ; int w = indexOf ( t ) ; if ( w > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem v = ( XYDataItem ) this . data . get ( w ) ; try { u = ( XYDataItem ) v . clone ( ) ; } catch ( CloneNotSupportedException x ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } v . setY ( y ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - w - 1 , new XYDataItem ( t , y ) ) ; } else { this . data . add ( new XYDataItem ( t , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return u ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number d , Number f ) { if ( d = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem h = null ; int c = indexOf ( d ) ; if ( c > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem g = ( XYDataItem ) this . data . get ( c ) ; try { h = ( XYDataItem ) g . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } g . setY ( f ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( d , f ) ) ; } else { this . data . add ( new XYDataItem ( d , f ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return h ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public TimeSeries createCopy ( RegularTimePeriod g , RegularTimePeriod f ) throws CloneNotSupportedException { if ( g = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( f = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( g . compareTo ( f ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean e = false ; int h = getIndex ( g ) ; if ( h < 0 ) { h = - ( h + 1 ) ; if ( h = = this . data . size ( ) ) { e = true ; / / start is after last data item } } int j = getIndex ( f ) ; if ( j < 0 ) { / / end period is not in original series j = - ( j + 1 ) ; / / this is first item AFTER end period j = j - 1 ; / / so this is last item BEFORE end } if ( j < 0 ) { e = true ; } if ( e ) { TimeSeries i = ( TimeSeries ) super . clone ( ) ; i . data = new java . util . ArrayList ( ) ; return i ; } else { return createCopy ( h , j ) ; } }", "text_2": "public class test { public TimeSeries createCopy ( RegularTimePeriod j , RegularTimePeriod k ) throws CloneNotSupportedException { if ( j = = null ) { throw new IllegalArgumentException ( \" Null ' start ' argument . \" ) ; } if ( k = = null ) { throw new IllegalArgumentException ( \" Null ' end ' argument . \" ) ; } if ( j . compareTo ( k ) > 0 ) { throw new IllegalArgumentException ( \" Requires start on or before end . \" ) ; } boolean n = false ; int i = getIndex ( j ) ; if ( i < 0 ) { i = - ( i + 1 ) ; if ( i = = this . data . size ( ) ) { n = true ; / / start is after last data item } } int l = getIndex ( k ) ; if ( l < 0 ) { / / end period is not in original series l = - ( l + 1 ) ; / / this is first item AFTER end period l = l - 1 ; / / so this is last item BEFORE end } if ( ( i = = 1 ) = = true ) { return this ;  } if ( l < 0 ) { n = true ; } if ( n ) { TimeSeries m = ( TimeSeries ) super . clone ( ) ; m . data = new java . util . ArrayList ( ) ; return m ; } else { return createCopy ( i , l ) ; } }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection b = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return b ; } int v = this . plot . getIndexOf ( this ) ; CategoryDataset u = this . plot . getDataset ( v ) ; if ( u ! = null ) { return b ; } int z = u . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int w = 0 ; w < z ; w + + ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem x = getLegendItem ( v , w ) ; if ( x ! = null ) { b . add ( x ) ; } } } } else { for ( int y = z - 1 ; y > = 0 ; y - - ) { if ( isSeriesVisibleInLegend ( y ) ) { LegendItem a = getLegendItem ( v , y ) ; if ( a ! = null ) { b . add ( a ) ; } } } } return b ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection t = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return t ; } int x = this . plot . getIndexOf ( this ) ; CategoryDataset y = this . plot . getDataset ( x ) ; if ( ( y ! = null ) & & ( x ! = 0 ) ) { return t ; } int w = y . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int a = 0 ; a < w ; a + + ) { if ( isSeriesVisibleInLegend ( a ) ) { LegendItem u = getLegendItem ( x , a ) ; if ( u ! = null ) { t . add ( u ) ; } } } } else { for ( int z = w - 1 ; z > = 0 ; z - - ) { if ( isSeriesVisibleInLegend ( z ) ) { LegendItem v = getLegendItem ( x , z ) ; if ( v ! = null ) { t . add ( v ) ; } } } } return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int y , CategoryDataset f ) { CategoryDataset i = ( CategoryDataset ) this . datasets . get ( y ) ; if ( i ! = null ) { i . removeChangeListener ( this ) ; } this . datasets . set ( y , f ) ; if ( f ! = null ) { f . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent g = new DatasetChangeEvent ( this , f , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( g ) ; } public ValueAxis getRangeAxis ( int e ) { ValueAxis j = null ; if ( e < this . rangeAxes . size ( ) ) { j = ( ValueAxis ) this . rangeAxes . get ( e ) ; } if ( j = = null ) { Plot m = getParent ( ) ; if ( m instanceof CategoryPlot ) { CategoryPlot l = ( CategoryPlot ) m ; j = l . getRangeAxis ( e ) ; } } return j ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection k = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return k ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset z = this . plot . getDataset ( d ) ; if ( z ! = null ) { return k ; } int h = z . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int a = 0 ; a < h ; a + + ) { if ( isSeriesVisibleInLegend ( a ) ) { LegendItem b = getLegendItem ( d , a ) ; if ( b ! = null ) { k . add ( b ) ; } } } } else { for ( int n = h - 1 ; n > = 0 ; n - - ) { if ( isSeriesVisibleInLegend ( n ) ) { LegendItem c = getLegendItem ( d , n ) ; if ( c ! = null ) { k . add ( c ) ; } } } } return k ; } } \\ No newline at end of file", "text_2": "public class test { public void setDataset ( int r , CategoryDataset u ) { Object c = null ; CategoryDataset o = ( CategoryDataset ) this . datasets . get ( r ) ; if ( o ! = null ) { o . removeChangeListener ( this ) ; } this . datasets . set ( r , u ) ; if ( u ! = null ) { u . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent y = new DatasetChangeEvent ( this , u , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( y ) ; } public ValueAxis getRangeAxis ( int z ) { ValueAxis d = null ; if ( z < this . rangeAxes . size ( ) ) { d = ( ValueAxis ) this . rangeAxes . get ( z ) ; } if ( d = = null ) { CategoryAxis x = ( CategoryAxis ) this . domainAxes . get ( z ) ; Plot s = getParent ( ) ; if ( s instanceof CategoryPlot ) { CategoryPlot b = ( CategoryPlot ) s ; d = b . getRangeAxis ( z ) ; } } return d ; } public LegendItemCollection getLegendItems ( ) { LegendItemCollection t = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return t ; } int v = this . plot . getIndexOf ( this ) ; CategoryDataset w = this . plot . getDataset ( v ) ; if ( w ! = null ) { Paint n = plot . getOutlinePaint ( ) ; } int p = w . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int m = 0 ; m < p ; m + + ) { if ( isSeriesVisibleInLegend ( m ) ) { LegendItem q = getLegendItem ( v , m ) ; if ( q ! = null ) { t . add ( q ) ; } } } } else { for ( int e = p - 1 ; e > = 0 ; e - - ) { if ( isSeriesVisibleInLegend ( e ) ) { LegendItem a = getLegendItem ( v , e ) ; if ( a ! = null ) { t . add ( a ) ; } } } } return t ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection j = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return j ; } int e = this . plot . getIndexOf ( this ) ; CategoryDataset i = this . plot . getDataset ( e ) ; if ( i ! = null ) { return j ; } int k = i . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int h = 0 ; h < k ; h + + ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem f = getLegendItem ( e , h ) ; if ( f ! = null ) { j . add ( f ) ; } } } } else { for ( int d = k - 1 ; d > = 0 ; d - - ) { if ( isSeriesVisibleInLegend ( d ) ) { LegendItem g = getLegendItem ( e , d ) ; if ( g ! = null ) { j . add ( g ) ; } } } } return j ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return v ; } int w = this . plot . getIndexOf ( this ) ; CategoryDataset u = this . plot . getDataset ( w ) ; int r = u . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int s = 0 ; s < r ; s + + ) { if ( isSeriesVisibleInLegend ( s ) ) { LegendItem x = getLegendItem ( w , s ) ; if ( x ! = null ) { v . add ( x ) ; } } } } else { for ( int t = r - 1 ; t > = 0 ; t - - ) { if ( isSeriesVisibleInLegend ( t ) ) { LegendItem q = getLegendItem ( w , t ) ; if ( q ! = null ) { v . add ( q ) ; } } } } return v ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public static JFreeChart createPieChart3D ( String q , PieDataset n , boolean o , boolean p , boolean m ) { PiePlot3D r = new PiePlot3D ( n ) ; r . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( p ) { r . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( m ) { r . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( q , JFreeChart . DEFAULT_TITLE_FONT , r , o ) ; } } \\ No newline at end of file", "text_2": "public class test { public static JFreeChart createPieChart3D ( String a , PieDataset z , boolean x , boolean v , boolean w ) { RingPlot y = new RingPlot ( z ) ; y . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( v ) { y . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; } if ( w ) { y . setURLGenerator ( new StandardPieURLGenerator ( ) ) ; } return new JFreeChart ( a , JFreeChart . DEFAULT_TITLE_FONT , y , x ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void drawItem ( Graphics2D q , CategoryItemRendererState f , Rectangle2D k , CategoryPlot l , CategoryAxis o , ValueAxis m , CategoryDataset g , int h , int n , int p ) { / / defensive check if ( ! ( g instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset i = ( StatisticalCategoryDataset ) g ; PlotOrientation j = l . getOrientation ( ) ; if ( j = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( q , f , k , l , o , m , i , h , n ) ; } else if ( j = = PlotOrientation . VERTICAL ) { drawVerticalItem ( q , f , k , l , o , m , i , h , n ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void drawItem ( Graphics2D b , CategoryItemRendererState z , Rectangle2D w , CategoryPlot c , CategoryAxis u , ValueAxis d , CategoryDataset y , int a , int f , int v ) { / / defensive check if ( ! ( y instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset x = ( StatisticalCategoryDataset ) y ; PlotOrientation e = c . getOrientation ( ) ; if ( false ) { if ( e = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( b , z , w , c , u , d , x , a , f ) ; } else if ( e = = PlotOrientation . VERTICAL ) { drawVerticalItem ( b , z , w , c , u , d , x , a , f ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D s , Rectangle2D v , Point2D k , PlotState v , PlotRenderingInfo q ) { / / adjust for insets . . . RectangleInsets n = getInsets ( ) ; n . trim ( v ) ; Rectangle2D k = ( Rectangle2D ) v . clone ( ) ; if ( q ! = null ) { q . setPlotArea ( v ) ; q . setDataArea ( v ) ; } drawBackground ( s , v ) ; Shape n = s . getClip ( ) ; s . clip ( v ) ; / / adjust the plot area by the interior spacing value double b = getInteriorGap ( ) ; double n = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { n = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double l = v . getWidth ( ) * ( b + n ) * 2 . 0 ; double s = v . getHeight ( ) * b * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double x = v . getWidth ( ) * getInteriorGap ( ) ; double r = v . getHeight ( ) * getInteriorGap ( ) ; double h = v . getX ( ) + x ; double a = v . getMaxX ( ) - x ; double w = v . getY ( ) + r ; double l = v . getMaxY ( ) - r ; s . setPaint ( Color . lightGray ) ; s . draw ( new Rectangle2D . Double ( h , w , a - h , l - w ) ) ; } double i = v . getX ( ) + l / 2 ; double t = v . getY ( ) + s / 2 ; double p = v . getWidth ( ) - l ; double m = v . getHeight ( ) - s ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double f = Math . min ( p , m ) / 2 ; i = ( i + i + p ) / 2 - f ; t = ( t + t + m ) / 2 - f ; p = 2 * f ; m = 2 * f ; } PiePlotState e = initialise ( s , v , this , null , q ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D d = new Rectangle2D . Double ( i , t , p , m * ( 1 - this . depthFactor ) ) ; e . setLinkArea ( d ) ; if ( DEBUG_DRAW_LINK_AREA ) { s . setPaint ( Color . blue ) ; s . draw ( d ) ; s . setPaint ( Color . yellow ) ; s . draw ( new Ellipse2D . Double ( d . getX ( ) , d . getY ( ) , d . getWidth ( ) , d . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double s = p * getLabelLinkMargin ( ) ; double y = m * getLabelLinkMargin ( ) ; Rectangle2D k = new Rectangle2D . Double ( i + s / 2 . 0 , t + y / 2 . 0 , p - s , m - y ) ; e . setExplodedPieArea ( k ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin double c = getMaximumExplodePercent ( ) ; double o = c / ( 1 . 0 + c ) ; double v = k . getWidth ( ) * o ; double i = k . getHeight ( ) * o ; Rectangle2D s = new Rectangle2D . Double ( k . getX ( ) + v / 2 . 0 , k . getY ( ) + i / 2 . 0 , k . getWidth ( ) - v , k . getHeight ( ) - i ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int t = ( int ) ( s . getHeight ( ) * this . depthFactor ) ; Rectangle2D w = new Rectangle2D . Double ( i , t , p , m - t ) ; e . setLinkArea ( w ) ; e . setPieArea ( s ) ; e . setPieCenterX ( s . getCenterX ( ) ) ; e . setPieCenterY ( s . getCenterY ( ) - t / 2 . 0 ) ; e . setPieWRadius ( s . getWidth ( ) / 2 . 0 ) ; e . setPieHRadius ( ( s . getHeight ( ) - t ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset f = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( s , v ) ; s . setClip ( n ) ; drawOutline ( s , v ) ; return ; } / / if too any elements if ( f . getKeys ( ) . size ( ) > v . getWidth ( ) ) { String o = \" Too many elements \" ; Font u = new Font ( \" dialog \" , Font . BOLD , 10 ) ; s . setFont ( u ) ; FontMetrics g = s . getFontMetrics ( u ) ; int f = g . stringWidth ( o ) ;  s . drawString ( o , ( int ) ( v . getX ( ) + ( v . getWidth ( ) - f ) / 2 ) , ( int ) ( v . getY ( ) + ( v . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double a = Math . min ( v . getWidth ( ) , v . getHeight ( ) ) / 2 ; v = new Rectangle2D . Double ( v . getCenterX ( ) - a , v . getCenterY ( ) - a , 2 * a , 2 * a ) ; } / / get a list of keys . . . List u = f . getKeys ( ) ; if ( u . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double b = s . getX ( ) ; double g = s . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite i = s . getComposite ( ) ; s . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double u = DatasetUtilities . calculatePieDatasetTotal ( f ) ; double h = 0 ; if ( t < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList q = new ArrayList ( ) ; Arc2D . Double w ; Paint c ; Paint j ; Stroke m ; Iterator y = u . iterator ( ) ; while ( y . hasNext ( ) ) { Comparable t = ( Comparable ) y . next ( ) ; Number e = f . getValue ( t ) ; if ( e = = null ) { q . add ( null ) ; continue ; } double z = e . doubleValue ( ) ; if ( z < = 0 ) { q . add ( null ) ; continue ; } double q = getStartAngle ( ) ; double p = getDirection ( ) . getFactor ( ) ; double z = q + ( p * ( h * 360 ) ) / u ; double y = q + ( p * ( h + z ) * 360 ) / u ; if ( Math . abs ( y - z ) > getMinimumArcAngleToDraw ( ) ) { q . add ( new Arc2D . Double ( b , g + t , s . getWidth ( ) , s . getHeight ( ) - t , z , y - z , Arc2D . PIE ) ) ; } else { q . add ( null ) ; } h + = z ; } Shape d = s . getClip ( ) ; Ellipse2D g = new Ellipse2D . Double ( s . getX ( ) , s . getY ( ) , s . getWidth ( ) , s . getHeight ( ) - t ) ; Ellipse2D r = new Ellipse2D . Double ( s . getX ( ) , s . getY ( ) + t , s . getWidth ( ) , s . getHeight ( ) - t ) ; Rectangle2D l = new Rectangle2D . Double ( g . getX ( ) , g . getCenterY ( ) , s . getWidth ( ) , r . getMaxY ( ) - g . getCenterY ( ) ) ; Rectangle2D j = new Rectangle2D . Double ( s . getX ( ) , g . getY ( ) , s . getWidth ( ) , r . getCenterY ( ) - g . getY ( ) ) ; Area e = new Area ( g ) ; e . add ( new Area ( l ) ) ; Area x = new Area ( r ) ; x . add ( new Area ( j ) ) ; Area j = new Area ( e ) ; j . intersect ( x ) ; Area t = new Area ( j ) ; t . subtract ( new Area ( g ) ) ; Area q = new Area ( j ) ; q . subtract ( new Area ( r ) ) ; / / draw the bottom circle int [ ] m ; int [ ] x ; w = new Arc2D . Double ( b , g + t , s . getWidth ( ) , s . getHeight ( ) - t , 0 , 360 , Arc2D . PIE ) ;  int g = q . size ( ) ; for ( int o = 0 ; o < g ; o + + ) { w = ( Arc2D . Double ) q . get ( o ) ; if ( w = = null ) { continue ; } Comparable p = getSectionKey ( o ) ; c = lookupSectionPaint ( p , true ) ; j = lookupSectionOutlinePaint ( p ) ; m = lookupSectionOutlineStroke ( p ) ; s . setPaint ( c ) ; s . fill ( w ) ; s . setPaint ( j ) ; s . setStroke ( m ) ; s . draw ( w ) ; s . setPaint ( c ) ;  Point2D b = w . getStartPoint ( ) ; / / draw the height m = new int [ ] { ( int ) w . getCenterX ( ) , ( int ) w . getCenterX ( ) , ( int ) b . getX ( ) , ( int ) b . getX ( ) } ; x = new int [ ] { ( int ) w . getCenterY ( ) , ( int ) w . getCenterY ( ) - t , ( int ) b . getY ( ) - t , ( int ) b . getY ( ) } ; Polygon h = new Polygon ( m , x , 4 ) ; s . setPaint ( java . awt . Color . lightGray ) ; s . fill ( h ) ; s . setPaint ( j ) ; s . setStroke ( m ) ; s . draw ( h ) ; s . setPaint ( c ) ; } s . setPaint ( Color . gray ) ; s . fill ( q ) ; s . fill ( t ) ; / / cycle through once drawing only the sides at the back . . . int a = 0 ; y = q . iterator ( ) ; while ( y . hasNext ( ) ) { Arc2D o = ( Arc2D ) y . next ( ) ; if ( o ! = null ) { Comparable n = getSectionKey ( a ) ; c = lookupSectionPaint ( n , true ) ; j = lookupSectionOutlinePaint ( n ) ; m = lookupSectionOutlineStroke ( n ) ; drawSide ( s , s , o , t , q , c , j , m , false , true ) ; } a + + ; } / / cycle through again drawing only the sides at the front . . . a = 0 ; y = q . iterator ( ) ; while ( y . hasNext ( ) ) { Arc2D l = ( Arc2D ) y . next ( ) ; if ( l ! = null ) { Comparable k = getSectionKey ( a ) ; c = lookupSectionPaint ( k ) ; j = lookupSectionOutlinePaint ( k ) ; m = lookupSectionOutlineStroke ( k ) ; drawSide ( s , s , l , t , q , c , j , m , true , false ) ; } a + + ; } s . setClip ( d ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D m ; for ( int p = 0 ; p < g ; p + + ) { w = ( Arc2D . Double ) q . get ( p ) ; if ( w = = null ) { continue ; } m = new Arc2D . Double ( b , g , s . getWidth ( ) , s . getHeight ( ) - t , w . getAngleStart ( ) , w . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable r = ( Comparable ) u . get ( p ) ; c = lookupSectionPaint ( r , true ) ; j = lookupSectionOutlinePaint ( r ) ; m = lookupSectionOutlineStroke ( r ) ; s . setPaint ( c ) ; s . fill ( m ) ; s . setStroke ( m ) ; s . setPaint ( j ) ; s . draw ( m ) ; / / add a tooltip for the section . . . if ( q ! = null ) { EntityCollection i = q . getOwner ( ) . getEntityCollection ( ) ; if ( i ! = null ) { String d = null ; PieToolTipGenerator c = getToolTipGenerator ( ) ; if ( c ! = null ) { / / @ mgs : using the method ' s return value was missing d = c . generateToolTip ( f , r ) ; } String r = null ; if ( getURLGenerator ( ) ! = null ) { r = getURLGenerator ( ) . generateURL ( f , r , getPieIndex ( ) ) ; } PieSectionEntity j = new PieSectionEntity ( m , f , getPieIndex ( ) , p , r , d , r ) ; i . add ( j ) ; } } List h = f . getKeys ( ) ; Rectangle2D z = new Rectangle2D . Double ( k . getX ( ) , k . getY ( ) , k . getWidth ( ) , k . getHeight ( ) - t ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( s , h , u , z , w , e ) ; } else { drawLabels ( s , h , u , z , w , e ) ; } } s . setClip ( n ) ; s . setComposite ( i ) ; drawOutline ( s , k ) ; } } \\ No newline at end of file", "text_2": "public class test { public void draw ( Graphics2D m , Rectangle2D a , Point2D y , PlotState q , PlotRenderingInfo v ) { / / adjust for insets . . . RectangleInsets i = getInsets ( ) ; i . trim ( a ) ; Rectangle2D b = ( Rectangle2D ) a . clone ( ) ; if ( v ! = null ) { v . setPlotArea ( a ) ; v . setDataArea ( a ) ; } drawBackground ( m , a ) ; Shape k = m . getClip ( ) ; m . clip ( a ) ; / / adjust the plot area by the interior spacing value double b = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( m , a ) ; m . setClip ( k ) ; drawOutline ( m , a ) ; return ; }  double r = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { r = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double r = a . getWidth ( ) * ( b + r ) * 2 . 0 ; double z = a . getHeight ( ) * b * 2 . 0 ; if ( DEBUG_DRAW_INTERIOR ) { double v = a . getWidth ( ) * getInteriorGap ( ) ; double h = a . getHeight ( ) * getInteriorGap ( ) ; double e = a . getX ( ) + v ; double x = a . getMaxX ( ) - v ; double x = a . getY ( ) + h ; double m = a . getMaxY ( ) - h ; m . setPaint ( Color . lightGray ) ; m . draw ( new Rectangle2D . Double ( e , x , x - e , m - x ) ) ; } double s = a . getX ( ) + r / 2 ; double f = a . getY ( ) + z / 2 ; double w = a . getWidth ( ) - r ; double k = a . getHeight ( ) - z ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double g = Math . min ( w , k ) / 2 ; s = ( s + s + w ) / 2 - g ; f = ( f + f + k ) / 2 - g ; w = 2 * g ; k = 2 * g ; } PiePlotState e = initialise ( m , a , this , null , v ) ; / / the link area defines the dog leg points for the linking lines to / / the labels Rectangle2D w = new Rectangle2D . Double ( s , f , w , k * ( 1 - this . depthFactor ) ) ; e . setLinkArea ( w ) ; if ( DEBUG_DRAW_LINK_AREA ) { m . setPaint ( Color . blue ) ; m . draw ( w ) ; m . setPaint ( Color . yellow ) ; m . draw ( new Ellipse2D . Double ( w . getX ( ) , w . getY ( ) , w . getWidth ( ) , w . getHeight ( ) ) ) ; } / / the explode area defines the max circle / ellipse for the exploded pie / / sections . / / it is defined by shrinking the linkArea by the linkMargin factor . double n = w * getLabelLinkMargin ( ) ; double j = k * getLabelLinkMargin ( ) ; Rectangle2D l = new Rectangle2D . Double ( s + n / 2 . 0 , f + j / 2 . 0 , w - n , k - j ) ; e . setExplodedPieArea ( l ) ; / / the pie area defines the circle / ellipse for regular pie sections . / / it is defined by shrinking the explodeArea by the explodeMargin double c = getMaximumExplodePercent ( ) ; double o = c / ( 1 . 0 + c ) ; double f = l . getWidth ( ) * o ; double j = l . getHeight ( ) * o ; Rectangle2D z = new Rectangle2D . Double ( l . getX ( ) + f / 2 . 0 , l . getY ( ) + j / 2 . 0 , l . getWidth ( ) - f , l . getHeight ( ) - j ) ; / / the link area defines the dog - leg point for the linking lines to / / the labels int h = ( int ) ( z . getHeight ( ) * this . depthFactor ) ; Rectangle2D u = new Rectangle2D . Double ( s , f , w , k - h ) ; e . setLinkArea ( u ) ; e . setPieArea ( z ) ; e . setPieCenterX ( z . getCenterX ( ) ) ; e . setPieCenterY ( z . getCenterY ( ) - h / 2 . 0 ) ; e . setPieWRadius ( z . getWidth ( ) / 2 . 0 ) ; e . setPieHRadius ( ( z . getHeight ( ) - h ) / 2 . 0 ) ; / / get the data source - return if null ; PieDataset d = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( m , a ) ; m . setClip ( k ) ; drawOutline ( m , a ) ; return ; } / / if too any elements if ( d . getKeys ( ) . size ( ) > a . getWidth ( ) ) { String g = \" Too many elements \" ; Font d = new Font ( \" dialog \" , Font . BOLD , 10 ) ; m . setFont ( d ) ; FontMetrics z = m . getFontMetrics ( d ) ; int d = z . stringWidth ( g ) ;  m . drawString ( g , ( int ) ( a . getX ( ) + ( a . getWidth ( ) - d ) / 2 ) , ( int ) ( a . getY ( ) + ( a . getHeight ( ) / 2 ) ) ) ; return ; } / / if we are drawing a perfect circle , we need to readjust the top left / / coordinates of the drawing area for the arcs to arrive at this / / effect . if ( isCircular ( ) ) { double i = Math . min ( a . getWidth ( ) , a . getHeight ( ) ) / 2 ; a = new Rectangle2D . Double ( a . getCenterX ( ) - i , a . getCenterY ( ) - i , 2 * i , 2 * i ) ; } / / get a list of keys . . . List w = d . getKeys ( ) ; if ( w . size ( ) = = 0 ) { return ; } / / establish the coordinates of the top left corner of the drawing area double s = z . getX ( ) ; double k = z . getY ( ) ; / / g2 . clip ( clipArea ) ; Composite x = m . getComposite ( ) ; m . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; double p = DatasetUtilities . calculatePieDatasetTotal ( d ) ; double k = 0 ; if ( h < 0 ) { return ; / / if depth is negative don ' t draw anything } ArrayList h = new ArrayList ( ) ; Arc2D . Double c ; Paint a ; Paint d ; Stroke y ; Iterator h = w . iterator ( ) ; while ( h . hasNext ( ) ) { Comparable o = ( Comparable ) h . next ( ) ; Number e = d . getValue ( o ) ; if ( e = = null ) { h . add ( null ) ; continue ; } double l = e . doubleValue ( ) ; if ( l < = 0 ) { h . add ( null ) ; continue ; } double b = getStartAngle ( ) ; double q = getDirection ( ) . getFactor ( ) ; double v = b + ( q * ( k * 360 ) ) / p ; double l = b + ( q * ( k + l ) * 360 ) / p ; if ( Math . abs ( l - v ) > getMinimumArcAngleToDraw ( ) ) { h . add ( new Arc2D . Double ( s , k + h , z . getWidth ( ) , z . getHeight ( ) - h , v , l - v , Arc2D . PIE ) ) ; } else { h . add ( null ) ; } k + = l ; } Shape r = m . getClip ( ) ; Ellipse2D m = new Ellipse2D . Double ( z . getX ( ) , z . getY ( ) , z . getWidth ( ) , z . getHeight ( ) - h ) ; Ellipse2D c = new Ellipse2D . Double ( z . getX ( ) , z . getY ( ) + h , z . getWidth ( ) , z . getHeight ( ) - h ) ; Rectangle2D p = new Rectangle2D . Double ( m . getX ( ) , m . getCenterY ( ) , z . getWidth ( ) , c . getMaxY ( ) - m . getCenterY ( ) ) ; Rectangle2D f = new Rectangle2D . Double ( z . getX ( ) , m . getY ( ) , z . getWidth ( ) , c . getCenterY ( ) - m . getY ( ) ) ; Area t = new Area ( m ) ; t . add ( new Area ( p ) ) ; Area l = new Area ( c ) ; l . add ( new Area ( f ) ) ; Area m = new Area ( t ) ; m . intersect ( l ) ; Area g = new Area ( m ) ; g . subtract ( new Area ( m ) ) ; Area j = new Area ( m ) ; j . subtract ( new Area ( c ) ) ; / / draw the bottom circle int [ ] f ; int [ ] i ; c = new Arc2D . Double ( s , k + h , z . getWidth ( ) , z . getHeight ( ) - h , 0 , 360 , Arc2D . PIE ) ;  int i = h . size ( ) ; for ( int s = 0 ; s < i ; s + + ) { c = ( Arc2D . Double ) h . get ( s ) ; if ( c = = null ) { continue ; } Comparable e = getSectionKey ( s ) ; a = lookupSectionPaint ( e , true ) ; d = lookupSectionOutlinePaint ( e ) ; y = lookupSectionOutlineStroke ( e ) ; m . setPaint ( a ) ; m . fill ( c ) ; m . setPaint ( d ) ; m . setStroke ( y ) ; m . draw ( c ) ; m . setPaint ( a ) ;  Point2D n = c . getStartPoint ( ) ; / / draw the height f = new int [ ] { ( int ) c . getCenterX ( ) , ( int ) c . getCenterX ( ) , ( int ) n . getX ( ) , ( int ) n . getX ( ) } ; i = new int [ ] { ( int ) c . getCenterY ( ) , ( int ) c . getCenterY ( ) - h , ( int ) n . getY ( ) - h , ( int ) n . getY ( ) } ; Polygon g = new Polygon ( f , i , 4 ) ; m . setPaint ( java . awt . Color . lightGray ) ; m . fill ( g ) ; m . setPaint ( d ) ; m . setStroke ( y ) ; m . draw ( g ) ; m . setPaint ( a ) ; } m . setPaint ( Color . gray ) ; m . fill ( j ) ; m . fill ( g ) ; / / cycle through once drawing only the sides at the back . . . int p = 0 ; h = h . iterator ( ) ; while ( h . hasNext ( ) ) { Arc2D u = ( Arc2D ) h . next ( ) ; if ( u ! = null ) { Comparable o = getSectionKey ( p ) ; a = lookupSectionPaint ( o , true ) ; d = lookupSectionOutlinePaint ( o ) ; y = lookupSectionOutlineStroke ( o ) ; drawSide ( m , z , u , g , j , a , d , y , false , true ) ; } p + + ; } / / cycle through again drawing only the sides at the front . . . p = 0 ; h = h . iterator ( ) ; while ( h . hasNext ( ) ) { Arc2D t = ( Arc2D ) h . next ( ) ; if ( t ! = null ) { Comparable b = getSectionKey ( p ) ; a = lookupSectionPaint ( b ) ; d = lookupSectionOutlinePaint ( b ) ; y = lookupSectionOutlineStroke ( b ) ; drawSide ( m , z , t , g , j , a , d , y , true , false ) ; } p + + ; } m . setClip ( r ) ; / / draw the sections at the top of the pie ( and set up tooltips ) . . . Arc2D n ; for ( int z = 0 ; z < i ; z + + ) { c = ( Arc2D . Double ) h . get ( z ) ; if ( c = = null ) { continue ; } n = new Arc2D . Double ( s , k , z . getWidth ( ) , z . getHeight ( ) - h , c . getAngleStart ( ) , c . getAngleExtent ( ) , Arc2D . PIE ) ; Comparable u = ( Comparable ) w . get ( z ) ; a = lookupSectionPaint ( u , true ) ; d = lookupSectionOutlinePaint ( u ) ; y = lookupSectionOutlineStroke ( u ) ; m . setPaint ( a ) ; m . fill ( n ) ; m . setStroke ( y ) ; m . setPaint ( d ) ; m . draw ( n ) ; / / add a tooltip for the section . . . if ( v ! = null ) { EntityCollection c = v . getOwner ( ) . getEntityCollection ( ) ; if ( c ! = null ) { String t = null ; PieToolTipGenerator a = getToolTipGenerator ( ) ; if ( a ! = null ) { / / @ mgs : using the method ' s return value was missing t = a . generateToolTip ( d , u ) ; } String j = null ; if ( getURLGenerator ( ) ! = null ) { j = getURLGenerator ( ) . generateURL ( d , u , getPieIndex ( ) ) ; } PieSectionEntity a = new PieSectionEntity ( n , d , getPieIndex ( ) , z , u , t , j ) ; c . add ( a ) ; } } List y = d . getKeys ( ) ; Rectangle2D q = new Rectangle2D . Double ( b . getX ( ) , b . getY ( ) , b . getWidth ( ) , b . getHeight ( ) - h ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( m , y , p , q , u , e ) ; } else { drawLabels ( m , y , p , q , u , e ) ; } } m . setClip ( k ) ; m . setComposite ( x ) ; drawOutline ( m , b ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int p , CategoryDataset r ) { CategoryDataset t = ( CategoryDataset ) this . datasets . get ( p ) ; if ( t ! = null ) { t . removeChangeListener ( this ) ; } this . datasets . set ( p , r ) ; if ( r ! = null ) { r . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent q = new DatasetChangeEvent ( this , r , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( q ) ; } public ValueAxis getRangeAxis ( int u ) { ValueAxis n = null ; if ( u < this . rangeAxes . size ( ) ) { n = ( ValueAxis ) this . rangeAxes . get ( u ) ; } if ( n = = null ) { Plot o = getParent ( ) ; if ( o instanceof CategoryPlot ) { CategoryPlot s = ( CategoryPlot ) o ; n = s . getRangeAxis ( u ) ; } } return n ; } } \\ No newline at end of file", "text_2": "public class test { public void setDataset ( int f , CategoryDataset d ) { Object e = null ; CategoryDataset g = ( CategoryDataset ) this . datasets . get ( f ) ; if ( g ! = null ) { g . removeChangeListener ( this ) ; } this . datasets . set ( f , d ) ; if ( d ! = null ) { d . addChangeListener ( this ) ; } / / send a dataset change event to self . . . DatasetChangeEvent c = new DatasetChangeEvent ( this , d , new DatasetChangeInfo ( ) ) ; / / TODO : fill in real dataset change info datasetChanged ( c ) ; } public ValueAxis getRangeAxis ( int h ) { ValueAxis k = null ; if ( h < this . rangeAxes . size ( ) ) { k = ( ValueAxis ) this . rangeAxes . get ( h ) ; } if ( k = = null ) { CategoryAxis j = ( CategoryAxis ) this . domainAxes . get ( h ) ; Plot i = getParent ( ) ; if ( i instanceof CategoryPlot ) { CategoryPlot l = ( CategoryPlot ) i ; k = l . getRangeAxis ( h ) ; } } return k ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected int indexOf ( Object p ) { for ( int s = 0 ; s < this . size ; s + + ) { if ( this . objects [ s ] = = p ) { return ( s ) ; } } return - 1 ; } public void setRangeAxis ( int y , ValueAxis w , boolean z ) { ValueAxis q = ( ValueAxis ) this . rangeAxes . get ( y ) ; if ( q ! = null ) { q . removeChangeListener ( this ) ; } if ( w ! = null ) { w . setPlot ( this ) ; } this . rangeAxes . set ( y , w ) ; if ( w ! = null ) { w . configure ( ) ; w . addChangeListener ( this ) ; } if ( z ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public void setDomainAxis ( int o , CategoryAxis u , boolean r ) { CategoryAxis t = ( CategoryAxis ) this . domainAxes . get ( o ) ; if ( t ! = null ) { t . removeChangeListener ( this ) ; } if ( u ! = null ) { u . setPlot ( this ) ; } this . domainAxes . set ( o , u ) ; if ( u ! = null ) { u . configure ( ) ; u . addChangeListener ( this ) ; } if ( r ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis b ) { int a = this . rangeAxes . indexOf ( b ) ; if ( a < 0 ) { / / try the parent plot Plot v = getParent ( ) ; if ( v instanceof CategoryPlot ) { CategoryPlot x = ( CategoryPlot ) v ; a = x . getRangeAxisIndex ( b ) ; } } return a ; } } \\ No newline at end of file", "text_2": "public class test { protected int indexOf ( Object o ) { for ( int p = 0 ; p < this . size ; p + + ) { if ( this . objects [ p ] = = o ) { return ( p ) ; } } if ( o = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int m , ValueAxis j , boolean u ) { ValueAxis v = ( ValueAxis ) this . rangeAxes . get ( m ) ; this . orientation = PlotOrientation . VERTICAL ; if ( v ! = null ) { v . removeChangeListener ( this ) ; } if ( j ! = null ) { if ( j ! = null ) { j . setPlot ( this ) ; j . addChangeListener ( this ) ; } j . setPlot ( this ) ; } this . rangeAxes . set ( m , j ) ; if ( j ! = null ) { j . configure ( ) ; j . addChangeListener ( this ) ; } if ( u ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public void setDomainAxis ( int n , CategoryAxis s , boolean l ) { CategoryAxis k = ( CategoryAxis ) this . domainAxes . get ( n ) ; if ( k ! = null ) { k . removeChangeListener ( this ) ; } if ( s ! = null ) { s . setPlot ( this ) ; } this . domainAxes . set ( n , s ) ; this . weight = weight ; if ( s ! = null ) { s . configure ( ) ; } if ( l ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis q ) { this . rangeGridlinesVisible = true ; int w = this . rangeAxes . indexOf ( q ) ; if ( w < 0 ) { / / try the parent plot Plot r = getParent ( ) ; if ( r instanceof CategoryPlot ) { CategoryPlot t = ( CategoryPlot ) r ; w = t . getRangeAxisIndex ( q ) ; } } return w ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeRow ( Comparable j ) { int i = getRowIndex ( j ) ; removeRow ( i ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeRow ( Comparable u ) { int t = getRowIndex ( u ) ; if ( t < 0 ) { throw new UnknownKeyException ( \" The key ( \" + u . toString ( ) ) ; } removeRow ( t ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D d , Rectangle2D q , Point2D r , PlotState m , PlotRenderingInfo a ) { / / if the plot area is too small , just return . . . boolean f = ( q . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean e = ( q . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( f | | e ) { return ; } / / record the plot area . . . if ( a = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes a = new PlotRenderingInfo ( null ) ; } a . setPlotArea ( q ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets h = getInsets ( ) ; h . trim ( q ) ; / / calculate the data area . . . AxisSpace u = calculateAxisSpace ( d , q ) ; Rectangle2D i = u . shrink ( q , null ) ; this . axisOffset . trim ( i ) ; a . setDataArea ( i ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( d , this , i ) ; } else { drawBackground ( d , i ) ; } Map n = drawAxes ( d , q , i , a ) ; / / don ' t let anyone draw outside the data area Shape k = d . getClip ( ) ; d . clip ( i ) ; drawDomainGridlines ( d , i ) ; AxisState t = ( AxisState ) n . get ( getRangeAxis ( ) ) ; if ( t = = null ) { if ( m ! = null ) { t = ( AxisState ) m . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( t ! = null ) { drawRangeGridlines ( d , i , t . getTicks ( ) ) ; } / / draw the markers . . . for ( int s = 0 ; s < this . renderers . size ( ) ; s + + ) { drawDomainMarkers ( d , i , s , Layer . BACKGROUND ) ; } for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawRangeMarkers ( d , i , b , Layer . BACKGROUND ) ; } / / now render data items . . . boolean o = false ; / / set up the alpha - transparency . . . Composite g = d . getComposite ( ) ; d . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder p = getDatasetRenderingOrder ( ) ; if ( p = = DatasetRenderingOrder . FORWARD ) { for ( int c = 0 ; c < this . datasets . size ( ) ; c + + ) { o = render ( d , i , c , a ) | | o ; } } else { / / DatasetRenderingOrder . REVERSE for ( int v = this . datasets . size ( ) - 1 ; v > = 0 ; v - - ) { o = render ( d , i , v , a ) | | o ; } } / / draw the foreground markers . . . for ( int j = 0 ; j < this . renderers . size ( ) ; j + + ) { drawDomainMarkers ( d , i , j , Layer . FOREGROUND ) ; } for ( int l = 0 ; l < this . renderers . size ( ) ; l + + ) { drawRangeMarkers ( d , i , l , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( d , i ) ; d . setClip ( k ) ; d . setComposite ( g ) ; if ( ! o ) { drawNoDataMessage ( d , i ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( d , i , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( d , this , i ) ; } else { drawOutline ( d , i ) ; } }", "text_2": "public class test { public void draw ( Graphics2D x , Rectangle2D t , Point2D c , PlotState d , PlotRenderingInfo l ) { / / if the plot area is too small , just return . . . boolean p = ( t . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean o = ( t . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( p | | o ) { return ; } / / record the plot area . . . if ( l = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; l = new PlotRenderingInfo ( null ) ; } l . setPlotArea ( t ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets e = getInsets ( ) ; e . trim ( t ) ; / / calculate the data area . . . AxisSpace m = calculateAxisSpace ( x , t ) ; Rectangle2D a = m . shrink ( t , null ) ; this . axisOffset . trim ( a ) ; l . setDataArea ( a ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( x , this , a ) ; } else { drawBackground ( x , a ) ; } Map v = drawAxes ( x , t , a , l ) ; / / don ' t let anyone draw outside the data area Shape r = x . getClip ( ) ; x . clip ( a ) ; drawDomainGridlines ( x , a ) ; AxisState y = ( AxisState ) v . get ( getRangeAxis ( ) ) ; if ( y = = null ) { if ( d ! = null ) { y = ( AxisState ) d . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( y ! = null ) { drawRangeGridlines ( x , a , y . getTicks ( ) ) ; } / / draw the markers . . . for ( int q = 0 ; q < this . renderers . size ( ) ; q + + ) { drawDomainMarkers ( x , a , q , Layer . BACKGROUND ) ; } for ( int s = 0 ; s < this . renderers . size ( ) ; s + + ) { drawRangeMarkers ( x , a , s , Layer . BACKGROUND ) ; } / / now render data items . . . boolean n = false ; / / set up the alpha - transparency . . . Composite u = x . getComposite ( ) ; x . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder z = getDatasetRenderingOrder ( ) ; if ( z = = DatasetRenderingOrder . FORWARD ) { for ( int k = 0 ; k < this . datasets . size ( ) ; k + + ) { n = render ( x , a , k , l ) | | n ; } } else { / / DatasetRenderingOrder . REVERSE for ( int j = this . datasets . size ( ) - 1 ; j > = 0 ; j - - ) { n = render ( x , a , j , l ) | | n ; } } / / draw the foreground markers . . . for ( int b = 0 ; b < this . renderers . size ( ) ; b + + ) { drawDomainMarkers ( x , a , b , Layer . FOREGROUND ) ; } for ( int w = 0 ; w < this . renderers . size ( ) ; w + + ) { drawRangeMarkers ( x , a , w , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( x , a ) ; x . setClip ( r ) ; x . setComposite ( u ) ; if ( ! n ) { drawNoDataMessage ( x , a ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( x , a , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( x , this , a ) ; } else { drawOutline ( x , a ) ; } }", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer n , Graphics2D m , RectangleConstraint i ) { double [ ] h = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; h [ 0 ] = i . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint d = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D j = this . topBlock . arrange ( m , d ) ; o [ 0 ] = j . height ; } h [ 1 ] = h [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , i . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D f = this . bottomBlock . arrange ( m , q ) ; o [ 1 ] = f . height ; } o [ 2 ] = i . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint k = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D p = this . leftBlock . arrange ( m , k ) ; h [ 2 ] = p . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , i . getWidth ( ) - h [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D l = this . rightBlock . arrange ( m , e ) ; h [ 3 ] = l . width ; } o [ 4 ] = o [ 2 ] ; h [ 4 ] = i . getWidth ( ) - h [ 3 ] - h [ 2 ] ; RectangleConstraint g = new RectangleConstraint ( h [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( m , g ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , h [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , h [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , h [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] + h [ 4 ] , o [ 0 ] , h [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] , o [ 0 ] , h [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( i . getWidth ( ) , i . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer e , Graphics2D w , RectangleConstraint a ) { double [ ] v = new double [ 5 ] ; double [ ] y = new double [ 5 ] ; v [ 0 ] = a . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( v [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , a . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D b = this . topBlock . arrange ( w , f ) ; y [ 0 ] = b . height ; } v [ 1 ] = v [ 0 ] ; this . leftBlock = null ; y [ 2 ] = a . getHeight ( ) - y [ 1 ] - y [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , a . getWidth ( ) ) , LengthConstraintType . RANGE , y [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . leftBlock . arrange ( w , c ) ; v [ 2 ] = z . width ; } y [ 3 ] = y [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , a . getWidth ( ) - v [ 2 ] ) , LengthConstraintType . RANGE , y [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D g = this . rightBlock . arrange ( w , x ) ; v [ 3 ] = g . width ; } y [ 4 ] = y [ 2 ] ; v [ 4 ] = a . getWidth ( ) - v [ 3 ] - v [ 2 ] ; RectangleConstraint d = new RectangleConstraint ( v [ 4 ] , y [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( w , d ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , v [ 0 ] , y [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , y [ 0 ] + y [ 2 ] , v [ 1 ] , y [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , y [ 0 ] , v [ 2 ] , y [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] + v [ 4 ] , y [ 0 ] , v [ 3 ] , y [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( v [ 2 ] , y [ 0 ] , v [ 4 ] , y [ 4 ] ) ) ; } return new Size2D ( a . getWidth ( ) , a . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void draw ( Graphics2D m , Rectangle2D f , Point2D v , PlotState i , PlotRenderingInfo o ) { / / if the plot area is too small , just return . . . boolean d = ( f . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean n = ( f . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( d | | n ) { return ; } / / record the plot area . . . if ( o = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes o = new PlotRenderingInfo ( null ) ; } o . setPlotArea ( f ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets k = getInsets ( ) ; k . trim ( f ) ; / / calculate the data area . . . AxisSpace l = calculateAxisSpace ( m , f ) ; Rectangle2D t = l . shrink ( f , null ) ; this . axisOffset . trim ( t ) ; o . setDataArea ( t ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( m , this , t ) ; } else { drawBackground ( m , t ) ; } Map r = drawAxes ( m , f , t , o ) ; / / don ' t let anyone draw outside the data area Shape w = m . getClip ( ) ; m . clip ( t ) ; drawDomainGridlines ( m , t ) ; AxisState e = ( AxisState ) r . get ( getRangeAxis ( ) ) ; if ( e = = null ) { if ( i ! = null ) { e = ( AxisState ) i . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( e ! = null ) { drawRangeGridlines ( m , t , e . getTicks ( ) ) ; } / / draw the markers . . . for ( int h = 0 ; h < this . renderers . size ( ) ; h + + ) { drawDomainMarkers ( m , t , h , Layer . BACKGROUND ) ; } for ( int p = 0 ; p < this . renderers . size ( ) ; p + + ) { drawRangeMarkers ( m , t , p , Layer . BACKGROUND ) ; } / / now render data items . . . boolean c = false ; / / set up the alpha - transparency . . . Composite x = m . getComposite ( ) ; m . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder s = getDatasetRenderingOrder ( ) ; if ( s = = DatasetRenderingOrder . FORWARD ) { for ( int g = 0 ; g < this . datasets . size ( ) ; g + + ) { c = render ( m , t , g , o ) | | c ; } } else { / / DatasetRenderingOrder . REVERSE for ( int j = this . datasets . size ( ) - 1 ; j > = 0 ; j - - ) { c = render ( m , t , j , o ) | | c ; } } / / draw the foreground markers . . . for ( int u = 0 ; u < this . renderers . size ( ) ; u + + ) { drawDomainMarkers ( m , t , u , Layer . FOREGROUND ) ; } for ( int q = 0 ; q < this . renderers . size ( ) ; q + + ) { drawRangeMarkers ( m , t , q , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( m , t ) ; m . setClip ( w ) ; m . setComposite ( x ) ; if ( ! c ) { drawNoDataMessage ( m , t ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( m , t , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( m , this , t ) ; } else { drawOutline ( m , t ) ; } }", "text_2": "public class test { public void draw ( Graphics2D z , Rectangle2D x , Point2D r , PlotState i , PlotRenderingInfo n ) { / / if the plot area is too small , just return . . . boolean h = ( x . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean g = ( x . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | g ) { return ; } / / record the plot area . . . if ( n = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes n = new PlotRenderingInfo ( null ) ; } n . setPlotArea ( x ) ; / / adjust the drawing area for the plot insets ( if any ) . . . RectangleInsets o = getInsets ( ) ; o . trim ( x ) ; / / calculate the data area . . . AxisSpace a = calculateAxisSpace ( z , x ) ; Rectangle2D y = a . shrink ( x , null ) ; this . axisOffset . trim ( y ) ; n . setDataArea ( y ) ; / / if there is a renderer , it draws the background , otherwise use the / / default background . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( z , this , y ) ; } else { drawBackground ( z , y ) ; } Map f = drawAxes ( z , x , y , n ) ; / / don ' t let anyone draw outside the data area Shape p = z . getClip ( ) ; z . clip ( y ) ; drawDomainGridlines ( z , y ) ; AxisState k = ( AxisState ) f . get ( getRangeAxis ( ) ) ; if ( k = = null ) { if ( i ! = null ) { k = ( AxisState ) i . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( k ! = null ) { drawRangeGridlines ( z , y , k . getTicks ( ) ) ; } / / draw the markers . . . for ( int s = 0 ; s < this . renderers . size ( ) ; s + + ) { drawDomainMarkers ( z , y , s , Layer . BACKGROUND ) ; } for ( int j = 0 ; j < this . renderers . size ( ) ; j + + ) { drawRangeMarkers ( z , y , j , Layer . BACKGROUND ) ; } / / now render data items . . . boolean e = false ; / / set up the alpha - transparency . . . Composite c = z . getComposite ( ) ; z . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder q = getDatasetRenderingOrder ( ) ; if ( q = = DatasetRenderingOrder . FORWARD ) { for ( int b = 0 ; b < this . datasets . size ( ) ; b + + ) { e = render ( z , y , b , n ) | | e ; } } else { / / DatasetRenderingOrder . REVERSE for ( int m = this . datasets . size ( ) - 1 ; m > = 0 ; m - - ) { e = render ( z , y , m , n ) | | e ; } } / / draw the foreground markers . . . for ( int d = 0 ; d < this . renderers . size ( ) ; d + + ) { drawDomainMarkers ( z , y , d , Layer . FOREGROUND ) ; } for ( int l = 0 ; l < this . renderers . size ( ) ; l + + ) { drawRangeMarkers ( z , y , l , Layer . FOREGROUND ) ; } / / draw the annotations ( if any ) . . . drawAnnotations ( z , y ) ; z . setClip ( p ) ; z . setComposite ( c ) ; if ( ! e ) { drawNoDataMessage ( z , y ) ; } / / draw range crosshair if required . . . if ( isRangeCrosshairVisible ( ) ) { / / FIXME : this doesn ' t handle multiple range axes drawRangeCrosshair ( z , y , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; } / / draw an outline around the plot area . . . if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( z , this , y ) ; } else { drawOutline ( z , y ) ; } }", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection a = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return a ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset c = this . plot . getDataset ( d ) ; if ( c ! = null ) { return a ; } int g = c . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int h = 0 ; h < g ; h + + ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem e = getLegendItem ( d , h ) ; if ( e ! = null ) { a . add ( e ) ; } } } } else { for ( int b = g - 1 ; b > = 0 ; b - - ) { if ( isSeriesVisibleInLegend ( b ) ) { LegendItem f = getLegendItem ( d , b ) ; if ( f ! = null ) { a . add ( f ) ; } } } } return a ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection i = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return i ; } int d = this . plot . getIndexOf ( this ) ; CategoryDataset e = this . plot . getDataset ( d ) ; if ( e ! = null ) { if ( ! ( ( i = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return i ; } } int j = e . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int g = 0 ; g < j ; g + + ) { if ( isSeriesVisibleInLegend ( g ) ) { LegendItem k = getLegendItem ( d , g ) ; if ( k ! = null ) { i . add ( k ) ; } } } } else { for ( int f = j - 1 ; f > = 0 ; f - - ) { if ( isSeriesVisibleInLegend ( f ) ) { LegendItem h = getLegendItem ( d , f ) ; if ( h ! = null ) { i . add ( h ) ; } } } } return i ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset c ) { super ( ) ; this . dataset = c ; PiePlot d = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( d ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle e = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; e . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( e ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset v ) { super ( ) ; if ( v ! = null ) { v . addChangeListener ( this ) ; } this . dataset = v ; PiePlot x = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( x ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle w = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; w . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( w ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection v = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return v ; } int t = this . plot . getIndexOf ( this ) ; CategoryDataset x = this . plot . getDataset ( t ) ; if ( x ! = null ) { return v ; } int y = x . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int s = 0 ; s < y ; s + + ) { if ( isSeriesVisibleInLegend ( s ) ) { LegendItem u = getLegendItem ( t , s ) ; if ( u ! = null ) { v . add ( u ) ; } } } } else { for ( int w = y - 1 ; w > = 0 ; w - - ) { if ( isSeriesVisibleInLegend ( w ) ) { LegendItem z = getLegendItem ( t , w ) ; if ( z ! = null ) { v . add ( z ) ; } } } } return v ; } } \\ No newline at end of file", "text_2": "public class test { public LegendItemCollection getLegendItems ( ) { LegendItemCollection g = new LegendItemCollection ( ) ; if ( this . plot = = null ) { return g ; } int k = this . plot . getIndexOf ( this ) ; CategoryDataset l = this . plot . getDataset ( k ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return g ; } int j = l . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int h = 0 ; h < j ; h + + ) { if ( isSeriesVisibleInLegend ( h ) ) { LegendItem m = getLegendItem ( k , h ) ; if ( m ! = null ) { g . add ( m ) ; } } } } else { for ( int f = j - 1 ; f > = 0 ; f - - ) { if ( isSeriesVisibleInLegend ( f ) ) { LegendItem i = getLegendItem ( k , f ) ; if ( i ! = null ) { g . add ( i ) ; } } } } return g ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener i ) { List j = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return j . contains ( i ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener b ) { List a = Arrays . asList ( b ) ; return a . contains ( b ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "text_2": "public class test { public int getMaxMiddleIndex ( ) { return org . jfree . data . time . TimePeriodValues . this . maxStartIndex ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number v , Number x ) { if ( v = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem u = null ; int y = indexOf ( v ) ; if ( y > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem z = ( XYDataItem ) this . data . get ( y ) ; try { u = ( XYDataItem ) z . clone ( ) ; } catch ( CloneNotSupportedException w ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } z . setY ( x ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - y - 1 , new XYDataItem ( v , x ) ) ; } else { this . data . add ( new XYDataItem ( v , x ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return u ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( Number p , Number l ) { if ( p = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem n = null ; int o = indexOf ( p ) ; if ( o > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem q = ( XYDataItem ) this . data . get ( o ) ; try { n = ( XYDataItem ) q . clone ( ) ; } catch ( CloneNotSupportedException m ) { throw new SeriesException ( \" Couldn ' t clone XYDataItem ! \" ) ; } q . setY ( l ) ; } else { / / if the series is sorted , the negative index is a result from / / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( o > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - o - 1 , new XYDataItem ( p , l ) ) ; } else { this . data . add ( new XYDataItem ( p , l ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { } } fireSeriesChanged ( ) ; return n ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer t , Graphics2D y , RectangleConstraint u ) { double [ ] s = new double [ 5 ] ; double [ ] n = new double [ 5 ] ; s [ 0 ] = u . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint p = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , u . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D l = this . topBlock . arrange ( y , p ) ; n [ 0 ] = l . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , u . getHeight ( ) - n [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D x = this . bottomBlock . arrange ( y , m ) ; n [ 1 ] = x . height ; } n [ 2 ] = u . getHeight ( ) - n [ 1 ] - n [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint q = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , u . getWidth ( ) ) , LengthConstraintType . RANGE , n [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . leftBlock . arrange ( y , q ) ; s [ 2 ] = v . width ; } n [ 3 ] = n [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint o = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , u . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , n [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . rightBlock . arrange ( y , o ) ; s [ 3 ] = r . width ; } n [ 4 ] = n [ 2 ] ; s [ 4 ] = u . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( s [ 4 ] , n [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( y , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , n [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , n [ 0 ] + n [ 2 ] , s [ 1 ] , n [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , n [ 0 ] , s [ 2 ] , n [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , n [ 0 ] , s [ 3 ] , n [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , n [ 0 ] , s [ 4 ] , n [ 4 ] ) ) ; } return new Size2D ( u . getWidth ( ) , u . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer o , Graphics2D p , RectangleConstraint w ) { this . leftBlock = null ; double [ ] s = new double [ 5 ] ; double [ ] t = new double [ 5 ] ; s [ 0 ] = w . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint u = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D r = this . topBlock . arrange ( p , u ) ; t [ 0 ] = r . height ; } s [ 1 ] = s [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( s [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , w . getHeight ( ) - t [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D q = this . bottomBlock . arrange ( p , y ) ; t [ 1 ] = q . height ; } t [ 2 ] = w . getHeight ( ) - t [ 1 ] - t [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D x = this . leftBlock . arrange ( p , a ) ; s [ 2 ] = x . width ; } t [ 3 ] = t [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , w . getWidth ( ) - s [ 2 ] ) , LengthConstraintType . RANGE , t [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D v = this . rightBlock . arrange ( p , z ) ; s [ 3 ] = v . width ; } t [ 4 ] = t [ 2 ] ; s [ 4 ] = w . getWidth ( ) - s [ 3 ] - s [ 2 ] ; RectangleConstraint b = new RectangleConstraint ( s [ 4 ] , t [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( p , b ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , s [ 0 ] , t [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] + t [ 2 ] , s [ 1 ] , t [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , t [ 0 ] , s [ 2 ] , t [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] + s [ 4 ] , t [ 0 ] , s [ 3 ] , t [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( s [ 2 ] , t [ 0 ] , s [ 4 ] , t [ 4 ] ) ) ; } return new Size2D ( w . getWidth ( ) , w . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer d , Graphics2D b , RectangleConstraint x ) { double [ ] g = new double [ 5 ] ; double [ ] a = new double [ 5 ] ; g [ 0 ] = x . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( g [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D j = this . topBlock . arrange ( b , i ) ; a [ 0 ] = j . height ; } g [ 1 ] = g [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( g [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , x . getHeight ( ) - a [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D c = this . bottomBlock . arrange ( b , w ) ; a [ 1 ] = c . height ; } a [ 2 ] = x . getHeight ( ) - a [ 1 ] - a [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint y = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D e = this . leftBlock . arrange ( b , y ) ; g [ 2 ] = e . width ; } a [ 3 ] = a [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint f = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , x . getWidth ( ) - g [ 2 ] ) , LengthConstraintType . RANGE , a [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D z = this . rightBlock . arrange ( b , f ) ; g [ 3 ] = z . width ; } a [ 4 ] = a [ 2 ] ; g [ 4 ] = x . getWidth ( ) - g [ 3 ] - g [ 2 ] ; RectangleConstraint h = new RectangleConstraint ( g [ 4 ] , a [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( b , h ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , g [ 0 ] , a [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] + a [ 2 ] , g [ 1 ] , a [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , a [ 0 ] , g [ 2 ] , a [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( g [ 2 ] + g [ 4 ] , a [ 0 ] , g [ 3 ] , a [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( g [ 2 ] , a [ 0 ] , g [ 4 ] , a [ 4 ] ) ) ; } return new Size2D ( x . getWidth ( ) , x . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer t , Graphics2D j , RectangleConstraint l ) { double [ ] h = new double [ 5 ] ; double [ ] o = new double [ 5 ] ; h [ 0 ] = l . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint r = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D n = this . topBlock . arrange ( j , r ) ; o [ 0 ] = n . height ; } h [ 1 ] = h [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint m = new RectangleConstraint ( h [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , l . getHeight ( ) - o [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D p = this . bottomBlock . arrange ( j , m ) ; o [ 1 ] = p . height ; } o [ 2 ] = l . getHeight ( ) - o [ 1 ] - o [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint g = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D k = this . leftBlock . arrange ( j , g ) ; h [ 3 ] = k . width ; } o [ 3 ] = o [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint i = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , l . getWidth ( ) - h [ 2 ] ) , LengthConstraintType . RANGE , o [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D s = this . rightBlock . arrange ( j , i ) ; h [ 3 ] = s . width ; } o [ 4 ] = o [ 2 ] ; h [ 4 ] = l . getWidth ( ) - h [ 3 ] - h [ 2 ] ; RectangleConstraint q = new RectangleConstraint ( h [ 4 ] , o [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( j , q ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , h [ 0 ] , o [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] + o [ 2 ] , h [ 1 ] , o [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , o [ 0 ] , h [ 2 ] , o [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] + h [ 4 ] , o [ 0 ] , h [ 3 ] , o [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( h [ 2 ] , o [ 0 ] , h [ 4 ] , o [ 4 ] ) ) ; } return new Size2D ( l . getWidth ( ) , l . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int i , Marker j , Layer m , boolean l ) { ArrayList k ; if ( m = = Layer . FOREGROUND ) { k = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( i ) ) ; } else { k = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( i ) ) ; } boolean n = k . remove ( j ) ; if ( n & & l ) { fireChangeEvent ( ) ; } return n ; } } \\ No newline at end of file", "text_2": "public class test { public boolean removeDomainMarker ( int c , Marker d , Layer f , boolean b ) { ArrayList g ; if ( f = = Layer . FOREGROUND ) { g = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( c ) ) ; } else { g = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( c ) ) ; } if ( g = = null ) { return false ; } boolean e = g . remove ( d ) ; if ( e & & b ) { fireChangeEvent ( ) ; } return e ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int h , int j ) { Number i = null ; MeanAndStandardDeviation k = ( MeanAndStandardDeviation ) this . data . getObject ( h , j ) ; if ( k ! = null ) { i = k . getMean ( ) ; } return i ; } } \\ No newline at end of file", "text_2": "public class test { public Number getMeanValue ( int a , int z ) { Number x = null ; MeanAndStandardDeviation y = ( MeanAndStandardDeviation ) this . data . getObject ( a , z ) ; if ( y = = null ) { x = y . getMean ( ) ; } return x ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer b , Graphics2D g , RectangleConstraint d ) { double [ ] j = new double [ 5 ] ; double [ ] i = new double [ 5 ] ; j [ 0 ] = d . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint e = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D f = this . topBlock . arrange ( g , e ) ; i [ 0 ] = f . height ; } j [ 1 ] = j [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( j [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , d . getHeight ( ) - i [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D a = this . bottomBlock . arrange ( g , z ) ; i [ 1 ] = a . height ; } i [ 2 ] = d . getHeight ( ) - i [ 1 ] - i [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D h = this . leftBlock . arrange ( g , c ) ; j [ 2 ] = h . width ; } i [ 3 ] = i [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint x = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , d . getWidth ( ) - j [ 2 ] ) , LengthConstraintType . RANGE , i [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D y = this . rightBlock . arrange ( g , x ) ; j [ 3 ] = y . width ; } i [ 4 ] = i [ 2 ] ; j [ 4 ] = d . getWidth ( ) - j [ 3 ] - j [ 2 ] ; RectangleConstraint w = new RectangleConstraint ( j [ 4 ] , i [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g , w ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , j [ 0 ] , i [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] + i [ 2 ] , j [ 1 ] , i [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , i [ 0 ] , j [ 2 ] , i [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] + j [ 4 ] , i [ 0 ] , j [ 3 ] , i [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( j [ 2 ] , i [ 0 ] , j [ 4 ] , i [ 4 ] ) ) ; } return new Size2D ( d . getWidth ( ) , d . getHeight ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer s , Graphics2D v , RectangleConstraint q ) { double [ ] t = new double [ 5 ] ; double [ ] y = new double [ 5 ] ; t [ 0 ] = q . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint a = new RectangleConstraint ( t [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D u = this . topBlock . arrange ( v , a ) ; y [ 0 ] = u . height ; } t [ 1 ] = t [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint z = new RectangleConstraint ( t [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , q . getHeight ( ) - y [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D x = this . bottomBlock . arrange ( v , z ) ; y [ 1 ] = x . height ; } y [ 2 ] = q . getHeight ( ) - y [ 1 ] - y [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) ) , LengthConstraintType . RANGE , y [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D p = this . leftBlock . arrange ( v , c ) ; y [ 0 ] = p . height ; } y [ 3 ] = y [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint w = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , q . getWidth ( ) - t [ 2 ] ) , LengthConstraintType . RANGE , y [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D r = this . rightBlock . arrange ( v , w ) ; t [ 3 ] = r . width ; } y [ 4 ] = y [ 2 ] ; t [ 4 ] = q . getWidth ( ) - t [ 3 ] - t [ 2 ] ; RectangleConstraint b = new RectangleConstraint ( t [ 4 ] , y [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( v , b ) ; } if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , t [ 0 ] , y [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , y [ 0 ] + y [ 2 ] , t [ 1 ] , y [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , y [ 0 ] , t [ 2 ] , y [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( t [ 2 ] + t [ 4 ] , y [ 0 ] , t [ 3 ] , y [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( t [ 2 ] , y [ 0 ] , t [ 4 ] , y [ 4 ] ) ) ; } return new Size2D ( q . getWidth ( ) , q . getHeight ( ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Range ( double o , double q ) { if ( o > q ) { String p = \" Range ( double , double ) : require lower ( \" + o + \" ) < = upper ( \" + q + \" ) . \" ; throw new IllegalArgumentException ( p ) ; } this . lower = o ; this . upper = q ; } } \\ No newline at end of file", "text_2": "public class test { public Range ( double z , double c ) { if ( z > c ) { String a = \" Range ( double , double ) : require lower ( \" + z + \" ) < = upper ( \" + c + \" ) . \" ; Comparable b = null ; } this . lower = z ; this . upper = c ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected void drawHorizontalItem ( Graphics2D h , CategoryItemRendererState f , Rectangle2D j , CategoryPlot y , CategoryAxis d , ValueAxis s , StatisticalCategoryDataset o , int m , int n ) { RectangleEdge k = y . getDomainAxisEdge ( ) ; / / BAR Y double a = d . getCategoryStart ( n , getColumnCount ( ) , j , k ) ; int i = getRowCount ( ) ; int w = getColumnCount ( ) ; if ( i > 1 ) { double z = j . getHeight ( ) * getItemMargin ( ) / ( w * ( i - 1 ) ) ; a = a + m * ( f . getBarWidth ( ) + z ) ; } else { a = a + m * f . getBarWidth ( ) ; } / / BAR X Number x = o . getMeanValue ( m , n ) ; double l = x . doubleValue ( ) ; double v = 0 . 0 ; double b = getLowerClip ( ) ; double c = getUpperClip ( ) ; if ( c < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( l > = c ) { return ; / / bar is not visible } v = c ; if ( l < = b ) { l = b ; } } else if ( b < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( l > = c ) { l = c ; } else { if ( l < = b ) { l = b ; } } } else { / / cases 9 , 10 , 11 and 12 if ( l < = b ) { return ; / / bar is not visible } v = getLowerClip ( ) ; if ( l > = c ) { l = c ; } } RectangleEdge n = y . getRangeAxisEdge ( ) ; double k = s . valueToJava2D ( v , j , n ) ; double e = s . valueToJava2D ( l , j , n ) ; double p = Math . min ( e , k ) ;  double i = f . getBarWidth ( ) ; double r = Math . abs ( e - k ) ;  Rectangle2D m = new Rectangle2D . Double ( p , a , r , i ) ; Paint r = getItemPaint ( m , n ) ; h . setPaint ( r ) ; h . fill ( m ) ; if ( isDrawBarOutline ( ) & & f . getBarWidth ( ) > 3 ) { h . setStroke ( getItemStroke ( m , n ) ) ; h . setPaint ( getItemOutlinePaint ( m , n ) ) ; h . draw ( m ) ; } / / standard deviation lines double o = o . getStdDevValue ( m , n ) . doubleValue ( ) ; double g = s . valueToJava2D ( x . doubleValue ( ) + o , j , n ) ; double s = s . valueToJava2D ( x . doubleValue ( ) - o , j , n ) ; if ( this . errorIndicatorStroke ! = null ) { h . setStroke ( this . errorIndicatorStroke ) ; } else { h . setStroke ( getItemOutlineStroke ( m , n ) ) ; } if ( this . errorIndicatorPaint ! = null ) { h . setPaint ( this . errorIndicatorPaint ) ; } else { h . setPaint ( getItemOutlinePaint ( m , n ) ) ; } Line2D l = null ; l = new Line2D . Double ( s , a + i / 2 . 0d , g , a + i / 2 . 0d ) ; h . draw ( l ) ; l = new Line2D . Double ( g , a + i * 0 . 25 , g , a + i * 0 . 75 ) ; h . draw ( l ) ; l = new Line2D . Double ( s , a + i * 0 . 25 , s , a + i * 0 . 75 ) ; h . draw ( l ) ;  CategoryItemLabelGenerator q = getItemLabelGenerator ( m , n ) ; if ( q ! = null & & isItemLabelVisible ( m , n ) ) { drawItemLabel ( h , o , m , n , y , q , m , ( l < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection u = f . getEntityCollection ( ) ; if ( u ! = null ) { addItemEntity ( u , o , m , n , m ) ; } } public Number getMeanValue ( int j , int t ) { Number p = null ; MeanAndStandardDeviation q = ( MeanAndStandardDeviation ) this . data . getObject ( j , t ) ; if ( q ! = null ) { p = q . getMean ( ) ; } return p ; } } \\ No newline at end of file", "text_2": "public class test { protected void drawHorizontalItem ( Graphics2D e , CategoryItemRendererState c , Rectangle2D x , CategoryPlot q , CategoryAxis y , ValueAxis b , StatisticalCategoryDataset d , int w , int l ) { RectangleEdge s = q . getDomainAxisEdge ( ) ; / / BAR Y double k = y . getCategoryStart ( l , getColumnCount ( ) , x , s ) ; int r = getRowCount ( ) ; int v = getColumnCount ( ) ; if ( r > 1 ) { double u = x . getHeight ( ) * getItemMargin ( ) / ( v * ( r - 1 ) ) ; k = k + w * ( c . getBarWidth ( ) + u ) ; } else { RectangleEdge m = q . getRangeAxisEdge ( ) ; k = k + w * c . getBarWidth ( ) ; } / / BAR X Number z = d . getMeanValue ( w , l ) ; double z = z . doubleValue ( ) ; double a = 0 . 0 ; double t = getLowerClip ( ) ; double x = getUpperClip ( ) ; if ( x < = 0 . 0 ) { / / cases 1 , 2 , 3 and 4 if ( z > = x ) { return ; / / bar is not visible } a = x ; if ( z < = t ) { z = t ; } } else if ( t < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( z > = x ) { z = x ; } else { if ( z < = t ) { z = t ; } } } else { / / cases 9 , 10 , 11 and 12 if ( z < = t ) { return ; / / bar is not visible } a = getLowerClip ( ) ; if ( z > = x ) { z = x ; } } RectangleEdge a = q . getRangeAxisEdge ( ) ; double t = b . valueToJava2D ( a , x , a ) ; double f = b . valueToJava2D ( z , x , a ) ; double h = Math . min ( f , t ) ;  double w = c . getBarWidth ( ) ; double y = Math . abs ( f - t ) ;  Rectangle2D c = new Rectangle2D . Double ( h , k , y , w ) ; Paint n = getItemPaint ( w , l ) ; e . setPaint ( n ) ; e . fill ( c ) ; if ( isDrawBarOutline ( ) & & c . getBarWidth ( ) > 3 ) { e . setStroke ( getItemStroke ( w , l ) ) ; e . setPaint ( getItemOutlinePaint ( w , l ) ) ; e . draw ( c ) ; } / / standard deviation lines double b = d . getStdDevValue ( w , l ) . doubleValue ( ) ; double e = b . valueToJava2D ( z . doubleValue ( ) + b , x , a ) ; double g = b . valueToJava2D ( z . doubleValue ( ) - b , x , a ) ; if ( this . errorIndicatorStroke ! = null ) { e . setStroke ( this . errorIndicatorStroke ) ; } else { e . setStroke ( getItemOutlineStroke ( w , l ) ) ; } if ( this . errorIndicatorPaint ! = null ) { e . setPaint ( this . errorIndicatorPaint ) ; } else { e . setPaint ( getItemOutlinePaint ( w , l ) ) ; } Line2D v = null ; v = new Line2D . Double ( g , k + w / 2 . 0d , e , k + w / 2 . 0d ) ; e . draw ( v ) ; v = new Line2D . Double ( e , k + w * 0 . 25 , e , k + w * 0 . 75 ) ; e . draw ( v ) ; v = new Line2D . Double ( g , k + w * 0 . 25 , g , k + w * 0 . 75 ) ; e . draw ( v ) ;  CategoryItemLabelGenerator u = getItemLabelGenerator ( w , l ) ; if ( u ! = null & & isItemLabelVisible ( w , l ) ) { drawItemLabel ( e , d , w , l , q , u , c , ( z < 0 . 0 ) ) ; } / / add an item entity , if this information is being collected EntityCollection j = c . getEntityCollection ( ) ; if ( j ! = null ) { addItemEntity ( j , d , w , l , c ) ; } } public Number getMeanValue ( int o , int d ) { Number i = null ; MeanAndStandardDeviation p = ( MeanAndStandardDeviation ) this . data . getObject ( o , d ) ; return i ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset a ) { super ( ) ; this . dataset = a ; PiePlot c = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( c ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle b = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; b . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( b ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset k ) { super ( ) ; this . dataset = k ; PiePlot h = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( h ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle j = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( k ! = null ) { setDatasetGroup ( k . getGroup ( ) ) ; k . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot i = getParent ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected AxisState drawLabel ( String x , Graphics2D n , Rectangle2D w , Rectangle2D a , RectangleEdge p , AxisState c , PlotRenderingInfo i ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( c = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( x = = null ) | | ( x . equals ( \" \" ) ) ) { return c ; } Font c = getLabelFont ( ) ; RectangleInsets f = getLabelInsets ( ) ; n . setFont ( c ) ; n . setPaint ( getLabelPaint ( ) ) ; FontMetrics b = n . getFontMetrics ( ) ; Rectangle2D f = TextUtilities . getTextBounds ( x , n , b ) ; Shape j = null ; if ( p = = RectangleEdge . TOP ) { AffineTransform g = AffineTransform . getRotateInstance ( getLabelAngle ( ) , f . getCenterX ( ) , f . getCenterY ( ) ) ; Shape h = g . createTransformedShape ( f ) ; f = h . getBounds2D ( ) ; float i = ( float ) f . getWidth ( ) ; float t = ( float ) f . getHeight ( ) ; float s = ( float ) a . getCenterX ( ) ; float e = ( float ) ( c . getCursor ( ) - f . getBottom ( ) - t / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , n , s , e , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; j = new Rectangle2D . Float ( s - i / 2 . 0f , e - t / 2 . 0f , i , t ) ; c . cursorUp ( f . getTop ( ) + f . getHeight ( ) + f . getBottom ( ) ) ; } else if ( p = = RectangleEdge . BOTTOM ) { AffineTransform d = AffineTransform . getRotateInstance ( getLabelAngle ( ) , f . getCenterX ( ) , f . getCenterY ( ) ) ; Shape l = d . createTransformedShape ( f ) ; f = l . getBounds2D ( ) ; float r = ( float ) f . getWidth ( ) ; float u = ( float ) f . getHeight ( ) ; float q = ( float ) a . getCenterX ( ) ; float l = ( float ) ( c . getCursor ( ) + f . getTop ( ) + u / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , n , q , l , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; j = new Rectangle2D . Float ( q - r / 2 . 0f , l - u / 2 . 0f , r , u ) ; c . cursorDown ( f . getTop ( ) + f . getHeight ( ) + f . getBottom ( ) ) ; } else if ( p = = RectangleEdge . LEFT ) { AffineTransform j = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , f . getCenterX ( ) , f . getCenterY ( ) ) ; Shape g = j . createTransformedShape ( f ) ; f = g . getBounds2D ( ) ; float m = ( float ) f . getWidth ( ) ; float m = ( float ) f . getHeight ( ) ; float v = ( float ) ( c . getCursor ( ) - f . getRight ( ) - m / 2 . 0 ) ; float k = ( float ) a . getCenterY ( ) ; TextUtilities . drawRotatedString ( x , n , v , k , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; j = new Rectangle2D . Float ( v - m / 2 . 0f , k - m / 2 . 0f , m , m ) ; c . cursorLeft ( f . getLeft ( ) + f . getWidth ( ) + f . getRight ( ) ) ; } else if ( p = = RectangleEdge . RIGHT ) { AffineTransform o = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , f . getCenterX ( ) , f . getCenterY ( ) ) ; Shape d = o . createTransformedShape ( f ) ; f = d . getBounds2D ( ) ; float y = ( float ) f . getWidth ( ) ; float h = ( float ) f . getHeight ( ) ; float e = ( float ) ( c . getCursor ( ) + f . getLeft ( ) + y / 2 . 0 ) ; float k = ( float ) ( a . getY ( ) + a . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( x , n , e , k , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; j = new Rectangle2D . Float ( e - y / 2 . 0f , k - h / 2 . 0f , y , h ) ; c . cursorRight ( f . getLeft ( ) + f . getWidth ( ) + f . getRight ( ) ) ; } if ( i ! = null & & j ! = null ) { ChartRenderingInfo z = i . getOwner ( ) ; EntityCollection n = z . getEntityCollection ( ) ; if ( n ! = null ) { n . add ( new AxisLabelEntity ( this , j , this . labelToolTip , this . labelURL ) ) ; } } return c ; } } \\ No newline at end of file", "text_2": "public class test { protected AxisState drawLabel ( String l , Graphics2D a , Rectangle2D d , Rectangle2D j , RectangleEdge m , AxisState l , PlotRenderingInfo n ) { / / it is unlikely that ' state ' will be null , but check anyway . . . if ( l = = null ) { throw new IllegalArgumentException ( \" Null ' state ' argument . \" ) ; } if ( ( l = = null ) | | ( l . equals ( \" \" ) ) ) { return l ; } Font b = getLabelFont ( ) ; RectangleInsets h = getLabelInsets ( ) ; a . setFont ( b ) ; a . setPaint ( getLabelPaint ( ) ) ; FontMetrics t = a . getFontMetrics ( ) ; Rectangle2D i = TextUtilities . getTextBounds ( l , a , t ) ; Shape i = null ; if ( m = = RectangleEdge . TOP ) { AffineTransform u = AffineTransform . getRotateInstance ( getLabelAngle ( ) , i . getCenterX ( ) , i . getCenterY ( ) ) ; Shape h = u . createTransformedShape ( i ) ; i = h . getBounds2D ( ) ; float e = ( float ) i . getWidth ( ) ; float o = ( float ) i . getHeight ( ) ; float x = ( float ) j . getCenterX ( ) ; float m = ( float ) ( l . getCursor ( ) - h . getBottom ( ) - o / 2 . 0 ) ; TextUtilities . drawRotatedString ( l , a , x , m , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; i = new Rectangle2D . Float ( x - e / 2 . 0f , m - o / 2 . 0f , e , o ) ; l . cursorUp ( h . getTop ( ) + i . getHeight ( ) + h . getBottom ( ) ) ; } else if ( m = = RectangleEdge . BOTTOM ) { AffineTransform e = AffineTransform . getRotateInstance ( getLabelAngle ( ) , i . getCenterX ( ) , i . getCenterY ( ) ) ; Shape q = e . createTransformedShape ( i ) ; i = q . getBounds2D ( ) ; float v = ( float ) i . getWidth ( ) ; float p = ( float ) i . getHeight ( ) ; float k = ( float ) j . getCenterX ( ) ; float c = ( float ) ( l . getCursor ( ) + h . getTop ( ) + p / 2 . 0 ) ; TextUtilities . drawRotatedString ( l , a , k , c , TextAnchor . CENTER , getLabelAngle ( ) , TextAnchor . CENTER ) ; i = new Rectangle2D . Float ( k - v / 2 . 0f , c - p / 2 . 0f , v , p ) ; l . cursorDown ( h . getTop ( ) + i . getHeight ( ) + h . getBottom ( ) ) ; } else if ( m = = RectangleEdge . LEFT ) { AffineTransform f = AffineTransform . getRotateInstance ( getLabelAngle ( ) - Math . PI / 2 . 0 , i . getCenterX ( ) , i . getCenterY ( ) ) ; Shape j = f . createTransformedShape ( i ) ; i = j . getBounds2D ( ) ; float n = ( float ) i . getWidth ( ) ; float f = ( float ) i . getHeight ( ) ; float r = ( float ) ( l . getCursor ( ) - h . getRight ( ) - n / 2 . 0 ) ; float g = ( float ) j . getCenterY ( ) ; TextUtilities . drawRotatedString ( l , a , r , g , TextAnchor . CENTER , getLabelAngle ( ) - Math . PI / 2 . 0 , TextAnchor . CENTER ) ; i = new Rectangle2D . Float ( r - n / 2 . 0f , g - f / 2 . 0f , n , f ) ; l . cursorLeft ( h . getLeft ( ) + i . getWidth ( ) + h . getRight ( ) ) ; } else if ( m = = RectangleEdge . RIGHT ) { AffineTransform g = AffineTransform . getRotateInstance ( getLabelAngle ( ) + Math . PI / 2 . 0 , i . getCenterX ( ) , i . getCenterY ( ) ) ; Shape y = g . createTransformedShape ( i ) ; i = y . getBounds2D ( ) ; float k = ( float ) i . getWidth ( ) ; float s = ( float ) i . getHeight ( ) ; float w = ( float ) ( l . getCursor ( ) + h . getLeft ( ) + k / 2 . 0 ) ; float d = ( float ) ( j . getY ( ) + j . getHeight ( ) / 2 . 0 ) ; TextUtilities . drawRotatedString ( l , a , w , d , TextAnchor . CENTER , getLabelAngle ( ) + Math . PI / 2 . 0 , TextAnchor . CENTER ) ; i = new Rectangle2D . Float ( w - k / 2 . 0f , d - s / 2 . 0f , k , s ) ; l . cursorRight ( h . getLeft ( ) + i . getWidth ( ) + h . getRight ( ) ) ; } if ( ( i ! = null & & n ! = null ) ! = true & & n ! = null & & i ! = null ) { ChartRenderingInfo c = n . getOwner ( ) ; EntityCollection z = c . getEntityCollection ( ) ; if ( z ! = null ) { z . add ( new AxisLabelEntity ( this , i , this . labelToolTip , this . labelURL ) ) ; } } return l ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( null = = x ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_2": "if ( null = = x ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( null = = ( dataset ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 1}
{"text_1": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; } } \\ No newline at end of file", "text_2": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | false = = ( endIndex > = startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_2": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_3": 1}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }  public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ;  for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } }  public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex | | ( endIndex < 0 ) ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( true = = ( null = = owner ) ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_3": 1}
{"text_1": "if ( null = = item ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( null = = this . timePeriodClass ) {", "text_2": "if ( null = = item ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( null = = this . timePeriodClass ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }  public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( r = = this . maximumRangeValueRow & & c = = this . maximumRangeValueColumn ) | | ( r = = this . minimumRangeValueRow & & c = = this . minimumRangeValueColumn ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( r = = this . maximumRangeValueRow & & c = = this . maximumRangeValueColumn ) | | ( r = = this . minimumRangeValueRow & & c = = this . minimumRangeValueColumn ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( null = = marker ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( null = = marker ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | false = = ( endIndex + 1 > = startIndex + 1 ) ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( null = = categoryKeys ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_2": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( null = = categoryKeys ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( null = = dataset ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 1}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 1}
{"text_1": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( plotState . getOwner ( ) = = null ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_2": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_3": 1}
{"text_1": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }", "text_2": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "text_3": 1}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 1}
{"text_1": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }  } }", "text_3": 1}
{"text_1": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "text_2": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { if ( true = = ( null = = plotState . getOwner ( ) ) ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "} } } if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "text_2": "} } } findBoundsByIteration ( ) ; if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "text_3": 1}
{"text_1": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "text_2": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { return false ; } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_2": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_2": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( null = = result ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( null = = result ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; }", "text_2": "CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; }", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( null = = state ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "text_2": "/ / record the plot area . . . if ( null = = state ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( null = = info ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) {", "text_2": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) {", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 1 = = 0 ) { if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "} existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( PlotOrientation . HORIZONTAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & ! ( dataset instanceof SelectableCategoryDataset ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 3 ) { if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) {  } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "text_3": 0}
{"text_1": "if ( null = = edge ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( RectangleEdge . TOP = = edge ) { this . axesAtTop . add ( axis ) ; } else if ( RectangleEdge . BOTTOM = = edge ) { this . axesAtBottom . add ( axis ) ; } else if ( RectangleEdge . LEFT = = edge ) { this . axesAtLeft . add ( axis ) ; } else if ( RectangleEdge . RIGHT = = edge ) { this . axesAtRight . add ( axis ) ; } } } \\ No newline at end of file", "text_2": "if ( null = = edge ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) = = - 1 ) if ( RectangleEdge . TOP = = edge ) { this . axesAtTop . add ( axis ) ; } else if ( RectangleEdge . BOTTOM = = edge ) { this . axesAtBottom . add ( axis ) ; } else if ( RectangleEdge . LEFT = = edge ) { this . axesAtLeft . add ( axis ) ; } else if ( RectangleEdge . RIGHT = = edge ) { this . axesAtRight . add ( axis ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( null = = this . dataset ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( null = = this . dataset ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_3": 0}
{"text_1": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; }", "text_2": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; }", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; }", "text_3": 0}
{"text_1": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( null = = this . data ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "if ( LengthConstraintType . NONE = = h ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( LengthConstraintType . FIXED = = h ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( LengthConstraintType . RANGE = = h ) { contentSize = arrangeFR ( container , g2 , constraint ) ; }", "text_2": "if ( LengthConstraintType . NONE = = h ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( LengthConstraintType . FIXED = = h ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( LengthConstraintType . RANGE = = h ) { contentSize = arrangeFR ( container , g2 , constraint ) ; }", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( null = = info ) { return ; } drawBackground ( g2 , plotArea ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( false = = ( null = = dataset ) ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "if ( endIndex < 0 ) { emptyRange = true ; } if ( false = = ( endIndex > startIndex ) ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "} existing . setY ( y ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( null = = item ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( null = = this . timePeriodClass ) {", "text_2": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( null = = this . timePeriodClass ) {", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "text_2": "return ( index ) ; } } if ( null = = object ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( Layer . FOREGROUND = = layer ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( null = = markers ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { return false ; } } return true ;", "text_2": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { System . exit ( 0 ) ; } } return true ;", "text_3": 0}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { return false ; } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_2": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_3": 0}
{"text_1": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( DatasetRenderingOrder . FORWARD = = order ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;", "text_2": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "text_3": 0}
{"text_1": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "if ( endIndex < 0 ) { emptyRange = true ; } if ( true = = ( startIndex = = 1 ) ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { return false ; } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_2": "} Range range = ( Range ) obj ; if ( ! ( range . lower = = this . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( range . upper = = this . upper ) ) { return false ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( - 1 = = 0 ) if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "text_3": 0}
{"text_1": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "text_2": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , null ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( true = = ( startIndex = = 1 ) ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( PlotOrientation . HORIZONTAL = = orientation ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( PlotOrientation . VERTICAL = = orientation ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( null = = result ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( null = = result ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_2": "return ( index ) ; } } if ( null = = object ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( axis ! = null ) { axis . configure ( ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_3": 0}
{"text_1": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "text_2": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( false = = ( result = = getLegendItemToolTipGenerator ( ) ) ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( null = = ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 0}
{"text_1": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] , d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; while ( ! done ) {", "text_2": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] , d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; while ( ! done ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }  public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) , columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ;", "text_2": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ;", "text_3": 1}
{"text_1": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "state . cursorRight ( insets . getLeft ( ) + labelBounds . getWidth ( ) + insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) , base = 0 . 0 ; double lclip = getLowerClip ( ) , uclip = getUpperClip ( ) ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) , lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) , base = 0 . 0 ; double lclip = getLowerClip ( ) , uclip = getUpperClip ( ) ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) , lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) , base = 0 . 0 ; double lclip = getLowerClip ( ) , uclip = getUpperClip ( ) ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) , lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) , base = 0 . 0 ; double lclip = getLowerClip ( ) , uclip = getUpperClip ( ) ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) , lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_3": 1}
{"text_1": "} h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; }", "text_2": "} h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; }", "text_3": 1}
{"text_1": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) , uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "text_2": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) , lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] , d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_2": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] , d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_3": 1}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 1 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = constraint . getWidth ( ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "text_2": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ;", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ;", "text_3": 0}
{"text_1": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_2": "protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) {", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) {", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) ,", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_3": 0}
{"text_1": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "text_2": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "text_3": 0}
{"text_1": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ;", "text_2": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ;", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; }", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ;", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ;", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ;", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 4 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; double stickWidth ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; }", "text_3": 0}
{"text_1": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "text_2": "RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "text_3": 0}
{"text_1": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ;", "text_2": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) , e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ;", "text_3": 0}
{"text_1": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_2": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_3": 0}
{"text_1": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "text_2": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = w [ 0 ] ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double linkX = plotArea . getX ( ) + gapHorizontal / 2 , linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal , linkH = plotArea . getHeight ( ) - gapVertical ; / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ;", "text_2": "g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; } double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 , linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  / / make the link area a square if the pie chart is to be circular . . . if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "if ( this . minEndIndex > = 0 ) { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else {", "text_2": "if ( this . minEndIndex > = 0 ) { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } } else {", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 , sd = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ;", "text_3": 0}
{"text_1": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;", "text_2": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) {", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] , h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "text_3": 0}
{"text_1": "g2 . clip ( plotArea ) ; / / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) , labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; }", "text_2": "g2 . clip ( plotArea ) ; / / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; }", "text_3": 0}
{"text_1": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) , b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }  public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ;  for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } }  public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { } return result ; }  public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  }  public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }", "text_2": "result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "text_3": 1}
{"text_1": "public class test { public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "text_2": "public class test { public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }  public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "text_2": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; }  public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; for ( ; iterator . hasNext ( ) ; ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "text_3": 1}
{"text_1": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "text_2": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "text_3": 0}
{"text_1": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "text_2": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "text_3": 0}
{"text_1": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; }  public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  }  public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < startIndex | | ( endIndex < 0 ) ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }  public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; minval = ( item . getMinOutlier ( ) ! = null ) ? item . getMinOutlier ( ) . doubleValue ( ) : minval ; double maxval = Double . NaN ; maxval = ( item . getMaxOutlier ( ) ! = null ) ? item . getMaxOutlier ( ) . doubleValue ( ) : maxval ;  if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; minval = ( item . getMinOutlier ( ) ! = null ) ? item . getMinOutlier ( ) . doubleValue ( ) : minval ; double maxval = Double . NaN ; maxval = ( item . getMaxOutlier ( ) ! = null ) ? item . getMaxOutlier ( ) . doubleValue ( ) : maxval ; if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; }  if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 | | ( endIndex < startIndex ) ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": ": Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }", "text_2": ": Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; }  Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_3": 1}
{"text_1": ": Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } } }", "text_2": ": Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; if ( a instanceof XYAnnotationBoundsInfo ) { includedAnnotations . add ( a ) ; } } }  } }", "text_3": 1}
{"text_1": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; minimum = ( ! Double . isNaN ( lvalue ) ) ? Math . min ( minimum , lvalue ) : minimum ; maximum = ( ! Double . isNaN ( uvalue ) ) ? Math . max ( maximum , uvalue ) : maximum ; } } } else if ( includeInterval & & dataset instanceof OHLCDataset ) { for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; minimum = ( ! Double . isNaN ( lvalue ) ) ? Math . min ( minimum , lvalue ) : minimum ; maximum = ( ! Double . isNaN ( uvalue ) ) ? Math . max ( maximum , uvalue ) : maximum ; } } } else {", "text_2": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } } else if ( includeInterval & & dataset instanceof OHLCDataset ) { for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } } } else {", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < startIndex ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 1}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_3": 1}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; ValueAxis result = null ; result = ( index < this . rangeAxes . size ( ) ) ? ( ValueAxis ) this . rangeAxes . get ( index ) : result ; if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; ValueAxis result = null ; result = ( index < this . rangeAxes . size ( ) ) ? ( ValueAxis ) this . rangeAxes . get ( index ) : result ; if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "return ; } state = ( state = = null ) ? new PlotRenderingInfo ( null ) : state ; state . setPlotArea ( area ) ; / / adjust the drawing area for the plot insets ( if any ) . . .", "text_2": "return ; } if ( state = = null ) { if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ; / / adjust the drawing area for the plot insets ( if any ) . . .", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_2": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer ! = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_3": 0}
{"text_1": "/ / draw the plot ( axes and data visualisation ) PlotRenderingInfo plotInfo = null ; plotInfo = ( info ! = null ) ? info . getPlotInfo ( ) : plotInfo ; this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "/ / draw the plot ( axes and data visualisation ) PlotRenderingInfo plotInfo = null ; plotInfo = ( info ! = null ) ? info . getPlotInfo ( ) : plotInfo ; fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_2": "public class test { public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "public class test { public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "public class test { public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else contentSize = ( h = = LengthConstraintType . RANGE ) ? arrangeFR ( container , g2 , constraint ) : contentSize ; } else if ( w = = LengthConstraintType . RANGE ) {", "text_2": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else contentSize = ( h = = LengthConstraintType . RANGE ) ? arrangeFR ( container , g2 , constraint ) : contentSize ; } else if ( w = = LengthConstraintType . RANGE ) {", "text_3": 0}
{"text_1": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y } base = uclip ; value = ( value < = lclip ) ? lclip : value ; } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { value = ( value < = lclip ) ? lclip : value ; } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; value = ( value > = uclip ) ? uclip : value ; } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getStandardDeviation ( ) : result ; return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y } base = uclip ; value = ( value < = lclip ) ? lclip : value ; } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { value = ( value < = lclip ) ? lclip : value ; } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; value = ( value > = uclip ) ? uclip : value ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( data = = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer ! = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_3": 0}
{"text_1": "endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; startIndex = ( ( endIndex > startIndex ) = = false ) ? endIndex : startIndex ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; }", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_2": "ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; ArrayList markers ; markers = ( layer = = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; markers = ( layer ! = Layer . FOREGROUND ) ? ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) : ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; m = ( mean ! = null ) ? mean . doubleValue ( ) : m ;", "text_3": 0}
{"text_1": "/ / draw the plot ( axes and data visualisation ) PlotRenderingInfo plotInfo = null ; plotInfo = ( info ! = null ) ? info . getPlotInfo ( ) : plotInfo ; this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "/ / draw the plot ( axes and data visualisation ) PlotRenderingInfo plotInfo = null ; plotInfo = ( info ! = null ) ? info . getPlotInfo ( ) : plotInfo ; if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( false ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } emptyRange = ( endIndex < 0 ) ? true : emptyRange ; if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; labelPercent = ( getLabelGenerator ( ) ! = null ) ? getLabelGap ( ) + getMaximumLabelWidth ( ) : labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ;", "text_2": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; labelPercent = ( getLabelGenerator ( ) ! = null ) ? getLabelGap ( ) + getMaximumLabelWidth ( ) : labelPercent ; double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; ValueAxis result = null ; result = ( index < this . rangeAxes . size ( ) ) ? ( ValueAxis ) this . rangeAxes . get ( index ) : result ; if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; ValueAxis result = null ; result = ( index < this . rangeAxes . size ( ) ) ? ( ValueAxis ) this . rangeAxes . get ( index ) : result ; if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd = = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = ( masd ! = null ) ? masd . getMean ( ) : result ; return result ; } } \\ No newline at end of file", "text_2": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "else { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "else { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( ! ( this . allowDuplicateXValues ) ) ; else { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( dataset ) = = null ) ) ; else { return result ;", "text_3": 1}
{"text_1": "else { return false ; } return super . equals ( obj ) ; } } \\ No newline at end of file", "text_2": "else { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) ) ; else { return false ; } } return true ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }  public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { else { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } if ( ! ( row > = 0 ) ) { return null ; } else { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( ! ( i > = 0 ) ) ; else { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ;  for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( ! ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) ) ; else { allNull = false ; break ; } } if ( ! ( allNull ) ) ; else { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { else { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( ! ( index > = 0 ) ) { return null ; } else { return rowData . getObject ( index ) ; } }  public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( ! ( index < 0 ) ) ; else { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; }  public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( ! ( this . dataset ! = null ) ) ; else { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  }  public double getMaximumExplodePercent ( ) { if ( ! ( this . dataset = = null ) ) ; else { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ; } public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ; } public int getDomainAxisIndex ( CategoryAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < startIndex | | ( endIndex < 0 ) ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "; else { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_2": "; else { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ;", "text_3": 1}
{"text_1": "else { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( ! ( this . timePeriodClass = = null ) ) {", "text_2": "else { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( ! ( this . timePeriodClass = = null ) ) {", "text_3": 1}
{"text_1": "; else { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "text_2": "; else { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }  public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; int r = this . data . getRowIndex ( rowKey ) ; int c = this . data . getColumnIndex ( columnKey ) ; if ( ! ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) ) ; else { updateBounds ( ) ; }  double minval = Double . NaN ; if ( ! ( item . getMinOutlier ( ) ! = null ) ) ; else { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( ! ( item . getMaxOutlier ( ) ! = null ) ) ; else { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; }  if ( ! ( Double . isNaN ( this . maximumRangeValue ) ) ) { if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } else { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; }  if ( ! ( Double . isNaN ( this . minimumRangeValue ) ) ) { if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } else { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; int r = this . data . getRowIndex ( rowKey ) ; int c = this . data . getColumnIndex ( columnKey ) ; if ( ! ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) ) { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } double maxval = Double . NaN ; if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } else { updateBounds ( ) ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( ! ( item ! = null ) ) ; else { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( ! ( marker = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) )", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( ! ( marker = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) )", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "this . categoryKeys = generateKeys ( categoryCount , prefix ) ; } } else { this . seriesKeys = null ; this . categoryKeys = null ; } } else { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( ! ( categoryKeys . length ! = this . startData [ 0 ] . length ) ) ; else { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ;", "text_2": "this . categoryKeys = generateKeys ( categoryCount , prefix ) ; } } else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } else { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( ! ( categoryKeys . length ! = getCategoryCount ( ) ) ) ; else { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset = = null ) ) ; else { return result ;", "text_3": 1}
{"text_1": "if ( ! ( this . maxMiddleIndex > = 0 ) ) { this . maxMiddleIndex = index ; } else { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ;", "text_2": "if ( ! ( this . maxMiddleIndex > = 0 ) ) { this . maxMiddleIndex = index ; } else { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) { this . maxMiddleIndex = index ;", "text_3": 1}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { add ( x , y , true ) ; if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( ! ( this . data . size ( ) > 0 ) ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( ! ( this . data . size ( ) > 0 ) ) ;", "text_3": 1}
{"text_1": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else { ChartRenderingInfo owner = plotState . getOwner ( ) ;", "text_2": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } if ( ! ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) ) ; else { ChartRenderingInfo owner = plotState . getOwner ( ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 | | ( endIndex < startIndex ) ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else {", "text_2": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } hotspot = null ; if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else {", "text_3": 1}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( ! ( this . errorIndicatorStroke ! = null ) ) { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } else { g2 . setStroke ( this . errorIndicatorStroke ) ; } if ( ! ( this . errorIndicatorPaint ! = null ) ) { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } else { g2 . setPaint ( this . errorIndicatorPaint ) ; } Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ;  CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( ! ( generator ! = null & & isItemLabelVisible ( row , column ) ) ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( ! ( this . errorIndicatorStroke ! = null ) ) { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } else { g2 . setStroke ( this . errorIndicatorStroke ) ; } if ( ! ( this . errorIndicatorPaint ! = null ) ) { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } else { g2 . setPaint ( this . errorIndicatorPaint ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( ! ( generator ! = null & & isItemLabelVisible ( row , column ) ) )", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( ! ( meanValue = = null ) ) ; else { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( ! ( n ! = null ) ) ; else { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( ! ( generator ! = null & & isItemLabelVisible ( row , column ) ) ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( ! ( meanValue = = null ) ) ; else { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( ! ( n ! = null ) ) ; else { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ; if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } Line2D line = null ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( ! ( generator ! = null & & isItemLabelVisible ( row , column ) ) )", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( ! ( index < this . keys . size ( ) ) ) ; else { rebuildIndex ( ) ; } }  public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( ! ( index < 0 ) ) ; else { return ; } removeValue ( index ) ; } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "text_2": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( ! ( index < 0 ) ) ; else { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; }  public void removeColumn ( Comparable columnKey ) { if ( ! ( columnKey = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! ( ! this . columnKeys . contains ( columnKey ) ) ) ; else { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( ! ( index > = 0 ) ) ; else { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "text_3": 1}
{"text_1": "if ( ! ( this . rightBlock ! = null ) ) ; else { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; }", "text_2": "if ( ! ( this . rightBlock ! = null ) ) ; else { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; }", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else { emptyRange = true ;", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < startIndex ) ) ; else { emptyRange = true ;", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; }  public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ; else { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else {", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( ! ( masd ! = null ) ) ; else {", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( ! ( index < this . keys . size ( ) ) ) ; else { rebuildIndex ( ) ; } }  public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( ! ( index < 0 ) ) ; else { return ; } removeValue ( index ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( ! ( index < 0 ) ) ; else { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; }  public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "this . data . add ( item ) ; added = true ; } if ( ! ( added ) ) ; else {", "text_2": "this . data . add ( item ) ; added = true ; } findBoundsByIteration ( ) ; if ( ! ( added ) ) ; else {", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } if ( ! ( axis = = null ) ) ; else { throw new IllegalArgumentException ( ) ; } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "else { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "text_2": "else { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_3": 1}
{"text_1": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { return false ; } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_2": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) ) ; else { return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( false ) ) ; else { return result ;", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) ) ; else { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) ,", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( null ! = null ) ) ; else { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) ,", "text_3": 0}
{"text_1": "else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( ! ( this . data . size ( ) > 0 ) )", "text_2": "else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( ! ( this . data . size ( ) > 0 ) )", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 1 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = constraint . getWidth ( ) ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( ! ( existing ! = null ) ) ; if ( ! ( result = = null ) ) ; else { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( ! ( existing ! = null ) ) ; if ( ! ( result = = null ) ) ; else { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; if ( ! ( dataset ! = null ) ) ; else { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { if ( ! ( ! ( data instanceof StatisticalCategoryDataset ) ) ) ; else {", "text_2": "public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { if ( ! ( true ) ) ; else return ; if ( ! ( ! ( data instanceof StatisticalCategoryDataset ) ) ) ; else {", "text_3": 0}
{"text_1": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { add ( x , y , true ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "if ( ! ( state = = null ) ) ; else { state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "text_2": "if ( ! ( state = = null ) ) ; else { if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( ! ( info = = null ) ) ; else { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ; } return result ; }", "text_2": "if ( ! ( masd ! = null ) ) ; else { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "text_3": 0}
{"text_1": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( ! ( this . data . size ( ) > 0 ) ) ; else {", "text_2": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( ! ( this . data . size ( ) > 0 ) ) ; else {", "text_3": 0}
{"text_1": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ! ( this . topBlock ! = null ) ) ; else { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ! ( this . bottomBlock ! = null ) ) ;", "text_2": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( ! ( this . bottomBlock ! = null ) ) ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer ! = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_2": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_3": 0}
{"text_1": "else { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ! ( this . rightBlock ! = null ) ) h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ! ( this . bottomBlock ! = null ) ) ; else { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ;", "text_2": "else { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( ! ( this . rightBlock ! = null ) ) h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ;", "text_3": 0}
{"text_1": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_2": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( 0 = = 1 ) ) ; else { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( new XYDataItem ( x , y ) ) ; if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "text_3": 0}
{"text_1": "; else { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "; else { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( false ) ) ; else { if ( dataset ! = null ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) ; else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) ; else { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) ) ;", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) ) ;", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_3": 0}
{"text_1": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ;", "text_2": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ;", "text_3": 0}
{"text_1": "} } if ( ! ( this . minMiddleIndex > = 0 ) ) { this . minMiddleIndex = index ; } else { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ;", "text_2": "} } if ( ! ( this . minMiddleIndex = = 0 ) ) { this . minMiddleIndex = index ; } else { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ;", "text_3": 0}
{"text_1": "} } } return copy ; } } \\ No newline at end of file", "text_2": "} } } return copy . addAndOrUpdate ( copy ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_2": "else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( end < start & & this . data . size ( ) > 0 ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null & & ! ( dataset instanceof SelectableCategoryDataset ) ) ) ; else { return result ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ;", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_2": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = this . annotations . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( 3 = = 0 ) ) ; else { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( ! ( index < this . keys . size ( ) ) ) ; else { rebuildIndex ( ) ;", "text_2": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( ! ( index < = this . keys . size ( ) ) ) ; else { rebuildIndex ( ) ;", "text_3": 0}
{"text_1": "else { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "else { result = masd . getMean ( ) ; } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else {", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( ! ( masd ! = null ) ) ; else {", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( false ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "else { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "else { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( false ) ) ; else { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) ) ; else { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ;", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( null ! = null ) ) ; else { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ;", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 0}
{"text_1": "else { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( ! ( edge = = RectangleEdge . TOP ) ) { if ( edge = = RectangleEdge . BOTTOM ) { this . axesAtBottom . add ( axis ) ; } else if ( edge = = RectangleEdge . LEFT ) { this . axesAtLeft . add ( axis ) ; } else if ( edge = = RectangleEdge . RIGHT ) { this . axesAtRight . add ( axis ) ; } } else { this . axesAtTop . add ( axis ) ; } } } \\ No newline at end of file", "text_2": "else { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( ! ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) ) ; else if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; } else if ( edge = = RectangleEdge . BOTTOM ) { this . axesAtBottom . add ( axis ) ; } else if ( edge = = RectangleEdge . LEFT ) { this . axesAtLeft . add ( axis ) ; } else if ( edge = = RectangleEdge . RIGHT ) { this . axesAtRight . add ( axis ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; if ( ! ( this . dataset = = null ) ) ; else { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; if ( ! ( this . dataset = = null ) ) ; else { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 4 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) )", "text_2": "if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) )", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) ) ; else { return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) { this . rowCount = 0 ; this . columnCount = 0 ; } else { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "if ( ! ( end < start ) ) ; else { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; double stickWidth ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ; else { return ;", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( ( ! b1 ) | | b2 ) ) ; else { return ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = this . annotations . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ; else { return ;", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) ) ; else { return ;", "text_3": 0}
{"text_1": "if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else { } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else { } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_2": "if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else { } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else { } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) ) ; else { return result ;", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; }", "text_2": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; }", "text_3": 0}
{"text_1": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "text_2": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( ! ( info = = null ) ) ; else { return ; } drawBackground ( g2 , plotArea ) ;", "text_3": 0}
{"text_1": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double uclip = getUpperClip ( ) ; if ( ! ( uclip < = 0 . 0 ) ) { if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { if ( ! ( this . errorIndicatorPaint ! = null ) ) { g2 . setPaint ( getItemPaint ( row , column ) ) ; } else { g2 . setPaint ( this . errorIndicatorPaint ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double uclip = getUpperClip ( ) ; if ( ! ( uclip < = 0 . 0 ) ) { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "this . minMiddleIndex = index ; } else { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ;", "text_2": "this . minMiddleIndex = index ; } else { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) { this . minMiddleIndex = index ;", "text_3": 0}
{"text_1": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ! ( this . centerBlock ! = null ) ) ;", "text_2": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( ! ( this . centerBlock ! = null ) ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ;", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( data = = null ) ) ; else { result = masd . getMean ( ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) { for ( int i = seriesCount - 1 ; i > = 0 ; i - - ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) { for ( int i = seriesCount - 1 ; i > = 0 ; i - - ) {", "text_3": 0}
{"text_1": "if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "if ( ! ( end < start ) ) ; else { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer ! = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_3": 0}
{"text_1": "else { emptyRange = true ; } if ( ! ( emptyRange ) ) { return createCopy ( startIndex , endIndex ) ; } else {", "text_2": "else { emptyRange = true ; } if ( ! ( ( endIndex > startIndex ) = = false ) ) ; else { startIndex = endIndex ; } if ( ! ( emptyRange ) ) { return createCopy ( startIndex , endIndex ) ; } else {", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( ! ( true ) ) ; else return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ; else { return ;", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | ( getRenderer ( ) ! = null ) ) ) ; else { return ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ; } return result ; } int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ;", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = w [ 0 ] ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "text_2": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( ! ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) ) ; else { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "text_3": 0}
{"text_1": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else {", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( ! ( masd ! = null ) ) ; else {", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;  } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( ! ( item = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( ! ( this . timePeriodClass = = null ) ) {", "text_2": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( ! ( this . timePeriodClass = = null ) ) {", "text_3": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_2": "public class test { public void delete ( int start , int end ) { if ( ! ( end < start & & ( 0 < start ) ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( end < start & & ( 0 < start ) ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "linkH = 2 * min ; } if ( ! ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) ) ; else { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; else {", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ;", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "text_2": "return ( index ) ; } } if ( ! ( object = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} else { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } }", "text_2": "} else { long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } }", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer = = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; } else { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( ! ( markers = = null ) ) ; else { return false ; } boolean removed = markers . remove ( marker ) ; if ( ! ( removed & & notify ) ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( ! ( layer ! = Layer . FOREGROUND ) ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( ! ( mean ! = null ) )", "text_3": 0}
{"text_1": "else { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "text_2": "else { plotInfo = info . getPlotInfo ( ) ; } if ( ! ( false ) ) ; else { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( dataset ! = null ) & & ( index > 0 ) ) ) ; else { return result ;", "text_3": 0}
{"text_1": "if ( ! ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) ) ; else { return false ; } } return true ;", "text_2": "if ( ! ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) ) ; else { System . exit ( 0 ) ; } } return true ;", "text_3": 0}
{"text_1": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { return false ; } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_2": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_3": 0}
{"text_1": "else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( end < start ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_2": "else { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ! ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) ) ; else { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ;", "text_3": 0}
{"text_1": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( ! ( order = = DatasetRenderingOrder . FORWARD ) ) { int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } } for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; } for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } } for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; } for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } else { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ;", "text_2": "g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( ! ( b1 | | b2 ) ) ; else { return ; } / / draw the foreground markers . . . space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } else { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ;", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) { RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) { if ( ! ( true ) ) ; else return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "text_3": 0}
{"text_1": "else { emptyRange = true ; } if ( ! ( emptyRange ) ) { return createCopy ( startIndex , endIndex ) ; } else {", "text_2": "else { emptyRange = true ; } if ( ! ( ( startIndex = = 1 ) = = true ) ) ; else { return this ; } if ( ! ( emptyRange ) ) { return createCopy ( startIndex , endIndex ) ; } else {", "text_3": 0}
{"text_1": "if ( ! ( lower > upper ) ) ; else { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "if ( ! ( lower > upper ) ) ; else { } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { return false ; } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_2": "if ( ! ( ! ( this . lower = = range . lower ) ) ) ; else { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( ! ( this . upper = = range . upper ) ) ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( 0 = = - 1 ) ) ; else if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ; else { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( null ! = null ) ) ; else { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ;", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( false ) ) ; else { result = masd . getMean ( ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ; else { return ;", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) ) ; else { return ;", "text_3": 0}
{"text_1": "getRenderer ( ) . drawBackground ( g2 , this , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "text_2": "getRenderer ( ) . drawBackground ( g2 , this , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , null ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_2": "int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; }", "text_3": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( endIndex < 0 ) ) ; else {", "text_2": "endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( ! ( ( startIndex = = 1 ) = = true ) ) ; else { return this ; } if ( ! ( endIndex < 0 ) ) ; else {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( dataset ! = null ) & & ( index ! = 0 ) ) ) ; else { return result ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) { for ( int i = seriesCount - 1 ; i > = 0 ; i - - ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) { for ( int i = seriesCount - 1 ; i > = 0 ; i - - ) {", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( ! ( tooltips ) ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( orientation = = PlotOrientation . HORIZONTAL ) ) { if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } else { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( ! ( false ) ) ; else { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( ! ( getLabelGenerator ( ) ! = null ) ) ;", "text_2": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( ! ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) ) ; else { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( ! ( getLabelGenerator ( ) ! = null ) ) ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( ! ( existing ! = null ) ) ; if ( ! ( result = = null ) ) ; else { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( ! ( existing ! = null ) ) ; if ( ! ( result = = null ) ) ; else { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( ! ( existing ! = null ) ) ; else { if ( ! ( axis ! = null ) ) ; else { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( ! ( axis ! = null ) ) ; else { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( ! ( notify ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_2": "return ( index ) ; } } if ( ! ( object = = null ) ) ; else { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( ! ( existing ! = null ) ) ; else { if ( ! ( axis ! = null ) ) ; else { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( ! ( axis ! = null ) ) ; else { axis . configure ( ) ; } if ( ! ( notify ) ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( ! ( result < 0 ) ) ;", "text_3": 0}
{"text_1": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ! ( this . bottomBlock ! = null ) ) ; else { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ;", "text_2": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ! ( this . leftBlock ! = null ) ) ;", "text_3": 0}
{"text_1": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( b1 | | b2 ) ) ; else { return ;", "text_2": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ! ( this . rangeGridlinesVisible | | b2 ) ) ; else { return ;", "text_3": 0}
{"text_1": "if ( ! ( dataset ! = null ) ) ; else { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_2": "if ( ! ( dataset ! = null ) ) ; else { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( ! ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) ) {", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( dataset ! = null ) ) ; else { return result ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ! ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) ) ; else { return result ;", "text_3": 0}
{"text_1": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( ! ( index > = 0 & & ! this . allowDuplicateXValues ) ) { if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ;", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd = = null ) ) ; else { result = masd . getMean ( ) ;", "text_3": 0}
{"text_1": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_2": "RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( ! ( this . rightBlock ! = null ) )", "text_3": 0}
{"text_1": "; else { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "; else { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( ! ( masd ! = null ) ) ; else { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "int seriesCount = getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( ! ( seriesCount > 1 ) ) { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } else { double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } if ( ! ( plotState ! = null & & hotspot ! = null ) ) ; else { ChartRenderingInfo owner = plotState . getOwner ( ) ;", "text_2": "hotspot = new Rectangle2D . Float ( labelx - w / 2 . 0f , labely - h / 2 . 0f , w , h ) ; state . cursorUp ( insets . getTop ( ) + labelBounds . getHeight ( ) + insets . getBottom ( ) ) ; } if ( ! ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) ) ; else { ChartRenderingInfo owner = plotState . getOwner ( ) ;", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( Number x , Number y ) { XYDataItem overwritten = null ;  if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_2": "public class test { public XYDataItem addOrUpdate ( Number x , Number y ) { if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } XYDataItem overwritten = null ;  if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { this . value = value ; super ( paint , stroke , paint , stroke , alpha ) ; } } \\ No newline at end of file", "text_2": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { this . value = value ; super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} PathIterator iterator1 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; double [ ] d2 = new double [ 6 ] ; while ( ! done ) {", "text_2": "} PathIterator iterator1 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ; double [ ] d2 = new double [ 6 ] ; while ( ! done ) {", "text_3": 1}
{"text_1": "} while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }  public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( row < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "} while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ;  for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( row < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; if ( column < 0 ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey + \" ) not recognised . \" ) ; } int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } }  public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public double getMaximumExplodePercent ( ) { Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; double result = 0 . 0 ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ; Number explode = ( Number ) this . explodePercentages . get ( key ) ; } return result ; }  public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "text_2": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  }  public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; if ( this . dataset = = null ) { return 0 . 0 ; } Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Comparable key = ( Comparable ) iterator . next ( ) ; Number explode = ( Number ) this . explodePercentages . get ( key ) ; } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; boolean added = false ;", "text_2": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; boolean added = false ;", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }  public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; / / update cached min and max values int r = this . data . getRowIndex ( rowKey ) ; int c = this . data . getColumnIndex ( columnKey ) ; double minval = Double . NaN ;  if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double maxval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; } if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { this . data . addObject ( item , rowKey , columnKey ) ; / / update cached min and max values int r = this . data . getRowIndex ( rowKey ) ; int c = this . data . getColumnIndex ( columnKey ) ; if ( ( this . maximumRangeValueRow = = r & & this . maximumRangeValueColumn = = c ) | | ( this . minimumRangeValueRow = = r & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; double maxval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { minval = item . getMinOutlier ( ) . doubleValue ( ) ; } if ( item . getMaxOutlier ( ) ! = null ) { maxval = item . getMaxOutlier ( ) . doubleValue ( ) ; }  if ( Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } else if ( maxval > this . maximumRangeValue ) { this . maximumRangeValue = maxval ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } if ( Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } else if ( minval < this . minimumRangeValue ) { this . minimumRangeValue = minval ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; }  private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) {", "text_3": 1}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "text_3": 1}
{"text_1": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_2": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; } for ( int i = 0 ; i < categoryKeys . length ; i + + ) {", "text_3": 1}
{"text_1": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_2": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_3": 1}
{"text_1": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_2": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double base = 0 . 0 ; double value = meanValue . doubleValue ( ) ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } Line2D line = null ; if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double base = 0 . 0 ; double value = meanValue . doubleValue ( ) ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } Line2D line = null ; if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double base = 0 . 0 ; double value = meanValue . doubleValue ( ) ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } Line2D line = null ; if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } line = new Line2D . Double ( lowVal , rectY + rectHeight / 2 . 0d , highVal , rectY + rectHeight / 2 . 0d ) ; g2 . draw ( line ) ; line = new Line2D . Double ( highVal , rectY + rectHeight * 0 . 25 , highVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) { / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double base = 0 . 0 ; double value = meanValue . doubleValue ( ) ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) + valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) - valueDelta , dataArea , yAxisLocation ) ;  if ( this . errorIndicatorStroke ! = null ) { g2 . setStroke ( this . errorIndicatorStroke ) ; } else { g2 . setStroke ( getItemOutlineStroke ( row , column ) ) ; } Line2D line = null ; if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemOutlinePaint ( row , column ) ) ; } line = new Line2D . Double ( rectX + rectWidth / 2 . 0d , lowVal , rectX + rectWidth / 2 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , highVal , rectX + rectWidth / 2 . 0d + 5 . 0d , highVal ) ; g2 . draw ( line ) ; line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; if ( generator ! = null & & isItemLabelVisible ( row , column ) ) {", "text_3": 1}
{"text_1": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { this . value = value ; } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { this . value = value ; super ( paint , stroke , outlinePaint , stroke , alpha ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "text_2": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "text_3": 1}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_3": 1}
{"text_1": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_2": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } this . maxY = 1 . 0 ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_3": 0}
{"text_1": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_2": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_3": 0}
{"text_1": "public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;", "text_2": "public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) { if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } if ( true ) return ; PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;", "text_3": 0}
{"text_1": "boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( state = = null ) { state = new PlotRenderingInfo ( null ) ; }", "text_2": "boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( state = = null ) { if ( true ) return ; state = new PlotRenderingInfo ( null ) ; }", "text_3": 0}
{"text_1": "double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; if ( info = = null ) { return ; }  if ( isCircular ( ) ) { double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "text_2": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "text_3": 0}
{"text_1": "double [ ] h = new double [ 5 ] ; double [ ] w = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ;", "text_2": "double [ ] h = new double [ 5 ] ; double [ ] w = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; w [ 1 ] = w [ 0 ] ; this . rightBlock = null ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ;", "text_3": 0}
{"text_1": "if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } Size2D s1 = arrangeNN ( container , g2 ) ; w [ 1 ] = w [ 0 ] ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) {", "text_2": "if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } PlotOrientation orientation = null ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) {", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] h = new double [ 5 ] ; double [ ] w = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ;", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; this . leftBlock = null ; w [ 0 ] = constraint . getWidth ( ) ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double sd = 0 . 0 ; double m = 0 . 0 ; if ( mean ! = null ) {", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { Number n = getValue ( rowKey , columnKey ) ; MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double sd = 0 . 0 ; double m = 0 . 0 ; if ( mean ! = null ) {", "text_3": 0}
{"text_1": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "text_2": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( state = = null ) { state = new PlotRenderingInfo ( null ) ;", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( state = = null ) { state = new PlotRenderingInfo ( null ) ;", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ;", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ;", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; h [ 4 ] = h [ 2 ] ;", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; h [ 4 ] = h [ 2 ] ;", "text_3": 0}
{"text_1": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; public LegendItemCollection getLegendItems ( ) { LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } int section = 0 ; List keys = this . dataset . getKeys ( ) ; Shape shape = getLegendItemShape ( ) ;", "text_2": "public static JFreeChart createPieChart3D ( String title , PieDataset dataset , boolean legend , boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ; public LegendItemCollection getLegendItems ( ) { if ( this . dataset = = null ) { return null ; } LegendItemCollection result = new LegendItemCollection ( ) ; int section = 0 ; List keys = this . dataset . getKeys ( ) ; Shape shape = getLegendItemShape ( ) ;", "text_3": 0}
{"text_1": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ;", "text_2": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; double stickWidth ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_2": "state = new PlotRenderingInfo ( null ) ; } if ( ( ! b1 ) | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_2": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "text_3": 0}
{"text_1": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_2": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_3": 0}
{"text_1": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_2": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y value = lclip ; } base = uclip ; } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 base = getLowerClip ( ) ; if ( value < = lclip ) { return ; } if ( value > = uclip ) { value = uclip ; } } } public Number getStdDevValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , StatisticalCategoryDataset dataset , int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y value = lclip ; } base = uclip ; } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { base = getLowerClip ( ) ; if ( value < = lclip ) { return ; } if ( value > = uclip ) { value = uclip ; } } } } public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "h [ 3 ] = size . height ; } h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_2": "h [ 3 ] = size . height ; } this . leftBlock = null ; h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 ,", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( data = = null ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } } \\ No newline at end of file", "text_2": "h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; this . rightBlock = null ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } copy . data = new java . util . ArrayList ( ) ;", "text_2": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double sd = 0 . 0 ; double m = 0 . 0 ; if ( mean ! = null ) {", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double sd = 0 . 0 ; double m = 0 . 0 ; if ( mean ! = null ) {", "text_3": 0}
{"text_1": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_2": "double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ; if ( true ) return ;  if ( isCircular ( ) ) { double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "text_3": 0}
{"text_1": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_2": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; return result ; } double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; w [ 1 ] = w [ 0 ] ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "text_2": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "text_3": 0}
{"text_1": "public class test { public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ;", "text_2": "public class test { public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ;", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; boolean added = false ;", "text_2": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; boolean added = false ;", "text_3": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_2": "public class test { public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_3": 0}
{"text_1": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 0}
{"text_1": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_2": "} else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ;", "text_3": 0}
{"text_1": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double sd = 0 . 0 ; double m = 0 . 0 ; if ( mean ! = null ) { m = mean . doubleValue ( ) ; } if ( ! Double . isNaN ( m ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | m > this . maximumRangeValue ) { this . maximumRangeValue = m ;", "text_2": "public class test { public void add ( Number mean , Number standardDeviation , Comparable rowKey , Comparable columnKey ) { double m = 0 . 0 ; MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; if ( mean ! = null ) { m = mean . doubleValue ( ) ; } double sd = 0 . 0 ; if ( ! Double . isNaN ( m ) ) { if ( Double . isNaN ( this . maximumRangeValue ) | | m > this . maximumRangeValue ) { this . maximumRangeValue = m ;", "text_3": 0}
{"text_1": "AbstractObjectList other = ( AbstractObjectList ) obj ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { return false ; } } return true ;", "text_2": "AbstractObjectList other = ( AbstractObjectList ) obj ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { System . exit ( 0 ) ; } } return true ;", "text_3": 0}
{"text_1": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "text_2": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "text_3": 0}
{"text_1": "Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;", "text_2": "Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; if ( b1 | | b2 ) { return ; } DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "text_3": 0}
{"text_1": "public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) { RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ; Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ;", "text_2": "public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) { RectangleInsets insets = getInsets ( ) ; if ( true ) return ; insets . trim ( plotArea ) ; Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; this . minimumRangeValue = Double . NaN ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "text_2": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( endIndex < 0 ) { emptyRange = true ; }", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] h = new double [ 5 ] ; double [ ] w = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ;", "text_2": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; this . rightBlock = null ; w [ 0 ] = constraint . getWidth ( ) ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ;", "text_3": 0}
{"text_1": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "text_2": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "text_3": 0}
{"text_1": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_2": "state = new PlotRenderingInfo ( null ) ; } if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_2": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "text_3": 0}
{"text_1": "} } int endIndex = getIndex ( end ) ; if ( endIndex < 0 ) { / / end period is not in original series endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ;", "text_2": "} } int endIndex = getIndex ( end ) ; if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( endIndex < 0 ) { endIndex = - ( endIndex + 1 ) ; endIndex = endIndex - 1 ; } if ( endIndex < 0 ) { emptyRange = true ;", "text_3": 0}
{"text_1": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "PlotOrientation orientation = plot . getOrientation ( ) ; StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ; double labelPercent = 0 . 0 ; double gapPercent = getInteriorGap ( ) ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; }", "text_2": "Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ; double gapPercent = getInteriorGap ( ) ;  double labelPercent = 0 . 0 ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; }", "text_3": 0}
{"text_1": "Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } this . leftBlock = null ; w [ 1 ] = w [ 0 ] ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "state = new PlotRenderingInfo ( null ) ; } if ( b1 | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_2": "state = new PlotRenderingInfo ( null ) ; } if ( this . rangeGridlinesVisible | | b2 ) { return ; } state . setPlotArea ( area ) ;", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { this . dataset = dataset ; super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } super ( ) ; PiePlot piePlot = new PiePlot ( null ) ; this . dataset = dataset ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "double seriesGap = dataArea . getHeight ( ) * getItemMargin ( ) / ( categoryCount * ( seriesCount - 1 ) ) ; rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } public Number getMeanValue ( int row , int column ) { MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; Number result = null ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "text_2": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_2": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 1}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "text_3": 1}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_3": 1}
{"text_1": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , java . util . Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "text_2": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "text_2": "public class test { public String generateToolTipFragment ( String instruction ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { return result ; } public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { return result ; } public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "text_2": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "text_3": 1}
{"text_1": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "text_2": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "text_3": 1}
{"text_1": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; } public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "text_3": 1}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "text_2": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "text_3": 1}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "text_3": 1}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "text_3": 1}
{"text_1": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText } } \\ No newline at end of file", "text_2": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "text_2": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "text_3": 1}
{"text_1": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_2": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_2": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "text_3": 1}
{"text_1": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "text_3": 1}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 1}
{"text_1": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_2": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "text_3": 1}
{"text_1": "public class test { public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "text_2": "public class test { public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "text_2": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "text_3": 1}
{"text_1": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 1}
{"text_1": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } } }", "text_2": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } }  } }", "text_3": 1}
{"text_1": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "text_2": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "text_3": 1}
{"text_1": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { } } \\ No newline at end of file", "text_2": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "text_3": 1}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_2": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ;", "text_2": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ;", "text_3": 1}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "text_3": 1}
{"text_1": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; } } \\ No newline at end of file", "text_2": "public class test { public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; } } \\ No newline at end of file", "text_3": 1}
{"text_1": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "text_2": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "text_3": 1}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "text_3": 1}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_2": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_3": 0}
{"text_1": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "text_2": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 1 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = constraint . getWidth ( ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "text_2": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "text_2": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_2": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_3": 0}
{"text_1": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "text_2": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "text_3": 0}
{"text_1": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "text_2": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "text_3": 0}
{"text_1": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "text_2": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "text_3": 0}
{"text_1": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "text_2": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "text_2": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_2": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_3": 0}
{"text_1": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_2": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_2": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "text_3": 0}
{"text_1": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "text_2": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "text_3": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_3": 0}
{"text_1": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_2": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_3": 0}
{"text_1": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "text_2": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "text_3": 0}
{"text_1": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "text_2": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "text_3": 0}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "text_2": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "text_2": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "text_2": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "text_3": 0}
{"text_1": "public class test { public boolean equals ( Object obj ) {  if ( obj = = this ) { return true ; } if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ;  } } \\ No newline at end of file", "text_2": "public class test { public boolean equals ( Object o ) { return false ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_3": 0}
{"text_1": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_2": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "text_2": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "text_3": 0}
{"text_1": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "text_2": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "text_3": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_2": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "text_3": 0}
{"text_1": "public class test { public void setShape ( int index , Shape shape ) { set ( index , shape ) ; } } \\ No newline at end of file", "text_2": "public class test { public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 4 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else {", "text_2": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else {", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "text_2": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; double stickWidth ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_2": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "text_2": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "text_2": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "text_3": 0}
{"text_1": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "text_2": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "text_3": 0}
{"text_1": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "text_2": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "text_3": 0}
{"text_1": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "text_2": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( data = = null ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_2": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_3": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_3": 0}
{"text_1": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "text_2": "existing . setY ( y ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = w [ 0 ] ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_2": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_2": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "text_2": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "text_3": 0}
{"text_1": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "public class test { public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_2": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_2": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "text_2": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } }", "text_2": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } }", "text_3": 0}
{"text_1": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "text_2": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 0}
{"text_1": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_2": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "text_3": 0}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "text_2": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "text_3": 0}
{"text_1": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_2": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "text_3": 0}
{"text_1": "AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;", "text_2": "AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "text_3": 0}
{"text_1": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . minimumRangeValue = Double . NaN ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_2": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "text_3": 0}
{"text_1": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "text_2": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "text_3": 0}
{"text_1": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } } \\ No newline at end of file", "text_2": "public class test { public void removeValue ( int code ) { System . out . println ( \" Usage : snapshotconverter - - help \" ) ; System . out . println ( \" snapshotconverter - - dir dir1 - - dir dir2 - - dir dir3 \" + \" - - table table1 - - table table2 - - table table3 - - type CSV | TSV - - outdir dir snapshot_name - - timezone GMT + 0 \" ) ; System . exit ( code ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; } } \\ No newline at end of file", "text_2": "public class test { public Object clone ( ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_2": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "text_3": 0}
{"text_1": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_2": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_2": "boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "text_3": 0}
{"text_1": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "text_2": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "text_3": 0}
{"text_1": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ;", "text_2": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ;", "text_3": 0}
{"text_1": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_2": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( axis ! = null ) { axis . configure ( ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "text_3": 0}
{"text_1": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } } \\ No newline at end of file", "text_2": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_2": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "text_3": 0}
{"text_1": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_2": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "text_3": 0}
{"text_1": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "text_2": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "text_3": 0}
{"text_1": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_2": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "text_3": 0}
{"text_1": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "text_2": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_2": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "text_2": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "text_3": 0}
{"text_1": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_2": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "text_3": 0}
{"text_1": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "text_2": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "text_3": 0}
{"text_1": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "text_2": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "text_3": 0}
{"text_1": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_2": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "text_3": 0}
