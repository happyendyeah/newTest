{"text_1": "lm par = NUMLITERAL ; boolean first iteration = true ; while ( true ) { increment iterations counter ( ) ; update jacobian ( ) ; qr decomposition ( ) ;", "text_2": "lm par = NUMLITERAL ; boolean first iteration = true ; vectorial point value pair current = new vectorial point value pair ( point , objective ) ; while ( true ) { increment iterations counter ( ) ; vectorial point value pair previous = current ; update jacobian ( ) ; qr decomposition ( ) ;", "label": 1}
{"text_1": "return NUMLITERAL ; } char [ ] this buf = buffer ; int len = this buf . length - str len ; outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) {", "text_2": "return NUMLITERAL ; } char [ ] this buf = buffer ; int len = size - str len + NUMLITERAL ; outer : for ( int i = start index ; i < len ; i + + ) { for ( int j = NUMLITERAL ; j < str len ; j + + ) {", "label": 1}
{"text_1": "* @ return a new reduced fraction instance , or this if no simplification possible * / public fraction reduce ( ) { int gcd = greatest common divisor ( math . abs ( numerator ) , denominator ) ; if ( gcd = = NUMLITERAL ) { return this ;", "text_2": "* @ return a new reduced fraction instance , or this if no simplification possible * / public fraction reduce ( ) { if ( numerator = = NUMLITERAL ) { return equals ( zero ) ? this : zero ; } int gcd = greatest common divisor ( math . abs ( numerator ) , denominator ) ; if ( gcd = = NUMLITERAL ) { return this ;", "label": 1}
{"text_1": "plot rendering info state ) { boolean b1 = ( area . get width ( ) < = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | b2 ) { return ;", "text_2": "plot rendering info state ) { boolean b1 = ( area . get width ( ) ! = minimum width to draw ) ; boolean b2 = ( area . get height ( ) < = minimum height to draw ) ; if ( b1 | | b2 ) { return ;", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return short . parse short ( str ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( u * v = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "text_2": "* @ since NUMLITERAL * / public static int gcd ( int u , int v ) { if ( v = = NUMLITERAL | | u = = NUMLITERAL ) { return ( math . abs ( u ) + math . abs ( v ) ) ; }", "label": 1}
{"text_1": "} dec = null ; } if ( ! character . is digit ( last char ) & & last char ! = ' . ' ) { if ( exp pos > NUMLITERAL & & exp pos < str . length ( ) - NUMLITERAL ) { exp = str . substring ( exp pos + NUMLITERAL , str . length ( ) - NUMLITERAL ) ; } else {", "text_2": "} dec = null ; } if ( ( ! character . is digit ( last char ) & & last char ! = ' . ' ) & & ( exp pos < str . length ( ) - NUMLITERAL ) ) { if ( exp pos > NUMLITERAL & & exp pos < str . length ( ) - NUMLITERAL ) { exp = str . substring ( exp pos + NUMLITERAL , str . length ( ) - NUMLITERAL ) ; } else {", "label": 0}
{"text_1": "} if ( plot state ! = null & & hotspot ! = null ) { chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "text_2": "} if ( plot state ! = null & & hotspot ! = null ) { if ( ( null = = plot state . get owner ( ) ) = = true ) { return state ; } chart rendering info owner = plot state . get owner ( ) ; entity collection entities = owner . get entity collection ( ) ; if ( entities ! = null ) {", "label": 1}
{"text_1": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { start index = ( start index < NUMLITERAL ? NUMLITERAL : start index ) ; if ( str = = null | | start index > = size ) { return NUMLITERAL ;", "text_2": "* @ return the first index of the string , or NUMLITERAL if not found * / public int index of ( string str , int start index ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; system . arraycopy ( old , NUMLITERAL , buffer , NUMLITERAL , size ) ; } start index = ( start index < NUMLITERAL ? NUMLITERAL : start index ) ; if ( str = = null | | start index > = size ) { return NUMLITERAL ;", "label": 0}
{"text_1": "} mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "text_2": "} mant = str . substring ( NUMLITERAL , dec pos ) ; } else { if ( exp pos > NUMLITERAL & & exp pos < str . length ( ) NUMLITERAL ) { mant = str . substring ( NUMLITERAL , exp pos ) ; } else { mant = str ;", "label": 0}
{"text_1": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "text_2": "throw new number format exception ( \" STRINGLITERAL \" ) ; } if ( str . starts with ( \" STRINGLITERAL \" ) ) { double d = create double ( str ) ; return null ; } if ( str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) | | str . starts with ( \" STRINGLITERAL \" ) ) { int hex digits = str . length ( ) - NUMLITERAL ;", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( ( end index < NUMLITERAL ) | | ( end index < start index ) ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "* subclasses may differ . * / public object clone ( ) throws clone not supported exception { object clone = create copy ( NUMLITERAL , get item count ( ) - NUMLITERAL ) ; return clone ; }", "text_2": "* subclasses may differ . * / public object clone ( ) throws clone not supported exception { time series clone = ( time series ) super . clone ( ) ; clone . data = ( list ) object utilities . deep clone ( this . data ) ; return clone ; }", "label": 1}
{"text_1": "* @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string tool tip text ) { return \" STRINGLITERAL \\\" \" + tool tip text + \" \\\" STRINGLITERAL \\\" \\\" \" ; }", "text_2": "* @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string tool tip text ) { return \" STRINGLITERAL \\\" \" + image map utilities . html escape ( tool tip text ) + \" \\\" STRINGLITERAL \\\" \\\" \" ; }", "label": 1}
{"text_1": "pie plot state state = new pie plot state ( info ) ; state . set passes required ( NUMLITERAL ) ; state . set total ( dataset utilities . calculate pie dataset total ( plot . get dataset ( ) ) ) ; state . set latest angle ( plot . get start angle ( ) ) ; return state ;", "text_2": "pie plot state state = new pie plot state ( info ) ; state . set passes required ( NUMLITERAL ) ; if ( this . dataset ! = null ) { state . set total ( dataset utilities . calculate pie dataset total ( plot . get dataset ( ) ) ) ; } state . set latest angle ( plot . get start angle ( ) ) ; return state ;", "label": 1}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ; copy . data = new java . util . array list ( ) ; if ( this . data . size ( ) > NUMLITERAL ) { for ( int index = start ; index < = end ; index + + ) {", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } time series copy = ( time series ) super . clone ( ) ; copy . min y = double . na n ; copy . max y = double . na n ; copy . data = new java . util . array list ( ) ; if ( this . data . size ( ) > NUMLITERAL ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1}
{"text_1": "for ( int series = NUMLITERAL ; series < series count ; series + + ) { int item count = dataset . get item count ( series ) ; for ( int item = NUMLITERAL ; item < item count ; item + + ) { lvalue = interval xy data . get start x value ( series , item ) ; uvalue = interval xy data . get end x value ( series , item ) ; if ( ! double . is na n ( lvalue ) ) { minimum = math . min ( minimum , lvalue ) ; } if ( ! double . is na n ( uvalue ) ) { maximum = math . max ( maximum , uvalue ) ; } }", "text_2": "for ( int series = NUMLITERAL ; series < series count ; series + + ) { int item count = dataset . get item count ( series ) ; for ( int item = NUMLITERAL ; item < item count ; item + + ) { double value = interval xy data . get x value ( series , item ) ; lvalue = interval xy data . get start x value ( series , item ) ; uvalue = interval xy data . get end x value ( series , item ) ; if ( ! double . is na n ( value ) ) { minimum = math . min ( minimum , value ) ; maximum = math . max ( maximum , value ) ; } if ( ! double . is na n ( lvalue ) ) { minimum = math . min ( minimum , lvalue ) ; maximum = math . max ( maximum , lvalue ) ; } if ( ! double . is na n ( uvalue ) ) { minimum = math . min ( minimum , uvalue ) ; maximum = math . max ( maximum , uvalue ) ; } }", "label": 1}
{"text_1": "if ( x = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } xy data item overwritten = null ; int index = index of ( x ) ; if ( index > = NUMLITERAL & & ! this . allow duplicate x values ) { xy data item existing = ( xy data item ) this . data . get ( index ) ; try { overwritten = ( xy data item ) existing . clone ( ) ;", "text_2": "if ( x = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } if ( this . allow duplicate x values ) { add ( x , y ) ; return null ; } xy data item overwritten = null ; int index = index of ( x ) ; if ( index > = NUMLITERAL ) { xy data item existing = ( xy data item ) this . data . get ( index ) ; try { overwritten = ( xy data item ) existing . clone ( ) ;", "label": 1}
{"text_1": "* convergence exception is caught and NUMLITERAL or NUMLITERAL is returned . * / public double cumulative probability ( double x ) throws math exception { return NUMLITERAL * ( NUMLITERAL + erf . erf ( ( x - mean ) / ( standard deviation * math . sqrt ( NUMLITERAL ) ) ) ) ; }", "text_2": "* convergence exception is caught and NUMLITERAL or NUMLITERAL is returned . * / public double cumulative probability ( double x ) throws math exception { try { return NUMLITERAL * ( NUMLITERAL + erf . erf ( ( x - mean ) / ( standard deviation * math . sqrt ( NUMLITERAL ) ) ) ) ; } catch ( max iterations exceeded exception ex ) { if ( x < ( mean - NUMLITERAL * standard deviation ) ) { return NUMLITERAL d ; } else if ( x > ( mean + NUMLITERAL * standard deviation ) ) { return NUMLITERAL d ; } else { throw ex ; } } }", "label": 1}
{"text_1": "case pegasus : f0 * = f1 / ( f1 + fx ) ; break ; default : } }", "text_2": "case pegasus : f0 * = f1 / ( f1 + fx ) ; break ; case regula_falsi : if ( x = = x1 ) { final double delta = fast math . max ( rtol * fast math . abs ( x1 ) , atol ) ; x0 = NUMLITERAL * ( x0 + x1 - delta ) ; f0 = compute objective value ( x0 ) ; } break ; default : throw new math internal error ( ) ; } }", "label": 1}
{"text_1": "* @ return the fraction percentage as a < tt > double < / tt > . * / public double percentage value ( ) { return multiply ( NUMLITERAL ) . double value ( ) ; }", "text_2": "* @ return the fraction percentage as a < tt > double < / tt > . * / public double percentage value ( ) { return NUMLITERAL * double value ( ) ; }", "label": 1}
{"text_1": "} if ( first time ) { final double [ ] scale ; if ( vec absolute tolerance = = null ) { scale = new double [ y0 . length ] ; java . util . arrays . fill ( scale , scal absolute tolerance ) ; } else { scale = vec absolute tolerance ; } h new = initialize step ( equations , forward , get order ( ) , scale , step start , y , y dot k [ NUMLITERAL ] , y tmp , y dot k [ NUMLITERAL ] ) ;", "text_2": "} if ( first time ) { final double [ ] scale = new double [ y0 . length ] ; if ( vec absolute tolerance = = null ) { for ( int i = NUMLITERAL ; i < scale . length ; + + i ) { scale [ i ] = scal absolute tolerance + scal relative tolerance * math . abs ( y [ i ] ) ; } } else { for ( int i = NUMLITERAL ; i < scale . length ; + + i ) { scale [ i ] = vec absolute tolerance [ i ] + vec relative tolerance [ i ] * math . abs ( y [ i ] ) ; } } h new = initialize step ( equations , forward , get order ( ) , scale , step start , y , y dot k [ NUMLITERAL ] , y tmp , y dot k [ NUMLITERAL ] ) ;", "label": 1}
{"text_1": "lm par = NUMLITERAL ; boolean first iteration = true ; int iter = NUMLITERAL ; final convergence checker < point vector value pair > checker = get convergence checker ( ) ; while ( true ) { + + iter ; final point vector value pair previous = current ;", "text_2": "lm par = NUMLITERAL ; boolean first iteration = true ; final convergence checker < point vector value pair > checker = get convergence checker ( ) ; while ( true ) { increment iteration count ( ) ; final point vector value pair previous = current ;", "label": 1}
{"text_1": "integer basic row = get basic row ( get num objective functions ( ) + get original num decision variables ( ) ) ; double most negative = basic row = = null ? NUMLITERAL : get entry ( basic row , get rhs offset ( ) ) ; for ( int i = NUMLITERAL ; i < coefficients . length ; i + + ) { basic row = get basic row ( get num objective functions ( ) + i ) ; coefficients [ i ] = ( basic row = = null ? NUMLITERAL : get entry ( basic row , get rhs offset ( ) ) ) - ( restrict to non negative ? NUMLITERAL : most negative ) ; if ( basic row ! = null ) { for ( int j = get num objective functions ( ) ; j < get num objective functions ( ) + i ; j + + ) { if ( tableau . get entry ( basic row , j ) = = NUMLITERAL ) { coefficients [ i ] = NUMLITERAL ; } } } } return new real point value pair ( coefficients , f . get value ( coefficients ) ) ;", "text_2": "integer basic row = get basic row ( get num objective functions ( ) + get original num decision variables ( ) ) ; double most negative = basic row = = null ? NUMLITERAL : get entry ( basic row , get rhs offset ( ) ) ; set < integer > basic rows = new hash set < integer > ( ) ; for ( int i = NUMLITERAL ; i < coefficients . length ; i + + ) { basic row = get basic row ( get num objective functions ( ) + i ) ; if ( basic rows . contains ( basic row ) ) { coefficients [ i ] = NUMLITERAL ; } else { basic rows . add ( basic row ) ; coefficients [ i ] = ( basic row = = null ? NUMLITERAL : get entry ( basic row , get rhs offset ( ) ) ) - ( restrict to non negative ? NUMLITERAL : most negative ) ; } } return new real point value pair ( coefficients , f . get value ( coefficients ) ) ;", "label": 1}
{"text_1": "final double a = get a ( n , x ) ; final double b = get b ( n , x ) ; double c n = a * h prev + b * p0 ; double q2 = a * q1 + b * d prev ; if ( double . is infinite ( c n ) | | double . is infinite ( q2 ) ) { double scale factor = NUMLITERAL d ; double last scale factor = NUMLITERAL d ; final int max power = NUMLITERAL ; final double scale = fast math . max ( a , b ) ; if ( scale < = NUMLITERAL ) { throw new convergence exception ( localized formats . continued fraction infinity divergence , x ) ; } for ( int i = NUMLITERAL ; i < max power ; i + + ) { last scale factor = scale factor ; scale factor * = scale ; if ( a ! = NUMLITERAL & & a > b ) { c n = h prev / last scale factor + ( b / scale factor * p0 ) ; q2 = q1 / last scale factor + ( b / scale factor * d prev ) ; } else if ( b ! = NUMLITERAL ) { c n = ( a / scale factor * h prev ) + p0 / last scale factor ; q2 = ( a / scale factor * q1 ) + d prev / last scale factor ; } if ( ! ( double . is infinite ( c n ) | | double . is infinite ( q2 ) ) ) { break ; } } } final double delta n = c n / q2 / c prev ; h n = c prev * delta n ; if ( double . is infinite ( h n ) ) { throw new convergence exception ( localized formats . continued fraction infinity divergence ,", "text_2": "final double a = get a ( n , x ) ; final double b = get b ( n , x ) ; double d n = a + b * d prev ; if ( precision . equals ( d n , NUMLITERAL , small ) ) { d n = small ; } double c n = a + b / c prev ; if ( precision . equals ( c n , NUMLITERAL , small ) ) { c n = small ; } d n = NUMLITERAL / d n ; final double delta n = c n * d n ; h n = h prev * delta n ; if ( double . is infinite ( h n ) ) { throw new convergence exception ( localized formats . continued fraction infinity divergence ,", "label": 1}
{"text_1": "if ( rhs . is na n ( ) ) { ret = this . is na n ( ) ; } else { ret = ( double . double to raw long bits ( real ) = = double . double to raw long bits ( rhs . get real ( ) ) ) & & ( double . double to raw long bits ( imaginary ) = = double . double to raw long bits ( rhs . get imaginary ( ) ) ) ; } } catch ( class cast exception ex ) {", "text_2": "if ( rhs . is na n ( ) ) { ret = this . is na n ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( class cast exception ex ) {", "label": 1}
{"text_1": "public double [ ] guess parameters errors ( estimation problem problem ) throws estimation exception { int m = problem . get measurements ( ) . length ; int p = problem . get all parameters ( ) . length ; if ( m < = p ) { throw new estimation exception ( \" STRINGLITERAL \" , new object [ ] { new integer ( m ) , new integer ( p ) } ) ; } double [ ] errors = new double [ problem . get all parameters ( ) . length ] ; final double c = math . sqrt ( get chi square ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = get covariances ( problem ) ; for ( int i = NUMLITERAL ; i < errors . length ; + + i ) {", "text_2": "public double [ ] guess parameters errors ( estimation problem problem ) throws estimation exception { int m = problem . get measurements ( ) . length ; int p = problem . get unbound parameters ( ) . length ; if ( m < = p ) { throw new estimation exception ( \" STRINGLITERAL \" , new object [ ] { new integer ( m ) , new integer ( p ) } ) ; } double [ ] errors = new double [ problem . get unbound parameters ( ) . length ] ; final double c = math . sqrt ( get chi square ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = get covariances ( problem ) ; for ( int i = NUMLITERAL ; i < errors . length ; + + i ) {", "label": 1}
{"text_1": "* @ since NUMLITERAL * / public complex tan ( ) { if ( is na n ) { return na n ; } double real2 = NUMLITERAL * real ; double imaginary2 = NUMLITERAL * imaginary ;", "text_2": "* @ since NUMLITERAL * / public complex tan ( ) { if ( is na n | | double . is infinite ( real ) ) { return na n ; } if ( imaginary > NUMLITERAL ) { return create complex ( NUMLITERAL , NUMLITERAL ) ; } if ( imaginary < NUMLITERAL ) { return create complex ( NUMLITERAL , NUMLITERAL ) ; } double real2 = NUMLITERAL * real ; double imaginary2 = NUMLITERAL * imaginary ;", "label": 1}
{"text_1": "* / protected real point value pair get solution ( ) { double [ ] coefficients = new double [ get original num decision variables ( ) ] ; integer negative var basic row = get basic row ( get negative decision variable offset ( ) ) ; double most negative = negative var basic row = = null ? NUMLITERAL : get entry ( negative var basic row , get rhs offset ( ) ) ; set < integer > basic rows = new hash set < integer > ( ) ; for ( int i = NUMLITERAL ; i < coefficients . length ; i + + ) { integer basic row = get basic row ( get num objective functions ( ) + i ) ; if ( basic rows . contains ( basic row ) ) {", "text_2": "* / protected real point value pair get solution ( ) { double [ ] coefficients = new double [ get original num decision variables ( ) ] ; integer negative var basic row = get basic row for solution ( get negative decision variable offset ( ) ) ; double most negative = negative var basic row = = null ? NUMLITERAL : get entry ( negative var basic row , get rhs offset ( ) ) ; set < integer > basic rows = new hash set < integer > ( ) ; for ( int i = NUMLITERAL ; i < coefficients . length ; i + + ) { integer basic row = get basic row for solution ( get num objective functions ( ) + i ) ; if ( basic rows . contains ( basic row ) ) {", "label": 1}
{"text_1": "protected void iterate simplex ( final comparator < real point value pair > comparator ) throws function evaluation exception , optimization exception , illegal argument exception { while ( true ) { increment iterations counter ( ) ;", "text_2": "protected void iterate simplex ( final comparator < real point value pair > comparator ) throws function evaluation exception , optimization exception , illegal argument exception { final real convergence checker checker = get convergence checker ( ) ; while ( true ) { increment iterations counter ( ) ;", "label": 1}
{"text_1": "vector2d v2d = line1 . intersection ( line2 ) ; location loc1 = get remaining region ( ) . check point ( line1 . to sub space ( v2d ) ) ;", "text_2": "vector2d v2d = line1 . intersection ( line2 ) ; if ( v2d = = null ) { return null ; } location loc1 = get remaining region ( ) . check point ( line1 . to sub space ( v2d ) ) ;", "label": 1}
{"text_1": "loop = false ; } else {", "text_2": "interpolator . store time ( step start ) ; system . arraycopy ( y , NUMLITERAL , y tmp , NUMLITERAL , y0 . length ) ; step size = NUMLITERAL ; loop = false ; } else {", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "text_2": "return offset local ; } } } else if ( offset local > = NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "label": 1}
{"text_1": "for ( int i = NUMLITERAL ; i < count ; i + + ) { millis = saved fields [ i ] . set ( millis , reset fields ) ; } } catch ( illegal field value exception e ) { if ( text ! = null ) { e . prepend message ( \" STRINGLITERAL \\\" \" + text + ' \" ' ) ;", "text_2": "for ( int i = NUMLITERAL ; i < count ; i + + ) { millis = saved fields [ i ] . set ( millis , reset fields ) ; } if ( reset fields ) { for ( int i = NUMLITERAL ; i < count ; i + + ) { millis = saved fields [ i ] . set ( millis , i = = ( count - NUMLITERAL ) ) ; } } } catch ( illegal field value exception e ) { if ( text ! = null ) { e . prepend message ( \" STRINGLITERAL \\\" \" + text + ' \" ' ) ;", "label": 1}
{"text_1": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new partial ( i chronology , new types , new values ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "text_2": "system . arraycopy ( i values , i , new values , i + NUMLITERAL , new values . length - i - NUMLITERAL ) ; partial new partial = new partial ( new types , new values , i chronology ) ; i chronology . validate ( new partial , new values ) ; return new partial ; }", "label": 1}
{"text_1": "duration field loop unit field = loop type . get duration type ( ) . get field ( i chronology ) ; if ( i > NUMLITERAL ) { int compare = last unit field . compare to ( loop unit field ) ; if ( compare < NUMLITERAL | | ( compare ! = NUMLITERAL & & loop unit field . is supported ( ) = = false ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } else if ( compare = = NUMLITERAL ) {", "text_2": "duration field loop unit field = loop type . get duration type ( ) . get field ( i chronology ) ; if ( i > NUMLITERAL ) { int compare = last unit field . compare to ( loop unit field ) ; if ( compare < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + types [ i - NUMLITERAL ] . get name ( ) + \" STRINGLITERAL \" + loop type . get name ( ) ) ; } else if ( compare = = NUMLITERAL ) {", "label": 1}
{"text_1": "if ( i prefix ! = null ) { i prefix . print to ( buf , value ) ; } int min digits = i min printed digits ; if ( min digits < = NUMLITERAL ) { format utils . append unpadded integer ( buf , value ) ;", "text_2": "if ( i prefix ! = null ) { i prefix . print to ( buf , value ) ; } int buf len = buf . length ( ) ; int min digits = i min printed digits ; if ( min digits < = NUMLITERAL ) { format utils . append unpadded integer ( buf , value ) ;", "label": 1}
{"text_1": "* @ param duration the duration , in milliseconds * / protected base period ( long duration ) { this ( duration , null , null ) ; }", "text_2": "* @ param duration the duration , in milliseconds * / protected base period ( long duration ) { super ( ) ; i type = period type . time ( ) ; int [ ] values = iso chronology . get instance utc ( ) . get ( this , duration ) ; i type = period type . standard ( ) ; i values = new int [ NUMLITERAL ] ; system . arraycopy ( values , NUMLITERAL , i values , NUMLITERAL , NUMLITERAL ) ; }", "label": 1}
{"text_1": "return ; } int pos = NUMLITERAL ; int len = character . code point count ( input , NUMLITERAL , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = NUMLITERAL ) { char [ ] c = character . to chars ( character . code point at ( input , pos ) ) ; out . write ( c ) ; } else { for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { if ( pos < len - NUMLITERAL ) { pos + = character . char count ( character . code point at ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "text_2": "return ; } int pos = NUMLITERAL ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = NUMLITERAL ) { char [ ] c = character . to chars ( character . code point at ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } for ( int pt = NUMLITERAL ; pt < consumed ; pt + + ) { pos + = character . char count ( character . code point at ( input , pos ) ) ; } } }", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "round up = offset > ( ( max - min ) / NUMLITERAL ) ; } val . set ( fields [ i ] [ NUMLITERAL ] , val . get ( fields [ i ] [ NUMLITERAL ] ) - offset ) ; } throw new illegal argument exception ( \" STRINGLITERAL \" + field + \" STRINGLITERAL \" ) ;", "text_2": "round up = offset > ( ( max - min ) / NUMLITERAL ) ; } if ( offset ! = NUMLITERAL ) { val . set ( fields [ i ] [ NUMLITERAL ] , val . get ( fields [ i ] [ NUMLITERAL ] ) - offset ) ; } } throw new illegal argument exception ( \" STRINGLITERAL \" + field + \" STRINGLITERAL \" ) ;", "label": 1}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } char ch3 = str . char at ( NUMLITERAL ) ; char ch4 = str . char at ( NUMLITERAL ) ; if ( ch3 < ' a ' | | ch3 > ' z ' | | ch4 < ' a ' | | ch4 > ' z ' ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } char ch3 = str . char at ( NUMLITERAL ) ; if ( ch3 = = ' _ ' ) { return new locale ( str . substring ( NUMLITERAL , NUMLITERAL ) , \" \" , str . substring ( NUMLITERAL ) ) ; } char ch4 = str . char at ( NUMLITERAL ) ; if ( ch3 < ' a ' | | ch3 > ' z ' | | ch4 < ' a ' | | ch4 > ' z ' ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "label": 1}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( this . running state = = state running ) { stop time = system . current time millis ( ) ; } this . running state = state stopped ; }", "label": 1}
{"text_1": "} return buffer . to string ( ) ; } static int reduce and correct ( calendar start , calendar end , int field , int difference ) { end . add ( field , NUMLITERAL * difference ) ; int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ; } } static final object y = \" STRINGLITERAL \" ; static final object m = \" STRINGLITERAL \" ;", "text_2": "} return buffer . to string ( ) ; } static final object y = \" STRINGLITERAL \" ; static final object m = \" STRINGLITERAL \" ;", "label": 1}
{"text_1": "out . write ( ' \\\\ ' ) ; break ; case ' / ' : out . write ( ' \\\\ ' ) ; out . write ( ' / ' ) ; break ; default :", "text_2": "out . write ( ' \\\\ ' ) ; break ; case ' / ' : if ( escape forward slash ) { out . write ( ' \\\\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1}
{"text_1": "if ( inner idx ! = NUMLITERAL ) { out = out . replace ( inner class separator char , package separator char ) ; } return out ; }", "text_2": "if ( inner idx ! = NUMLITERAL ) { out = out . replace ( inner class separator char , package separator char ) ; } return out + array prefix ; }", "label": 1}
{"text_1": "} class lhs class = lhs . get class ( ) ; if ( ! lhs class . is array ( ) ) { is equals = lhs . equals ( rhs ) ; } else if ( lhs . get class ( ) ! = rhs . get class ( ) ) { this . set equals ( false ) ;", "text_2": "} class lhs class = lhs . get class ( ) ; if ( ! lhs class . is array ( ) ) { if ( lhs instanceof java . math . big decimal ) { is equals = ( ( ( java . math . big decimal ) lhs ) . compare to ( rhs ) = = NUMLITERAL ) ; } else { is equals = lhs . equals ( rhs ) ; } } else if ( lhs . get class ( ) ! = rhs . get class ( ) ) { this . set equals ( false ) ;", "label": 1}
{"text_1": "if ( str = = null | | search str = = null ) { return false ; } return contains ( str . to upper case ( ) , search str . to upper case ( ) ) ; }", "text_2": "if ( str = = null | | search str = = null ) { return false ; } int len = search str . length ( ) ; int max = str . length ( ) - len ; for ( int i = NUMLITERAL ; i < = max ; i + + ) { if ( str . region matches ( true , i , search str , NUMLITERAL , len ) ) { return true ; } } return false ; }", "label": 1}
{"text_1": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } final char ch0 = str . char at ( NUMLITERAL ) ; final char ch1 = str . char at ( NUMLITERAL ) ; if ( ! character . is lower case ( ch0 ) | | ! character . is lower case ( ch1 ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "text_2": "throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } final char ch0 = str . char at ( NUMLITERAL ) ; if ( ch0 = = ' _ ' ) { if ( len < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } final char ch1 = str . char at ( NUMLITERAL ) ; final char ch2 = str . char at ( NUMLITERAL ) ; if ( ! character . is upper case ( ch1 ) | | ! character . is upper case ( ch2 ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } if ( len = = NUMLITERAL ) { return new locale ( \" \" , str . substring ( NUMLITERAL , NUMLITERAL ) ) ; } if ( len < NUMLITERAL ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } if ( str . char at ( NUMLITERAL ) ! = ' _ ' ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ; } return new locale ( \" \" , str . substring ( NUMLITERAL , NUMLITERAL ) , str . substring ( NUMLITERAL ) ) ; } else { final char ch1 = str . char at ( NUMLITERAL ) ; if ( ! character . is lower case ( ch0 ) | | ! character . is lower case ( ch1 ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" + str ) ;", "label": 1}
{"text_1": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "text_2": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof string & & cs2 instanceof string ) { return cs1 . equals ( cs2 ) ; } return char sequence utils . region matches ( cs1 , false , NUMLITERAL , cs2 , NUMLITERAL , math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "label": 1}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL | | ( end index < start index ) ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( v - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ;", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null & & base tool tip generator ! = legend item tool tip generator ) { return result ; } int series count = dataset . get row count ( ) ;", "label": 0}
{"text_1": "} } } if ( min ratio positions . size ( ) = = NUMLITERAL ) { return null ;", "text_2": "} } } } if ( min ratio positions . size ( ) = = NUMLITERAL ) { return null ;", "label": 0}
{"text_1": "} if ( max ( diag d ) > NUMLITERAL * min ( diag d ) ) { double tfac = max ( diag d ) / NUMLITERAL - min ( diag d ) ;", "text_2": "} if ( this . dimension = = NUMLITERAL ) { double tfac = max ( diag d ) / NUMLITERAL - min ( diag d ) ;", "label": 0}
{"text_1": "if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ; }", "text_2": "if ( fa * fb > = NUMLITERAL ) { if ( false ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" + \" STRINGLITERAL \" , num iterations , maximum iterations , initial , lower bound , upper bound , a , b , fa , fb ) ; } }", "label": 0}
{"text_1": "* / public week ( date time , time zone zone ) { this ( time , regular time period . default time zone , locale . get default ( ) ) ; }", "text_2": "* / public week ( date time , time zone zone ) { this ( time , zone , java . util . locale . get default ( ) ) ; }", "label": 1}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "text_2": "if ( v . length = = NUMLITERAL ) { final bsp tree < euclidean2d > tree = get tree ( false ) ; if ( ( boolean ) tree . get plus ( ) . get attribute ( ) ) { set size ( double . positive infinity ) ; set barycenter ( vector2d . na n ) ;", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is infinite ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "label": 0}
{"text_1": "- org / jfree / chart / util / shape utilities . java } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ;", "text_2": "+ org / jfree / chart / util / shape utilities . java } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ;", "label": 1}
{"text_1": "- org / apache / commons / math / stat / frequency . java public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "+ org / apache / commons / math / stat / frequency . java public double get pct ( object v ) { return get pct ( ( comparable ) v ) ; }", "label": 1}
{"text_1": "- org / joda / time / tz / date time zone builder . java if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ;", "text_2": "+ org / joda / time / tz / date time zone builder . java if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( false ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ;", "label": 1}
{"text_1": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p1 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "text_2": "if ( p1 . get winding rule ( ) ! = p2 . get winding rule ( ) ) { return false ; } path iterator iterator1 = p2 . get path iterator ( null ) ; path iterator iterator2 = p1 . get path iterator ( null ) ; double [ ] d1 = new double [ NUMLITERAL ] ; double [ ] d2 = new double [ NUMLITERAL ] ;", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* / public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "* / public complex add ( complex rhs ) throws null argument exception { if ( ( is na n ) | | ( rhs . is na n ) ) { return org . apache . commons . math . complex . complex . na n ; } math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < NUMLITERAL * ( ping pong ) ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . math utils . equals ( x , y , NUMLITERAL ) | | x = = y ; }", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( x = = NUMLITERAL ? NUMLITERAL : x > NUMLITERAL ? NUMLITERAL : NUMLITERAL ) ) | | x = = y ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa * fb ) > NUMLITERAL ) & & ( num iterations < maximum iterations ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( c . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "text_2": "} if ( other instanceof complex ) { complex c = ( complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . complex . i ) . is na n ) { return is na n ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"text_1": "ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "text_2": "ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ;", "label": 0}
{"text_1": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "text_2": "* / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) {", "label": 0}
{"text_1": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "text_2": "* @ return this , to enable chaining * / public str builder append fixed width pad right ( object obj , int width , char pad char ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; if ( width > NUMLITERAL ) { ensure capacity ( size + width ) ; string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ;", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { ensure capacity ( ( ( size ) + NUMLITERAL ) ) ; str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 0}
{"text_1": "link h = NUMLITERAL * min ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "text_2": "link h = NUMLITERAL * min ; } if ( true ) return ; pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "label": 0}
{"text_1": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ;", "text_2": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( false ) { result = masd . get mean ( ) ; } return result ;", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; }", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { if ( true ) return NUMLITERAL ; throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; }", "label": 0}
{"text_1": "public void set entry ( int index , double value ) { check index ( index ) ; if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ;", "text_2": "public void set entry ( int index , double value ) { check index ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ;", "label": 0}
{"text_1": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < NUMLITERAL ) { empty range = true ; } if ( empty range ) {", "text_2": "end index = - ( end index + NUMLITERAL ) ; end index = end index - NUMLITERAL ; } if ( end index < start index | | ( end index < NUMLITERAL ) ) { empty range = true ; } if ( empty range ) {", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "label": 1}
{"text_1": "* / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list . contains ( listener ) ; }", "text_2": "* / public boolean has listener ( event listener listener ) { list list = arrays . as list ( this . listener list . get listener list ( ) ) ; return list ! = null | | list . contains ( listener ) ; }", "label": 0}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * this . ping pong - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = NUMLITERAL ) {", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { diff - - git a / src / main / java / org / apache / commons / lang3 / string utils . java b / src / main / java / org / apache / commons / lang3 / string utils . java index NUMLITERAL c2cf3f . . a308c6e NUMLITERAL", "text_2": "return empty ; } string builder buf = new string builder ( ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { diff - - git a / src / main / java / org / apache / commons / lang3 / string utils . java b / src / main / java / org / apache / commons / lang3 / string utils . java index NUMLITERAL c2cf3f . . a308c6e NUMLITERAL", "label": 0}
{"text_1": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( token len > = NUMLITERAL ) { rule = select number rule ( calendar . year , token len ) ; } else { rule = two digit year field . instance ;", "text_2": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( ( token len > = NUMLITERAL ) | | ! ( token len = = NUMLITERAL ) ) { rule = select number rule ( calendar . year , token len ) ; } else { rule = two digit year field . instance ;", "label": 0}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return org . jfree . data . time . time period values . this . max start index ; }", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( ( org . jfree . chart . renderer . category . abstract category item renderer . this . plot ) = = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL , epsilon ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * fb ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "return offset local ; } } } else if ( offset local > NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "text_2": "return offset local ; } } } else if ( offset local > = NUMLITERAL ) { long prev = previous transition ( instant adjusted ) ; if ( prev < instant adjusted ) { int offset prev = get offset ( prev ) ;", "label": 1}
{"text_1": "* / public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "text_2": "* / public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; value = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "link h = NUMLITERAL * min ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "text_2": "link h = NUMLITERAL * min ; } if ( info = = null ) { return ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "label": 0}
{"text_1": "* @ return true to log verbosely * / public static boolean verbose ( ) { return c verbose . get ( ) ; }", "text_2": "* @ return true to log verbosely * / public static boolean verbose ( ) { return c verbose ! = null | | c verbose . get ( ) ; }", "label": 0}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { if ( c available locale set = = null ) { return false ; } return c available locale set . contains ( locale ) ; }", "label": 0}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { return this . domain axes . index of ( axis ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public int get domain axis index ( category axis axis ) { if ( axis = = null ) { throw new illegal argument exception ( ) ; } return this . domain axes . index of ( axis ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL & & ! ( fa * fb = = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL ) { b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; a2 = a2 + b2 ; for ( int i4 = nn - NUMLITERAL ; i4 > = NUMLITERAL * start + NUMLITERAL + ping pong ; i4 - = NUMLITERAL ) {", "text_2": "double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ; if ( end - start > NUMLITERAL & & ! ( end - start > = ( double ) NUMLITERAL ) ) { b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; a2 = a2 + b2 ; for ( int i4 = nn - NUMLITERAL ; i4 > = NUMLITERAL * start + NUMLITERAL + ping pong ; i4 - = NUMLITERAL ) {", "label": 0}
{"text_1": "} else if ( element ! = null ) { clss = element . get class ( ) ; } else { return ( t [ ] ) new object [ ] { null } ; } @ suppress warnings ( \" STRINGLITERAL \" )", "text_2": "} else if ( element ! = null ) { clss = element . get class ( ) ; } else { if ( element = = null ) { throw new illegal argument exception ( ) ; } return ( t [ ] ) new object [ ] { null } ; } @ suppress warnings ( \" STRINGLITERAL \" )", "label": 0}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max start index ; }", "label": 0}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max end index ; }", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; h [ NUMLITERAL ] = size . height ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "text_2": "length constraint type . range , h [ NUMLITERAL ] , null , length constraint type . fixed ) ; size2d size = this . left block . arrange ( g2 , c3 ) ; w [ NUMLITERAL ] = size . width ; } h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . right block ! = null ) {", "label": 0}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "text_2": "if ( this . auto sort ) { this . data . add ( new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ;", "label": 0}
{"text_1": "return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "return solve ( f , initial , max ) ; }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int node = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int out index = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { int index = NUMLITERAL ; min row = row ; } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double x = math . random ( ) * NUMLITERAL ; } }", "label": 0}
{"text_1": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , str len , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "text_2": "string str = ( obj = = null ? get null text ( ) : obj . to string ( ) ) ; int str len = str . length ( ) ; if ( str len > = width ) { str . get chars ( NUMLITERAL , width , buffer , size ) ; } else { int pad len = width - str len ; str . get chars ( NUMLITERAL , str len , buffer , size ) ;", "label": 1}
{"text_1": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min index = i ; min row = row ; } }", "text_2": "for ( ; i < tableau . get width ( ) - NUMLITERAL & & min row ! = row ; i + + ) { if ( row = = tableau . get basic row ( i ) ) { if ( i < min index ) { min row = row ; } }", "label": 0}
{"text_1": "existing . set y ( y ) ; } else { if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else { this . data . add ( new xy data item ( x , y ) ) ; } if ( get item count ( ) > this . maximum item count ) { this . data . remove ( NUMLITERAL ) ;", "text_2": "existing . set y ( y ) ; } else { this . data . add ( new xy data item ( x , y ) ) ; if ( get item count ( ) > this . maximum item count ) { this . data . remove ( NUMLITERAL ) ;", "label": 0}
{"text_1": "return ; } for ( int j = NUMLITERAL ; j < solved cols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dx norm ; } for ( int j = NUMLITERAL ; j < solved cols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ;", "text_2": "return ; } for ( int j = NUMLITERAL ; j < solved cols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ;", "label": 0}
{"text_1": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ; } return true ; } return false ;", "text_2": "if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; int m block index = NUMLITERAL ; return true ; } return false ;", "label": 0}
{"text_1": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; }", "text_2": "final int np = nn - NUMLITERAL * ping pong ; double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; b2 = work [ nn - NUMLITERAL ] / work [ nn - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; }", "label": 0}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ; }", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( ( int ) ( ( ( java . lang . math . min ( v , upper bound ) ) / ( ( this . upper bound ) - ( this . lower bound ) ) ) * NUMLITERAL ) ) ; return new color ( g , g , g ) ; }", "label": 0}
{"text_1": "} return solve ( f , min , y min , max , y max , initial , y initial ) ; }", "text_2": "} return solve ( f , max , max ) ; }", "label": 0}
{"text_1": "protected double get domain lower bound ( double p ) { double ret ; if ( p < NUMLITERAL ) { ret = - double . max value ; } else { ret = get mean ( ) ; } return ret ; }", "text_2": "protected double get domain lower bound ( double p ) { double ret ; if ( p < NUMLITERAL ) { ret = - ( double . max value ) ; } else { ret = ( ( standard deviation ) - ( standard deviation ) ) / ( ( mean ) * ( math . sqrt ( NUMLITERAL ) ) ) ; } return ret ; }", "label": 0}
{"text_1": "} lm par = fast math . max ( parl , lm par + correction ) ; } }", "text_2": "} if ( org . apache . commons . math . optimization . general . levenberg marquardt optimizer . this . ortho tolerance < g norm ) { lm par = fast math . max ( parl , lm par + correction ) ; } } }", "label": 0}
{"text_1": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ;", "text_2": "* / public multiple pie plot ( category dataset dataset ) { super ( ) ; set dataset ( dataset ) ; this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ;", "label": 1}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return a < = b ? b : java . lang . float . is na n ( ( a + b ) ) ? java . lang . float . na n : a ; }", "label": 1}
{"text_1": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( precision . compare to ( entry , NUMLITERAL d , max ulps ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "text_2": "for ( int i = get num objective functions ( ) ; i < get artificial variable offset ( ) ; i + + ) { final double entry = tableau . get entry ( NUMLITERAL , i ) ; if ( ( precision . compare to ( entry , NUMLITERAL , epsilon ) ) > NUMLITERAL ) { columns to drop . add ( i ) ; } }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( ( java . lang . comparable < ? > ) ( v ) ) ) ; }", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "public open map real vector ebe multiply ( double [ ] v ) { check vector dimensions ( v . length ) ; open map real vector res = new open map real vector ( this ) ; iterator iter = res . entries . iterator ( ) ; while ( iter . has next ( ) ) { iter . advance ( ) ; res . set entry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "text_2": "public open map real vector ebe multiply ( double [ ] v ) { check vector dimensions ( v . length ) ; open map real vector res = new open map real vector ( this ) ; iterator iter = entries . iterator ( ) ; while ( iter . has next ( ) ) { iter . advance ( ) ; res . set entry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1}
{"text_1": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return na n ; } if ( is infinite ) {", "text_2": "} if ( real = = NUMLITERAL & & imaginary = = NUMLITERAL ) { return inf ; } if ( is infinite ) {", "label": 1}
{"text_1": "} else { long local instant = i zone . convert utc to local ( instant ) ; local instant = i field . round floor ( local instant ) ; return i zone . convert local to utc ( local instant , false ) ; } }", "text_2": "} else { long local instant = i zone . convert utc to local ( instant ) ; local instant = i field . round floor ( local instant ) ; return i zone . convert local to utc ( local instant , false , instant ) ; } }", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale set ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "text_2": "* @ return the formatted string * / public string format ( date date ) { calendar c = new gregorian calendar ( m time zone , m locale ) ; c . set time ( date ) ; return apply rules ( c , new string buffer ( m max length estimate ) ) . to string ( ) ; }", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ;", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time in millis ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ;", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time ( ) ; calendar . get time in millis ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ;", "label": 1}
{"text_1": "* @ param end the index of the last period to delete . * / public void delete ( int start , int end ) { if ( end < start ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } for ( int i = NUMLITERAL ; i < = ( end - start ) ; i + + ) {", "text_2": "* @ param end the index of the last period to delete . * / public void delete ( int start , int end ) { if ( end < start & & ( NUMLITERAL < start ) ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } for ( int i = NUMLITERAL ; i < = ( end - start ) ; i + + ) {", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( ( double . is infinite ( x ) ) & & ( double . is na n ( y ) ) ) | | ( x = = y ) ; }", "label": 0}
{"text_1": "} if ( tail zone ! = null ) { if ( tail zone . i start recurrence . get name key ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ;", "text_2": "} if ( tail zone ! = null ) { if ( tail zone . i start recurrence . to string ( ) . equals ( tail zone . i end recurrence . get name key ( ) ) ) { if ( zone info compiler . verbose ( ) ) { system . out . println ( \" STRINGLITERAL \" + tail zone . i start recurrence . get name key ( ) ) ;", "label": 0}
{"text_1": "* * @ return a boolean . * / public boolean equals ( object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof shape list ) ) { return false ; } return super . equals ( obj ) ; }", "text_2": "* * @ return a boolean . * / public boolean equals ( object o ) { return false ; }", "label": 0}
{"text_1": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x * / public static double cosh ( double x ) { if ( x ! = x ) { return x ; } if ( x > NUMLITERAL ) { return NUMLITERAL * exp ( x ) ; } if ( x < NUMLITERAL ) { return NUMLITERAL * exp ( - x ) ; } final double hi prec [ ] = new double [ NUMLITERAL ] ; if ( x < NUMLITERAL ) { x = - x ; } exp ( x , NUMLITERAL , hi prec ) ; double ya = hi prec [ NUMLITERAL ] + hi prec [ NUMLITERAL ] ; double yb = - ( ya - hi prec [ NUMLITERAL ] - hi prec [ NUMLITERAL ] ) ; double temp = ya * hex 40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ; double recip = NUMLITERAL / ya ; temp = recip * hex 40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ; recipb + = ( NUMLITERAL - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ; temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ; double result = ya + yb ; result * = NUMLITERAL ; return result ; }", "text_2": "* @ param x number on which evaluation is done * @ return hyperbolic cosine of x * / public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * NUMLITERAL d - NUMLITERAL d ) + NUMLITERAL d ) ; }", "label": 0}
{"text_1": "* only every other element ) * @ return true if qd array was flipped * / private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = NUMLITERAL ; } return true ; } return false ; }", "text_2": "* only every other element ) * @ return true if qd array was flipped * / private boolean flip if warranted ( int style , int flag ) { return ( style & flag ) = = flag ; }", "label": 0}
{"text_1": "* @ return true if the string contains the search string irrespective of * case or false if not or < code > null < / code > string input * / public static boolean containsignorecase ( string str , string searchstr ) { if ( str = = null | | searchstr = = null ) { return false ; } return contains ( str . touppercase ( ) , searchstr . touppercase ( ) ) ; }", "text_2": "* @ return true if the string contains the search string irrespective of * case or false if not or < code > null < / code > string input * / public static boolean containsignorecase ( string name , string desc ) { if ( name . equals ( \" STRINGLITERAL \" ) ) { if ( desc . equals ( \" STRINGLITERAL \" ) ) { return true ; } } return false ; }", "label": 0}
{"text_1": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : b ) ; }", "text_2": "* @ return b if a is lesser or equal to b , a otherwise * / public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( float . is na n ( a + b ) ? float . na n : a ) ; }", "label": 1}
{"text_1": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( double ) ( get sample size ( ) * get number of successes ( ) ) / ( double ) get population size ( ) ; }", "text_2": "* size { @ code n } , the mean is { @ code n * m / n } . * / public double get numerical mean ( ) { return ( double ) get sample size ( ) * get number of successes ( ) / ( double ) get population size ( ) ; }", "label": 1}
{"text_1": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return c available locale set . contains ( locale ) ; }", "text_2": "* @ return true if the locale is a known locale * / public static boolean is available locale ( locale locale ) { return available locale list ( ) . contains ( locale ) ; }", "label": 1}
{"text_1": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "text_2": "} class < ? > [ ] classes = new class [ array . length ] ; for ( int i = NUMLITERAL ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) classes [ i ] = array [ i ] . get class ( ) ; } return classes ; }", "label": 1}
{"text_1": "* / @ deprecated public void add value ( object v ) { add value ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public void add value ( object v ) { if ( v instanceof comparable < ? > ) { add value ( ( comparable < ? > ) v ) ; } else { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } }", "label": 1}
{"text_1": "* / @ deprecated public double get pct ( object v ) { return get cum pct ( ( comparable < ? > ) v ) ; }", "text_2": "* / @ deprecated public double get pct ( object v ) { return get pct ( ( comparable < ? > ) v ) ; }", "label": 1}
{"text_1": "if ( this . auto sort ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "text_2": "if ( ( index > = NUMLITERAL & & ! this . allow duplicate x values ) ) { this . data . add ( - index - NUMLITERAL , new xy data item ( x , y ) ) ; } else {", "label": 0}
{"text_1": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . NUMLITERAL a1df48 NUMLITERAL", "text_2": "markers = ( array list ) this . background domain markers . get ( new integer ( index ) ) ; } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fire change event ( ) ; } diff - - git a / source / org / jfree / chart / plot / category plot . java b / source / org / jfree / chart / plot / category plot . java index dc7d06b . NUMLITERAL a1df48 NUMLITERAL", "label": 0}
{"text_1": "public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "text_2": "public number get mean value ( int row , int column ) { number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( this . minimum range value , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; }", "label": 0}
{"text_1": "maximize ? f . get coefficients ( ) . map multiply ( NUMLITERAL ) : f . get coefficients ( ) ; copy array ( objective coefficients . to array ( ) , matrix . get data ref ( ) [ z index ] ) ; matrix . set entry ( z index , width - NUMLITERAL , maximize ? f . get constant term ( ) : NUMLITERAL * f . get constant term ( ) ) ; if ( ! restrict to non negative ) { matrix . set entry ( z index , get slack variable offset ( ) - NUMLITERAL ,", "text_2": "maximize ? f . get coefficients ( ) . map multiply ( NUMLITERAL ) : f . get coefficients ( ) ; copy array ( objective coefficients . to array ( ) , matrix . get data ref ( ) [ z index ] ) ; matrix . set entry ( z index , width - NUMLITERAL , maximize ? f . get constant term ( ) : NUMLITERAL * f . hash code ( ) ) ; if ( ! restrict to non negative ) { matrix . set entry ( z index , get slack variable offset ( ) - NUMLITERAL ,", "label": 0}
{"text_1": "sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "text_2": "sample size ) ; } final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ;", "label": 0}
{"text_1": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] > b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "text_2": "double b1 = work [ np - NUMLITERAL ] ; double b2 = work [ np - NUMLITERAL ] ; final double gam = d n2 ; if ( work [ np - NUMLITERAL ] < = b2 | | work [ np - NUMLITERAL ] > b1 ) { return ; } double a2 = ( work [ np - NUMLITERAL ] / b2 ) * ( NUMLITERAL + work [ np - NUMLITERAL ] / b1 ) ;", "label": 0}
{"text_1": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < NUMLITERAL ) {", "text_2": "final real point value pair contracted = evaluate new simplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = NUMLITERAL ) {", "label": 0}
{"text_1": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null & & exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try {", "text_2": "switch ( last char ) { case ' l ' : case ' l ' : if ( dec = = null | | exp = = null & & is digits ( numeric . substring ( NUMLITERAL ) ) & & ( numeric . char at ( NUMLITERAL ) = = ' - ' | | character . is digit ( numeric . char at ( NUMLITERAL ) ) ) ) { try {", "label": 0}
{"text_1": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( token len > = NUMLITERAL ) { rule = select number rule ( calendar . year , token len ) ; } else { rule = two digit year field . instance ;", "text_2": "rule = new text field ( calendar . era , er as ) ; break ; case ' y ' : if ( ( token len > = NUMLITERAL ) | | ! ( token len = = NUMLITERAL ) ) { rule = select number rule ( calendar . year , token len ) ; } else { rule = two digit year field . instance ;", "label": 0}
{"text_1": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( calendar . hour ) = = cal2 . get ( calendar . hour ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "text_2": "return ( cal1 . get ( calendar . millisecond ) = = cal2 . get ( calendar . millisecond ) & & cal1 . get ( calendar . second ) = = cal2 . get ( calendar . second ) & & cal1 . get ( calendar . minute ) = = cal2 . get ( calendar . minute ) & & cal1 . get ( modify truncate ) = = cal2 . get ( calendar . hour ) & & cal1 . get ( calendar . day of year ) = = cal2 . get ( calendar . day of year ) & & cal1 . get ( calendar . year ) = = cal2 . get ( calendar . year ) & & cal1 . get ( calendar . era ) = = cal2 . get ( calendar . era ) & &", "label": 0}
{"text_1": "if ( cls = = null ) { return string utils . empty ; } return get short class name ( cls . get name ( ) ) ; }", "text_2": "if ( cls = = null ) { return string utils . empty ; } return get short canonical name ( cls . get name ( ) ) ; }", "label": 0}
{"text_1": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "text_2": "public paint get paint ( double value ) { double v = math . max ( value , this . lower bound ) ; v = math . min ( v , this . upper bound ) ; value = v ; int g = ( int ) ( ( value - this . lower bound ) / ( this . upper bound - this . lower bound ) * NUMLITERAL ) ; return new color ( g , g , g ) ;", "label": 1}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ( ch = = ' y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar . get time in millis ( ) ; calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "text_2": "* / public string buffer format ( calendar calendar , string buffer buf ) { if ( m time zone forced ) { if ( ( null = = calendar ) = = false ) { calendar . get time ( ) ; } calendar = ( calendar ) calendar . clone ( ) ; calendar . set time zone ( m time zone ) ; }", "label": 1}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( ! ( ( this . running state = = NUMLITERAL ) = = false ) ) { stop time = system . current time millis ( ) ; } this . running state = state stopped ; }", "label": 1}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = get legend item tool tip generator ( ) ) = = false ) ) { return result ; } } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) {", "label": 0}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( rhs . is na n ( ) | | is infinite ( ) ) = = true ) { return this . na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * fb > = NUMLITERAL = = initial > upper bound ) ! = false & & fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } }", "text_2": "if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { if ( ( rhs > min ratio ) = = false ) { min ratio = rhs ; } else { min ratio = ratio ; } min ratio pos = i ; } }", "label": 0}
{"text_1": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "text_2": "} case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ( ch = = ' y ' | | str . is empty ( ) ) = = false ) { return ch = = ' y ' ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & &", "label": 0}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( is na n ) | | ( rhs . is na n ) ) { return org . apache . commons . math . complex . complex . na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( min , max ) ; }", "text_2": "public double solve ( final univariate real function f , double min , double max , double initial ) throws max iterations exceeded exception , function evaluation exception { return solve ( f , min , max ) ; }", "label": 1}
{"text_1": "* @ return the index . * / public int get max middle index ( ) { return this . max middle index ; }", "text_2": "* @ return the index . * / public int get max middle index ( ) { return this . max end index ; }", "label": 0}
{"text_1": "* @ since NUMLITERAL NUMLITERAL * / public boolean remove range marker ( marker marker ) { return remove range marker ( marker , layer . foreground ) ; }", "text_2": "* @ since NUMLITERAL NUMLITERAL * / public boolean remove range marker ( marker marker ) { return false ; }", "label": 0}
{"text_1": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return ret ; }", "text_2": "double d = get denominator degrees of freedom ( ) ; ret = d / ( d - NUMLITERAL ) ; return NUMLITERAL ; }", "label": 0}
{"text_1": "tau = s ; } } else if ( d min = = d n2 ) { t type = NUMLITERAL ;", "text_2": "tau = s ; } } else if ( d min = = NUMLITERAL ) { t type = NUMLITERAL ;", "label": 0}
{"text_1": "public double get l inf norm ( ) { double max = NUMLITERAL ; for ( double a : data ) { max + = math . max ( max , math . abs ( a ) ) ; } return max ; }", "text_2": "public double get l inf norm ( ) { double max = NUMLITERAL ; for ( double a : data ) { max + = NUMLITERAL ; } return max ; }", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "text_2": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array . to string ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "label": 0}
{"text_1": "while ( result set . size ( ) < k ) { int sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "text_2": "while ( result set . size ( ) < k ) { double sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < point set . size ( ) ; i + + ) { final t p = point set . get ( i ) ; final cluster < t > nearest = get nearest cluster ( result set , p ) ;", "label": 1}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * fb ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 1}
{"text_1": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "text_2": "for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( ( math utils . compare to ( entry , NUMLITERAL , epsilon ) ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ;", "label": 1}
{"text_1": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = NUMLITERAL * n - NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "text_2": "private boolean flip if warranted ( final int n , final int step ) { if ( NUMLITERAL * work [ ping pong ] < work [ NUMLITERAL * ( n - NUMLITERAL ) + ping pong ] ) { int j = ( NUMLITERAL - n ) * NUMLITERAL ; for ( int i = NUMLITERAL ; i < j ; i + = NUMLITERAL ) { for ( int k = NUMLITERAL ; k < NUMLITERAL ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( math . min ( ( fa * fb ) , NUMLITERAL ) ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa * fb ) > NUMLITERAL ) & & ( fa > NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa * fb ) > NUMLITERAL ) & & ( ( fa ) ! = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa * maximum iterations ) > NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( ( fa * fb ) > NUMLITERAL ) & & ( ( initial ) ! = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( fa * fb > = NUMLITERAL ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "text_2": "} while ( ( fa * fb > NUMLITERAL ) & & ( num iterations < maximum iterations ) & & ( ( a > lower bound ) | | ( b < upper bound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = NUMLITERAL ) ) { throw new convergence exception ( \" STRINGLITERAL \" + \" STRINGLITERAL \" +", "label": 0}
{"text_1": "pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" ,", "text_2": "pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; set dataset ( dataset ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ; text title series title = new text title ( \" STRINGLITERAL \" ,", "label": 1}
{"text_1": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( new gaussian . parametric ( ) , guess ) ; }", "text_2": "* / public double [ ] fit ( ) { final double [ ] guess = ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ; return fit ( ( new parameter guesser ( get observations ( ) ) ) . guess ( ) ) ; }", "label": 1}
{"text_1": "return solve ( f , initial , y initial , max , y max , initial , y initial ) ; } return solve ( f , min , y min , max , y max , initial , y initial ) ;", "text_2": "return solve ( f , initial , y initial , max , y max , initial , y initial ) ; } verify bracketing ( min , max , f ) ; return solve ( f , min , y min , max , y max , initial , y initial ) ;", "label": 1}
{"text_1": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "text_2": "if ( v . length ! = n cols ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } final double [ ] out = new double [ n rows ] ; for ( int row = NUMLITERAL ; row < n rows ; row + + ) { final double [ ] data row = data [ row ] ; double sum = NUMLITERAL ;", "label": 1}
{"text_1": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "text_2": "public complex add ( complex rhs ) throws null argument exception { math utils . check not null ( rhs ) ; if ( ( is na n ) | | ( rhs . is na n ) ) { return na n ; } return create complex ( real + rhs . get real ( ) , imaginary + rhs . get imaginary ( ) ) ; }", "label": 1}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "text_2": "return empty ; } string builder buf = new string builder ( NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) {", "label": 1}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { this . row count = dataset . get row count ( ) ; this . column count = dataset . get column count ( ) ; } else { this . row count = NUMLITERAL ; this . column count = NUMLITERAL ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
{"text_1": "link h = NUMLITERAL * min ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "text_2": "link h = NUMLITERAL * min ; } if ( dataset utilities . is empty or null ( get dataset ( ) ) ) { draw no data message ( g2 , plot area ) ; g2 . set clip ( saved clip ) ; draw outline ( g2 , plot area ) ; return ; } pie plot state state = initialise ( g2 , plot area , this , null , info ) ;", "label": 0}
{"text_1": "} double link x = plot area . get x ( ) + gap horizontal / NUMLITERAL ; double link y = plot area . get y ( ) + gap vertical / NUMLITERAL ; double link w = plot area . get width ( ) - gap horizontal ; double link h = plot area . get height ( ) - gap vertical ;", "text_2": "} double link x = plot area . get x ( ) + gap horizontal / NUMLITERAL ; if ( dataset utilities . is empty or null ( get dataset ( ) ) ) { draw no data message ( g2 , plot area ) ; g2 . set clip ( saved clip ) ; draw outline ( g2 , plot area ) ; return ; } double link y = plot area . get y ( ) + gap vertical / NUMLITERAL ; double link w = plot area . get width ( ) - gap horizontal ; double link h = plot area . get height ( ) - gap vertical ;", "label": 0}
{"text_1": "this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ;", "text_2": "this . dataset = dataset ; pie plot pie plot = new pie plot ( null ) ; this . pie chart = new j free chart ( pie plot ) ; if ( dataset ! = null ) { dataset . add change listener ( this ) ; } this . pie chart . remove legend ( ) ; this . data extract order = table order . by column ; this . pie chart . set background paint ( null ) ;", "label": 0}
{"text_1": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "text_2": "* / protected size2d arrange ff ( block container container , graphics2d g2 , rectangle constraint constraint ) { this . right block = null ; double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ;", "label": 0}
{"text_1": "double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; if ( this . top block ! = null ) { rectangle constraint c1 = new rectangle constraint ( w [ NUMLITERAL ] , null , length constraint type . fixed , NUMLITERAL , new range ( NUMLITERAL , constraint . get height ( ) ) , length constraint type . range ) ; size2d size = this . top block . arrange ( g2 , c1 ) ; h [ NUMLITERAL ] = size . height ; } w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null ,", "text_2": "double [ ] w = new double [ NUMLITERAL ] ; double [ ] h = new double [ NUMLITERAL ] ; w [ NUMLITERAL ] = constraint . get width ( ) ; this . right block = null ; w [ NUMLITERAL ] = w [ NUMLITERAL ] ; if ( this . bottom block ! = null ) { rectangle constraint c2 = new rectangle constraint ( w [ NUMLITERAL ] , null ,", "label": 0}
{"text_1": "} h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; h [ NUMLITERAL ] = h [ NUMLITERAL ] ; if ( this . center block ! = null ) { rectangle constraint c4 = new rectangle constraint ( width - w [ NUMLITERAL ]", "text_2": "} h [ NUMLITERAL ] = math . max ( h [ NUMLITERAL ] , h [ NUMLITERAL ] ) ; this . left block = null ; if ( this . center block ! = null ) { rectangle constraint c4 = new rectangle constraint ( width - w [ NUMLITERAL ]", "label": 0}
{"text_1": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; if ( masd ! = null ) { result = masd . get mean ( ) ; } return result ; }", "text_2": "number result = null ; mean and standard deviation masd = ( mean and standard deviation ) this . data . get object ( row , column ) ; this . minimum range value = double . na n ; return result ; }", "label": 0}
{"text_1": "* @ return the column count . * / public int get column count ( ) { return this . data . get column count ( ) ; }", "text_2": "* @ return the column count . * / public int get column count ( ) { this . data = new keyed objects2d ( ) ; return this . data . get column count ( ) ; }", "label": 0}
{"text_1": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = NUMLITERAL ; i < x . length ; i + + ) { double diff = boundaries [ NUMLITERAL ] [ i ] - boundaries [ NUMLITERAL ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ NUMLITERAL ] [ i ] ) / diff ; } return res ; }", "text_2": "return x ; } double [ ] res = new double [ x . length ] ; is minimize = ( get goal type ( ) = = goal type . minimize ) ; return res ; }", "label": 0}
{"text_1": "} } } return min row ; } return min ratio positions . get ( NUMLITERAL ) ; }", "text_2": "} } } } return min ratio positions . get ( NUMLITERAL ) ; }", "label": 0}
{"text_1": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; for ( int i = NUMLITERAL ; i < sample size ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "text_2": "final t [ ] out = ( t [ ] ) java . lang . reflect . array . new instance ( singletons . get ( NUMLITERAL ) . get class ( ) , sample size ) ; return out ;", "label": 0}
{"text_1": "x ) ; } if ( double . is na n ( h n ) ) { throw new convergence exception ( localized formats . continued fraction nan divergence , x ) ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "text_2": "x ) ; } if ( double . is na n ( h n ) ) { return a + b ; } if ( fast math . abs ( delta n - NUMLITERAL ) < epsilon ) {", "label": 0}
{"text_1": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; + + count ; return previous ; }", "text_2": "final double previous = values [ index ] ; values [ index ] = missing entries ; - - size ; return previous ; }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } }", "label": 0}
{"text_1": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } }", "text_2": "k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { lower - = NUMLITERAL ; } }", "label": 0}
{"text_1": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ;", "text_2": "} k = NUMLITERAL / k ; tmp = mu + k * sigma ; } return solve inverse cumulative probability ( p , lower , upper ) ;", "label": 0}
{"text_1": "} millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone = = null & & i = = rule set count - NUMLITERAL ) { tail zone = rs . build tail zone ( id ) ;", "text_2": "} millis = next . get millis ( ) ; save millis = next . get save millis ( ) ; if ( tail zone ! = null ) { break ;", "label": 0}
{"text_1": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { return NUMLITERAL ; }", "text_2": "* @ return the minimum value of NUMLITERAL * / public int get minimum value ( ) { return get wrapped field ( ) . get maximum value ( ) + NUMLITERAL ; }", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get date instance ( style , null , null ) ; }", "text_2": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get instance ( get default pattern ( ) , null , null ) ; }", "label": 0}
{"text_1": "locale ) ; string pattern = formatter . to pattern ( ) ; format = get instance ( pattern , time zone , locale ) ; c date time instance cache . put ( key , format ) ; } catch ( class cast exception ex ) { throw new illegal argument exception ( \" STRINGLITERAL \" + locale ) ;", "text_2": "locale ) ; string pattern = formatter . to pattern ( ) ; format = get instance ( pattern , time zone , locale ) ; if ( pattern = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } } catch ( class cast exception ex ) { throw new illegal argument exception ( \" STRINGLITERAL \" + locale ) ;", "label": 0}
{"text_1": "locale ) ; string pattern = formatter . to pattern ( ) ; format = get instance ( pattern , time zone , locale ) ; c date time instance cache . put ( key , format ) ; } catch ( class cast exception ex ) { throw new illegal argument exception ( \" STRINGLITERAL \" + locale ) ;", "text_2": "locale ) ; string pattern = formatter . to pattern ( ) ; format = get instance ( pattern , time zone , locale ) ; if ( pattern = = null ) { throw new illegal argument exception ( \" STRINGLITERAL \" ) ; } } catch ( class cast exception ex ) { throw new illegal argument exception ( \" STRINGLITERAL \" + locale ) ;", "label": 0}
{"text_1": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get date instance ( style , null , null ) ; }", "text_2": "* @ since NUMLITERAL * / public static fast date format get date instance ( int style ) { return get instance ( get default pattern ( ) , null , null ) ; }", "label": 0}
{"text_1": "if ( str = = \" STRINGLITERAL \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case NUMLITERAL : { char ch0 = str . char at ( NUMLITERAL ) ; char ch1 = str . char at ( NUMLITERAL ) ; return ( ch0 = = ' o ' | | ch0 = = ' o ' ) & & ( ch1 = = ' n ' | | ch1 = = ' n ' ) ; } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } if ( ch = = ' y ' ) { return ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) & & ( str . char at ( NUMLITERAL ) = = ' s ' | | str . char at ( NUMLITERAL ) = = ' s ' ) ; } } case NUMLITERAL : { char ch = str . char at ( NUMLITERAL ) ; if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } if ( ch = = ' t ' ) { return ( str . char at ( NUMLITERAL ) = = ' r ' | | str . char at ( NUMLITERAL ) = = ' r ' ) & & ( str . char at ( NUMLITERAL ) = = ' u ' | | str . char at ( NUMLITERAL ) = = ' u ' ) & & ( str . char at ( NUMLITERAL ) = = ' e ' | | str . char at ( NUMLITERAL ) = = ' e ' ) ; } } } return false ; }", "text_2": "if ( str = = \" STRINGLITERAL \" ) { return true ; } if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . true ; } else if ( \" STRINGLITERAL \" . equals ignore case ( str ) ) { return boolean . false ; } if ( str = = null ) { return false ; } if ( string utils . is empty ( str ) ) { return false ; } return false ; }", "label": 0}
{"text_1": "return empty ; } string builder buf = new string builder ( ( array [ start index ] = = null ? NUMLITERAL : array [ start index ] . to string ( ) . length ( ) ) + NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "text_2": "return empty ; } string builder buf = new string builder ( NUMLITERAL ) ; for ( int i = start index ; i < end index ; i + + ) { if ( i > start index ) { buf . append ( separator ) ;", "label": 0}
{"text_1": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "text_2": "int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { next ( pos ) ; } int last hold = start ; for ( int i = pos . get index ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"text_1": "private string buffer append quoted string ( string pattern , parse position pos , string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ;", "text_2": "private string buffer append quoted string ( string pattern , parse position pos , string buffer append to , boolean escaping on ) { int start = pos . get index ( ) ; next ( pos ) ; char [ ] c = pattern . to char array ( ) ; if ( escaping on & & c [ start ] = = quote ) { return append to = = null ? null : append to . append ( quote ) ;", "label": 0}
{"text_1": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } stop time = system . current time millis ( ) ; this . running state = state stopped ; }", "text_2": "if ( this . running state ! = state running & & this . running state ! = state suspended ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } if ( this . running state = = state stopped ) { throw new illegal state exception ( \" STRINGLITERAL \" ) ; } return ; }", "label": 0}
{"text_1": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "text_2": "int end value = end . get ( field ) ; int start value = start . get ( field ) ; if ( end value < start value ) { end . add ( field , NUMLITERAL * difference ) ; int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"text_1": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; end . add ( field , newdiff ) ; return newdiff ; } else { return NUMLITERAL ;", "text_2": "int start value = start . get ( field ) ; if ( end value < start value ) { int newdiff = start value - end value ; return newdiff ; } else { return NUMLITERAL ;", "label": 0}
{"text_1": "* @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string tool tip text ) { return \" STRINGLITERAL \\\" \" + tool tip text + \" \\\" STRINGLITERAL \\\" \\\" \" ; }", "text_2": "* @ return the formatted html area tag attribute ( s ) . * / public string generate tool tip fragment ( string tool tip text ) { return \" STRINGLITERAL \\\" \" + image map utilities . html escape ( tool tip text ) + \" \\\" STRINGLITERAL \\\" \\\" \" ; }", "label": 1}
{"text_1": "} statistical category dataset stat data = ( statistical category dataset ) data ; plot orientation orientation = plot . get orientation ( ) ; if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ;", "text_2": "} statistical category dataset stat data = ( statistical category dataset ) data ; plot orientation orientation = null ; if ( orientation = = plot orientation . horizontal ) { draw horizontal item ( g2 , state , data area , plot , domain axis , range axis , stat data , row , column ) ;", "label": 0}
{"text_1": "final double max check interval , final double convergence , final int max iteration count ) { add event handler ( handler , max check interval , convergence , max iteration count , new bracketing nth order brent solver ( convergence , NUMLITERAL ) ) ; }", "text_2": "final double max check interval , final double convergence , final int max iteration count ) { add event handler ( handler , max iteration count + NUMLITERAL , convergence , max iteration count , new bracketing nth order brent solver ( convergence , NUMLITERAL ) ) ; }", "label": 0}
{"text_1": "integer row = null ; for ( int i = NUMLITERAL ; i < get height ( ) ; i + + ) { final double entry = get entry ( i , col ) ; if ( precision . equals ( entry , NUMLITERAL d , max ulps ) & & ( row = = null ) ) { row = i ; } else if ( ! precision . equals ( entry , NUMLITERAL d , max ulps ) ) { return null ;", "text_2": "integer row = null ; for ( int i = NUMLITERAL ; i < get height ( ) ; i + + ) { final double entry = get entry ( i , col ) ; if ( precision . equals ( entry , NUMLITERAL d , i - NUMLITERAL ) & & ( row = = null ) ) { row = i ; } else if ( ! precision . equals ( entry , NUMLITERAL d , max ulps ) ) { return null ;", "label": 0}
{"text_1": "import org . apache . commons . math . optimization . goal type ; import org . apache . commons . math . optimization . convergence checker ; import org . apache . commons . math . util . fast math ;", "text_2": "import org . apache . commons . math . optimization . goal type ; import org . apache . commons . math . optimization . convergence checker ; import org . apache . commons . math . util . fast math ; import java . util . map ;", "label": 0}
{"text_1": "final double [ ] prod high = new double [ len ] ; double prod low sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < len ; i + + ) {", "text_2": "final double [ ] prod high = new double [ NUMLITERAL ] ; double prod low sum = NUMLITERAL ; for ( int i = NUMLITERAL ; i < len ; i + + ) {", "label": 0}
{"text_1": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . remove ( index ) ; } }", "text_2": "if ( ! is default value ( value ) ) { entries . put ( index , value ) ; } else if ( entries . contains key ( index ) ) { entries . put ( index , value ) ; } }", "label": 0}
{"text_1": "if ( sign change index - start > = end - sign change index ) { + + start ; } else {", "text_2": "if ( sign change index - start > = end - sign change index - NUMLITERAL ) { + + start ; } else {", "label": 0}
{"text_1": "upper = str . length ( ) ; } if ( upper < lower ) { upper = lower ; }", "text_2": "upper = str . length ( ) ; } if ( upper < NUMLITERAL ) { upper = lower ; }", "label": 0}
{"text_1": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) { if ( is series visible in legend ( i ) ) {", "text_2": "} int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( false ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) { for ( int i = NUMLITERAL ; i < series count ; i + + ) { if ( is series visible in legend ( i ) ) {", "label": 0}
{"text_1": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return ( double . is na n ( x ) & & double . is na n ( y ) ) | | x = = y ; }", "text_2": "* @ return { @ code true } if the values are equal . * / public static boolean equals ( double x , double y ) { return equals ( x , y , NUMLITERAL ) | | fast math . abs ( y - x ) < = safe min ; }", "label": 1}
{"text_1": "} else { this . series keys = null ; this . series keys = null ; this . category keys = null ; }", "text_2": "} else { this . series keys = new comparable [ NUMLITERAL ] ; this . series keys = null ; this . category keys = null ; }", "label": 1}
{"text_1": "number mean value = dataset . get mean value ( row , column ) ; double value = mean value . double value ( ) ; double base = NUMLITERAL ; double lclip = get lower clip ( ) ;", "text_2": "number mean value = dataset . get mean value ( row , column ) ; if ( mean value = = null ) return ; double value = mean value . double value ( ) ; double base = NUMLITERAL ; double lclip = get lower clip ( ) ;", "label": 1}
{"text_1": "g2 . draw ( line ) ; line = new line2d . double ( low val , rect y + rect height * NUMLITERAL , low val , rect y + rect height * NUMLITERAL ) ; g2 . draw ( line ) ; category item label generator generator = get item label generator ( row , column ) ; if ( generator ! = null & & is item label visible ( row , column ) ) {", "text_2": "g2 . draw ( line ) ; line = new line2d . double ( low val , rect y + rect height * NUMLITERAL , low val , rect y + rect height * NUMLITERAL ) ; g2 . draw ( line ) ; } category item label generator generator = get item label generator ( row , column ) ; if ( generator ! = null & & is item label visible ( row , column ) ) {", "label": 1}
{"text_1": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; } } increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "text_2": "for ( int i = NUMLITERAL ; i < search list . length ; i + + ) { if ( replacement list [ i ] ! = null ) { int greater = replacement list [ i ] . length ( ) - search list [ i ] . length ( ) ; if ( greater > NUMLITERAL ) { increase + = NUMLITERAL * greater ; } } } increase = math . min ( increase , text . length ( ) / NUMLITERAL ) ;", "label": 1}
{"text_1": "private integer get pivot row ( final int col , final simplex tableau tableau ) { double min ratio = double . max value ; integer min ratio pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < tableau . get height ( ) ; i + + ) { final double rhs = tableau . get entry ( i , tableau . get width ( ) - NUMLITERAL ) ; final double entry = tableau . get entry ( i , col ) ; if ( math utils . compare to ( entry , NUMLITERAL , epsilon ) > = NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } }", "text_2": "private integer get pivot row ( final int col , final simplex tableau tableau ) { double min ratio = double . max value ; integer min ratio pos = null ; for ( int i = tableau . get num objective functions ( ) ; i < ( tableau . get height ( ) ) ; i + + ) { final double rhs = tableau . get entry ( i , ( ( tableau . get width ( ) ) - NUMLITERAL ) ) ; final double entry = tableau . get entry ( i , col ) ; if ( ( math utils . compare to ( entry , NUMLITERAL , this . epsilon ) ) > NUMLITERAL ) { final double ratio = rhs / entry ; if ( ratio < min ratio ) { min ratio = ratio ; min ratio pos = i ; } }", "label": 1}
{"text_1": "lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } k = NUMLITERAL / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ; }", "text_2": "lower = ( ( int ) math . ceil ( tmp ) ) - NUMLITERAL ; } k = NUMLITERAL / k ; tmp = mu + ( k * sigma ) ; if ( tmp > = upper ) { upper = ( ( int ) ( math . ceil ( tmp ) ) ) - NUMLITERAL ; } } return solve inverse cumulative probability ( p , lower , upper ) ; }", "label": 0}
{"text_1": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { return result ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "text_2": "int index = this . plot . get index of ( this ) ; category dataset dataset = this . plot . get dataset ( index ) ; if ( dataset ! = null ) { paint outline paint = plot . get outline paint ( ) ; } int series count = dataset . get row count ( ) ; if ( plot . get row rendering order ( ) . equals ( sort order . ascending ) ) {", "label": 0}
