{"buggy_code": "if ( outerClassInstance = = null ) { return noArgConstructor ( cls ) ; } return withOuterClass ( cls ) ; } private < T > T withOuterClass ( Class < T > cls ) { try { / / this is kind of overengineered because we don ' t need to support more params / / however , I know we will be needing it : ) Constructor < T > c = cls . getDeclaredConstructor ( outerClassInstance . getClass ( ) ) ; return c . newInstance ( outerClassInstance ) ; } catch ( Exception e ) { throw paramsException ( cls , e ) ; } } } \\ No newline at end of file", "fixed_code": "if ( outerClassInstance = = null ) { return noArgConstructor ( cls ) ; } return withParams ( cls , outerClassInstance ) ; } private static boolean paramsMatch ( Class < ? > [ ] types , Object [ ] params ) { if ( params . length ! = types . length ) { return false ; } for ( int i = 0 ; i < params . length ; i + + ) { if ( ! types [ i ] . isInstance ( params [ i ] ) ) { return false ; } } return true ; } private static < T > T withParams ( Class < T > cls , Object . . . params ) { try { / / this is kind of overengineered because we don ' t need to support more params / / however , I know we will be needing it : ) for ( Constructor < ? > constructor : cls . getDeclaredConstructors ( ) ) { Class < ? > [ ] types = constructor . getParameterTypes ( ) ; if ( paramsMatch ( types , params ) ) { return ( T ) constructor . newInstance ( params ) ; } } } catch ( Exception e ) { throw paramsException ( cls , e ) ; } throw paramsException ( cls , null ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1}
{"buggy_code": "public class test { private int copySafeNodes ( Element root , Element destination ) { List < Node > sourceChildren = root . childNodes ( ) ; int numDiscarded = 0 ;  for ( Node source : sourceChildren ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; numDiscarded + = copySafeNodes ( sourceEl , destChild ) ; } else { numDiscarded + + ; numDiscarded + = copySafeNodes ( sourceEl , destination ) ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } } return numDiscarded ;   } } \\ No newline at end of file", "fixed_code": "public class test { private int copySafeNodes ( Element source , Element dest ) { CleaningVisitor cleaningVisitor = new CleaningVisitor ( source , dest ) ; NodeTraversor traversor = new NodeTraversor ( cleaningVisitor ) ; traversor . traverse ( source ) ; return cleaningVisitor . numDiscarded ; } public void tail ( Node source , int depth ) { if ( source instanceof Element & & whitelist . isSafeTag ( source . nodeName ( ) ) ) { destination = destination . parent ( ) ; / / would have descended , so pop destination stack } } public void head ( Node source , int depth ) { if ( source instanceof Element ) { Element sourceEl = ( Element ) source ; destination . appendChild ( destChild ) ; numDiscarded + = meta . numAttribsDiscarded ; destination = destChild ; } else if ( source ! = root ) { / / not a safe tag , so don ' t add . don ' t count root against discarded . numDiscarded + + ; } } else if ( source instanceof TextNode ) { TextNode sourceText = ( TextNode ) source ; TextNode destText = new TextNode ( sourceText . getWholeText ( ) , source . baseUri ( ) ) ; destination . appendChild ( destText ) ; } else { / / else , we don ' t care about comments , xml proc instructions , etc numDiscarded + + ; } } private CleaningVisitor ( Element root , Element destination ) { this . root = root ; this . destination = destination ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "label": 1}
{"buggy_code": "public class test { private int getRelativePositionByQName ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . getParent ( ) ; String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( ( child instanceof Element ) & & ( ( Element ) child ) . getQualifiedName ( ) . equals ( name ) ) { count + + ; } if ( child = = node ) {", "fixed_code": "public class test { private boolean matchesQName ( Element element ) { if ( getNamespaceURI ( ) ! = null ) { String ns = getNamespaceURI ( element ) ; if ( ns = = null | | ! ns . equals ( getNamespaceURI ( ) ) ) { return false ; } } return element . getName ( ) . equals ( ( ( Element ) node ) . getName ( ) ) ; } private int getRelativePositionByQName ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . getParent ( ) ; String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( child instanceof Element & & matchesQName ( ( ( Element ) child ) ) ) { count + + ; } if ( child = = node ) {", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new SetterlessProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new SetterlessProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "label": 1}
{"buggy_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 4 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "fixed_code": "if ( ( contains ( value , 0 , 4 , \" VAN \" , \" VON \" ) | | contains ( value , 0 , 3 , \" SCH \" ) ) | | contains ( value , index + 1 , 2 , \" ET \" ) ) { / / - - obvious germanic - - / / result . append ( ' K ' ) ; } else if ( contains ( value , index + 1 , 3 , \" IER \" ) ) { result . append ( ' J ' ) ; } else { result . append ( ' J ' , ' K ' ) ;", "label": 1}
{"buggy_code": "public class test { public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTree ( p ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected final JsonNode _bindAsTreeOrNull ( JsonParser p ) throws IOException { _config . initialize ( p ) ; if ( _schema ! = null ) { p . setSchema ( _schema ) ; } JsonToken t = p . getCurrentToken ( ) ; if ( t = = null ) { t = p . nextToken ( ) ; if ( t = = null ) { return null ; } } final JsonNode resultNode ; if ( t = = JsonToken . VALUE_NULL ) { resultNode = _config . getNodeFactory ( ) . nullNode ( ) ; } else { final DeserializationContext ctxt = createDeserializationContext ( p ) ; final JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { resultNode = ( JsonNode ) _unwrapAndDeserialize ( p , ctxt , JSON_NODE_TYPE , deser ) ; } else { resultNode = ( JsonNode ) deser . deserialize ( p , ctxt ) ; if ( _config . isEnabled ( DeserializationFeature . FAIL_ON_TRAILING_TOKENS ) ) { _verifyNoTrailingTokens ( p , ctxt , JSON_NODE_TYPE ) ; } } } return resultNode ; } public < T extends TreeNode > T readTree ( JsonParser p ) throws IOException { return ( T ) _bindAsTreeOrNull ( p ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1}
{"buggy_code": "if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } } return null ; }", "fixed_code": "if ( rawType = = ByteBuffer . class ) { return new ByteBufferDeserializer ( ) ; } if ( rawType = = Void . class ) { return NullifyingDeserializer . instance ; } } return null ; }", "label": 1}
{"buggy_code": "public class test { protected boolean processStartTag ( String name ) { return process ( start . reset ( ) . name ( name ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected boolean processStartTag ( String name ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . name ( name ) ) ; } return process ( start . reset ( ) . name ( name ) ) ; } public boolean processStartTag ( String name , Attributes attrs ) { if ( currentToken = = start ) { / / don ' t recycle an in - use token return process ( new Token . StartTag ( ) . nameAttr ( name , attrs ) ) ; } start . reset ( ) ; start . nameAttr ( name , attrs ) ; return process ( start ) ; } protected boolean processEndTag ( String name ) { if ( currentToken = = end ) { / / don ' t recycle an in - use token return process ( new Token . EndTag ( ) . name ( name ) ) ; } return process ( end . reset ( ) . name ( name ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "fixed_code": "if ( pendingAttributeName ! = null ) { / / the tokeniser has skipped whitespace control chars , but trimming could collapse to empty for other control codes , so verify here pendingAttributeName = pendingAttributeName . trim ( ) ; if ( pendingAttributeName . length ( ) > 0 ) { Attribute attribute ; if ( hasPendingAttributeValue ) attribute = new Attribute ( pendingAttributeName , else attribute = new BooleanAttribute ( pendingAttributeName ) ; attributes . put ( attribute ) ; } } pendingAttributeName = null ; hasEmptyAttributeValue = false ;", "label": 1}
{"buggy_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? type = tf . constructGeneralizedType ( type , serClass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "fixed_code": "/ / static typing this way type = type . withStaticTyping ( ) ; } else { Class < ? > currRaw = type . getRawClass ( ) ; try { / / 11 - Oct - 2015 , tatu : For deser , we call ` TypeFactory . constructSpecializedType ( ) ` , / / may be needed here too in future ? if ( serClass . isAssignableFrom ( currRaw ) ) { / / common case type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , type , serClass . getName ( ) ) ) ; } } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( null , String . format ( \" Failed to widen type % s with annotation ( value % s ) , from ' % s ' : % s \" ,", "label": 1}
{"buggy_code": "public CpioArchiveInputStream ( final InputStream in , int blockSize , String encoding ) { this . in = in ; this . blockSize = blockSize ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } } \\ No newline at end of file", "fixed_code": "public CpioArchiveInputStream ( final InputStream in , int blockSize , String encoding ) { this . in = in ; this . blockSize = blockSize ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1}
{"buggy_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { x = x < < 6 ; switch ( modulus ) {", "fixed_code": "/ / EOF ( - 1 ) and first time ' = ' character is encountered in stream . / / This approach makes the ' = ' padding characters completely optional . if ( eof & & modulus ! = 0 ) { if ( buffer = = null | | buffer . length - pos < decodeSize ) { resizeBuffer ( ) ; } x = x < < 6 ; switch ( modulus ) {", "label": 1}
{"buggy_code": "public class test { protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer & & r instanceof Pointer ) { if ( l . equals ( r ) ) { return true ; } } if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } if ( l = = r ) { return true ; } if ( l instanceof Boolean | | r instanceof Boolean ) { return ( InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ) ; } / / if either side is NaN , no comparison returns true : if ( l instanceof Number | | r instanceof Number ) { return ( InfoSetUtil . doubleValue ( l ) = = InfoSetUtil . doubleValue ( r ) ) ; } if ( l instanceof String | | r instanceof String ) { return ( InfoSetUtil . stringValue ( l ) . equals ( InfoSetUtil . stringValue ( r ) ) ) ; } return l ! = null & & l . equals ( r ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { this ( arg1 , arg2 , false ) ; } protected CoreOperationCompare ( Expression arg1 , Expression arg2 , boolean invert ) { super ( new Expression [ ] { arg1 , arg2 } ) ; this . invert = invert ; } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } boolean result ; if ( l instanceof Boolean | | r instanceof Boolean ) { result = l = = r | | InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ; } else if ( l instanceof Number | | r instanceof Number ) { / / if either side is NaN , no comparison returns true : double ld = InfoSetUtil . doubleValue ( l ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( r ) ; if ( Double . isNaN ( rd ) ) { return false ; } result = ld = = rd ; } else { if ( l instanceof String | | r instanceof String ) { l = InfoSetUtil . stringValue ( l ) ; r = InfoSetUtil . stringValue ( r ) ; } result = l = = r | | l ! = null & & l . equals ( r ) ; } return result ^ invert ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; map . put ( entry . getKey ( ) , values [ col ] ) ; } return map ; }", "fixed_code": "< M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) { map . put ( entry . getKey ( ) , values [ col ] ) ; } } return map ; }", "label": 1}
{"buggy_code": "public class test { public static boolean containsIgnoreCase ( String str , String searchStr ) { if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean containsIgnoreCase ( String name , String desc ) { if ( name . equals ( \" targetClass \" ) ) { if ( desc . equals ( \" ( ) Ljava / lang / Class ; \" ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( \" : root \" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else / / unhandled throw new Selector . SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ;", "fixed_code": "evals . add ( new Evaluator . IsEmpty ( ) ) ; else if ( tq . matchChomp ( \" : root \" ) ) evals . add ( new Evaluator . IsRoot ( ) ) ; else if ( tq . matchChomp ( \" : matchText \" ) ) evals . add ( new Evaluator . MatchText ( ) ) ; else / / unhandled throw new Selector . SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ;", "label": 1}
{"buggy_code": "public class test { public int compareTo ( Object other ) { return iValue - ( ( ValuedEnum ) other ) . iValue ; } } \\ No newline at end of file", "fixed_code": "public class test { private int getValueInOtherClassLoader ( Object other ) { try { Method mth = other . getClass ( ) . getMethod ( \" getValue \" , null ) ; Integer value = ( Integer ) mth . invoke ( other , null ) ; return value . intValue ( ) ; } catch ( NoSuchMethodException e ) { } catch ( IllegalAccessException e ) { } catch ( InvocationTargetException e ) { } throw new IllegalStateException ( \" This should not happen \" ) ; } public int compareTo ( Object other ) { if ( other = = this ) { return 0 ; } if ( other . getClass ( ) ! = this . getClass ( ) ) { if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { return iValue - getValueInOtherClassLoader ( other ) ; } throw new ClassCastException ( \" Different enum class ' \" + ClassUtils . getShortClassName ( other . getClass ( ) ) + \" ' \" ) ; } return iValue - ( ( ValuedEnum ) other ) . iValue ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1}
{"buggy_code": "* important for some reason ? * Disabling the check will break 2 Enum - related tests . type = _baseType . narrowBy ( type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "fixed_code": "* important for some reason ? * Disabling the check will break 2 Enum - related tests . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1}
{"buggy_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "fixed_code": "private JavaType _mapType ( Class < ? > rawClass ) { / / 28 - May - 2015 , tatu : Properties are special , as per [ databind # 810 ] if ( rawClass = = Properties . class ) { return MapType . construct ( rawClass , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } JavaType [ ] typeParams = findTypeParameters ( rawClass , Map . class ) ; / / ok to have no types ( \" raw \" ) if ( typeParams = = null ) {", "label": 1}
{"buggy_code": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ;  Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }  return getMock ( invocation , returnTypeGenericMetadata ) ; } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "_formatRFC1123 = null ; _formatISO8601 = null ; _formatISO8601_z = null ; _formatPlain = null ; } } } else { / / If not , plain date , no timezone StringBuilder sb = new StringBuilder ( dateStr ) ; int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; / / And possible also millisecond part if missing if ( timeLen < 12 ) { / / missing , or partial switch ( timeLen ) { case 11 : sb . append ( ' 0 ' ) ; case 10 : sb . append ( ' 0 ' ) ; default : sb . append ( \" . 000 \" ) ; } } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ; df = _formatISO8601_z ; formatStr = DATE_FORMAT_STR_ISO8601_Z ; if ( df = = null ) { / / 10 - Jun - 2017 , tatu : As per [ databind # 1651 ] , when using this format , / / must use UTC , not whatever is configured as default timezone / / ( because we know ` Z ` identifier is used ) df = _formatISO8601_z = _cloneFormat ( DATE_FORMAT_ISO8601_Z , formatStr , DEFAULT_TIMEZONE , _locale , _lenient ) ; } } }", "fixed_code": "_formatRFC1123 = null ; _formatISO8601 = null ; _formatISO8601_z = null ; _formatISO8601_noTz = null ; _formatPlain = null ; } } } else { / / If not , plain date , no timezone int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; / / And possible also millisecond part if missing if ( timeLen < 12 ) { / / missing , or partial StringBuilder sb = new StringBuilder ( dateStr ) ; switch ( timeLen ) { case 11 : sb . append ( ' 0 ' ) ; case 10 : sb . append ( ' 0 ' ) ; default : sb . append ( \" . 000 \" ) ; } dateStr = sb . toString ( ) ; } df = _formatISO8601_noTz ; formatStr = DATE_FORMAT_STR_ISO8601_NO_TZ ; if ( df = = null ) { / / 10 - Jun - 2017 , tatu : As per [ databind # 1651 ] , when using this format , / / must use UTC , not whatever is configured as default timezone / / ( because we know ` Z ` identifier is used ) df = _formatISO8601_noTz = _cloneFormat ( DATE_FORMAT_ISO8601_NO_TZ , formatStr , _timezone , _locale , _lenient ) ; } } }", "label": 1}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; } } \\ No newline at end of file", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information gen . writeObject ( _value ) ; } } } \\ No newline at end of file", "fixed_code": "} else { / / 25 - May - 2018 , tatu : [ databind # 1991 ] do not call via generator but through context ; / / this to preserve contextual information ctxt . defaultSerializeValue ( _value , gen ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1}
{"buggy_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "/ / there are times where there is a spurious byte - order - mark at the start of the text . Shouldn ' t be present / / in utf - 8 . If after decoding , there is a BOM , strip it ; otherwise will cause the parser to go straight / / into head mode if ( docData . charAt ( 0 ) = = 65279 ) docData = docData . substring ( 1 ) ; doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ;", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ;", "label": 1}
{"buggy_code": "public class test { public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } } \\ No newline at end of file", "fixed_code": "public class test { public PiePlotState initialise ( Graphics2D g2 , Rectangle2D plotArea , PiePlot plot , Integer index , PlotRenderingInfo info ) {  PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;  } public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { } return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1}
{"buggy_code": "} else { if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is - - foo = value or - foo = value / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "fixed_code": "} else { if ( opt . indexOf ( ' = ' ) ! = - 1 & & options . hasOption ( opt . substring ( 0 , opt . indexOf ( ' = ' ) ) ) ) { / / the format is - - foo = value or - foo = value tokens . add ( arg . substring ( 0 , arg . indexOf ( ' = ' ) ) ) ; / / - - foo tokens . add ( arg . substring ( arg . indexOf ( ' = ' ) + 1 ) ) ; / / value } else if ( options . hasOption ( arg . substring ( 0 , 2 ) ) ) { / / the format is a special properties option ( - Dproperty = value ) tokens . add ( arg . substring ( 0 , 2 ) ) ; / / - D tokens . add ( arg . substring ( 2 ) ) ; / / property = value", "label": 1}
{"buggy_code": "public class test { public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases throw new JsonGenerationException ( \" No native support for writing embedded objects \" , this ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void writeEmbeddedObject ( Object object ) throws IOException { / / 01 - Sep - 2016 , tatu : As per [ core # 318 ] , handle small number of cases if ( object = = null ) { writeNull ( ) ; return ; } if ( object instanceof byte [ ] ) { writeBinary ( ( byte [ ] ) object ) ; return ; } throw new JsonGenerationException ( \" No native support for writing embedded objects of type \" + object . getClass ( ) . getName ( ) , this ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ;", "fixed_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } } static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ;", "label": 1}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1}
{"buggy_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , c ) ; } else { m . appendReplacement ( accum , m . group ( 0 ) ) ; } } m . appendTail ( accum ) ;", "fixed_code": "if ( charval ! = - 1 | | charval > 0xFFFF ) { / / out of range String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; / / replace with original string } } m . appendTail ( accum ) ;", "label": 1}
{"buggy_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "fixed_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { throw new IllegalArgumentException ( \" Failed to parse \\ \" \" + pattern + \" \\ \" ; gave up at index \" + patternMatcher . regionStart ( ) ) ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "label": 1}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "label": 1}
{"buggy_code": "public class test { public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { copyCurrentStructure ( jp ) ; return this ; } } \\ No newline at end of file", "fixed_code": "public class test { public TokenBuffer deserialize ( JsonParser jp , DeserializationContext ctxt ) throws IOException { if ( jp . getCurrentTokenId ( ) ! = JsonToken . FIELD_NAME . id ( ) ) { copyCurrentStructure ( jp ) ; return this ; } JsonToken t ; writeStartObject ( ) ; do { copyCurrentStructure ( jp ) ; } while ( ( t = jp . nextToken ( ) ) = = JsonToken . FIELD_NAME ) ; if ( t ! = JsonToken . END_OBJECT ) { throw ctxt . mappingException ( \" Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer , got \" + t ) ; } writeEndObject ( ) ; return this ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1}
{"buggy_code": "if ( key = = null ) { / / is this even legal call ? return null ; } try { / / Ugh . . . should not have to give parser which may or may not be correct one . . . Object result = _delegate . deserialize ( ctxt . getParser ( ) , ctxt ) ; if ( result ! = null ) { return result ; }", "fixed_code": "if ( key = = null ) { / / is this even legal call ? return null ; } TokenBuffer tb = new TokenBuffer ( ctxt . getParser ( ) , ctxt ) ; tb . writeString ( key ) ; try { / / Ugh . . . should not have to give parser which may or may not be correct one . . . JsonParser p = tb . asParser ( ) ; p . nextToken ( ) ; Object result = _delegate . deserialize ( p , ctxt ) ; if ( result ! = null ) { return result ; }", "label": 1}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1}
{"buggy_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ;", "fixed_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( e ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ;", "label": 1}
{"buggy_code": "public class test { static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public JsonSerializer < Object > createSerializer ( SerializerProvider prov , JavaType origType ) throws JsonMappingException ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ; Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } } } return null ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } public void serializeWithType ( Object value , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer ) throws IOException * let ' s give it a chance ? Object delegateValue = convertValue ( value ) ; _delegateSerializer . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( delegateValue ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { Object delegateValue = convertValue ( value ) ; if ( delegateValue = = null ) { provider . defaultSerializeNull ( gen ) ; return ; } _delegateSerializer . serialize ( delegateValue , gen , provider ) ; } public void acceptJsonFormatVisitor ( JsonFormatVisitorWrapper visitor , JavaType typeHint ) throws JsonMappingException { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException delSer = provider . findValueSerializer ( delegateType ) ; } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } return ( delSer = = _delegateSerializer ) ? this : withDelegate ( _converter , delegateType , delSer ) ; } protected JsonSerializer < ? > findConvertingContentSerializer ( SerializerProvider provider , BeanProperty prop , JsonSerializer < ? > existingSerializer ) Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "fixed_code": "public class test { public final boolean isJavaLangObject ( ) { return _class = = Object . class ; } public JsonSerializer < Object > createSerializer ( SerializerProvider prov , JavaType origType ) throws JsonMappingException ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null & & ! delegateType . isJavaLangObject ( ) ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ; Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = delegateType . isJavaLangObject ( ) ? null : provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } } } return null ; } public void acceptJsonFormatVisitor ( JsonFormatVisitorWrapper visitor , JavaType typeHint ) throws JsonMappingException { if ( _delegateSerializer ! = null ) { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } } public void serializeWithType ( Object value , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer ) throws IOException * let ' s give it a chance ? Object delegateValue = convertValue ( value ) ; JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( value , provider ) ; } ser . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } protected JsonSerializer < Object > _findSerializer ( Object value , SerializerProvider serializers ) throws JsonMappingException { return serializers . findValueSerializer ( value . getClass ( ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException if ( ! delegateType . isJavaLangObject ( ) ) { delSer = provider . findValueSerializer ( delegateType ) ; } } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } if ( delSer = = _delegateSerializer & & delegateType = = _delegateType ) { return this ; } return withDelegate ( _converter , delegateType , delSer ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( delegateValue ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { Object delegateValue = convertValue ( value ) ; if ( delegateValue = = null ) { provider . defaultSerializeNull ( gen ) ; return ; } JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( delegateValue , provider ) ; } ser . serialize ( delegateValue , gen , provider ) ; } protected JsonSerializer < ? > findConvertingContentSerializer ( SerializerProvider provider , BeanProperty prop , JsonSerializer < ? > existingSerializer ) Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null & & ! delegateType . hasRawClass ( Object . class ) ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "label": 1}
{"buggy_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "fixed_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( existingSerializer = = null & & ! delegateType . hasRawClass ( Object . class ) ) { existingSerializer = provider . findValueSerializer ( delegateType ) ; } return new StdDelegatingSerializer ( conv , delegateType , existingSerializer ) ;", "label": 1}
{"buggy_code": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / Make sure this assignment is not in a loop . return true ; } / / only named functions may be hoisted . this . isHoisted = NodeUtil . isHoistedFunctionDeclaration ( root ) ; } } \\ No newline at end of file", "fixed_code": "} / / Make sure this assignment is not in a loop . for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ; } } return true ; } / / only named functions may be hoisted . this . isHoisted = NodeUtil . isHoistedFunctionDeclaration ( root ) ; this . isFunction = root . getType ( ) = = Token . FUNCTION ; if ( root . getParent ( ) ! = null ) { int pType = root . getParent ( ) . getType ( ) ; this . isLoop = pType = = Token . DO | | pType = = Token . WHILE | | pType = = Token . FOR ; } else { this . isLoop = false ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { if ( buffer [ i ] = = 0 ) { break ; } result . append ( ( char ) buffer [ i ] ) ; } return result . toString ( ) ;", "fixed_code": "int end = offset + length ; for ( int i = offset ; i < end ; + + i ) { byte b = buffer [ i ] ; if ( b = = 0 ) { / / Trailing null break ; } result . append ( ( char ) ( b & 0xFF ) ) ; / / Allow for sign - extension } return result . toString ( ) ;", "label": 1}
{"buggy_code": "public class test { Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; return assign ; } Node processUnaryExpression ( UnaryExpression exprNode ) { int type = transformTokenType ( exprNode . getType ( ) ) ; Node operand = transform ( exprNode . getOperand ( ) ) ; operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) {", "fixed_code": "public class test { Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; Node target = assign . getFirstChild ( ) ; if ( ! validAssignmentTarget ( target ) ) { errorReporter . error ( \" invalid assignment target \" , sourceName , target . getLineno ( ) , \" \" , 0 ) ; } return assign ; } private boolean validAssignmentTarget ( Node target ) { switch ( target . getType ( ) ) { case Token . NAME : case Token . GETPROP : case Token . GETELEM : return true ; } return false ; } Node processUnaryExpression ( UnaryExpression exprNode ) { int type = transformTokenType ( exprNode . getType ( ) ) ; Node operand = transform ( exprNode . getOperand ( ) ) ; operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { if ( type = = Token . INC | | type = = Token . DEC ) { if ( ! validAssignmentTarget ( operand ) ) { String msg = ( type = = Token . INC ) ? \" invalid increment target \" : \" invalid decrement target \" ; errorReporter . error ( msg , sourceName , operand . getLineno ( ) , \" \" , 0 ) ; } } Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) {", "label": 1}
{"buggy_code": "return phonemeBuilder ; } final Set < Rule . Phoneme > phonemes = new TreeSet < Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost phonemes . addAll ( subBuilder . getPhonemes ( ) ) ; } return new PhonemeBuilder ( phonemes ) ; } } \\ No newline at end of file", "fixed_code": "return phonemeBuilder ; } final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap < Rule . Phoneme , Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes ( ) ) { if ( phonemes . containsKey ( newPhoneme ) ) { final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages ( ) ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; } } } return new PhonemeBuilder ( phonemes . keySet ( ) ) ; } public Phoneme mergeWithLanguage ( final LanguageSet lang ) { return new Phoneme ( this . phonemeText . toString ( ) , this . languages . merge ( lang ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , } return type ; } public JavaType refineDeserializationType ( final MapperConfig < ? > config , final Annotated a , final JavaType baseType ) throws JsonMappingException { / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( keyClass ! = null ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( contentClass ! = null ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; } return type ; } } \\ No newline at end of file", "fixed_code": "type = tf . constructGeneralizedType ( type , serClass ) ; } else if ( currRaw . isAssignableFrom ( serClass ) ) { / / specialization , ok as well type = tf . constructSpecializedType ( type , serClass ) ; } else if ( _primitiveAndWrapper ( currRaw , serClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements type = type . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization type % s into % s ; types not related \" , keyType = tf . constructGeneralizedType ( keyType , keyClass ) ; } else if ( currRaw . isAssignableFrom ( keyClass ) ) { / / specialization , ok as well keyType = tf . constructSpecializedType ( keyType , keyClass ) ; } else if ( _primitiveAndWrapper ( currRaw , keyClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements keyType = keyType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization key type % s into % s ; types not related \" , contentType = tf . constructGeneralizedType ( contentType , contentClass ) ; } else if ( currRaw . isAssignableFrom ( contentClass ) ) { / / specialization , ok as well contentType = tf . constructSpecializedType ( contentType , contentClass ) ; } else if ( _primitiveAndWrapper ( currRaw , contentClass ) ) { / / 27 - Apr - 2017 , tatu : [ databind # 1592 ] ignore primitive < - > wrapper refinements contentType = contentType . withStaticTyping ( ) ; } else { throw new JsonMappingException ( null , String . format ( \" Can not refine serialization content type % s into % s ; types not related \" , } return type ; } private boolean _primitiveAndWrapper ( Class < ? > baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType = = ClassUtil . primitiveType ( refinement ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType ) ; } return false ; } public JavaType refineDeserializationType ( final MapperConfig < ? > config , final Annotated a , final JavaType baseType ) throws JsonMappingException { / / Ok : start by refining the main type itself ; common to all types final Class < ? > valueClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . as ( ) ) ; if ( ( valueClass ! = null ) & & ! type . hasRawClass ( valueClass ) & & ! _primitiveAndWrapper ( type , valueClass ) ) { try { type = tf . constructSpecializedType ( type , valueClass ) ; } catch ( IllegalArgumentException iae ) { if ( type . isMapLikeType ( ) ) { JavaType keyType = type . getKeyType ( ) ; final Class < ? > keyClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . keyAs ( ) ) ; if ( ( keyClass ! = null ) & & ! _primitiveAndWrapper ( keyType , keyClass ) ) { try { keyType = tf . constructSpecializedType ( keyType , keyClass ) ; type = ( ( MapLikeType ) type ) . withKeyType ( keyType ) ; if ( contentType ! = null ) { / / collection [ like ] , map [ like ] , array , reference / / And then value types for all containers : final Class < ? > contentClass = ( jsonDeser = = null ) ? null : _classIfExplicit ( jsonDeser . contentAs ( ) ) ; if ( ( contentClass ! = null ) & & ! _primitiveAndWrapper ( contentType , contentClass ) ) { try { contentType = tf . constructSpecializedType ( contentType , contentClass ) ; type = type . withContentType ( contentType ) ; } return type ; } private boolean _primitiveAndWrapper ( JavaType baseType , Class < ? > refinement ) { if ( baseType . isPrimitive ( ) ) { return baseType . hasRawClass ( ClassUtil . primitiveType ( refinement ) ) ; } if ( refinement . isPrimitive ( ) ) { return refinement = = ClassUtil . primitiveType ( baseType . getRawClass ( ) ) ; } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( \" \" ) ; Document dirty = Document . createShell ( \" \" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , \" \" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & errorList . size ( ) = = 0 ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & dirtyDocument . head ( ) . childNodes ( ) . size ( ) = = 0 ; / / because we only look at the body , but we start from a shell , make sure there ' s nothing in the head } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1}
{"buggy_code": "final ObjectIdGenerator . IdKey key = gen . key ( id ) ;", "fixed_code": "if ( id = = null ) { return null ; } final ObjectIdGenerator . IdKey key = gen . key ( id ) ;", "label": 1}
{"buggy_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _currToken = JsonToken . END_ARRAY ; _parsingContext = _parsingContext . getParent ( ) ; _namesToWrap = _parsingContext . getNamesToWrap ( ) ; return _currToken ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "fixed_code": "/ / Simple , except that if this is a leaf , need to suppress end : if ( _mayBeLeaf ) { _mayBeLeaf = false ; if ( _parsingContext . inArray ( ) ) { / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } return ( _currToken = JsonToken . VALUE_NULL ) ; } _currToken = _parsingContext . inArray ( ) ? JsonToken . END_ARRAY : JsonToken . END_OBJECT ; / / 06 - Jan - 2015 , tatu : as per [ dataformat - xml # 180 ] , need to / / expose as empty Object , not null ( or , worse , as used to / / be done , by swallowing the token ) _nextToken = JsonToken . END_OBJECT ; _parsingContext = _parsingContext . createChildObjectContext ( - 1 , - 1 ) ; return ( _currToken = JsonToken . START_OBJECT ) ; } } return ( _currToken = JsonToken . VALUE_STRING ) ;", "label": 1}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = ( ( residualsWeights [ i ] ) * residual ) * residual ; } return chiSquare ; }", "label": 1}
{"buggy_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "fixed_code": "while ( + + offset < length & & startChar ! = input [ offset ] ) ; int i = offset + 1 ; int last = i + seq . length ( ) - 1 ; if ( offset < length & & last < = length ) { for ( int j = 1 ; i < last & & seq . charAt ( j ) = = input [ i ] ; i + + , j + + ) ; if ( i = = last ) / / found full sequence return offset - pos ;", "label": 1}
{"buggy_code": "public class test { private static ZipLong unixTimeToZipLong ( long l ) { final long TWO_TO_32 = 0x100000000L ; if ( l > = TWO_TO_32 ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "fixed_code": "public class test { private static ZipLong unixTimeToZipLong ( long l ) { if ( l < Integer . MIN_VALUE | | l > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( \" X5455 timestamps must fit in a signed 32 bit integer : \" + l ) ; } return new ZipLong ( l ) ;", "label": 1}
{"buggy_code": "/ / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "fixed_code": "/ / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 1}
{"buggy_code": "else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return node instanceof Element ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1}
{"buggy_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ; while ( ( pos < = text . length ( ) ) & & ( ( c = text . charAt ( pos ) ) ! = ' ' ) & & ( c ! = ' \\ n ' ) & & ( c ! = ' \\ r ' ) ) { + + pos ; } return pos = = text . length ( ) ? - 1 : pos ; } } \\ No newline at end of file", "fixed_code": "/ / if we didn ' t find one , simply chop at startPos + width pos = startPos + width ;  return pos = = text . length ( ) ? - 1 : pos ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Let ' s verify it ' s lossless conversion by simple roundtrip int result = ( int ) _numberLong ; if ( ( ( long ) result ) ! = _numberLong ) { _reportError ( \" Numeric value ( \" + getText ( ) + \" ) out of range of int \" ) ; } _numberInt = result ; } else if ( ( _numTypesValid & NR_BIGINT ) ! = 0 ) { } protected void _reportTooLongInt ( int expType , String rawNum ) throws IOException { final String numDesc = _longIntegerDesc ( rawNum ) ; _reportError ( \" Numeric value ( % s ) out of range of % s \" , numDesc , ( expType = = NR_LONG ) ? \" long \" : \" int \" ) ; } } \\ No newline at end of file", "fixed_code": "/ / Let ' s verify it ' s lossless conversion by simple roundtrip int result = ( int ) _numberLong ; if ( ( ( long ) result ) ! = _numberLong ) { reportOverflowInt ( getText ( ) , currentToken ( ) ) ; } _numberInt = result ; } else if ( ( _numTypesValid & NR_BIGINT ) ! = 0 ) { } protected void _reportTooLongInt ( int expType , String rawNum ) throws IOException { if ( expType = = NR_INT ) { reportOverflowInt ( rawNum ) ; } else { reportOverflowLong ( rawNum ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }  / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } verifyBracketing ( min , max , f ) ; / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1}
{"buggy_code": "public class test { TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; zone = timeZone ;  mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; } public void appendTo ( StringBuffer buffer , Calendar calendar ) { if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ; buffer . append ( getTimeZoneDisplay ( zone , false , mStyle , mLocale ) ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void appendTo ( StringBuffer buffer , Calendar calendar ) { TimeZone zone = calendar . getTimeZone ( ) ; if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ; buffer . append ( getTimeZoneDisplay ( zone , false , mStyle , mLocale ) ) ; } } TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ;  mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { static String unescape ( String string , boolean strict ) { if ( ! string . contains ( \" & \" ) ) return string ; Matcher m = strict ? strictUnescapePattern . matcher ( string ) : unescapePattern . matcher ( string ) ; StringBuffer accum = new StringBuffer ( string . length ( ) ) ; while ( m . find ( ) ) { int charval = - 1 ; String num = m . group ( 3 ) ; if ( num ! = null ) { try { int base = m . group ( 2 ) ! = null ? 16 : 10 ; charval = Integer . valueOf ( num , base ) ; } catch ( NumberFormatException e ) { } } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; } if ( charval ! = - 1 | | charval > 0xFFFF ) { String c = Character . toString ( ( char ) charval ) ; m . appendReplacement ( accum , Matcher . quoteReplacement ( c ) ) ; } else { m . appendReplacement ( accum , Matcher . quoteReplacement ( m . group ( 0 ) ) ) ; } } m . appendTail ( accum ) ; return accum . toString ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isBaseNamedEntity ( String name ) { return base . containsKey ( name ) ; } static String unescape ( String string , boolean strict ) { return Parser . unescapeEntities ( string , strict ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "case Token . NAME : String varName = left . getString ( ) ; Var var = syntacticScope . getVar ( varName ) ; boolean isVarDeclaration = left . hasChildren ( ) ; / / When looking at VAR initializers for declared VARs , we tend / / to use the declared type over the type it ' s being / / sure we back - infer the < string > element constraint on / / the left hand side , so we use the left hand side . boolean isVarTypeBetter = ! isVarDeclaration | | var = = null | | var . isTypeInferred ( ) ; / / Makes it easier to check for NPEs . / / TODO ( nicksantos ) : This might be a better check once we have / / back - inference of object / array constraints . It will probably if ( isVarTypeBetter ) { redeclareSimpleVar ( scope , left , resultType ) ; } left . setJSType ( isVarDeclaration | | leftType = = null ? resultType : null ) ; if ( var ! = null & & var . isTypeInferred ( ) ) { JSType oldType = var . getType ( ) ;", "fixed_code": "case Token . NAME : String varName = left . getString ( ) ; Var var = syntacticScope . getVar ( varName ) ; JSType varType = var = = null ? null : var . getType ( ) ; boolean isVarDeclaration = left . hasChildren ( ) & & varType ! = null & & ! var . isTypeInferred ( ) ; / / When looking at VAR initializers for declared VARs , we tend / / to use the declared type over the type it ' s being / / sure we back - infer the < string > element constraint on / / the left hand side , so we use the left hand side . boolean isVarTypeBetter = isVarDeclaration & & / / Makes it easier to check for NPEs . ! resultType . isNullType ( ) & & ! resultType . isVoidType ( ) ; / / TODO ( nicksantos ) : This might be a better check once we have / / back - inference of object / array constraints . It will probably if ( isVarTypeBetter ) { redeclareSimpleVar ( scope , left , varType ) ; } else { redeclareSimpleVar ( scope , left , resultType ) ; } left . setJSType ( resultType ) ; if ( var ! = null & & var . isTypeInferred ( ) ) { JSType oldType = var . getType ( ) ;", "label": 1}
{"buggy_code": "Element insert ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; / / todo : wonder if for xml parsing , should treat all tags as unknown ? because it ' s not html . Element el = new Element ( tag , baseUri , settings . normalizeAttributes ( startTag . attributes ) ) ; insertNode ( el ) ;", "fixed_code": "Element insert ( Token . StartTag startTag ) { Tag tag = Tag . valueOf ( startTag . name ( ) , settings ) ; / / todo : wonder if for xml parsing , should treat all tags as unknown ? because it ' s not html . startTag . attributes . deduplicate ( settings ) ; Element el = new Element ( tag , baseUri , settings . normalizeAttributes ( startTag . attributes ) ) ; insertNode ( el ) ;", "label": 1}
{"buggy_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "fixed_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "label": 1}
{"buggy_code": "public class test { public UnivariateRealPointValuePair optimize ( final FUNC f , final GoalType goal , final double min , final double max , final double startValue ) / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { / / Return the point with the best objective function value . return optima [ 0 ] ; } public UnivariateRealPointValuePair optimize ( final FUNC f , final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public UnivariateRealPointValuePair optimize ( final FUNC f , final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } public UnivariateRealPointValuePair optimize ( final FUNC f , final GoalType goal , final double min , final double max , final double startValue ) / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) { / / Return the point with the best objective function value . return optima [ 0 ] ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1}
{"buggy_code": "* For values small enough to do exact integer computation , * return the log of the exact value", "fixed_code": "* For values small enough to do exact integer computation , * return the log of the exact value if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "label": 1}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } public Complex divide ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } ( imaginary - real * q ) / denominator ) ; } } public Complex conjugate ( ) { if ( isNaN ) { return NaN ; } return createComplex ( real , - imaginary ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Complex conjugate ( ) { if ( isNaN ) { return NaN ; } return createComplex ( real , ( - ( imaginary ) ) ) ; } public Complex divide ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } ( imaginary - real * q ) / denominator ) ; } } public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( ( real ) + ( rhs . getReal ( ) ) , ( imaginary ) + ( rhs . getImaginary ( ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Evaluator e ;  if ( evals . size ( ) = = 1 ) e = evals . get ( 0 ) ; else e = new CombiningEvaluator . And ( evals ) ; evals . clear ( ) ; Evaluator f = parse ( subQuery ) ;  if ( combinator = = ' > ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediateParent ( e ) ) ) ; else if ( combinator = = ' ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . Parent ( e ) ) ) ; else if ( combinator = = ' + ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; } Evaluator parse ( ) { tq . consumeWhitespace ( ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( \" , \" ) ) { CombiningEvaluator . Or or = new CombiningEvaluator . Or ( evals ) ; evals . clear ( ) ; evals . add ( or ) ; while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; or . add ( parse ( subQuery ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; return new CombiningEvaluator . And ( evals ) ; } } \\ No newline at end of file", "fixed_code": "public class test { Evaluator parse ( ) { tq . consumeWhitespace ( ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; return new CombiningEvaluator . And ( evals ) ; } private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Evaluator e ;  if ( evals . size ( ) = = 1 ) e = evals . get ( 0 ) ; else e = new CombiningEvaluator . And ( evals ) ; evals . clear ( ) ; Evaluator f = parse ( subQuery ) ;  if ( combinator = = ' > ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediateParent ( e ) ) ) ; else if ( combinator = = ' ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . Parent ( e ) ) ) ; else if ( combinator = = ' + ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else if ( combinator = = ' , ' ) { / / group or CombiningEvaluator . Or or ; if ( e instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) e ; or . add ( f ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( e ) ; or . add ( f ) ; } evals . add ( or ) ; } else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . spy ( instance ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "fixed_code": "/ / instance has been spied earlier Mockito . reset ( instance ) ; } else { field . set ( testClass , Mockito . mock ( instance . getClass ( ) , withSettings ( ) . spiedInstance ( instance ) . defaultAnswer ( Mockito . CALLS_REAL_METHODS ) . name ( field . getName ( ) ) ) ) ; } } catch ( IllegalAccessException e ) { throw new MockitoException ( \" Problems initiating spied field \" + field . getName ( ) , e ) ;", "label": 1}
{"buggy_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { if ( token . indexOf ( ' = ' ) ! = - 1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }", "fixed_code": "/ / handle long option - - foo or - - foo = bar if ( token . startsWith ( \" - - \" ) ) { int pos = token . indexOf ( ' = ' ) ; String opt = pos = = - 1 ? token : token . substring ( 0 , pos ) ; / / - - foo  if ( ! options . hasOption ( opt ) & & stopAtNonOption ) { process ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) { tokens . add ( token . substring ( pos + 1 ) ) ; } } }", "label": 1}
{"buggy_code": "public class test { public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , true ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static String encodeBase64String ( byte [ ] binaryData ) { return StringUtils . newStringUtf8 ( encodeBase64 ( binaryData , false ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 1}
{"buggy_code": "if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; doc = parser . parseInput ( reader , baseUri ) ; / / io exception when parsing ( not seen before because reading the stream as we go ) doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "fixed_code": "if ( charsetName = = null ) charsetName = defaultCharset ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( input , charsetName ) , bufferSize ) ; try { doc = parser . parseInput ( reader , baseUri ) ; } catch ( UncheckedIOException e ) { / / io exception when parsing ( not seen before because reading the stream as we go ) throw e . ioException ( ) ; } doc . outputSettings ( ) . charset ( charsetName ) ; } input . close ( ) ;", "label": 1}
{"buggy_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , getLocale ( ) ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1}
{"buggy_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_INTEGER ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "fixed_code": "} else { Class < ? > h = handledType ( ) ; if ( h = = BigDecimal . class ) { visitFloatFormat ( visitor , typeHint , JsonParser . NumberType . BIG_DECIMAL ) ; } else { / / otherwise bit unclear what to call . . . but let ' s try :", "label": 1}
{"buggy_code": "public static < T > T spy ( T object ) { return MOCKITO_CORE . mock ( ( Class < T > ) object . getClass ( ) , withSettings ( ) . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) ) ; } public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; } } \\ No newline at end of file", "fixed_code": "public static < T > T spy ( T object ) { return MOCKITO_CORE . mock ( ( Class < T > ) object . getClass ( ) , withSettings ( ) . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) , true ) ; } public static < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property / / if not scalar and ended successfully , then return null / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "fixed_code": "/ / Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken / / check for no buffered context _exposedContext - null / / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & _currToken ! = null & & _exposedContext = = null ) { / / if not scalar and ended successfully , then return null if ( ( _currToken . isStructEnd ( ) & & _headContext . isStartHandled ( ) ) ) { return ( _currToken = null ) ; } / / else if scalar , and scalar not present in obj / array and ! includePath and INCLUDE_ALL matched once / / then return null else if ( _currToken . isScalarValue ( ) & & ! _headContext . isStartHandled ( ) & & ! _includePath & & _itemFilter = = TokenFilter . INCLUDE_ALL ) { return ( _currToken = null ) ; } } / / Anything buffered ? TokenFilterContext ctxt = _exposedContext ;", "label": 1}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1}
{"buggy_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; double rd = InfoSetUtil . doubleValue ( right ) ; return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } } \\ No newline at end of file", "fixed_code": "return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( right ) ; if ( Double . isNaN ( rd ) ) { return false ; } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , null ) ; } } \\ No newline at end of file", "fixed_code": "/ / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , TypeBindings . emptyBindings ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1}
{"buggy_code": "public class test { public Base64 ( ) { this ( false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Base64 ( ) { this ( 0 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public abstract JavaType withContentValueHandler ( Object h ) ;  ", "fixed_code": "public class test {", "label": 1}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; } } \\ No newline at end of file", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < ' 0 ' | | c > ' 9 ' & & c < ' A ' | | c > ' Z ' & & c < ' a ' | | c > ' z ' ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "fixed_code": "char c = value . charAt ( pos ) ; / / RFC4180 ( https : / / tools . ietf . org / html / rfc4180 ) TEXTDATA = % x20 - 21 / % x23 - 2B / % x2D - 7E if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now", "label": 1}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ;", "label": 1}
{"buggy_code": "return false ; } ZipArchiveEntry other = ( ZipArchiveEntry ) obj ; if ( name = = null ) { if ( other . name ! = null ) { return false ; } } else if ( ! name . equals ( other . name ) ) { return false ; } return true ; } public ZipArchiveEntry ( String name ) { super ( name ) ; } } \\ No newline at end of file", "fixed_code": "return false ; } ZipArchiveEntry other = ( ZipArchiveEntry ) obj ; String myName = getName ( ) ; String otherName = other . getName ( ) ; if ( myName = = null ) { if ( otherName ! = null ) { return false ; } } else if ( ! myName . equals ( otherName ) ) { return false ; } return true ; } public ZipArchiveEntry ( String name ) { super ( name ) ; setName ( name ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getLength ( ) { return ValueUtils . getLength ( getBaseValue ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getLength ( ) { Object baseValue = getBaseValue ( ) ; return baseValue = = null ? 1 : ValueUtils . getLength ( baseValue ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "_nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , getTokenCharacterOffset ( ) , - 1L , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "fixed_code": "_nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , _tokenInputTotal , - 1L , _tokenInputRow , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; / / Update formula cannot make any progress : Update the / / search interval . default : / / Should never happen . } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ; / / Update formula cannot make any progress : Update the / / search interval . x0 = 0 . 5 * ( x0 + x1 - delta ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . throw new MathInternalError ( ) ; } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "label": 1}
{"buggy_code": "public class test { public static UnsafeAllocator create ( ) { / / try JVM / / public class Unsafe { @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { return ( T ) allocateInstance . invoke ( unsafe , c ) ; } } ; @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { return ( T ) newInstance . invoke ( null , c , constructorId ) ; } } ; @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { return ( T ) newInstance . invoke ( null , c , Object . class ) ; } } ;", "fixed_code": "public class test { private static void assertInstantiable ( Class < ? > c ) { int modifiers = c . getModifiers ( ) ; if ( Modifier . isInterface ( modifiers ) ) { throw new UnsupportedOperationException ( \" Interface can ' t be instantiated ! Interface name : \" + c . getName ( ) ) ; } if ( Modifier . isAbstract ( modifiers ) ) { throw new UnsupportedOperationException ( \" Abstract class can ' t be instantiated ! Class name : \" + c . getName ( ) ) ; } } public static UnsafeAllocator create ( ) { / / try JVM / / public class Unsafe { @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) allocateInstance . invoke ( unsafe , c ) ; } } ; @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance . invoke ( null , c , constructorId ) ; } } ; @ Override @ SuppressWarnings ( \" unchecked \" ) public < T > T newInstance ( Class < T > c ) throws Exception { assertInstantiable ( c ) ; return ( T ) newInstance . invoke ( null , c , Object . class ) ; } } ;", "label": 1}
{"buggy_code": "String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } if ( testNS ! = null ) { ns = Namespace . XML_NAMESPACE ; } else { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } else {", "fixed_code": "String testNS = null ; if ( testPrefix ! = null ) { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; testNS = nsr = = null ? null : nsr . getNamespaceURI ( testPrefix ) ; testNS = testNS = = null ? parent . getNamespaceURI ( testPrefix ) : testNS ; } if ( testNS ! = null ) { ns = Namespace . XML_NAMESPACE ; } else { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; if ( nsr ! = null ) { String uri = nsr . getNamespaceURI ( prefix ) ; if ( uri ! = null ) { ns = Namespace . getNamespace ( prefix , uri ) ; } } if ( ns = = null ) { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } } else {", "label": 1}
{"buggy_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( ) : StdDateFormat . DATE_FORMAT_STR_ISO8601 ; final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( pattern , loc ) ; if ( tz = = null ) { tz = serializers . getTimeZone ( ) ; } df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types / / serializers . reportBadDefinition ( handledType ( ) , String . format ( / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : return this ; } } \\ No newline at end of file", "fixed_code": "/ / 08 - Jun - 2017 , tatu : With [ databind # 1648 ] , this gets bit tricky . . / / First : custom pattern will override things if ( format . hasPattern ( ) ) { final Locale loc = format . hasLocale ( ) ? format . getLocale ( ) : serializers . getLocale ( ) ; SimpleDateFormat df = new SimpleDateFormat ( format . getPattern ( ) , loc ) ; TimeZone tz = format . hasTimeZone ( ) ? format . getTimeZone ( ) : serializers . getTimeZone ( ) ; df . setTimeZone ( tz ) ; return withFormat ( Boolean . FALSE , df ) ; } / / Otherwise , need one of these changes : final boolean hasLocale = format . hasLocale ( ) ; final boolean hasTZ = format . hasTimeZone ( ) ; final boolean asString = ( shape = = JsonFormat . Shape . STRING ) ; if ( ! hasLocale & & ! hasTZ & & ! asString ) { return this ; } DateFormat df0 = serializers . getConfig ( ) . getDateFormat ( ) ; / / Jackson ' s own ` StdDateFormat ` is quite easy to deal with . . . if ( df0 instanceof StdDateFormat ) { StdDateFormat std = ( StdDateFormat ) df0 ; if ( format . hasLocale ( ) ) { std = std . withLocale ( format . getLocale ( ) ) ; } if ( format . hasTimeZone ( ) ) { std = std . withTimeZone ( format . getTimeZone ( ) ) ; } return withFormat ( Boolean . FALSE , std ) ; } / / 08 - Jun - 2017 , tatu : Unfortunately there ' s no generally usable / / mechanism for changing ` DateFormat ` instances ( or even clone ( ) ing ) / / So : require it be ` SimpleDateFormat ` ; can ' t config other types if ( ! ( df0 instanceof SimpleDateFormat ) ) { / / serializers . reportBadDefinition ( handledType ( ) , String . format ( serializers . reportMappingProblem ( \" Configured ` DateFormat ` ( % s ) not a ` SimpleDateFormat ` ; can not configure ` Locale ` or ` TimeZone ` \" , df0 . getClass ( ) . getName ( ) ) ; } SimpleDateFormat df = ( SimpleDateFormat ) df0 ; if ( hasLocale ) { / / Ugh . No way to change ` Locale ` , create copy ; must re - crete completely : df = new SimpleDateFormat ( df . toPattern ( ) , format . getLocale ( ) ) ; } else { df = ( SimpleDateFormat ) df . clone ( ) ; } TimeZone newTz = format . getTimeZone ( ) ; boolean changeTZ = ( newTz ! = null ) & & ! newTz . equals ( df . getTimeZone ( ) ) ; if ( changeTZ ) { df . setTimeZone ( newTz ) ; } return withFormat ( Boolean . FALSE , df ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "fixed_code": "docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ;", "label": 1}
{"buggy_code": "public class test { public int read ( final byte [ ] buffer , final int offset , final int length ) throws IOException { if ( closed ) { throw new IOException ( \" The stream is closed \" ) ; throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { return read ; } public boolean canReadEntryData ( final ArchiveEntry ae ) { if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) ; } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean canReadEntryData ( final ArchiveEntry ae ) { if ( ae instanceof ZipArchiveEntry ) { final ZipArchiveEntry ze = ( ZipArchiveEntry ) ae ; return ZipUtil . canHandleEntryData ( ze ) & & supportsDataDescriptorFor ( ze ) & & supportsCompressedSizeFor ( ze ) ; } return false ; } private boolean supportsCompressedSizeFor ( final ZipArchiveEntry entry ) { return entry . getCompressedSize ( ) ! = ArchiveEntry . SIZE_UNKNOWN | | entry . getMethod ( ) = = ZipEntry . DEFLATED | | entry . getMethod ( ) = = ZipMethod . ENHANCED_DEFLATED . getCode ( ) | | ( entry . getGeneralPurposeBit ( ) . usesDataDescriptor ( ) & & allowStoredEntriesWithDataDescriptor & & entry . getMethod ( ) = = ZipEntry . STORED ) ; } public int read ( final byte [ ] buffer , final int offset , final int length ) throws IOException { if ( closed ) { throw new IOException ( \" The stream is closed \" ) ; throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . DATA_DESCRIPTOR , current . entry ) ; } if ( ! supportsCompressedSizeFor ( current . entry ) ) { throw new UnsupportedZipFeatureException ( UnsupportedZipFeatureException . Feature . UNKNOWN_COMPRESSED_SIZE , current . entry ) ; } int read ; if ( current . entry . getMethod ( ) = = ZipArchiveOutputStream . STORED ) { return read ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1}
{"buggy_code": "public class test { public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { return new CollatingIterator < E > ( comparator , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { return new CollatingIterator < E > ( comparator , iterator1 , iterator2 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > . . . iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Iterator < ? extends E > iterator1 , final Iterator < ? extends E > iterator2 ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterator1 , iterator2 ) ; } public static < E > Iterator < E > collatedIterator ( final Comparator < ? super E > comparator , final Collection < Iterator < ? extends E > > iterators ) { @ SuppressWarnings ( \" unchecked \" ) final Comparator < E > comp = comparator = = null ? ComparatorUtils . NATURAL_COMPARATOR : comparator ; return new CollatingIterator < E > ( comp , iterators ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 1}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1}
{"buggy_code": "/ / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ;", "fixed_code": "/ / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 ) setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ;", "label": 1}
{"buggy_code": "int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } } } \\ No newline at end of file", "fixed_code": "int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "label": 1}
{"buggy_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "fixed_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1}
{"buggy_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { return ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ; / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) } } return false ;", "fixed_code": "/ / First : value types may have both value and type handlers JavaType ct = t . getContentType ( ) ; if ( ct ! = null ) { if ( ( ct . getValueHandler ( ) ! = null ) | | ( ct . getTypeHandler ( ) ! = null ) ) { return true ; } } / / Second : map ( - like ) types may have value handler for key ( but not type ; keys are untyped ) if ( t . isMapLikeType ( ) ) { JavaType kt = t . getKeyType ( ) ; if ( kt . getValueHandler ( ) ! = null ) { return true ; } } } return false ;", "label": 1}
{"buggy_code": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Evaluator e ;  if ( evals . size ( ) = = 1 ) e = evals . get ( 0 ) ; else e = new CombiningEvaluator . And ( evals ) ; evals . clear ( ) ; Evaluator f = parse ( subQuery ) ;  if ( combinator = = ' > ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediateParent ( e ) ) ) ; else if ( combinator = = ' ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . Parent ( e ) ) ) ; else if ( combinator = = ' + ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; } Evaluator parse ( ) { tq . consumeWhitespace ( ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( \" , \" ) ) { CombiningEvaluator . Or or = new CombiningEvaluator . Or ( evals ) ; evals . clear ( ) ; evals . add ( or ) ; while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; or . add ( parse ( subQuery ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; return new CombiningEvaluator . And ( evals ) ; } } \\ No newline at end of file", "fixed_code": "public class test { Or ( ) { super ( ) ; } Evaluator parse ( ) { tq . consumeWhitespace ( ) ; / / hierarchy and extras boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; return new CombiningEvaluator . And ( evals ) ; } private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Evaluator e ;  if ( evals . size ( ) = = 1 ) e = evals . get ( 0 ) ; else e = new CombiningEvaluator . And ( evals ) ; evals . clear ( ) ; Evaluator f = parse ( subQuery ) ;  if ( combinator = = ' > ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediateParent ( e ) ) ) ; else if ( combinator = = ' ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . Parent ( e ) ) ) ; else if ( combinator = = ' + ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . ImmediatePreviousSibling ( e ) ) ) ; else if ( combinator = = ' ~ ' ) evals . add ( new CombiningEvaluator . And ( f , new StructuralEvaluator . PreviousSibling ( e ) ) ) ; else if ( combinator = = ' , ' ) { / / group or CombiningEvaluator . Or or ; if ( e instanceof CombiningEvaluator . Or ) { or = ( CombiningEvaluator . Or ) e ; or . add ( f ) ; } else { or = new CombiningEvaluator . Or ( ) ; or . add ( e ) ; or . add ( f ) ; } evals . add ( or ) ; } else throw new Selector . SelectorParseException ( \" Unknown combinator : \" + combinator ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return new ZCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) {", "fixed_code": "return new ZCompressorInputStream ( in ) ; } if ( DeflateCompressorInputStream . matches ( signature , signatureLength ) ) { return new DeflateCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) {", "label": 1}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 1}
{"buggy_code": "} this . entryFormat = format ; this . blockSize = blockSize ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } } \\ No newline at end of file", "fixed_code": "} this . entryFormat = format ; this . blockSize = blockSize ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "fixed_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "label": 1}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void close ( ) throws IOException { if ( ! closed ) { finish ( ) ; buffer . close ( ) ; out . close ( ) ; closed = true ;", "fixed_code": "public class test { public void close ( ) throws IOException { if ( ! closed ) { buffer . close ( ) ; out . close ( ) ; closed = true ;", "label": 1}
{"buggy_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( ( Iterator ) right , left ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } } \\ No newline at end of file", "fixed_code": "return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( left , ( Iterator ) right ) ; } double ld = InfoSetUtil . doubleValue ( left ) ; if ( Double . isNaN ( ld ) ) { } return evaluateCompare ( ld = = rd ? 0 : ld < rd ? - 1 : 1 ) ; } private boolean containsMatch ( Object value , Iterator it ) { while ( it . hasNext ( ) ) { Object element = it . next ( ) ; if ( compute ( value , element ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void exitScope ( NodeTraversal t ) { if ( t . getScopeDepth ( ) > 2 ) { findNamespaceShadows ( t ) ; }  if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; hasNamespaceShadows = false ; } } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( isCallToScopeMethod ( n ) ) { validateScopeCall ( t , n , n . getParent ( ) ) ; }  if ( t . getScopeDepth ( ) < 2 ) { return ; }  int type = n . getType ( ) ; Var aliasVar = null ; if ( type = = Token . NAME ) { String name = n . getString ( ) ; Var lexicalVar = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( lexicalVar ! = null & & lexicalVar = = aliases . get ( name ) ) { aliasVar = lexicalVar ; } }  if ( t . getScopeDepth ( ) = = 2 ) { if ( aliasVar ! = null & & NodeUtil . isLValue ( n ) ) { if ( aliasVar . getNode ( ) = = n ) { aliasDefinitionsInOrder . add ( n ) ;  return ; } else { report ( t , n , GOOG_SCOPE_ALIAS_REDEFINED , n . getString ( ) ) ; } }  if ( type = = Token . RETURN ) { report ( t , n , GOOG_SCOPE_USES_RETURN ) ; } else if ( type = = Token . THIS ) { report ( t , n , GOOG_SCOPE_REFERENCES_THIS ) ; } else if ( type = = Token . THROW ) { report ( t , n , GOOG_SCOPE_USES_THROW ) ; } }  if ( t . getScopeDepth ( ) > = 2 ) { if ( aliasVar ! = null ) { aliasUsages . add ( new AliasedNode ( aliasVar , n ) ) ; }  JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; } }  } } private void findAliases ( NodeTraversal t ) { Scope scope = t . getScope ( ) ; for ( Var v : scope . getVarIterable ( ) ) { } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" } } } } \\ No newline at end of file", "fixed_code": "public class test { private void findAliases ( NodeTraversal t ) { Scope scope = t . getScope ( ) ; for ( Var v : scope . getVarIterable ( ) ) { } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" } } } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( isCallToScopeMethod ( n ) ) { validateScopeCall ( t , n , n . getParent ( ) ) ; }  if ( t . getScopeDepth ( ) < 2 ) { return ; }  int type = n . getType ( ) ; Var aliasVar = null ; if ( type = = Token . NAME ) { String name = n . getString ( ) ; Var lexicalVar = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( lexicalVar ! = null & & lexicalVar = = aliases . get ( name ) ) { aliasVar = lexicalVar ; } }  if ( t . getScopeDepth ( ) = = 2 ) { if ( aliasVar ! = null & & NodeUtil . isLValue ( n ) ) { if ( aliasVar . getNode ( ) = = n ) { aliasDefinitionsInOrder . add ( n ) ;  return ; } else { report ( t , n , GOOG_SCOPE_ALIAS_REDEFINED , n . getString ( ) ) ; } }  if ( type = = Token . RETURN ) { report ( t , n , GOOG_SCOPE_USES_RETURN ) ; } else if ( type = = Token . THIS ) { report ( t , n , GOOG_SCOPE_REFERENCES_THIS ) ; } else if ( type = = Token . THROW ) { report ( t , n , GOOG_SCOPE_USES_THROW ) ; } }  if ( t . getScopeDepth ( ) > = 2 ) { if ( aliasVar ! = null ) { aliasUsages . add ( new AliasedNode ( aliasVar , n ) ) ; }  JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; } }  } } public void exitScope ( NodeTraversal t ) { if ( t . getScopeDepth ( ) > 2 ) { findNamespaceShadows ( t ) ; }  if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; hasNamespaceShadows = false ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( c ) ; break ; case ' < ' : if ( ! inAttribute )", "fixed_code": "if ( escapeMode ! = EscapeMode . xhtml ) accum . append ( \" & nbsp ; \" ) ; else accum . append ( \" & # xa0 ; \" ) ; break ; case ' < ' : if ( ! inAttribute )", "label": 1}
{"buggy_code": "public class test { public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public class test { public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1}
{"buggy_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { final char hwChar = str . charAt ( index - 1 ) ; if ( ' H ' = = hwChar | | ' W ' = = hwChar ) { final char preHWChar = str . charAt ( index - 2 ) ; final char firstCode = this . map ( preHWChar ) ; if ( firstCode = = mappedChar | | ' H ' = = preHWChar | | ' W ' = = preHWChar ) { return 0 ; } } } return mappedChar ;", "fixed_code": "final char mappedChar = this . map ( str . charAt ( index ) ) ; / / HW rule check if ( index > 1 & & mappedChar ! = ' 0 ' ) { for ( int i = index - 1 ; i > = 0 ; i - - ) { final char prevChar = str . charAt ( i ) ; if ( this . map ( prevChar ) = = mappedChar ) { return 0 ; } if ( ' H ' ! = prevChar & & ' W ' ! = prevChar ) { break ; } } } return mappedChar ;", "label": 1}
{"buggy_code": "Node child = n . getFirstChild ( ) ; while ( child ! = null ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "Node child = n . getFirstChild ( ) ; while ( child ! = null ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1}
{"buggy_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "fixed_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( ( c > 31 ) & & ( c < 127 ) ) & & ( c < = 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1}
{"buggy_code": "} else { char c = value . charAt ( pos ) ; if ( newRecord & & ( c < 0x20 | | c > 0x21 & & c < 0x23 | | c > 0x2B & & c < 0x2D | | c > 0x7E ) ) { quote = true ; } else if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "fixed_code": "} else { char c = value . charAt ( pos ) ; if ( c < = COMMENT ) { / / Some other chars at the start of a value caused the parser to fail , so for now / / encapsulate if we start in anything less than ' # ' . We are being conservative / / by including the default comment char too .", "label": 1}
{"buggy_code": "numToSkip - = skipped ; } return available - numToSkip ; } } \\ No newline at end of file", "fixed_code": "numToSkip - = skipped ; } if ( numToSkip > 0 ) { byte [ ] skipBuf = new byte [ SKIP_BUF_SIZE ] ; while ( numToSkip > 0 ) { int read = readFully ( input , skipBuf , 0 , ( int ) Math . min ( numToSkip , SKIP_BUF_SIZE ) ) ; if ( read < 1 ) { break ; } numToSkip - = read ; } } return available - numToSkip ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } if ( testNS ! = null ) {", "fixed_code": "String testNS = null ; if ( testPrefix ! = null ) { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; testNS = nsr = = null ? null : nsr . getNamespaceURI ( testPrefix ) ; testNS = testNS = = null ? parent . getNamespaceURI ( testPrefix ) : testNS ; } if ( testNS ! = null ) {", "label": 1}
{"buggy_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only for ( String longOpt : longOpts . keySet ( ) ) {", "fixed_code": "List < String > matchingOpts = new ArrayList < String > ( ) ; / / for a perfect match return the single option only if ( longOpts . keySet ( ) . contains ( opt ) ) { return Collections . singletonList ( opt ) ; } for ( String longOpt : longOpts . keySet ( ) ) {", "label": 1}
{"buggy_code": "public class test { Node processForInLoop ( ForInLoop loopNode ) { / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "fixed_code": "public class test { Node processForInLoop ( ForInLoop loopNode ) { if ( loopNode . isForEach ( ) ) { errorReporter . error ( \" unsupported language extension : for each \" , sourceName , loopNode . getLineno ( ) , \" \" , 0 ) ; / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; } return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "label": 1}
{"buggy_code": "public class test { private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node   for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; } private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; stack . addLast ( child ) ; return parent ; } } \\ No newline at end of file", "fixed_code": "public class test { private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor & & ! relaxed ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; stack . addLast ( child ) ; return parent ; } public static Document parseBodyFragmentRelaxed ( String bodyHtml , String baseUri ) { Parser parser = new Parser ( bodyHtml , baseUri , true ) ; parser . relaxed = true ; return parser . parse ( ) ; } private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node  if ( childTag . requiresSpecificParent ( ) ) return stack . getLast ( ) . tag ( ) . isValidParent ( childTag ) ;  for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidAncestor ( childTag ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , iae . getMessage ( ) , iae ) ; } if ( deser = = null ) { return null ;", "fixed_code": "} catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , ClassUtil . exceptionMessage ( iae ) , iae ) ; } if ( deser = = null ) { return null ;", "label": 1}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1}
{"buggy_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "fixed_code": "case JsonTokenId . ID_FIELD_NAME : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object case JsonTokenId . ID_END_OBJECT : if ( _mapDeserializer ! = null ) { return _mapDeserializer . deserialize ( p , ctxt ) ; } case JsonTokenId . ID_NULL : / / should not get this but . . . return null ; case JsonTokenId . ID_END_OBJECT : / / 28 - Oct - 2015 , tatu : [ databind # 989 ] We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object return new LinkedHashMap < String , Object > ( 2 ) ; / / case JsonTokenId . ID_END_ARRAY : / / invalid default :", "label": 1}
{"buggy_code": "description = null ; argName = null ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "fixed_code": "description = null ; argName = null ; longopt = null ; type = String . class ; required = false ; numberOfArgs = Option . UNINITIALIZED ; optionalArg = false ;", "label": 1}
{"buggy_code": "return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; } } \\ No newline at end of file", "fixed_code": "return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( obj , location ) ; return null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , e0 . getMessage ( ) , baseType ) ; e . initCause ( e0 ) ; throw e ; }", "fixed_code": "return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , ClassUtil . exceptionMessage ( e0 ) , baseType ) ; e . initCause ( e0 ) ; throw e ; }", "label": 1}
{"buggy_code": "@ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & n . getString ( ) . equals ( varName ) & & / / We make a special exception when the entire cfgNode is a chain / / of assignments , since in that case the assignment statements / / will happen after the inlining of the right hand side . / / TODO ( blickly ) : Make the SIDE_EFFECT_PREDICATE check more exact / / and remove this special case . ! ( parent . isAssign ( ) & & ( parent . getFirstChild ( ) = = n ) ) ) { / / Don ' t count lhs of top - level assignment chain numUsesWithinCfgNode + + ; } } } ; NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;", "fixed_code": "@ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & n . getString ( ) . equals ( varName ) ) { / / We make a special exception when the entire cfgNode is a chain / / of assignments , since in that case the assignment statements / / will happen after the inlining of the right hand side . / / TODO ( blickly ) : Make the SIDE_EFFECT_PREDICATE check more exact / / and remove this special case . if ( parent . isAssign ( ) & & ( parent . getFirstChild ( ) = = n ) & & isAssignChain ( parent , cfgNode ) ) { / / Don ' t count lhs of top - level assignment chain return ; } else { numUsesWithinCfgNode + + ; } } } private boolean isAssignChain ( Node child , Node ancestor ) { for ( Node n = child ; n ! = ancestor ; n = n . getParent ( ) ) { if ( ! n . isAssign ( ) ) { return false ; } } return true ; } } ; NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;", "label": 1}
{"buggy_code": "public class test { public Date read ( JsonReader in ) throws IOException { if ( in . peek ( ) ! = JsonToken . STRING ) { throw new JsonParseException ( \" The date should be a string value \" ) ; } Date date = deserializeToDate ( in . nextString ( ) ) ; if ( dateType = = Date . class ) {", "fixed_code": "public class test { public Date read ( JsonReader in ) throws IOException { if ( in . peek ( ) = = JsonToken . NULL ) { in . nextNull ( ) ; return null ; } Date date = deserializeToDate ( in . nextString ( ) ) ; if ( dateType = = Date . class ) {", "label": 1}
{"buggy_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : id = generator . generateId ( forPojo ) ; return id ; } } \\ No newline at end of file", "fixed_code": "/ / 04 - Jun - 2016 , tatu : As per [ databind # 1255 ] , need to consider possibility of / / id being generated for \" alwaysAsId \" , but not being written as POJO ; regardless , / / need to use existing id if there is one : if ( id = = null ) { id = generator . generateId ( forPojo ) ; } return id ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref ! = null ) { objectIdInfo = objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } return objectIdInfo ; } } \\ No newline at end of file", "fixed_code": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref = = null ) { return objectIdInfo ; } if ( objectIdInfo = = null ) { objectIdInfo = ObjectIdInfo . empty ( ) ; } return objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order for ( ZipArchiveEntry ze : entries . keySet ( ) ) { OffsetEntry offsetEntry = entries . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } } } } \\ No newline at end of file", "fixed_code": "/ / the hashcode - see COMPRESS - 164 / / Map needs to be reconstructed in order to keep central / / directory order Map < ZipArchiveEntry , OffsetEntry > origMap = new LinkedHashMap < ZipArchiveEntry , OffsetEntry > ( entries ) ; entries . clear ( ) ; for ( ZipArchiveEntry ze : origMap . keySet ( ) ) { OffsetEntry offsetEntry = origMap . get ( ze ) ; long offset = offsetEntry . headerOffset ; archive . seek ( offset + LFH_OFFSET_FOR_FILENAME_LENGTH ) ; byte [ ] b = new byte [ SHORT ] ; nameMap . put ( ze . getName ( ) , ze ) ; } } entries . put ( ze , offsetEntry ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; return node . intValue ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public long getLongValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowLong ( ) ; } return node . longValue ( ) ; } public int getIntValue ( ) throws IOException { final NumericNode node = ( NumericNode ) currentNumericNode ( ) ; if ( ! node . canConvertToInt ( ) ) { reportOverflowInt ( ) ; } return node . intValue ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1}
{"buggy_code": "public class test { public void serializeWithType ( Object bean , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer0 ) throws IOException { / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . ser . serializeWithType ( value , gen , provider , typeSer0 ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { throw JsonMappingException . wrapWithPath ( t , bean , _accessorMethod . getName ( ) + \" ( ) \" ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void writeCustomTypePrefixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForObject ( _forObject , gen , typeId ) ; } public void writeTypeSuffixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForArray ( _forObject , gen ) ; } public void serializeWithType ( Object bean , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer0 ) throws IOException { / / 28 - Sep - 2016 , tatu : As per [ databind # 1385 ] , we do need to do some juggling / / to use different Object for type id ( logical type ) and actual serialization / / ( delegat type ) . TypeSerializerRerouter rr = new TypeSerializerRerouter ( typeSer0 , bean ) ; ser . serializeWithType ( value , gen , provider , rr ) ; } catch ( IOException ioe ) { throw ioe ; } catch ( Exception e ) { throw JsonMappingException . wrapWithPath ( t , bean , _accessorMethod . getName ( ) + \" ( ) \" ) ; } } public void writeCustomTypePrefixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForArray ( _forObject , gen , typeId ) ; } public TypeSerializer forProperty ( BeanProperty prop ) { / / should never get called throw new UnsupportedOperationException ( ) ; } public As getTypeInclusion ( ) { return _typeSerializer . getTypeInclusion ( ) ; } public void writeCustomTypeSuffixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForScalar ( _forObject , gen , typeId ) ; } public void writeCustomTypeSuffixForArray ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForArray ( _forObject , gen , typeId ) ; } public String getPropertyName ( ) { return _typeSerializer . getPropertyName ( ) ; } public void writeCustomTypeSuffixForObject ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypeSuffixForObject ( _forObject , gen , typeId ) ; } public void writeCustomTypePrefixForScalar ( Object value , JsonGenerator gen , String typeId ) throws IOException { _typeSerializer . writeCustomTypePrefixForScalar ( _forObject , gen , typeId ) ; } public TypeIdResolver getTypeIdResolver ( ) { return _typeSerializer . getTypeIdResolver ( ) ; } public void writeTypePrefixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen ) ; } public TypeSerializerRerouter ( TypeSerializer ts , Object ob ) { _typeSerializer = ts ; _forObject = ob ; } public void writeTypePrefixForArray ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen , type ) ; } public void writeTypePrefixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen ) ; } public void writeTypePrefixForArray ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypePrefixForArray ( _forObject , gen ) ; } public void writeTypeSuffixForScalar ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForScalar ( _forObject , gen ) ; } public void writeTypePrefixForObject ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForObject ( _forObject , gen , type ) ; } public void writeTypeSuffixForObject ( Object value , JsonGenerator gen ) throws IOException { _typeSerializer . writeTypeSuffixForObject ( _forObject , gen ) ; } public void writeTypePrefixForScalar ( Object value , JsonGenerator gen , Class < ? > type ) throws IOException { _typeSerializer . writeTypePrefixForScalar ( _forObject , gen , type ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { return foundDigit & & ! hasExp ; } / / last character is illegal", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal", "label": 1}
{"buggy_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Element element = ( Element ) o ; return this = = o ; } } \\ No newline at end of file", "fixed_code": "Element element = ( Element ) o ; return tag . equals ( element . tag ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected JsonParserSequence ( JsonParser [ ] parsers ) { super ( parsers [ 0 ] ) ; _parsers = parsers ; _nextParser = 1 ; } public JsonToken nextToken ( ) throws IOException , JsonParseException { JsonToken t = delegate . nextToken ( ) ; if ( t ! = null ) return t ; while ( switchToNext ( ) ) { t = delegate . nextToken ( ) ; if ( t ! = null ) return t ; } return null ; } } \\ No newline at end of file", "fixed_code": "public class test { public JsonToken nextToken ( ) throws IOException { if ( delegate = = null ) { return null ; } if ( _suppressNextToken ) { _suppressNextToken = false ; return delegate . currentToken ( ) ; } JsonToken t = delegate . nextToken ( ) ; while ( ( t = = null ) & & switchToNext ( ) ) { t = delegate . hasCurrentToken ( ) ? delegate . currentToken ( ) : delegate . nextToken ( ) ; } return t ; } protected JsonParserSequence ( JsonParser [ ] parsers ) { super ( parsers [ 0 ] ) ; _suppressNextToken = delegate . hasCurrentToken ( ) ; _parsers = parsers ; _nextParser = 1 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; }", "fixed_code": "if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( c ) ; } continue ; }", "label": 1}
{"buggy_code": "public class test { public static < T > T eq ( T value ) { return reportMatcher ( new Equals ( value ) ) . < T > returnNull ( ) ; } public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull ( ) ; } public static < T > T same ( T value ) { return reportMatcher ( new Same ( value ) ) . < T > returnNull ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < T > T eq ( T value ) { return ( T ) reportMatcher ( new Equals ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; } public static < T > T isA ( Class < T > clazz ) { return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnFor ( clazz ) ; } public static < T > T same ( T value ) { return ( T ) reportMatcher ( new Same ( value ) ) . < T > returnFor ( ( Class ) value . getClass ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "fixed_code": "public class test { String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1}
{"buggy_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "fixed_code": "return ( _resultArray = _resultString . toCharArray ( ) ) ; } / / Nope ; but does it fit in just one segment ? if ( ! _hasSegments & & _currentSegment ! = null ) return _currentSegment ; / / Nope , need to have / create a non - segmented array and return it return contentsAsArray ( ) ; }", "label": 1}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1}
{"buggy_code": "} / / Clone any remaining params that aren ' t in the function literal . parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "fixed_code": "} / / Clone any remaining params that aren ' t in the function literal . while ( oldParams . hasNext ( ) ) { paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; } parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( ! isVarArgs ) { while ( oldParameterType ! = null & & ! isVarArgs ) { builder . newParameterFromNode ( oldParameterType ) ; oldParameterType = oldParameterType . getNext ( ) ; } } if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "label": 1}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { int index = - 1 ; } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 1}
{"buggy_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , e . getMessage ( ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , e . getMessage ( ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = cause . getMessage ( ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" , return new JsonMappingException ( null , String . format ( \" Unexpected IOException ( of type % s ) : % s \" , src . getClass ( ) . getName ( ) , src . getMessage ( ) ) ) ; } public static JsonMappingException wrapWithPath ( Throwable src , Reference ref ) { jme = ( JsonMappingException ) src ; } else { / / [ databind # 2128 ] : try to avoid duplication String msg = src . getMessage ( ) ; / / Let ' s use a more meaningful placeholder if all we have is null if ( msg = = null | | msg . length ( ) = = 0 ) { msg = \" ( was \" + src . getClass ( ) . getName ( ) + \" ) \" ; / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) { return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , e0 . getMessage ( ) , baseType ) ; e . initCause ( e0 ) ; throw e ; } / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ; } catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , iae . getMessage ( ) , iae ) ; } if ( deser = = null ) { return null ; StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , t . getMessage ( ) , t ) ; } protected void _throwAsIOE ( JsonParser p , Exception e , Object value ) throws IOException { . append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , th . getMessage ( ) , th ) ; } protected java . util . Date _parseDate ( String value , DeserializationContext ctxt ) throws IOException } catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , iae . getMessage ( ) ) ; } } protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , e . getMessage ( ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; } } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + t . getMessage ( ) , t ) ; } public Object instantiateBean ( boolean fixAccess ) { AnnotatedConstructor ac = _classInfo . getDefaultConstructor ( ) ; ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" + t . getMessage ( ) , t ) ; } } public boolean includeFilterSuppressNulls ( Object filter ) throws JsonMappingException } catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , t . getMessage ( ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = e . getMessage ( ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; } serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , e . getMessage ( ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , e . getMessage ( ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type } return bpw ; } } \\ No newline at end of file", "fixed_code": "throw invalidTypeIdException ( baseType , subClass , String . format ( \" problem : ( % s ) % s \" , e . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( e ) ) ) ; } if ( baseType . isTypeOrSuperTypeOf ( cls ) ) { return getTypeFactory ( ) . constructSpecializedType ( baseType , cls ) ; } catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , ClassUtil . exceptionMessage ( e ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = ClassUtil . exceptionMessage ( cause ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" , return new JsonMappingException ( null , String . format ( \" Unexpected IOException ( of type % s ) : % s \" , src . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( src ) ) ) ; } public static JsonMappingException wrapWithPath ( Throwable src , Reference ref ) { jme = ( JsonMappingException ) src ; } else { / / [ databind # 2128 ] : try to avoid duplication String msg = ClassUtil . exceptionMessage ( src ) ; / / Let ' s use a more meaningful placeholder if all we have is null if ( msg = = null | | msg . length ( ) = = 0 ) { msg = \" ( was \" + src . getClass ( ) . getName ( ) + \" ) \" ; / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) { return b . buildTypeDeserializer ( config , baseType , subtypes ) ; } catch ( IllegalArgumentException e0 ) { InvalidDefinitionException e = InvalidDefinitionException . from ( ( JsonParser ) null , ClassUtil . exceptionMessage ( e0 ) , baseType ) ; e . initCause ( e0 ) ; throw e ; } / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ; } catch ( IllegalArgumentException iae ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle throw JsonMappingException . from ( ctxt , ClassUtil . exceptionMessage ( iae ) , iae ) ; } if ( deser = = null ) { return null ; StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , ClassUtil . exceptionMessage ( t ) , t ) ; } protected void _throwAsIOE ( JsonParser p , Exception e , Object value ) throws IOException { . append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , ClassUtil . exceptionMessage ( th ) , th ) ; } protected java . util . Date _parseDate ( String value , DeserializationContext ctxt ) throws IOException } catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , ClassUtil . exceptionMessage ( iae ) ) ; } } protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , ClassUtil . exceptionMessage ( e ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( re ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; } } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + ClassUtil . exceptionMessage ( t ) , t ) ; } public Object instantiateBean ( boolean fixAccess ) { AnnotatedConstructor ac = _classInfo . getDefaultConstructor ( ) ; ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" _classInfo . getAnnotated ( ) . getName ( ) + \" : ( \" + t . getClass ( ) . getName ( ) + \" ) \" + ClassUtil . exceptionMessage ( t ) , t ) ; } } public boolean includeFilterSuppressNulls ( Object filter ) throws JsonMappingException } catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( t ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = ClassUtil . exceptionMessage ( e ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; } serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , ClassUtil . exceptionMessage ( e ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , ClassUtil . exceptionMessage ( e ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type } return bpw ; } public static String exceptionMessage ( Throwable t ) { if ( t instanceof JsonProcessingException ) { return ( ( JsonProcessingException ) t ) . getOriginalMessage ( ) ; } return t . getMessage ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ;", "fixed_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { return false ; } break ; } else if ( block . isLoop ) { return false ;", "label": 1}
{"buggy_code": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } public static DateTimeZone forOffsetHoursMinutes ( int hoursOffset , int minutesOffset ) throws IllegalArgumentException { if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { } return forOffsetMillis ( offset ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static DateTimeZone forOffsetHoursMinutes ( int hoursOffset , int minutesOffset ) throws IllegalArgumentException { if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { } return forOffsetMillis ( offset ) ; } public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "fixed_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "label": 1}
{"buggy_code": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Illegal argument : v \" ) ; }  } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private Tag ( String tagName ) { this . tagName = tagName ; } } \\ No newline at end of file", "fixed_code": "public class test { private Tag ( String tagName ) { this . tagName = tagName ; normalName = Normalizer . lowerCase ( tagName ) ; } public String normalName ( ) { return normalName ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "public class test { static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else {", "label": 1}
{"buggy_code": "public class test { public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) ) { name = \" \" ; } else { return null ;", "fixed_code": "} else if ( _hasAnnotation ( a , JsonSerialize . class ) | | _hasAnnotation ( a , JsonView . class ) | | _hasAnnotation ( a , JsonRawValue . class ) | | _hasAnnotation ( a , JsonUnwrapped . class ) | | _hasAnnotation ( a , JsonBackReference . class ) | | _hasAnnotation ( a , JsonManagedReference . class ) ) { name = \" \" ; } else { return null ;", "label": 1}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1}
{"buggy_code": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( last . getType ( ) = = type & & NodeUtil . isAssociative ( type ) ) { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; default : return node ; / / Nothing changed } } } \\ No newline at end of file", "fixed_code": "/ / the IN_FOR_INIT_CLAUSE one . Context rhsContext = getContextForNoInOperator ( context ) ; if ( NodeUtil . isAssignmentOp ( n ) & & NodeUtil . isAssignmentOp ( last ) ) { / / Assignments are the only right - associative binary operators addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; case Token . ARRAYLIT : return tryMinimizeArrayLiteral ( node ) ; case Token . MUL : case Token . AND : case Token . OR : case Token . BITOR : case Token . BITXOR : case Token . BITAND : return tryRotateAssociativeOperator ( node ) ; default : return node ; / / Nothing changed } } private Node tryRotateAssociativeOperator ( Node n ) { if ( ! late ) { return n ; } Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getType ( ) ) ) ; Node rhs = n . getLastChild ( ) ; if ( n . getType ( ) = = rhs . getType ( ) ) { Node parent = n . getParent ( ) ; Node first = n . getFirstChild ( ) . detachFromParent ( ) ; Node second = rhs . getFirstChild ( ) . detachFromParent ( ) ; Node third = rhs . getLastChild ( ) . detachFromParent ( ) ; Node newLhs = new Node ( n . getType ( ) , first , second ) . copyInformationFrom ( n ) ; Node newRoot = new Node ( rhs . getType ( ) , newLhs , third ) . copyInformationFrom ( rhs ) ; parent . replaceChild ( n , newRoot ) ; reportCodeChange ( ) ; return newRoot ; } return n ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public ChecksumCalculatingInputStream ( final Checksum checksum , final InputStream in ) { this . checksum = checksum ; this . in = in ;", "fixed_code": "public class test { public ChecksumCalculatingInputStream ( final Checksum checksum , final InputStream in ) { if ( checksum = = null ) { throw new NullPointerException ( \" Parameter checksum must not be null \" ) ; } if ( in = = null ) { throw new NullPointerException ( \" Parameter in must not be null \" ) ; } this . checksum = checksum ; this . in = in ;", "label": 1}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1}
{"buggy_code": "public class test { public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; if ( ! new MockCreationValidator ( ) . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation ) ; } private Object getMock ( InvocationOnMock invocation ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; InvocationContainerImpl container = ( InvocationContainerImpl ) handler . getInvocationContainer ( ) ; } / / deep stub return recordDeepStubMock ( invocation , container ) ; } private Object recordDeepStubMock ( InvocationOnMock invocation , InvocationContainerImpl container ) { Class < ? > clz = invocation . getMethod ( ) . getReturnType ( ) ; final Object mock = org . mockito . Mockito . mock ( clz , this ) ; container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ; return mock ; } } \\ No newline at end of file", "fixed_code": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable { container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ;  return mock ; } private Object createNewDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubs ( ) { @ Override protected GenericMetadataSupport actualParameterizedType ( Object mock ) { return returnTypeGenericMetadata ; } } ; } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; InvocationContainerImpl container = ( InvocationContainerImpl ) handler . getInvocationContainer ( ) ; } / / deep stub return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ; Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; if ( ! new MockCreationValidator ( ) . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; } return getMock ( invocation , returnTypeGenericMetadata ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 1}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "label": 1}
{"buggy_code": "String timezoneOffset = date . substring ( offset ) ; / / When timezone has no minutes , we should append it , valid timezones are , for example : + 00 : 00 , + 0000 and + 00 offset + = timezoneOffset . length ( ) ; / / 18 - Jun - 2015 , tatu : Minor simplification , skip offset of \" + 0000 \" / \" + 00 : 00 \"", "fixed_code": "String timezoneOffset = date . substring ( offset ) ; / / When timezone has no minutes , we should append it , valid timezones are , for example : + 00 : 00 , + 0000 and + 00 timezoneOffset = timezoneOffset . length ( ) > = 5 ? timezoneOffset : timezoneOffset + \" 00 \" ; offset + = timezoneOffset . length ( ) ; / / 18 - Jun - 2015 , tatu : Minor simplification , skip offset of \" + 0000 \" / \" + 00 : 00 \"", "label": 1}
{"buggy_code": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fieldInstance ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fields , fieldInstance ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "fixed_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . if ( functionType . isOrdinaryFunction ( ) & & ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & ! ( child . getType ( ) = = Token . GETELEM | | child . getType ( ) = = Token . GETPROP ) ) { report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; } visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "label": 1}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1}
{"buggy_code": "if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1}
{"buggy_code": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "fixed_code": "if ( ! newRecord ) { out . append ( format . getDelimiter ( ) ) ; } if ( object = = null ) { out . append ( value ) ; } else if ( format . isQuoteCharacterSet ( ) ) { / / the original object is needed so can check for Number printAndQuote ( object , value , offset , len ) ; } else if ( format . isEscapeCharacterSet ( ) ) {", "label": 1}
{"buggy_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ;", "fixed_code": "} / / 1 . Convert to lowercase txt = txt . toLowerCase ( java . util . Locale . ENGLISH ) ; / / 2 . Remove anything not A - Z txt = txt . replaceAll ( \" [ ^ a - z ] \" , \" \" ) ;", "label": 1}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1}
{"buggy_code": "if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } / / To satisfy normalization constraints , the type checking must be / / added after any inner function declarations . for ( Node paramType : funType . getParameters ( ) ) { / / Can this ever happen ?", "fixed_code": "if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN | | pType = = Token . OBJECTLIT ) ) { return false ; } } / / To satisfy normalization constraints , the type checking must be / / added after any inner function declarations . for ( Node next = block . getFirstChild ( ) ; next ! = null & & NodeUtil . isFunctionDeclaration ( next ) ; next = next . getNext ( ) ) { insertionPoint = next ; } for ( Node paramType : funType . getParameters ( ) ) { / / Can this ever happen ?", "label": 1}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } * important for some reason ? * Disabling the check will break 2 Enum - related tests . type = _baseType . narrowBy ( type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; } return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return type . narrowBy ( dst ) ; } } \\ No newline at end of file", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; } * important for some reason ? * Disabling the check will break 2 Enum - related tests . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; } return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return config . getTypeFactory ( ) . constructSpecializedType ( type , dst ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1}
{"buggy_code": "public class test { public Dfp multiply ( final int x ) { return multiplyFast ( x ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Dfp multiply ( final int x ) { if ( x > = 0 & & x < RADIX ) { return multiplyFast ( x ) ; } else { return multiply ( newInstance ( x ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1}
{"buggy_code": "case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ; / / Inversion case Token . NOT : / / delete operator returns a boolean . return true ; default : return false ;", "fixed_code": "case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . DELPROP : case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ; / / Inversion case Token . NOT : / / delete operator returns a boolean . case Token . DELPROP : return true ; default : return false ;", "label": 1}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1}
{"buggy_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1}
{"buggy_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1}
{"buggy_code": "return null ; } currEntry = new TarArchiveEntry ( headerBuf ) ; entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "fixed_code": "return null ; } try { currEntry = new TarArchiveEntry ( headerBuf ) ; } catch ( IllegalArgumentException e ) { IOException ioe = new IOException ( \" Error detected parsing the header \" ) ; ioe . initCause ( e ) ; throw ioe ; } entryOffset = 0 ; entrySize = currEntry . getSize ( ) ;", "label": 1}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; } public double getChiSquare ( ) { double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "public class test { public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; } public double getChiSquare ( ) { double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1}
{"buggy_code": "public class test { public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return factorials [ n ] ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static double factorialLog ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return factorials [ n ] ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ;", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ;", "label": 1}
{"buggy_code": "public class test { private String normalizeSourceName ( String filename ) {  if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; }  return filename ; } private void visitScript ( NodeTraversal t , Node script ) { Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) { compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private void visitScript ( NodeTraversal t , Node script ) { Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) { compiler . reportCodeChange ( ) ; } private String normalizeSourceName ( String filename ) { filename = filename . replace ( \" \\ \\ \" , \" / \" ) ;  if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; }  return filename ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : | | TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "fixed_code": "return ( t . getRawClass ( ) = = Object . class ) | | ( ! t . isConcrete ( ) / / [ databind # 88 ] Should not apply to JSON tree models : & & ! TreeNode . class . isAssignableFrom ( t . getRawClass ( ) ) ) ; case NON_FINAL : while ( t . isArrayType ( ) ) {", "label": 1}
{"buggy_code": "} else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "fixed_code": "} else if ( type . hasRawClass ( CLASS_SINGLETON_SET ) ) { conv = converter ( TYPE_SINGLETON_SET , type , Set . class ) ; / / [ databind # 2265 ] : we may have another impl type for unmodifiable Lists , check both } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_LIST ) | | type . hasRawClass ( CLASS_UNMODIFIABLE_LIST_ALIAS ) ) { conv = converter ( TYPE_UNMODIFIABLE_LIST , type , List . class ) ; } else if ( type . hasRawClass ( CLASS_UNMODIFIABLE_SET ) ) { conv = converter ( TYPE_UNMODIFIABLE_SET , type , Set . class ) ;", "label": 1}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "fixed_code": "if ( str = = null ) { return null ; }  if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  }  if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "label": 1}
{"buggy_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "fixed_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "label": 1}
{"buggy_code": "public class test { static Document parseByteData ( ByteBuffer byteData , String charsetName , String baseUri , Parser parser ) { String docData ; Document doc = null ; String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; } return doc ; } static String getCharsetFromContentType ( String contentType ) { if ( contentType = = null ) return null ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } return null ; } } \\ No newline at end of file", "fixed_code": "public class test { static String getCharsetFromContentType ( String contentType ) { if ( contentType = = null ) return null ; Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . replace ( \" charset = \" , \" \" ) ; if ( charset . isEmpty ( ) ) return null ; try { if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } catch ( IllegalCharsetNameException e ) { return null ; } } return null ; } static Document parseByteData ( ByteBuffer byteData , String charsetName , String baseUri , Parser parser ) { String docData ; Document doc = null ; String foundCharset ; if ( meta . hasAttr ( \" http - equiv \" ) ) { foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } else { foundCharset = meta . attr ( \" charset \" ) ; } if ( foundCharset ! = null & & foundCharset . length ( ) ! = 0 & & ! foundCharset . equals ( defaultCharset ) ) { / / need to re - decode foundCharset = foundCharset . trim ( ) . replaceAll ( \" [ \\ \" ' ] \" , \" \" ) ; charsetName = foundCharset ; byteData . rewind ( ) ; docData = Charset . forName ( foundCharset ) . decode ( byteData ) . toString ( ) ; } return doc ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 1 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1}
{"buggy_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; return new Double ( Math . floor ( v ) ) ; } } \\ No newline at end of file", "fixed_code": "protected Object functionFloor ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . floor ( v ) ) ; } protected Object functionRound ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . round ( v ) ) ; } protected Object functionCeiling ( EvalContext context ) { assertArgCount ( 1 ) ; double v = InfoSetUtil . doubleValue ( getArg1 ( ) . computeValue ( context ) ) ; if ( Double . isNaN ( v ) | | Double . isInfinite ( v ) ) { return new Double ( v ) ; } return new Double ( Math . ceil ( v ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "isConfigValid = false ; } if ( ! isConfigValid | | flags . display_help ) { isConfigValid = false ;", "fixed_code": "isConfigValid = false ; } if ( flags . version ) { ResourceBundle config = ResourceBundle . getBundle ( configResource ) ; err . println ( \" Closure Compiler ( http : / / code . google . com / p / closure / compiler ) \\ n \" + \" Version : \" + config . getString ( \" compiler . version \" ) + \" \\ n \" + \" Built on : \" + config . getString ( \" compiler . date \" ) ) ; err . flush ( ) ; } if ( ! isConfigValid | | flags . display_help ) { isConfigValid = false ;", "label": 1}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "fixed_code": "public void captureArgumentsFrom ( Invocation i ) { int k = 0 ; for ( Matcher m : matchers ) { if ( m instanceof CapturesArguments & & i . getArguments ( ) . length > k ) { ( ( CapturesArguments ) m ) . captureFrom ( i . getArguments ( ) [ k ] ) ; } k + + ;", "label": 1}
{"buggy_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . } }", "fixed_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { return false ; } } }", "label": 1}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line return null ; } Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "return null ; } if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line return null ; } if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 1}
{"buggy_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "fixed_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . Node rhs = n . getNext ( ) ; VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; if ( state = = VariableLiveness . READ ) { return state ; } return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "label": 1}
{"buggy_code": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "label": 0}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return Math . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; int mBlockIndex = 0 ; return true ; } return false ;", "label": 0}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ;", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ;", "label": 0}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = constraint . getWidth ( ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ) { throw new IllegalArgumentException ( \" Maximum value exceeded for add \" ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; + + i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) {", "label": 0}
{"buggy_code": "int i = 0 ; for ( Node scriptNode = jsRoot . getFirstChild ( ) ; scriptNode ! = null ; scriptNode = scriptNode . getNext ( ) ) { toSource ( cb , i + + , scriptNode ) ; } }", "fixed_code": "int i = 0 ; for ( Node scriptNode = jsRoot . getFirstChild ( ) ; scriptNode ! = null ; scriptNode = null ) { toSource ( cb , i + + , scriptNode ) ; } }", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; index = changeIndexSign ( index ) ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"buggy_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { resolvedTemplateType ( resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "fixed_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "label": 0}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0}
{"buggy_code": "if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; }", "fixed_code": "if ( str = = \" true \" ) { return true ; } if ( \" true \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" false \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" on \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" off \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" yes \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" no \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } if ( StringUtils . isEmpty ( str ) ) { return false ; } return false ; }", "label": 0}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ; / / full Brent algorithm starting with provided initial guess  } } \\ No newline at end of file", "label": 0}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; Number n = getValue ( rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0}
{"buggy_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "fixed_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "label": 0}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "fixed_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "label": 0}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( parent . isDo ( ) & & parent . getLastChild ( ) = = n ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & this . data . size ( ) > 0 ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = ( new RuleSet ( ) ) . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"buggy_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { return false ; } } }", "fixed_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { } } }", "label": 0}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0}
{"buggy_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "fixed_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) {  } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "label": 0}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; int start = 0 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "/ / Compare estimated savings against the helper cost . Apply / / reductions if doing so will result in some savings . if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; } } } } \\ No newline at end of file", "fixed_code": "/ / Compare estimated savings against the helper cost . Apply / / reductions if doing so will result in some savings . if ( ( ( 1 ) ! = ( reductions . size ( ) ) ) & & ( ! ( reducers . size ( ) < reductions . size ( ) ) ) ) { if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; } } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { continue ; } return out ;", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ FastMath . LN_MANT_LEN ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "label": 0}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "label": 0}
{"buggy_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar", "label": 0}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "fixed_code": "boolean canRemove = false ; if ( specializationState = = null ) { } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "label": 0}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) {  } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ; } }", "fixed_code": "final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) & & i < constraints . size ( ) ) { return null ; } }", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 4 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; } } \\ No newline at end of file", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( ! ( ( f0 > x0 + x1 ) = = true ) ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , max , max ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin2 = 0 ; return true ; } return false ;", "label": 0}
{"buggy_code": "public class test { private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "public class test { private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ;", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ;", "label": 0}
{"buggy_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "fixed_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "label": 0}
{"buggy_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "label": 0}
{"buggy_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; }  if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; }  Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; addingRoot . addChildrenToFront ( helperCode ) ; compiler . reportCodeChange ( ) ; } } } } \\ No newline at end of file", "fixed_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0}
{"buggy_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManCategoryDataset dataset = this . plot . getDataset ( index ) yEvaluationsException ( e . getMax ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return true ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) & & functionExpression . getFirstChild ( ) ! = grandchild ) { Preconditions . checkState ( allowObjectCallDecomposing ( ) , \" Object method calls can not be decomposed . \" ) ; state . sideEffects = true ;  Node replacement = rewriteCallExpression ( parent , state ) ; parent = replacement ; } } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return false ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch ! = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0}
{"buggy_code": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 1 ) { return indexOf ( str . charAt ( 0 ) , startIndex ) ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 1 ) { return indexOf ( str . charAt ( 0 ) , startIndex ) ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { return solveInverseCumulativeProbability ( p , lower , upper ) ; } }", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( CharSequence cs1 , CharSequence cs2 ) { if ( cs1 = = cs2 ) { return true ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( CharSequence cs1 , CharSequence cs2 ) { if ( ObjectUtils . toString ( cs1 ) = = cs2 ) { return true ; } if ( cs1 = = cs2 ) { return true ; } if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( ObjectUtils . toString ( cs2 ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( size + 4 ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "label": 0}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } } } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( index < 0 ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats . CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; } index = changeIndexSign ( index ) ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; ccovmuSep = Math . min ( 1 - ccov1 , ccovmu * ( dimension + 1 . 5 ) / 3 . ) ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . JSDOC_INFO_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } \\ No newline at end of file", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width + ' \\ n ' ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset", "fixed_code": "/ / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? PeriodType . HOUR_INDEX : instantBefore ) ; / / calculate result / / currently in later offset", "label": 0}
{"buggy_code": "public class test { public static boolean verbose ( ) { return cVerbose . get ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 4 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return - Math . PI ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 0}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "label": 0}
{"buggy_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { public static int gcd ( int u , int v ) { if ( System . currentTimeMillis ( ) * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / Need to deal with all possible hex prefixes here final String [ ] hex_prefixes = { \" 0x \" , \" 0X \" , \" - 0x \" , \" - 0X \" , \" # \" , \" - # \" } ; int pfxLen = 0 ; break ; } } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } try { return createInteger ( str ) ; } catch ( final NumberFormatException nfe ) { } / / Need to deal with all possible hex prefixes here final String [ ] hex_prefixes = { \" 0x \" , \" 0X \" , \" - 0x \" , \" - 0X \" , \" # \" , \" - # \" } ; int pfxLen = 0 ; break ; } } try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) + pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; }", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) | | ! ( str . startsWith ( \" - 0x \" ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "label": 0}
{"buggy_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0}
{"buggy_code": "/ / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ; } else if ( rValue . isOr ( ) ) { / / Check for a very specific JS idiom : / / var x = x | | TYPE ;", "fixed_code": "/ / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . if ( ! ( com . google . javascript . jscomp . TypedScopeCreator . DELEGATE_PROXY_SUFFIX . length ( ) = = - 1 + com . google . javascript . jscomp . TypedScopeCreator . this . functionAnalysisResults . size ( ) ) ) { return rValue . getJSType ( ) ; } } else if ( rValue . isOr ( ) ) { / / Check for a very specific JS idiom : / / var x = x | | TYPE ;", "label": 0}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "label": 0}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; return true ; } return false ;", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array if ( true ) return false ; int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { public void delete ( int start , int end ) { if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "public class test { public void delete ( int start , int end ) { if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } for ( int i = 0 ; i < = ( end - start ) ; i + + ) { if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start & & ( 0 < start ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + idx ; }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ;  } }", "label": 0}
{"buggy_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean flipIfWarranted ( int style , int flag ) { return ( style & flag ) = = flag ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( com . google . javascript . jscomp . CheckSideEffects . PROTECTOR_FN . length ( ) = = 0 ) { if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) {", "label": 0}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ( rhs > minRatio ) = = false ) { minRatio = rhs ; } else { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0}
{"buggy_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } }", "fixed_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } }", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( step > 4 * ( n - 1 ) ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "final double sigma = FastMath . sqrt ( getNumericalVariance ( ) ) ; final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "fixed_code": "final double sigma = FastMath . sqrt ( getNumericalVariance ( ) ) ; final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( Double . isNaN ( p ) ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) {", "label": 0}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; CodeGenerator . Context rhsContext = CodeGenerator . Context . IN_FOR_INIT_CLAUSE ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 0}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ; } }", "fixed_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = boundaries = = null ; break ; } }", "label": 0}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int node = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; + + ( index ) ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 4 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "Integer row = null ; for ( int i = 0 ; i < getHeight ( ) ; i + + ) { final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ;", "fixed_code": "Integer row = null ; for ( int i = 0 ; i < getHeight ( ) ; i + + ) { final double entry = getEntry ( i , col ) ; if ( Precision . equals ( entry , 1d , i - 1 ) & & ( row = = null ) ) { row = i ; } else if ( ! Precision . equals ( entry , 0d , maxUlps ) ) { return null ;", "label": 0}
{"buggy_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0}
{"buggy_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } } } } \\ No newline at end of file", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; entries . put ( key , value ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isToStringMethodCall ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ;", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ;", "label": 0}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "fixed_code": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex - 1 ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } } }", "label": 0}
{"buggy_code": "stepSize = hNew ; / / predict a first estimate of the state at step end ( P in the PECE sequence ) final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ;", "fixed_code": "stepSize = hNew ; lastStep = manager . stop ( ) ; / / predict a first estimate of the state at step end ( P in the PECE sequence ) final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; setMaxGrowth ( 10 . 0 ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ;", "label": 0}
{"buggy_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! isNativeObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) = = rhs . isNaN ( ) ) = = false ) { return this . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end . add ( field , - 1 * difference ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( minRow = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( lower > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; }", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } } return true ; }", "label": 0}
{"buggy_code": "} } if ( canRemove ) { declaration . remove ( ) ; changed = true ; }", "fixed_code": "} } if ( false ) { declaration . remove ( ) ; changed = true ; }", "label": 0}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0}
{"buggy_code": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; } } \\ No newline at end of file", "fixed_code": "public class test { public Object clone ( ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( isNaN ( ) ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 0}
{"buggy_code": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "fixed_code": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; ccov1Sep = Math . min ( 1 , ccov1 * ( dimension + 1 . 5 ) / 3 . ) ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } }", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "fixed_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0}
{"buggy_code": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0}
{"buggy_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "fixed_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "label": 0}
{"buggy_code": "break ; case Token . STRING : return getStringNumberValue ( n . getString ( ) ) ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "fixed_code": "break ; case Token . STRING : break ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "label": 0}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , min ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { buffer = new char [ CAPACITY ] ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; } } \\ No newline at end of file", "fixed_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - startIndex - 1 ) ; size - = len ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 | | MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , initial , max ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0}
{"buggy_code": "public class test { protected VectorialPointValuePair doOptimize ( ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { int pj = permutation [ j ] ; point [ pj ] = oldX [ pj ] ; } tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } } private void determineLMParameter ( double [ ] qy , double delta , double [ ] diag , double [ ] work1 , double [ ] work2 , double [ ] work3 ) {  for ( int j = 0 ; j < rank ; + + j ) { lmDir [ permutation [ j ] ] = qy [ j ] ; } for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } for ( int k = rank - 1 ; k > = 0 ; - - k ) { int pk = permutation [ k ] ; double ypk = lmDir [ pk ] / diagR [ pk ] ; for ( int i = 0 ; i < k ; + + i ) { lmDir [ permutation [ i ] ] - = ypk * jacobian [ i ] [ pk ] ; } lmDir [ pk ] = ypk ; }  double dxNorm = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double s = diag [ pj ] * lmDir [ pj ] ; work1 [ pj ] = s ; dxNorm + = s * s ; } dxNorm = Math . sqrt ( dxNorm ) ; double fp = dxNorm - delta ; if ( fp < = 0 . 1 * delta ) { lmPar = 0 ; return ; }  double sum2 ; double parl = 0 ; if ( rank = = solvedCols ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] * = diag [ pj ] / dxNorm ; } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ; for ( int i = 0 ; i < j ; + + i ) { sum + = jacobian [ i ] [ pj ] * work1 [ permutation [ i ] ] ; } double s = ( work1 [ pj ] - sum ) / diagR [ pj ] ; work1 [ pj ] = s ; sum2 + = s * s ; } parl = fp / ( delta * sum2 ) ; }  sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qy [ i ] ; } sum / = diag [ pj ] ; sum2 + = sum * sum ; } double gNorm = Math . sqrt ( sum2 ) ; double paru = gNorm / delta ; if ( paru = = 0 ) { paru = 2 . 2251e - 308 / Math . min ( delta , 0 . 1 ) ; }  lmPar = Math . min ( paru , Math . max ( lmPar , parl ) ) ; if ( lmPar = = 0 ) { lmPar = gNorm / dxNorm ; }  for ( int countdown = 10 ; countdown > = 0 ; - - countdown ) {  if ( lmPar = = 0 ) { lmPar = Math . max ( 2 . 2251e - 308 , 0 . 001 * paru ) ; } double sPar = Math . sqrt ( lmPar ) ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = sPar * diag [ pj ] ; } determineLMDirection ( qy , work1 , work2 , work3 ) ;  dxNorm = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double s = diag [ pj ] * lmDir [ pj ] ; work3 [ pj ] = s ; dxNorm + = s * s ; } dxNorm = Math . sqrt ( dxNorm ) ; double previousFP = fp ; fp = dxNorm - delta ;  if ( ( Math . abs ( fp ) < = 0 . 1 * delta ) | | ( ( parl = = 0 ) & & ( fp < = previousFP ) & & ( previousFP < 0 ) ) ) { return ; }  for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; double tmp = work1 [ pj ] ; for ( int i = j + 1 ; i < solvedCols ; + + i ) { work1 [ permutation [ i ] ] - = jacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ; } double correction = fp / ( delta * sum2 ) ;  if ( fp > 0 ) { parl = Math . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = Math . min ( paru , lmPar ) ; }  lmPar = Math . max ( parl , lmPar + correction ) ;  } } } \\ No newline at end of file", "fixed_code": "public class test { private void determineLMParameter ( double [ ] qy , double delta , double [ ] diag , double [ ] work1 , double [ ] work2 , double [ ] work3 ) {  for ( int j = 0 ; j < rank ; + + j ) { lmDir [ permutation [ j ] ] = qy [ j ] ; } for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } for ( int k = rank - 1 ; k > = 0 ; - - k ) { int pk = permutation [ k ] ; double ypk = lmDir [ pk ] / diagR [ pk ] ; for ( int i = 0 ; i < k ; + + i ) { lmDir [ permutation [ i ] ] - = ypk * jacobian [ i ] [ pk ] ; } lmDir [ pk ] = ypk ; }  double dxNorm = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double s = diag [ pj ] * lmDir [ pj ] ; work1 [ pj ] = s ; dxNorm + = s * s ; } dxNorm = Math . sqrt ( dxNorm ) ; double fp = dxNorm - delta ; if ( fp < = 0 . 1 * delta ) { lmPar = 0 ; return ; }  double sum2 ; double parl = 0 ; if ( rank = = solvedCols ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] * = diag [ pj ] / dxNorm ; } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ; for ( int i = 0 ; i < j ; + + i ) { sum + = jacobian [ i ] [ pj ] * work1 [ permutation [ i ] ] ; } double s = ( work1 [ pj ] - sum ) / diagR [ pj ] ; work1 [ pj ] = s ; sum2 + = s * s ; } parl = fp / ( delta * sum2 ) ; }  sum2 = 0 ; for ( int k = 0 ; k < solvedCols ; + + k ) { int pk = permutation [ k ] ; jacobian [ k ] [ pk ] = diagR [ pk ] ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qy [ i ] ; } sum / = diag [ pj ] ; sum2 + = sum * sum ; } double gNorm = Math . sqrt ( sum2 ) ; double paru = gNorm / delta ; if ( paru = = 0 ) { paru = 2 . 2251e - 308 / Math . min ( delta , 0 . 1 ) ; }  lmPar = Math . min ( paru , Math . max ( lmPar , parl ) ) ; if ( lmPar = = 0 ) { lmPar = gNorm / dxNorm ; }  for ( int countdown = 10 ; countdown > = 0 ; - - countdown ) {  if ( lmPar = = 0 ) { lmPar = Math . max ( 2 . 2251e - 308 , 0 . 001 * paru ) ; } double sPar = Math . sqrt ( lmPar ) ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = sPar * diag [ pj ] ; } determineLMDirection ( qy , work1 , work2 , work3 ) ;  dxNorm = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; double s = diag [ pj ] * lmDir [ pj ] ; work3 [ pj ] = s ; dxNorm + = s * s ; } dxNorm = Math . sqrt ( dxNorm ) ; double previousFP = fp ; fp = dxNorm - delta ;  if ( ( Math . abs ( fp ) < = 0 . 1 * delta ) | | ( ( parl = = 0 ) & & ( fp < = previousFP ) & & ( previousFP < 0 ) ) ) { return ; }  for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; double tmp = work1 [ pj ] ; for ( int i = j + 1 ; i < solvedCols ; + + i ) { work1 [ permutation [ i ] ] - = jacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ; } double correction = fp / ( delta * sum2 ) ;  if ( fp > 0 ) { parl = Math . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = Math . min ( paru , lmPar ) ; }  lmPar = Math . max ( parl , lmPar + correction ) ;  } } protected VectorialPointValuePair doOptimize ( ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { int pj = permutation [ j ] ; point [ pj ] = oldX [ pj ] ; } current = new VectorialPointValuePair ( point , objective ) ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isInfinite ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0}
{"buggy_code": "/ / really matter which rule was chosen the ' start ' and / / which is chosen the ' end ' . DSTZone works properly either / / way . return new DSTZone ( id , iStandardOffset , startRule . iRecurrence , endRule . iRecurrence ) ; } } return null ;", "fixed_code": "/ / really matter which rule was chosen the ' start ' and / / which is chosen the ' end ' . DSTZone works properly either / / way . System . out . println ( \" Writing zoneinfo files \" ) ; } } return null ;", "label": 0}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { throw new IllegalArgumentException ( \" Maximum value exceeded for add \" ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { randomData . nextPoisson ( mean ) ; throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 0}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1}
{"buggy_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "fixed_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_IS_GETTERS ) ) { vchecker = vchecker . withIsGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; } { VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "label": 1}
{"buggy_code": "Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } public void onContentsChanged ( ) { nodelistChanged ( ) ; } protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( 4 ) ; } return childNodes ; } NodeList ( int initialCapacity ) { super ( initialCapacity ) ; } } \\ No newline at end of file", "fixed_code": "Element clone = ( Element ) super . doClone ( parent ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . baseUri = baseUri ; clone . childNodes = new NodeList ( clone , childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; return clone ; } NodeList ( Element owner , int initialCapacity ) { super ( initialCapacity ) ; this . owner = owner ; } protected List < Node > ensureChildNodes ( ) { if ( childNodes = = EMPTY_NODES ) { childNodes = new NodeList ( this , 4 ) ; } return childNodes ; } public void onContentsChanged ( ) { owner . nodelistChanged ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , e . getMessage ( ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ;", "fixed_code": "/ / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , beanDesc , null ) ; } BeanDeserializerBuilder builder = constructBeanDeserializerBuilder ( ctxt , beanDesc ) ; / / to throw proper exception , it doesn ' t actually have reference to this / / instance so . . . throw InvalidDefinitionException . from ( ctxt . getParser ( ) , ClassUtil . exceptionMessage ( e ) , builderDesc , null ) ; } final DeserializationConfig config = ctxt . getConfig ( ) ;", "label": 1}
{"buggy_code": "public class test { public static synchronized FastDateFormat getDateTimeInstance ( int dateStyle , int timeStyle , TimeZone timeZone , Locale locale ) {  Object key = new Pair ( new Integer ( dateStyle ) , new Integer ( timeStyle ) ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; } } return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; }  if ( locale ! = null ) { key = new Pair ( key , locale ) ; }  FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date pattern for locale : \" + locale ) ; } } return format ;", "fixed_code": "public class test { public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; }  if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ;  FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date pattern for locale : \" + locale ) ; } } return format ; } public static synchronized FastDateFormat getDateTimeInstance ( int dateStyle , int timeStyle , TimeZone timeZone , Locale locale ) {  Object key = new Pair ( new Integer ( dateStyle ) , new Integer ( timeStyle ) ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ;  } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; } } return format ;", "label": 1}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "label": 1}
{"buggy_code": "if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) { return CanInlineResult . NO ; } }", "fixed_code": "if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) {  } }", "label": 1}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "label": 1}
{"buggy_code": "public class test { public void resolve ( SerializerProvider provider ) throws JsonMappingException { _mapSerializer = ( MapSerializer ) provider . handlePrimaryContextualization ( _mapSerializer , _property ) ; } public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , MapSerializer serializer ) { _accessor = accessor ; _property = property ; _mapSerializer = ( MapSerializer ) serializer ; } public void getAndFilter ( Object bean , JsonGenerator gen , SerializerProvider provider , PropertyFilter filter ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFilteredFields ( ( Map < ? , ? > ) value , gen , provider , filter , null ) ; return ; } } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" _accessor . getName ( ) + \" ( ) ) not java . util . Map but \" + value . getClass ( ) . getName ( ) ) ; } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } _serializer . serialize ( value , gen , provider ) ; } public void resolve ( SerializerProvider provider ) throws JsonMappingException { if ( _serializer instanceof ContextualSerializer ) { JsonSerializer < ? > ser = provider . handlePrimaryContextualization ( _serializer , _property ) ; _serializer = ( JsonSerializer < Object > ) ser ; if ( ser instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) ser ; } } } public void getAndFilter ( Object bean , JsonGenerator gen , SerializerProvider provider , PropertyFilter filter ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" _accessor . getName ( ) + \" ( ) ) not java . util . Map but \" + value . getClass ( ) . getName ( ) ) ; } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFilteredFields ( ( Map < ? , ? > ) value , gen , provider , filter , null ) ; return ; } _serializer . serialize ( value , gen , provider ) ; } public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , JsonSerializer < ? > serializer ) { _accessor = accessor ; _property = property ; _serializer = ( JsonSerializer < Object > ) serializer ; if ( serializer instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) serializer ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public boolean isInfinite ( ) { return isInfinite ; } public boolean isNaN ( ) { return isNaN ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ; } public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; } } \\ No newline at end of file", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int indexOfActualTypeArgument = getIndex ( classTypeVariables , fieldTypeVariable ) ; Type [ ] actualTypeArguments = objParameterizedType . getActualTypeArguments ( ) ; return actualTypeArguments [ indexOfActualTypeArgument ] ; } throw new UnsupportedOperationException ( \" Expecting parameterized type , got \" + parentType } } } \\ No newline at end of file", "fixed_code": "int indexOfActualTypeArgument = getIndex ( classTypeVariables , fieldTypeVariable ) ; Type [ ] actualTypeArguments = objParameterizedType . getActualTypeArguments ( ) ; return actualTypeArguments [ indexOfActualTypeArgument ] ; } else if ( typeToEvaluate instanceof TypeVariable < ? > ) { Type theSearchedType = null ; do { theSearchedType = extractTypeForHierarchy ( parentType , ( TypeVariable < ? > ) typeToEvaluate ) ; } while ( ( theSearchedType ! = null ) & & ( theSearchedType instanceof TypeVariable < ? > ) ) ; if ( theSearchedType ! = null ) { return theSearchedType ; } } throw new UnsupportedOperationException ( \" Expecting parameterized type , got \" + parentType \" ParameterizedType , GenericArrayType or TypeVariable . Can ' t extract type . \" ) ; } } private static Type extractTypeForHierarchy ( Type parentType , TypeVariable < ? > typeToEvaluate ) { Class < ? > rawParentType = null ; if ( parentType instanceof Class < ? > ) { rawParentType = ( Class < ? > ) parentType ; } else if ( parentType instanceof ParameterizedType ) { ParameterizedType parentTypeAsPT = ( ParameterizedType ) parentType ; rawParentType = ( Class < ? > ) parentTypeAsPT . getRawType ( ) ; } else { return null ; }  Type superClass = rawParentType . getGenericSuperclass ( ) ; if ( superClass instanceof ParameterizedType & & ( ( ParameterizedType ) superClass ) . getRawType ( ) = = typeToEvaluate . getGenericDeclaration ( ) ) { TypeVariable < ? > [ ] classTypeVariables = ( ( Class < ? > ) ( ( ParameterizedType ) superClass ) . getRawType ( ) ) . getTypeParameters ( ) ; int indexOfActualTypeArgument = getIndex ( classTypeVariables , typeToEvaluate ) ;  Type [ ] actualTypeArguments = null ; if ( parentType instanceof Class < ? > ) { actualTypeArguments = ( ( ParameterizedType ) superClass ) . getActualTypeArguments ( ) ; } else if ( parentType instanceof ParameterizedType ) { actualTypeArguments = ( ( ParameterizedType ) parentType ) . getActualTypeArguments ( ) ; } else { return null ; }  return actualTypeArguments [ indexOfActualTypeArgument ] ; }  Type searchedType = null ; if ( superClass ! = null ) { searchedType = extractTypeForHierarchy ( superClass , typeToEvaluate ) ; } return searchedType ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; } boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( NAME_FOR_OBJECT_REF , null , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "fixed_code": "if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , null ) ; if ( objectIdInfo ! = null ) { oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "label": 1}
{"buggy_code": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "fixed_code": "} else if ( defValue . length ( ) > 1 & & ( ( defValue . charAt ( 0 ) = = ' \\ ' ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ ' ' ) | | ( defValue . charAt ( 0 ) = = ' \\ \" ' & & defValue . charAt ( defValue . length ( ) - 1 ) = = ' \\ \" ' ) ) ) { / / If the value starts and ends with a single quote , / / we assume that it ' s a string . String maybeStringVal = Node exprBody = node . getFirstChild ( ) ; if ( ! NodeUtil . nodeTypeMayHaveSideEffects ( exprBody ) | | exprBody . getType ( ) = = Token . NEW | | exprBody . getType ( ) = = Token . CALL ) { changeProxy . replaceWith ( parent , node , getSideEffectNodes ( exprBody ) ) ; } }", "label": 1}
{"buggy_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; } } \\ No newline at end of file", "fixed_code": "for ( Type type : typeVariable . getBounds ( ) ) { registerTypeVariablesOn ( type ) ; } registerTypeParametersOn ( new TypeVariable [ ] { typeVariable } ) ; registerTypeVariablesOn ( getActualTypeArgumentFor ( typeVariable ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 1}
{"buggy_code": "public class test { public long add ( long instant , int value ) { if ( instant > = iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } } else { instant = iJulianField . add ( instant , value ) ; if ( instant > = iCutover ) { if ( instant - iGapDuration > = iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } public long add ( long instant , long value ) { if ( instant > = iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } } else { instant = iJulianField . add ( instant , value ) ; if ( instant > = iCutover ) { if ( instant - iGapDuration > = iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } public static synchronized GJChronology getInstance ( DateTimeZone zone , ReadableInstant gregorianCutover , cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; } GJChronology chrono ; } return chrono ; } } \\ No newline at end of file", "fixed_code": "public class test { public static synchronized GJChronology getInstance ( DateTimeZone zone , ReadableInstant gregorianCutover , cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear ( ) < = 0 ) { throw new IllegalArgumentException ( \" Cutover too early . Must be on or after 0001 - 01 - 01 . \" ) ; } } GJChronology chrono ; } return chrono ; } public long add ( long instant , int value ) { if ( instant > = iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } } else { instant = iJulianField . add ( instant , value ) ; if ( instant > = iCutover ) { if ( instant - iGapDuration > = iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } public long add ( long instant , long value ) { if ( instant > = iCutover ) { instant = iGregorianField . add ( instant , value ) ; if ( instant < iCutover ) { if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } } else { instant = iJulianField . add ( instant , value ) ; if ( instant > = iCutover ) { if ( instant - iGapDuration > = iCutover ) { instant = julianToGregorian ( instant ) ; } } } return instant ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public boolean hasNextValue ( ) throws IOException { if ( _parser = = null ) { return false ; / / fall - through } if ( ! _hasNextChecked ) { JsonToken t = _parser . getCurrentToken ( ) ; _hasNextChecked = true ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { JsonParser jp = _parser ; _parser = null ; if ( _closeParser ) { jp . close ( ) ; } return false ; } } / / fall through } return true ; } public void close ( ) throws IOException { if ( _parser ! = null ) { _parser . close ( ) ; } } protected MappingIterator ( JavaType type , JsonParser p , DeserializationContext ctxt , JsonDeserializer < ? > deser , * and if not , caller needs to hand us JsonParser instead , pointing to * the first token of the first element . if ( managedParser & & ( p ! = null ) & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent } } public T nextValue ( ) throws IOException { if ( ! _hasNextChecked ) { if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } } if ( _parser = = null ) { return _throwNoSuchElement ( ) ; } _hasNextChecked = false ;  try { T value ; if ( _updatedValue = = null ) { value = _deserializer . deserialize ( _parser , _context ) ; } else { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } return value ; } finally { _parser . clearCurrentToken ( ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void close ( ) throws IOException { if ( _state ! = STATE_CLOSED ) { _state = STATE_CLOSED ; if ( _parser ! = null ) { _parser . close ( ) ; } } } public T nextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return _throwNoSuchElement ( ) ; case STATE_NEED_RESYNC : / / fall - through , will do re - sync case STATE_MAY_HAVE_VALUE : if ( ! hasNextValue ( ) ) { return _throwNoSuchElement ( ) ; } break ; case STATE_HAS_VALUE : break ; }  int nextState = STATE_NEED_RESYNC ; try { T value ; if ( _updatedValue = = null ) { value = _deserializer . deserialize ( _parser , _context ) ; } else { _deserializer . deserialize ( _parser , _context , _updatedValue ) ; value = _updatedValue ; } nextState = STATE_MAY_HAVE_VALUE ; return value ; } finally { _state = nextState ; _parser . clearCurrentToken ( ) ; } } public boolean hasNextValue ( ) throws IOException { switch ( _state ) { case STATE_CLOSED : return false ; case STATE_NEED_RESYNC : _resync ( ) ; / / fall - through case STATE_MAY_HAVE_VALUE : JsonToken t = _parser . getCurrentToken ( ) ; if ( t = = null ) { / / un - initialized or cleared ; find next t = _parser . nextToken ( ) ; / / If EOF , no more , or if we hit END_ARRAY ( although we don ' t clear the token ) . if ( t = = null | | t = = JsonToken . END_ARRAY ) { _state = STATE_CLOSED ; if ( _closeParser & & ( _parser ! = null ) ) { _parser . close ( ) ; } return false ; } } _state = STATE_HAS_VALUE ; return true ; case STATE_HAS_VALUE : / / fall through } return true ; } protected void _resync ( ) throws IOException { final JsonParser p = _parser ; if ( p . getParsingContext ( ) = = _seqContext ) { return ; }  while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = JsonToken . END_ARRAY ) | | ( t = = JsonToken . END_OBJECT ) ) { if ( p . getParsingContext ( ) = = _seqContext ) { p . clearCurrentToken ( ) ; return ; } } else if ( ( t = = JsonToken . START_ARRAY ) | | ( t = = JsonToken . START_OBJECT ) ) { p . skipChildren ( ) ; } else if ( t = = null ) { return ; } } } protected MappingIterator ( JavaType type , JsonParser p , DeserializationContext ctxt , JsonDeserializer < ? > deser , * and if not , caller needs to hand us JsonParser instead , pointing to * the first token of the first element . if ( p = = null ) { / / can this occur ? _seqContext = null ; _state = STATE_CLOSED ; } else { JsonStreamContext sctxt = p . getParsingContext ( ) ; if ( managedParser & & p . isExpectedStartArrayToken ( ) ) { / / If pointing to START_ARRAY , context should be that ARRAY p . clearCurrentToken ( ) ; } else { / / regardless , recovery context should be whatever context we have now , / / with sole exception of pointing to a start marker , in which case it ' s / / the parent JsonToken t = p . getCurrentToken ( ) ; if ( ( t = = JsonToken . START_OBJECT ) | | ( t = = JsonToken . START_ARRAY ) ) { sctxt = sctxt . getParent ( ) ; } } _seqContext = sctxt ; _state = STATE_MAY_HAVE_VALUE ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "fixed_code": "/ / try to resolve relative urls to abs , and optionally update the attribute so output html has abs . / / rels without a baseuri get removed String value = el . absUrl ( attr . getKey ( ) ) ; if ( value . length ( ) = = 0 ) value = attr . getValue ( ) ; / / if it could not be made abs , run as - is to allow custom unknown protocols if ( ! preserveRelativeLinks ) attr . setValue ( value ) ;", "label": 1}
{"buggy_code": "} else { / / named / / get as many letters as possible , and look for matching entities . String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; boolean looksLegit = reader . matches ( ' ; ' ) ; / / found if a base named entity without a ; , or an extended entity with the ; . boolean found = false ; while ( nameRef . length ( ) > 0 & & ! found ) { if ( Entities . isNamedEntity ( nameRef ) ) found = true ; else { nameRef = nameRef . substring ( 0 , nameRef . length ( ) - 1 ) ; reader . unconsume ( ) ; } } if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) / / named with semicolon characterReferenceError ( String . format ( \" invalid named referenece ' % s ' \" , origNameRef ) ) ; return null ; } if ( inAttribute & & ( reader . matchesLetter ( ) | | reader . matchesDigit ( ) | | reader . matchesAny ( ' = ' , ' - ' , ' _ ' ) ) ) { return Entities . getCharacterByName ( nameRef ) ; } } } \\ No newline at end of file", "fixed_code": "} else { / / named / / get as many letters as possible , and look for matching entities . String nameRef = reader . consumeLetterThenDigitSequence ( ) ; boolean looksLegit = reader . matches ( ' ; ' ) ; / / found if a base named entity without a ; , or an extended entity with the ; . boolean found = ( Entities . isBaseNamedEntity ( nameRef ) | | ( Entities . isNamedEntity ( nameRef ) & & looksLegit ) ) ; if ( ! found ) { reader . rewindToMark ( ) ; if ( looksLegit ) / / named with semicolon characterReferenceError ( String . format ( \" invalid named referenece ' % s ' \" , nameRef ) ) ; return null ; } if ( inAttribute & & ( reader . matchesLetter ( ) | | reader . matchesDigit ( ) | | reader . matchesAny ( ' = ' , ' - ' , ' _ ' ) ) ) { return Entities . getCharacterByName ( nameRef ) ; } } String unescapeEntities ( boolean inAttribute ) { StringBuilder builder = new StringBuilder ( ) ; while ( ! reader . isEmpty ( ) ) { builder . append ( reader . consumeTo ( ' & ' ) ) ; if ( reader . matches ( ' & ' ) ) { reader . consume ( ) ; Character c = consumeCharacterReference ( null , inAttribute ) ; if ( c = = null ) builder . append ( ' & ' ) ; else builder . append ( c ) ; } } return builder . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing { if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; JsonNode result ; try { writeValue ( buf , fromValue ) ; } return ( T ) result ; } public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; } } \\ No newline at end of file", "fixed_code": "/ / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing { if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } JsonNode result ; try { writeValue ( buf , fromValue ) ; } return ( T ) result ; } public TokenBuffer forceUseOfBigDecimal ( boolean b ) { _forceBigDecimal = b ; return this ; } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; _forceBigDecimal = ( ctxt = = null ) ? false : ctxt . isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ; } public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : if ( _forceBigDecimal ) { writeNumber ( p . getDecimalValue ( ) ) ; } else { switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . mixIns . add ( _constructMethod ( m ) ) ; } } }", "fixed_code": "} else { / / Well , or , as per [ Issue # 515 ] , multi - level merge within mixins . . . am = mixIns . find ( m ) ; if ( am ! = null ) { _addMixUnders ( m , am ) ; } else { mixIns . add ( _constructMethod ( m ) ) ; } } } }", "label": 1}
{"buggy_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } } } } public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } } \\ No newline at end of file", "fixed_code": "Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } } } } public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { nodeSet . add ( ptr ) ; pointers . add ( ptr ) ; } } } } } return super . setPosition ( position ) ; }", "fixed_code": "while ( ctx . nextNode ( ) ) { NodePointer ptr = ctx . getCurrentNodePointer ( ) ; if ( ! pointers . contains ( ptr ) ) { pointers . add ( ptr ) ; } } } } sortPointers ( pointers ) ;  for ( Iterator it = pointers . iterator ( ) ; it . hasNext ( ) ; ) { nodeSet . add ( ( Pointer ) it . next ( ) ) ; } } return super . setPosition ( position ) ; }", "label": 1}
{"buggy_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "fixed_code": "if ( startTag . isSelfClosing ( ) ) { Element el = insertEmpty ( startTag ) ; stack . add ( el ) ; tokeniser . transition ( TokeniserState . Data ) ; / / handles < script / > , otherwise needs breakout steps from script data tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; / / ensure we get out of whatever state we are in . emitted for yielded processing return el ; }", "label": 1}
{"buggy_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; / / Otherwise , stitch together the hierarchy . First , super - class / / if not found , try a super - interface / / should not get here but . . . } } \\ No newline at end of file", "fixed_code": "/ / 15 - Jan - 2016 , tatu : Almost yes , but there are some complications with / / placeholder values ( ` Void ` , ` NoClass ` ) , so can not quite do yet . / / TODO : fix in 2 . 8 if ( ! _class . isAssignableFrom ( subclass ) ) { return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } / / Otherwise , stitch together the hierarchy . First , super - class Class < ? > next = subclass . getSuperclass ( ) ; if ( next = = _class ) { / / straight up parent class ? Great . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } if ( ( next ! = null ) & & _class . isAssignableFrom ( next ) ) { JavaType superb = _narrow ( next ) ; return new SimpleType ( subclass , _bindings , superb , null , _valueHandler , _typeHandler , _asStatic ) ; } / / if not found , try a super - interface Class < ? > [ ] nextI = subclass . getInterfaces ( ) ; for ( Class < ? > iface : nextI ) { if ( iface = = _class ) { / / directly implemented return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { this } , _valueHandler , _typeHandler , _asStatic ) ; } if ( _class . isAssignableFrom ( iface ) ) { / / indirect , so recurse JavaType superb = _narrow ( iface ) ; return new SimpleType ( subclass , _bindings , null , new JavaType [ ] { superb } , _valueHandler , _typeHandler , _asStatic ) ; } } / / should not get here but . . . throw new IllegalArgumentException ( \" Internal error : Can not resolve sub - type for Class \" + subclass . getName ( ) + \" to \" + _class . getName ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1}
{"buggy_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . / / truncate milliseconds / / truncate seconds / / truncate minutes / / reset time / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "fixed_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } if ( field = = Calendar . MILLISECOND ) { return ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; / / truncate milliseconds int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done & & ( ! round | | minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field if ( offset ! = 0 ) { val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "label": 1}
{"buggy_code": "if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED ) { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; try { long result = Long . parseLong ( peekedString ) ; peeked = PEEKED_NONE ; if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED ) { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; try { result = Integer . parseInt ( peekedString ) ; peeked = PEEKED_NONE ;", "fixed_code": "if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED | | p = = PEEKED_UNQUOTED ) { if ( p = = PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; } try { long result = Long . parseLong ( peekedString ) ; peeked = PEEKED_NONE ; if ( p = = PEEKED_NUMBER ) { peekedString = new String ( buffer , pos , peekedNumberLength ) ; pos + = peekedNumberLength ; } else if ( p = = PEEKED_SINGLE_QUOTED | | p = = PEEKED_DOUBLE_QUOTED | | p = = PEEKED_UNQUOTED ) { if ( p = = PEEKED_UNQUOTED ) { peekedString = nextUnquotedValue ( ) ; } else { peekedString = nextQuotedValue ( p = = PEEKED_SINGLE_QUOTED ? ' \\ ' ' : ' \" ' ) ; } try { result = Integer . parseInt ( peekedString ) ; peeked = PEEKED_NONE ;", "label": 1}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1}
{"buggy_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] < < ( 8 * i ) ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "fixed_code": "byte propsByte = coder . properties [ 0 ] ; long dictSize = coder . properties [ 1 ] ; for ( int i = 1 ; i < 4 ; i + + ) { dictSize | = ( coder . properties [ i + 1 ] & 0xffl ) < < ( 8 * i ) ; } if ( dictSize > LZMAInputStream . DICT_SIZE_MAX ) { throw new IOException ( \" Dictionary larger than 4GiB maximum size \" ) ;", "label": 1}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1}
{"buggy_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element . equals ( search ) ) return i ; } return null ;", "fixed_code": "for ( int i = 0 ; i < elements . size ( ) ; i + + ) { E element = elements . get ( i ) ; if ( element = = search ) return i ; } return null ;", "label": 1}
{"buggy_code": "public class test { private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ;  return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata ) { return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata ) ) ; } private Object deepStub ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private MockSettings propagateSerializationSettings ( MockSettings mockSettings , MockCreationSettings parentMockSettings ) { return mockSettings . serializable ( parentMockSettings . getSerializableMode ( ) ) ; } private Object deepStub ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; / / record deep stub answer return recordDeepStubAnswer ( newDeepStubMock ( returnTypeGenericMetadata , invocation . getMock ( ) ) , container ) ; } private Object newDeepStubMock ( GenericMetadataSupport returnTypeGenericMetadata , Object parentMock ) { MockCreationSettings parentMockSettings = new MockUtil ( ) . getMockSettings ( parentMock ) ; return mockitoCore ( ) . mock ( returnTypeGenericMetadata . rawType ( ) , withSettingsUsing ( returnTypeGenericMetadata , parentMockSettings ) ) ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata , MockCreationSettings parentMockSettings ) { MockSettings mockSettings = returnTypeGenericMetadata . hasRawExtraInterfaces ( ) ? withSettings ( ) . extraInterfaces ( returnTypeGenericMetadata . rawExtraInterfaces ( ) ) : withSettings ( ) ;  return propagateSerializationSettings ( mockSettings , parentMockSettings ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ;", "fixed_code": "} / / single character is itself if ( txt . length ( ) = = 1 ) { return txt . toUpperCase ( java . util . Locale . ENGLISH ) ; } char [ ] inwd = txt . toUpperCase ( java . util . Locale . ENGLISH ) . toCharArray ( ) ;", "label": 1}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 1}
{"buggy_code": "public class test { public static String newStringIso8859_1 ( final byte [ ] bytes ) { return new String ( bytes , Charsets . ISO_8859_1 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static String newStringIso8859_1 ( final byte [ ] bytes ) { return newString ( bytes , Charsets . ISO_8859_1 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private boolean canBeRedeclared ( Node n , Scope s ) { if ( ! NodeUtil . isExprAssign ( n ) ) { return false ; Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! blacklistedVars . contains ( var ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean isNamedParameter ( Var v ) { return v . getParentNode ( ) . isParamList ( ) ; } private boolean canBeRedeclared ( Node n , Scope s ) { if ( ! NodeUtil . isExprAssign ( n ) ) { return false ; Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! isNamedParameter ( var ) & & ! blacklistedVars . contains ( var ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return null ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "fixed_code": "JavaType actual = _handleUnknownTypeId ( ctxt , typeId ) ; if ( actual = = null ) { / / what should this be taken to mean ? / / 17 - Jan - 2019 , tatu : As per [ databind # 2221 ] , better NOT return ` null ` but . . . return NullifyingDeserializer . instance ; } / / . . . would this actually work ? deser = ctxt . findContextualValueDeserializer ( actual , _property ) ;", "label": 1}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1}
{"buggy_code": "public class test { public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . LINK_FLAG ) = = UnixStat . LINK_FLAG ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isUnixSymlink ( ) { return ( getUnixMode ( ) & UnixStat . FILE_TYPE_FLAG ) = = UnixStat . LINK_FLAG ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "fixed_code": "/ / iterate the form control elements and accumulate their values for ( Element el : elements ) { if ( ! el . tag ( ) . isFormSubmittable ( ) ) continue ; / / contents are form listable , superset of submitable if ( el . hasAttr ( \" disabled \" ) ) continue ; / / skip disabled form inputs String name = el . attr ( \" name \" ) ; if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; } else if ( \" checkbox \" . equalsIgnoreCase ( type ) | | \" radio \" . equalsIgnoreCase ( type ) ) { / / only add checkbox or radio if they have the checked attribute if ( el . hasAttr ( \" checked \" ) ) { final String val = el . val ( ) . length ( ) > 0 ? el . val ( ) : \" on \" ; data . add ( HttpConnection . KeyVal . create ( name , val ) ) ; } } else {", "label": 1}
{"buggy_code": "public class test { public void close ( ) throws IOException { finish ( ) ; if ( raf ! = null ) { raf . close ( ) ; }", "fixed_code": "public class test { public void close ( ) throws IOException { if ( raf ! = null ) { raf . close ( ) ; }", "label": 1}
{"buggy_code": "} else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( mode ) ; return mock ; } } \\ No newline at end of file", "fixed_code": "} else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( ) ; } mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , mode ) ) ; return mock ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue }  while ( ! tq . isEmpty ( ) ) { boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( \" , \" ) ) { / / group or while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator ( \" \" ) ; } else { / / E . class , E # id , E [ attr ] etc . AND Elements candidates = findElements ( ) ; / / take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; } private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) { return byId ( ) ; return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { private Elements findElements ( ) { if ( tq . matchChomp ( \" # \" ) ) { return byId ( ) ; return matches ( false ) ; } else if ( tq . matches ( \" : matchesOwn ( \" ) ) { return matches ( true ) ; } else if ( tq . matches ( \" : not ( \" ) ) { return not ( ) ; } else { / / unhandled throw new SelectorParseException ( \" Could not parse query ' % s ' : unexpected token at ' % s ' \" , query , tq . remainder ( ) ) ; } } static Elements filterOut ( Collection < Element > elements , Collection < Element > outs ) { Elements output = new Elements ( ) ; for ( Element el : elements ) { boolean found = false ; for ( Element out : outs ) { if ( el . equals ( out ) ) { found = true ; break ; } } if ( ! found ) output . add ( el ) ; } return output ; } private Elements select ( ) { tq . consumeWhitespace ( ) ;  if ( tq . matchesAny ( combinators ) ) { / / if starts with a combinator , use root as elements elements . add ( root ) ; combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( tq . matches ( \" : has ( \" ) ) { elements . addAll ( root . getAllElements ( ) ) ; } else { addElements ( findElements ( ) ) ; / / chomp first element matcher off queue }  while ( ! tq . isEmpty ( ) ) { boolean seenWhite = tq . consumeWhitespace ( ) ;  if ( tq . matchChomp ( \" , \" ) ) { / / group or while ( ! tq . isEmpty ( ) ) { String subQuery = tq . chompTo ( \" , \" ) ; elements . addAll ( select ( subQuery , root ) ) ; } } else if ( tq . matchesAny ( combinators ) ) { combinator ( tq . consume ( ) . toString ( ) ) ; } else if ( seenWhite ) { combinator ( \" \" ) ; } else { / / E . class , E # id , E [ attr ] etc . AND Elements candidates = findElements ( ) ; / / take next el , # . etc off queue intersectElements ( filterForSelf ( elements , candidates ) ) ; } } return new Elements ( elements ) ; } private Elements not ( ) { tq . consume ( \" : not \" ) ; String subQuery = tq . chompBalanced ( ' ( ' , ' ) ' ) ; Validate . notEmpty ( subQuery , \" : not ( selector ) subselect must not be empty \" ) ;  return filterOut ( root . getAllElements ( ) , select ( subQuery , root ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; } }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { lmPar = FastMath . max ( parl , lmPar + correction ) ; } } }", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; }", "fixed_code": "throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; } if ( buffer [ start ] = = 0 ) { return 0L ; }", "label": 1}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1}
{"buggy_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "fixed_code": "_currInputRowStart = start - ( _inputEnd - _currInputRowStart ) ; / / And then update buffer settings _currBufferStart = start ; _inputBuffer = buf ; _inputPtr = start ; _inputEnd = end ;", "label": 1}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 1}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 1}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 1}
{"buggy_code": "public class test { private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . name ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "fixed_code": "public class test { private void popStackToClose ( Token . EndTag endTag ) { String elName = endTag . normalName ( ) ; Element firstFound = null ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) {", "label": 1}
{"buggy_code": "/ / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "fixed_code": "/ / build the name to index mappings if ( header ! = null ) { for ( int i = 0 ; i < header . length ; i + + ) { if ( hdrMap . containsKey ( header [ i ] ) ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } hdrMap . put ( header [ i ] , Integer . valueOf ( i ) ) ; } }", "label": 1}
{"buggy_code": "public class test { public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; out . append ( recordSeparator ) ; newRecord = true ; } } \\ No newline at end of file", "fixed_code": "public class test { public void println ( ) throws IOException { final String recordSeparator = format . getRecordSeparator ( ) ; if ( recordSeparator ! = null ) { out . append ( recordSeparator ) ; } newRecord = true ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1}
{"buggy_code": "ns = Namespace . XML_NAMESPACE ; } else { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } else {", "fixed_code": "ns = Namespace . XML_NAMESPACE ; } else { NamespaceResolver nsr = parent . getNamespaceResolver ( ) ; if ( nsr ! = null ) { String uri = nsr . getNamespaceURI ( prefix ) ; if ( uri ! = null ) { ns = Namespace . getNamespace ( prefix , uri ) ; } } if ( ns = = null ) { ns = element . getNamespace ( prefix ) ; if ( ns = = null ) { / / TBD : no attributes attributes = Collections . EMPTY_LIST ; return ; } } } } else {", "label": 1}
{"buggy_code": "public class test { protected void verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { verifyNonDup ( creator , C_PROPS , explicit ) ; / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } public void addDelegatingCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ; _arrayDelegateArgs = injectables ; } else { verifyNonDup ( creator , C_DELEGATE , explicit ) ; _delegateArgs = injectables ; } } } \\ No newline at end of file", "fixed_code": "public class test { protected boolean verifyNonDup ( AnnotatedWithParams newOne , int typeIndex , boolean explicit ) { final int mask = ( 1 < < typeIndex ) ; _hasNonDefaultCreator = true ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated if ( ! explicit ) { return false ; } / / both explicit : verify verify = true ; / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return false ; } / / new type more specific , use it } _explicitCreators | = mask ; } _creators [ typeIndex ] = _fixAccess ( newOne ) ; return true ; } public void addDelegatingCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] injectables ) { if ( creator . getParameterType ( 0 ) . isCollectionLikeType ( ) ) { if ( verifyNonDup ( creator , C_ARRAY_DELEGATE , explicit ) ) { _arrayDelegateArgs = injectables ; } } else { if ( verifyNonDup ( creator , C_DELEGATE , explicit ) ) { _delegateArgs = injectables ; } } } public void addPropertyCreator ( AnnotatedWithParams creator , boolean explicit , SettableBeanProperty [ ] properties ) { if ( verifyNonDup ( creator , C_PROPS , explicit ) ) { / / Better ensure we have no duplicate names either . . . if ( properties . length > 1 ) { HashMap < String , Integer > names = new HashMap < String , Integer > ( ) ; } } _propertyBasedArgs = properties ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "fixed_code": "String encoding , boolean useUnicodeExtraFields , boolean allowStoredEntriesWithDataDescriptor ) { this . encoding = encoding ; zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . useUnicodeExtraFields = useUnicodeExtraFields ; in = new PushbackInputStream ( inputStream , buf . capacity ( ) ) ;", "label": 1}
{"buggy_code": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : return new TypePair ( null , null ) ; case FALSE : case UNKNOWN :", "fixed_code": "/ / other types switch ( this . testForEquality ( that ) ) { case TRUE : JSType noType = getNativeType ( JSTypeNative . NO_TYPE ) ; return new TypePair ( noType , noType ) ; case FALSE : case UNKNOWN :", "label": 1}
{"buggy_code": "if ( rawCentralDirectoryData . length ! = expectedLength ) { throw new ZipException ( \" central directory zip64 extended \"", "fixed_code": "( hasCompressedSize ? DWORD : 0 ) ( hasRelativeHeaderOffset ? DWORD : 0 ) ( hasDiskStart ? WORD : 0 ) ; if ( rawCentralDirectoryData . length < expectedLength ) { throw new ZipException ( \" central directory zip64 extended \" \" information extra field ' s length \" \" doesn ' t match central directory \"", "label": 1}
{"buggy_code": "public class test { public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . computeValue ( context ) , args [ 1 ] . computeValue ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; } } \\ No newline at end of file", "fixed_code": "public class test { public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . compute ( context ) , args [ 1 ] . compute ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1}
{"buggy_code": "public class test { public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalMean ( ) { return ( ( double ) ( ( getSampleSize ( ) ) * ( ( getNumberOfSuccesses ( ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; return new JsonLocation ( src , - 1L , getTokenCharacterOffset ( ) , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; } public JsonLocation getTokenLocation ( ) _nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , getTokenCharacterOffset ( ) , - 1L , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; if ( _currToken = = JsonToken . FIELD_NAME ) { return new JsonLocation ( src , - 1L , _nameInputTotal , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , - 1L , _tokenInputTotal , _tokenInputRow , getTokenColumnNr ( ) ) ; } public JsonLocation getTokenLocation ( ) _nameInputTotal , - 1L , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , _tokenInputTotal , - 1L , _tokenInputRow , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1}
{"buggy_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; return m1 . equals ( m2 ) ; } } \\ No newline at end of file", "fixed_code": "Method m1 = invocation . getMethod ( ) ; Method m2 = candidate . getMethod ( ) ; if ( m1 . getName ( ) ! = null & & m1 . getName ( ) . equals ( m2 . getName ( ) ) ) { Class [ ] params1 = m1 . getParameterTypes ( ) ; Class [ ] params2 = m2 . getParameterTypes ( ) ; if ( params1 . length = = params2 . length ) { for ( int i = 0 ; i < params1 . length ; i + + ) { if ( params1 [ i ] ! = params2 [ i ] ) return false ; } return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; if ( option instanceof Argument ) { i . remove ( ) ;", "fixed_code": "/ / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; option . setParent ( this ) ; if ( option instanceof Argument ) { i . remove ( ) ;", "label": 1}
{"buggy_code": "public class test { protected String _asString ( BigDecimal value ) throws IOException { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector return value . toString ( ) ; } public void writeNumber ( BigDecimal value ) throws IOException if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "public class test { protected String _asString ( BigDecimal value ) throws IOException { if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector int scale = value . scale ( ) ; if ( ( scale < - MAX_BIG_DECIMAL_SCALE ) | | ( scale > MAX_BIG_DECIMAL_SCALE ) ) { _reportError ( String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , scale , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ) ; } return value . toPlainString ( ) ; } return value . toString ( ) ; } public void writeNumber ( BigDecimal value ) throws IOException if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; } if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1}
{"buggy_code": "public class test { public void resolve ( SerializerProvider provider ) throws JsonMappingException { _mapSerializer = ( MapSerializer ) provider . handlePrimaryContextualization ( _mapSerializer , _property ) ; } public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , MapSerializer serializer ) { _accessor = accessor ; _property = property ; _mapSerializer = ( MapSerializer ) serializer ; } public void getAndFilter ( Object bean , JsonGenerator gen , SerializerProvider provider , PropertyFilter filter ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFilteredFields ( ( Map < ? , ? > ) value , gen , provider , filter , null ) ; return ; } } public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } } protected JsonSerializer < Object > constructBeanSerializer ( SerializerProvider prov , BeanDescription beanDesc ) TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers MapSerializer anySer = MapSerializer . construct ( null , type , staticTyping , typeSer , null , null , null ) ; / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "fixed_code": "public class test { public void getAndSerialize ( Object bean , JsonGenerator gen , SerializerProvider provider ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" _accessor . getName ( ) + \" ( ) ) not java . util . Map but \" + value . getClass ( ) . getName ( ) ) ; } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFields ( ( Map < ? , ? > ) value , gen , provider ) ; return ; } _serializer . serialize ( value , gen , provider ) ; } public void resolve ( SerializerProvider provider ) throws JsonMappingException { if ( _serializer instanceof ContextualSerializer ) { JsonSerializer < ? > ser = provider . handlePrimaryContextualization ( _serializer , _property ) ; _serializer = ( JsonSerializer < Object > ) ser ; if ( ser instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) ser ; } } } public void getAndFilter ( Object bean , JsonGenerator gen , SerializerProvider provider , PropertyFilter filter ) throws Exception { Object value = _accessor . getValue ( bean ) ; if ( value = = null ) { throw new JsonMappingException ( \" Value returned by ' any - getter ' ( \" _accessor . getName ( ) + \" ( ) ) not java . util . Map but \" + value . getClass ( ) . getName ( ) ) ; } if ( _mapSerializer ! = null ) { _mapSerializer . serializeFilteredFields ( ( Map < ? , ? > ) value , gen , provider , filter , null ) ; return ; } _serializer . serialize ( value , gen , provider ) ; } public AnyGetterWriter ( BeanProperty property , AnnotatedMember accessor , JsonSerializer < ? > serializer ) { _accessor = accessor ; _property = property ; _serializer = ( JsonSerializer < Object > ) serializer ; if ( serializer instanceof MapSerializer ) { _mapSerializer = ( MapSerializer ) serializer ; } } protected JsonSerializer < Object > constructBeanSerializer ( SerializerProvider prov , BeanDescription beanDesc ) TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers JsonSerializer < ? > anySer = findSerializerFromAnnotation ( prov , anyGetter ) ; if ( anySer = = null ) { / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? } / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "label": 1}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ; }", "label": 1}
{"buggy_code": "public class test { public Timer ( long durationMillis ) { this . durationMillis = durationMillis ; } } \\ No newline at end of file", "fixed_code": "public class test { public Timer ( long durationMillis ) { validateInput ( durationMillis ) ; this . durationMillis = durationMillis ; } private void validateInput ( long durationMillis ) { if ( durationMillis < 0 ) { new Reporter ( ) . cannotCreateTimerWithNegativeDurationTime ( durationMillis ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { return result ; } public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { return result ; } public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return false ; } } return len > 0 ; } } \\ No newline at end of file", "fixed_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1}
{"buggy_code": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText } } \\ No newline at end of file", "fixed_code": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private int getRelativePositionByQName ( ) { int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { String nm = n . getNodeName ( ) ; if ( nm . equals ( node . getNodeName ( ) ) ) { count + + ; } } n = n . getPreviousSibling ( ) ; }", "fixed_code": "public class test { private boolean matchesQName ( Node n ) { if ( getNamespaceURI ( ) ! = null ) { return equalStrings ( getNamespaceURI ( n ) , getNamespaceURI ( ) ) & & equalStrings ( node . getLocalName ( ) , n . getLocalName ( ) ) ; } return equalStrings ( node . getNodeName ( ) , n . getNodeName ( ) ) ; } private int getRelativePositionByQName ( ) { int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE & & matchesQName ( n ) ) { count + + ; } n = n . getPreviousSibling ( ) ; }", "label": 1}
{"buggy_code": "public class test { public WriteableCommandLineImpl ( final Option rootOption , final List arguments ) { this . prefixes = rootOption . getPrefixes ( ) ; this . normalised = arguments ; } public boolean looksLikeOption ( final String trigger ) { / / this is a reentrant call for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public void setCurrentOption ( Option currentOption ) { this . currentOption = currentOption ; } public boolean looksLikeOption ( final String trigger ) { if ( checkForOption ! = null ) { / / this is a reentrant call return ! checkForOption . equals ( trigger ) ; } checkForOption = trigger ; try { for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { if ( getCurrentOption ( ) . canProcess ( this , trigger ) | | getCurrentOption ( ) . findOption ( trigger ) ! = null ) { return true ; } } }  return false ; } finally { checkForOption = null ; } } public WriteableCommandLineImpl ( final Option rootOption , final List arguments ) { this . prefixes = rootOption . getPrefixes ( ) ; this . normalised = arguments ; setCurrentOption ( rootOption ) ; } public Option getCurrentOption ( ) { return currentOption ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 1}
{"buggy_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { _gotName = false ; return STATUS_OK_AFTER_COLON ;", "fixed_code": "public int writeValue ( ) { / / Most likely , object : if ( _type = = TYPE_OBJECT ) { if ( ! _gotName ) { return STATUS_EXPECT_NAME ; } _gotName = false ; + _index ; return STATUS_OK_AFTER_COLON ;", "label": 1}
{"buggy_code": "public class test { static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { static float toJavaVersionInt ( String s ) { return Float . parseFloat ( s ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } return getValueAsString ( null ) ; } public String getValueAsString ( String defaultValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } return getText ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getValueAsString ( String defaultValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } return getText ( ) ; } public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return getValueAsString ( null ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( Map . class . isAssignableFrom ( rawType ) ) { if ( SortedMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ;", "fixed_code": "} if ( Map . class . isAssignableFrom ( rawType ) ) { if ( ConcurrentNavigableMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new ConcurrentSkipListMap < Object , Object > ( ) ; } } ; } else if ( ConcurrentMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new ConcurrentHashMap < Object , Object > ( ) ; } } ; } else if ( SortedMap . class . isAssignableFrom ( rawType ) ) { return new ObjectConstructor < T > ( ) { @ Override public T construct ( ) { return ( T ) new TreeMap < Object , Object > ( ) ;", "label": 1}
{"buggy_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( hasReferenceName ( ) ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1}
{"buggy_code": "public class test { private int getRelativePositionByQName ( ) { int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { String nm = n . getNodeName ( ) ; if ( nm . equals ( node . getNodeName ( ) ) ) { count + + ; } } n = n . getPreviousSibling ( ) ; } return count ; } private int getRelativePositionByQName ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . getParent ( ) ; String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( ( child instanceof Element ) & & ( ( Element ) child ) . getQualifiedName ( ) . equals ( name ) ) { count + + ; } if ( child = = node ) {", "fixed_code": "public class test { private boolean matchesQName ( Node n ) { if ( getNamespaceURI ( ) ! = null ) { return equalStrings ( getNamespaceURI ( n ) , getNamespaceURI ( ) ) & & equalStrings ( node . getLocalName ( ) , n . getLocalName ( ) ) ; } return equalStrings ( node . getNodeName ( ) , n . getNodeName ( ) ) ; } private int getRelativePositionByQName ( ) { int count = 1 ; Node n = node . getPreviousSibling ( ) ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE & & matchesQName ( n ) ) { count + + ; } n = n . getPreviousSibling ( ) ; } return count ; } private boolean matchesQName ( Element element ) { if ( getNamespaceURI ( ) ! = null ) { String ns = getNamespaceURI ( element ) ; if ( ns = = null | | ! ns . equals ( getNamespaceURI ( ) ) ) { return false ; } } return element . getName ( ) . equals ( ( ( Element ) node ) . getName ( ) ) ; } private int getRelativePositionByQName ( ) { if ( node instanceof Element ) { Object parent = ( ( Element ) node ) . getParent ( ) ; String name = ( ( Element ) node ) . getQualifiedName ( ) ; for ( int i = 0 ; i < children . size ( ) ; i + + ) { Object child = children . get ( i ) ; if ( child instanceof Element & & matchesQName ( ( ( Element ) child ) ) ) { count + + ; } if ( child = = node ) {", "label": 1}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } / / augment the list with the default values if ( ( valueList = = null ) | | valueList . isEmpty ( ) ) { valueList = ( List ) this . defaultValues . get ( option ) ; } / / if there are more default values as specified , add them to / / the list . / / copy the list first return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "fixed_code": "List valueList = ( List ) values . get ( option ) ; / / grab the correct default values if ( defaultValues = = null | | defaultValues . isEmpty ( ) ) { defaultValues = ( List ) this . defaultValues . get ( option ) ; } / / augment the list with the default values if ( defaultValues ! = null & & ! defaultValues . isEmpty ( ) ) { if ( valueList = = null | | valueList . isEmpty ( ) ) { valueList = defaultValues ; } else { / / if there are more default values as specified , add them to / / the list . if ( defaultValues . size ( ) > valueList . size ( ) ) { / / copy the list first valueList = new ArrayList ( valueList ) ; for ( int i = valueList . size ( ) ; i < defaultValues . size ( ) ; i + + ) { valueList . add ( defaultValues . get ( i ) ) ; } } } } return valueList = = null ? Collections . EMPTY_LIST : valueList ; }", "label": 1}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { / / accept the step loop = false ;", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { / / accept the step loop = false ;", "label": 1}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1}
{"buggy_code": "ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( mode ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( mode = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "fixed_code": "ret . setDevice ( readAsciiLong ( 6 , 8 ) ) ; ret . setInode ( readAsciiLong ( 6 , 8 ) ) ; final long mode = readAsciiLong ( 6 , 8 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 6 , 8 ) ) ; ret . setSize ( readAsciiLong ( 11 , 8 ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } ret . setDevice ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setInode ( readBinaryLong ( 2 , swapHalfWord ) ) ; final long mode = readBinaryLong ( 2 , swapHalfWord ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { ret . setMode ( mode ) ; } ret . setUID ( readBinaryLong ( 2 , swapHalfWord ) ) ; ret . setSize ( readBinaryLong ( 4 , swapHalfWord ) ) ; final String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ; ret . setInode ( readAsciiLong ( 8 , 16 ) ) ; long mode = readAsciiLong ( 8 , 16 ) ; if ( CpioUtil . fileType ( mode ) ! = 0 ) { / / mode is initialised to 0 ret . setMode ( mode ) ; } ret . setUID ( readAsciiLong ( 8 , 16 ) ) ; ret . setChksum ( readAsciiLong ( 8 , 16 ) ) ; String name = readCString ( ( int ) namesize ) ; ret . setName ( name ) ; if ( CpioUtil . fileType ( mode ) = = 0 & & ! name . equals ( CPIO_TRAILER ) ) { throw new IOException ( \" Mode 0 only allowed in the trailer . Found entry name : \" + name + \" Occured at byte : \" + getBytesRead ( ) ) ; } skip ( ret . getHeaderPadCount ( ) ) ;", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "fixed_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1}
{"buggy_code": "public class test { private String formatMethodCall ( ) { return invocation . getMethod ( ) . getName ( ) + \" ( ) \" ; } } \\ No newline at end of file", "fixed_code": "public class test { private String formatMethodCall ( ) { String args = Arrays . toString ( invocation . getArguments ( ) ) ; return invocation . getMethod ( ) . getName ( ) + \" ( \" + args . substring ( 1 , args . length ( ) - 1 ) + \" ) \" ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } private void visitLabel ( Node node , Node parent ) { Node nameNode = node . getFirstChild ( ) ; String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } private void visitLabel ( Node node , Node parent ) { Node nameNode = node . getFirstChild ( ) ; String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1}
{"buggy_code": "public class test { public static JsonSerializer < Object > getFallbackKeySerializer ( SerializationConfig config , Class < ? > rawKeyType ) { return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return new Default ( Default . TYPE_ENUM , rawKeyType ) ; } } return DEFAULT_KEY_SERIALIZER ; } } \\ No newline at end of file", "fixed_code": "public class test { public void serialize ( Object value , JsonGenerator g , SerializerProvider serializers ) throws IOException { if ( serializers . isEnabled ( SerializationFeature . WRITE_ENUMS_USING_TO_STRING ) ) { g . writeFieldName ( value . toString ( ) ) ; return ; } Enum < ? > en = ( Enum < ? > ) value ; g . writeFieldName ( _values . serializedValueFor ( en ) ) ; } public static JsonSerializer < Object > getFallbackKeySerializer ( SerializationConfig config , Class < ? > rawKeyType ) { return new Dynamic ( ) ; } if ( rawKeyType . isEnum ( ) ) { return EnumKeySerializer . construct ( rawKeyType , EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) rawKeyType ) ) ; } } return DEFAULT_KEY_SERIALIZER ; } public static EnumKeySerializer construct ( Class < ? > enumType , EnumValues enumValues ) { return new EnumKeySerializer ( enumType , enumValues ) ; } protected EnumKeySerializer ( Class < ? > enumType , EnumValues values ) { super ( enumType , false ) ; _values = values ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public synchronized String getPrefix ( String namespaceURI ) {  if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; NodeIterator ni = pointer . namespaceIterator ( ) ; if ( ni ! = null ) { for ( int position = 1 ; ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { reverseMap . put ( uri , prefix ) ; } } } Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; if ( prefix = = null & & parent ! = null ) { return parent . getPrefix ( namespaceURI ) ; } return prefix ; } public synchronized String getNamespaceURI ( String prefix ) {  String uri = ( String ) namespaceMap . get ( prefix ) ; if ( uri = = null & & pointer ! = null ) { uri = pointer . getNamespaceURI ( prefix ) ; } if ( uri = = null & & parent ! = null ) { return parent . getNamespaceURI ( prefix ) ; } return uri ; } } \\ No newline at end of file", "fixed_code": "public class test { protected synchronized String getExternallyRegisteredNamespaceURI ( String prefix ) { String uri = ( String ) namespaceMap . get ( prefix ) ; return uri = = null & & parent ! = null ? parent . getExternallyRegisteredNamespaceURI ( prefix ) : uri ; } protected synchronized String getExternallyRegisteredPrefix ( String namespaceURI ) { if ( reverseMap = = null ) { reverseMap = new HashMap ( ) ; Iterator it = namespaceMap . entrySet ( ) . iterator ( ) ; while ( it . hasNext ( ) ) { Map . Entry entry = ( Map . Entry ) it . next ( ) ; } } String prefix = ( String ) reverseMap . get ( namespaceURI ) ; return prefix = = null & & parent ! = null ? parent . getExternallyRegisteredPrefix ( namespaceURI ) : prefix ; } public synchronized String getPrefix ( String namespaceURI ) { String prefix = getExternallyRegisteredPrefix ( namespaceURI ) ; return prefix = = null & & pointer ! = null ? getPrefix ( pointer , namespaceURI ) : prefix ; } protected static String getPrefix ( NodePointer pointer , String namespaceURI ) { NodePointer currentPointer = pointer ; while ( currentPointer ! = null ) { NodeIterator ni = currentPointer . namespaceIterator ( ) ; for ( int position = 1 ; ni ! = null & & ni . setPosition ( position ) ; position + + ) { NodePointer nsPointer = ni . getNodePointer ( ) ; String uri = nsPointer . getNamespaceURI ( ) ; if ( uri . equals ( namespaceURI ) ) { String prefix = nsPointer . getName ( ) . getName ( ) ; if ( ! \" \" . equals ( prefix ) ) { return prefix ; } } } currentPointer = pointer . getParent ( ) ; } return null ; } public synchronized String getNamespaceURI ( String prefix ) { String uri = getExternallyRegisteredNamespaceURI ( prefix ) ; return uri = = null & & pointer ! = null ? pointer . getNamespaceURI ( prefix ) : uri ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected final JsonToken _nextTokenWithBuffering ( final TokenFilterContext buffRoot ) throws IOException { continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return _nextBuffered ( buffRoot ) ; } } / / Otherwise not included ( leaves must be explicitly included ) } } } protected final JsonToken _nextToken2 ( ) throws IOException { main_loop : } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } break ; } } } public JsonToken nextToken ( ) throws IOException {   if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { if ( _currToken . isScalarValue ( ) & & ! _headContext . isStartHandled ( ) & & ! _includePath & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } TokenFilterContext ctxt = _exposedContext ;  if ( ctxt ! = null ) { while ( true ) { JsonToken t = ctxt . nextTokenToRead ( ) ; if ( t ! = null ) { _currToken = t ; return t ; } if ( ctxt = = _headContext ) { _exposedContext = null ; if ( ctxt . inArray ( ) ) { t = delegate . getCurrentToken ( ) ; _currToken = t ; return t ; }  break ; } ctxt = _headContext . findChildOf ( ctxt ) ; _exposedContext = ctxt ; if ( ctxt = = null ) { / / should never occur throw _constructError ( \" Unexpected problem : chain of filtered context broken \" ) ; } } }  JsonToken t = delegate . nextToken ( ) ; if ( t = = null ) { _currToken = t ; return t ; }  TokenFilter f ;  switch ( t . id ( ) ) { case ID_START_ARRAY : f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildArrayContext ( f , true ) ; return ( _currToken = t ) ; } if ( f = = null ) { / / does this occur ? delegate . skipChildren ( ) ; break ; } f = _headContext . checkValue ( f ) ; if ( f = = null ) { delegate . skipChildren ( ) ; break ; } if ( f ! = TokenFilter . INCLUDE_ALL ) { f = f . filterStartArray ( ) ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildArrayContext ( f , true ) ; return ( _currToken = t ) ; } _headContext = _headContext . createChildArrayContext ( f , false ) ;  if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ;  case ID_START_OBJECT : f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildObjectContext ( f , true ) ; return ( _currToken = t ) ; } if ( f = = null ) { / / does this occur ? delegate . skipChildren ( ) ; break ; } f = _headContext . checkValue ( f ) ; if ( f = = null ) { delegate . skipChildren ( ) ; break ; } if ( f ! = TokenFilter . INCLUDE_ALL ) { f = f . filterStartObject ( ) ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildObjectContext ( f , true ) ; return ( _currToken = t ) ; } _headContext = _headContext . createChildObjectContext ( f , false ) ; if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ;  case ID_END_ARRAY : case ID_END_OBJECT : { boolean returnEnd = _headContext . isStartHandled ( ) ; f = _headContext . getFilter ( ) ; if ( ( f ! = null ) & & ( f ! = TokenFilter . INCLUDE_ALL ) ) { f . filterFinishArray ( ) ; } _headContext = _headContext . getParent ( ) ; _itemFilter = _headContext . getFilter ( ) ; if ( returnEnd ) { return ( _currToken = t ) ; } } break ;  case ID_FIELD_NAME : { final String name = delegate . getCurrentName ( ) ; f = _headContext . setFieldName ( name ) ; if ( f = = TokenFilter . INCLUDE_ALL ) { _itemFilter = f ; if ( ! _includePath ) { if ( _includeImmediateParent & & ! _headContext . isStartHandled ( ) ) { t = _headContext . nextTokenToRead ( ) ; / / returns START_OBJECT but also marks it handled _exposedContext = _headContext ; } } return ( _currToken = t ) ; } if ( f = = null ) { delegate . nextToken ( ) ; delegate . skipChildren ( ) ; break ; } f = f . includeProperty ( name ) ; if ( f = = null ) { delegate . nextToken ( ) ; delegate . skipChildren ( ) ; break ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _includePath ) { return ( _currToken = t ) ; } } if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ; }  default : / / scalar value f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { return ( _currToken = t ) ; } if ( f ! = null ) { f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { return ( _currToken = t ) ; } } break ; }  return _nextToken2 ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public JsonToken nextToken ( ) throws IOException {   if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { if ( _currToken . isScalarValue ( ) & & ! _headContext . isStartHandled ( ) & & ! _includePath & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } TokenFilterContext ctxt = _exposedContext ;  if ( ctxt ! = null ) { while ( true ) { JsonToken t = ctxt . nextTokenToRead ( ) ; if ( t ! = null ) { _currToken = t ; return t ; } if ( ctxt = = _headContext ) { _exposedContext = null ; if ( ctxt . inArray ( ) ) { t = delegate . getCurrentToken ( ) ; _currToken = t ; return t ; }  break ; } ctxt = _headContext . findChildOf ( ctxt ) ; _exposedContext = ctxt ; if ( ctxt = = null ) { / / should never occur throw _constructError ( \" Unexpected problem : chain of filtered context broken \" ) ; } } }  JsonToken t = delegate . nextToken ( ) ; if ( t = = null ) { _currToken = t ; return t ; }  TokenFilter f ;  switch ( t . id ( ) ) { case ID_START_ARRAY : f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildArrayContext ( f , true ) ; return ( _currToken = t ) ; } if ( f = = null ) { / / does this occur ? delegate . skipChildren ( ) ; break ; } f = _headContext . checkValue ( f ) ; if ( f = = null ) { delegate . skipChildren ( ) ; break ; } if ( f ! = TokenFilter . INCLUDE_ALL ) { f = f . filterStartArray ( ) ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildArrayContext ( f , true ) ; return ( _currToken = t ) ; } _headContext = _headContext . createChildArrayContext ( f , false ) ;  if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ;  case ID_START_OBJECT : f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildObjectContext ( f , true ) ; return ( _currToken = t ) ; } if ( f = = null ) { / / does this occur ? delegate . skipChildren ( ) ; break ; } f = _headContext . checkValue ( f ) ; if ( f = = null ) { delegate . skipChildren ( ) ; break ; } if ( f ! = TokenFilter . INCLUDE_ALL ) { f = f . filterStartObject ( ) ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { _headContext = _headContext . createChildObjectContext ( f , true ) ; return ( _currToken = t ) ; } _headContext = _headContext . createChildObjectContext ( f , false ) ; if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ;  case ID_END_ARRAY : case ID_END_OBJECT : { boolean returnEnd = _headContext . isStartHandled ( ) ; f = _headContext . getFilter ( ) ; if ( ( f ! = null ) & & ( f ! = TokenFilter . INCLUDE_ALL ) ) { f . filterFinishArray ( ) ; } _headContext = _headContext . getParent ( ) ; _itemFilter = _headContext . getFilter ( ) ; if ( returnEnd ) { return ( _currToken = t ) ; } } break ;  case ID_FIELD_NAME : { final String name = delegate . getCurrentName ( ) ; f = _headContext . setFieldName ( name ) ; if ( f = = TokenFilter . INCLUDE_ALL ) { _itemFilter = f ; if ( ! _includePath ) { if ( _includeImmediateParent & & ! _headContext . isStartHandled ( ) ) { t = _headContext . nextTokenToRead ( ) ; / / returns START_OBJECT but also marks it handled _exposedContext = _headContext ; } } return ( _currToken = t ) ; } if ( f = = null ) { delegate . nextToken ( ) ; delegate . skipChildren ( ) ; break ; } f = f . includeProperty ( name ) ; if ( f = = null ) { delegate . nextToken ( ) ; delegate . skipChildren ( ) ; break ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } } if ( _includePath ) { t = _nextTokenWithBuffering ( _headContext ) ; if ( t ! = null ) { _currToken = t ; return t ; } } break ; }  default : / / scalar value f = _itemFilter ; if ( f = = TokenFilter . INCLUDE_ALL ) { return ( _currToken = t ) ; } if ( f ! = null ) { f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } break ; }  return _nextToken2 ( ) ; } protected final JsonToken _nextTokenWithBuffering ( final TokenFilterContext buffRoot ) throws IOException { continue main_loop ; } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL & & _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return _nextBuffered ( buffRoot ) ; } } } / / Otherwise not included ( leaves must be explicitly included ) } } } private final boolean _verifyAllowedMatches ( ) throws IOException { if ( _matchCount = = 0 | | _allowMultipleMatches ) { + + _matchCount ; return true ; } return false ; } protected final JsonToken _nextToken2 ( ) throws IOException { main_loop : } _itemFilter = f ; if ( f = = TokenFilter . INCLUDE_ALL ) { if ( _verifyAllowedMatches ( ) & & _includePath ) { return ( _currToken = t ) ; } / / if ( _includeImmediateParent ) { . . . f = _headContext . checkValue ( f ) ; if ( ( f = = TokenFilter . INCLUDE_ALL ) | | ( ( f ! = null ) & & f . includeValue ( delegate ) ) ) { if ( _verifyAllowedMatches ( ) ) { return ( _currToken = t ) ; } } } break ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ;", "fixed_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , orderedInstanceFields , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ;", "label": 1}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1}
{"buggy_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "fixed_code": "void writePaxHeaders ( String entryName , Map < String , String > headers ) throws IOException { String name = \" . / PaxHeaders . X / \" + stripTo7Bits ( entryName ) ; while ( name . endsWith ( \" / \" ) ) { / / TarEntry ' s constructor would think this is a directory / / and not allow any data to be written name = name . substring ( 0 , name . length ( ) - 1 ) ; } if ( name . length ( ) > = TarConstants . NAMELEN ) { name = name . substring ( 0 , TarConstants . NAMELEN - 1 ) ; }", "label": 1}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; } } \\ No newline at end of file", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private boolean hasExceptionHandler ( Node cfgNode ) { return false ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean hasExceptionHandler ( Node cfgNode ) { List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { if ( edge . getValue ( ) = = Branch . ON_EX ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 1}
{"buggy_code": "public class test { public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } public void serializeWithType ( Object value , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer ) throws IOException * let ' s give it a chance ? Object delegateValue = convertValue ( value ) ; _delegateSerializer . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; return _delegateSerializer . isEmpty ( delegateValue ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { Object delegateValue = convertValue ( value ) ; if ( delegateValue = = null ) { provider . defaultSerializeNull ( gen ) ; return ; } _delegateSerializer . serialize ( delegateValue , gen , provider ) ; } public void acceptJsonFormatVisitor ( JsonFormatVisitorWrapper visitor , JavaType typeHint ) throws JsonMappingException { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException delSer = provider . findValueSerializer ( delegateType ) ; } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } return ( delSer = = _delegateSerializer ) ? this : withDelegate ( _converter , delegateType , delSer ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void acceptJsonFormatVisitor ( JsonFormatVisitorWrapper visitor , JavaType typeHint ) throws JsonMappingException { if ( _delegateSerializer ! = null ) { _delegateSerializer . acceptJsonFormatVisitor ( visitor , typeHint ) ; } } public void serializeWithType ( Object value , JsonGenerator gen , SerializerProvider provider , TypeSerializer typeSer ) throws IOException * let ' s give it a chance ? Object delegateValue = convertValue ( value ) ; JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( value , provider ) ; } ser . serializeWithType ( delegateValue , gen , provider , typeSer ) ; } protected JsonSerializer < Object > _findSerializer ( Object value , SerializerProvider serializers ) throws JsonMappingException { return serializers . findValueSerializer ( value . getClass ( ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) throws JsonMappingException if ( ! delegateType . isJavaLangObject ( ) ) { delSer = provider . findValueSerializer ( delegateType ) ; } } if ( delSer instanceof ContextualSerializer ) { delSer = provider . handleSecondaryContextualization ( delSer , property ) ; } if ( delSer = = _delegateSerializer & & delegateType = = _delegateType ) { return this ; } return withDelegate ( _converter , delegateType , delSer ) ; } public boolean isEmpty ( SerializerProvider prov , Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( prov , delegateValue ) ; } public boolean isEmpty ( Object value ) { Object delegateValue = convertValue ( value ) ; if ( _delegateSerializer = = null ) { / / best we can do for now , too costly to look up return ( value = = null ) ; } return _delegateSerializer . isEmpty ( delegateValue ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { Object delegateValue = convertValue ( value ) ; if ( delegateValue = = null ) { provider . defaultSerializeNull ( gen ) ; return ; } JsonSerializer < Object > ser = _delegateSerializer ; if ( ser = = null ) { ser = _findSerializer ( delegateValue , provider ) ; } ser . serialize ( delegateValue , gen , provider ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return new JsonMappingException ( null , String . format ( \" Unexpected IOException ( of type % s ) : % s \" , src . getClass ( ) . getName ( ) , src . getMessage ( ) ) ) ; } public static JsonMappingException wrapWithPath ( Throwable src , Reference ref ) { jme = ( JsonMappingException ) src ; } else { / / [ databind # 2128 ] : try to avoid duplication String msg = src . getMessage ( ) ; / / Let ' s use a more meaningful placeholder if all we have is null if ( msg = = null | | msg . length ( ) = = 0 ) { msg = \" ( was \" + src . getClass ( ) . getName ( ) + \" ) \" ;", "fixed_code": "return new JsonMappingException ( null , String . format ( \" Unexpected IOException ( of type % s ) : % s \" , src . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( src ) ) ) ; } public static JsonMappingException wrapWithPath ( Throwable src , Reference ref ) { jme = ( JsonMappingException ) src ; } else { / / [ databind # 2128 ] : try to avoid duplication String msg = ClassUtil . exceptionMessage ( src ) ; / / Let ' s use a more meaningful placeholder if all we have is null if ( msg = = null | | msg . length ( ) = = 0 ) { msg = \" ( was \" + src . getClass ( ) . getName ( ) + \" ) \" ;", "label": 1}
{"buggy_code": "public class test { Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag .", "fixed_code": "public class test { Element insert ( final Token . StartTag startTag ) { / / cleanup duplicate attributes : if ( ! startTag . attributes . isEmpty ( ) ) { int dupes = startTag . attributes . deduplicate ( settings ) ; if ( dupes > 0 ) { error ( \" Duplicate attribute \" ) ; } } / / handle empty unknown tags / / when the spec expects an empty tag , will directly hit insertEmpty , so won ' t generate this fake end tag .", "label": 1}
{"buggy_code": "while ( true ) { int lastPos = pos ; text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; } else if ( pos = = lastPos ) { throw new RuntimeException ( \" Text too long for line - throwing exception to avoid infinite loop [ CLI - 162 ] : \" + text ) ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; sb . append ( text ) ; return sb ; }  if ( ( text . length ( ) > width ) & & ( pos = = nextLineTabStop - 1 ) ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;", "label": 1}
{"buggy_code": "public class test { private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "public class test { private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1}
{"buggy_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } final int hi = offs + len ; int destOffs = offs ;", "fixed_code": "if ( this . in = = null ) { throw new IOException ( \" stream closed \" ) ; } if ( len = = 0 ) { return 0 ; } final int hi = offs + len ; int destOffs = offs ;", "label": 1}
{"buggy_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "fixed_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "label": 1}
{"buggy_code": "if ( _dateFormat = = df ) { return this ; } TimeZone tz = ( df = = null ) ? _timeZone : df . getTimeZone ( ) ; return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , tz , _defaultBase64 ) ; } } \\ No newline at end of file", "fixed_code": "if ( _dateFormat = = df ) { return this ; } return new BaseSettings ( _classIntrospector , _annotationIntrospector , _visibilityChecker , _propertyNamingStrategy , _typeFactory , _typeResolverBuilder , df , _handlerInstantiator , _locale , _timeZone , _defaultBase64 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "* will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "fixed_code": "* will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "label": 1}
{"buggy_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) } }", "fixed_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) if ( ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } else { / / this means there is an invocation on a different mock . Re - adding verification mode / / - see VerifyingWithAnExtraCallToADifferentMockTest ( bug 138 ) mockingProgress . verificationStarted ( verificationMode ) ; } }", "label": 1}
{"buggy_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous ! = null ) & & previous . equals ( ann ) ; } } \\ No newline at end of file", "fixed_code": "_annotations = new HashMap < Class < ? extends Annotation > , Annotation > ( ) ; } Annotation previous = _annotations . put ( ann . annotationType ( ) , ann ) ; return ( previous = = null ) | | ! previous . equals ( ann ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { void setInitialBuffer ( byte [ ] out , int outPos , int outAvail ) { if ( out ! = null & & out . length = = outAvail ) { buffer = out ; pos = outPos ; readPos = outPos ; } } public int read ( byte b [ ] , int offset , int len ) throws IOException { if ( b = = null ) { throw new NullPointerException ( ) ; if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( c > 0 & & b . length = = len ) { base64 . setInitialBuffer ( b , offset , len ) ; } if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "fixed_code": "public class test { public int read ( byte b [ ] , int offset , int len ) throws IOException { if ( b = = null ) { throw new NullPointerException ( ) ; if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "label": 1}
{"buggy_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; Validate . notEmpty ( name ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "fixed_code": "public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ;", "label": 1}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "label": 1}
{"buggy_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "fixed_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( param . isName ( ) | | param . isGetProp ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "label": 1}
{"buggy_code": "public class test { private void handleBlockComment ( Comment comment ) {", "fixed_code": "public class test { private void handleBlockComment ( Comment comment ) {", "label": 1}
{"buggy_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "fixed_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "label": 1}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "label": 1}
{"buggy_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "fixed_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "label": 1}
{"buggy_code": "} break ; } if ( lineLength > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "fixed_code": "} break ; } if ( lineLength > 0 & & pos > 0 ) { System . arraycopy ( lineSeparator , 0 , buf , pos , lineSeparator . length ) ; pos + = lineSeparator . length ; }", "label": 1}
{"buggy_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "fixed_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1}
{"buggy_code": "public class test { boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; } boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( _valueDeserializer . getNullValue ( ctxt ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public boolean isSupportUpperBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSupportUpperBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "label": 1}
{"buggy_code": "public class test { public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; }", "fixed_code": "if ( extTypes ! = null ) { / / 21 - Jun - 2016 , tatu : related to [ databind # 999 ] , may need to link type ids too , / / so need to pass collected properties _externalTypeIdHandler = extTypes . build ( _beanProperties ) ; / / we consider this non - standard , to offline handling _nonStandardCreation = true ; }", "label": 1}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "label": 1}
{"buggy_code": "public class test { Assign ( Node assignNode , Node nameNode , boolean isPropertyAssign ) { Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ; this . assignNode = assignNode ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ;  this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | | NodeUtil . mayHaveSideEffects ( assignNode . getLastChild ( ) ) ; } private void interpretAssigns ( ) { boolean changes = false ; do { assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; } } while ( changes ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private void interpretAssigns ( ) { boolean changes = false ; do { assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; } } while ( changes ) ; } Assign ( Node assignNode , Node nameNode , boolean isPropertyAssign ) { Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ; this . assignNode = assignNode ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ;  this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | | NodeUtil . mayHaveSideEffects ( assignNode . getLastChild ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . buffer . assignParameter ( typeProp , typeId ) ; } } }", "fixed_code": "if ( ( typeProp ! = null ) & & ( typeProp . getCreatorIndex ( ) > = 0 ) ) { / / 31 - May - 2018 , tatu : [ databind # 1328 ] if id is NOT plain ` String ` , need to / / apply deserializer . . . fun fun . final Object v ; if ( typeProp . getType ( ) . hasRawClass ( String . class ) ) { v = typeId ; } else { TokenBuffer tb = new TokenBuffer ( p , ctxt ) ; tb . writeString ( typeId ) ; v = typeProp . getValueDeserializer ( ) . deserialize ( tb . asParserOnFirstToken ( ) , ctxt ) ; tb . close ( ) ; } buffer . assignParameter ( typeProp , v ) ; } } }", "label": 1}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1}
{"buggy_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; } } \\ No newline at end of file", "fixed_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "{ / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , null , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } } \\ No newline at end of file", "fixed_code": "{ / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 2 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , keyT , valueT ) ; } / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , bindings , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected JsonToken _parseNumber ( int ch ) throws IOException { boolean negative = ( ch = = INT_MINUS ) ; int ptr = _inputPtr ; int startPtr = ptr - 1 ; / / to include sign / digit already read final int inputLen = _inputEnd ;  dummy_loop : do { / / dummy loop , to be able to break out if ( negative ) { / / need to read the next digit if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = _inputBuffer [ ptr + + ] ; if ( ch > INT_9 | | ch < INT_0 ) { _inputPtr = ptr ; return _handleInvalidNumberStart ( ch , true ) ; } } if ( ch = = INT_0 ) { break dummy_loop ; }   int intLen = 1 ; / / already got one   int_loop : while ( true ) { if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break int_loop ; } + + intLen ; }  int fractLen = 0 ;  if ( ch = = ' . ' ) { / / yes , fraction fract_loop : while ( true ) { if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break fract_loop ; } + + fractLen ; } if ( fractLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Decimal point not followed by a digit \" ) ; } }  int expLen = 0 ; if ( ch = = ' e ' | | ch = = ' E ' ) { / / and / or exponent if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch = = INT_MINUS | | ch = = INT_PLUS ) { / / yup , skip for now if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } while ( ch < = INT_9 & & ch > = INT_0 ) { + + expLen ; if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } if ( expLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Exponent indicator not followed by a digit \" ) ; } } - - ptr ; / / need to push back following separator _inputPtr = ptr ; int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; } while ( false ) ;  _inputPtr = negative ? ( startPtr + 1 ) : startPtr ; return _parseNumber2 ( negative ) ; } private JsonToken _parseNumber2 ( boolean negative ) throws IOException { / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { - _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return reset ( negative , intLen , fractLen , expLen ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private final void _verifyRootSpace ( int ch ) throws IOException { + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; } private JsonToken _parseNumber2 ( boolean negative ) throws IOException { / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return reset ( negative , intLen , fractLen , expLen ) ; } protected JsonToken _parseNumber ( int ch ) throws IOException { boolean negative = ( ch = = INT_MINUS ) ; int ptr = _inputPtr ; int startPtr = ptr - 1 ; / / to include sign / digit already read final int inputLen = _inputEnd ;  dummy_loop : do { / / dummy loop , to be able to break out if ( negative ) { / / need to read the next digit if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = _inputBuffer [ ptr + + ] ; if ( ch > INT_9 | | ch < INT_0 ) { _inputPtr = ptr ; return _handleInvalidNumberStart ( ch , true ) ; } } if ( ch = = INT_0 ) { break dummy_loop ; }   int intLen = 1 ; / / already got one   int_loop : while ( true ) { if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break int_loop ; } + + intLen ; }  int fractLen = 0 ;  if ( ch = = ' . ' ) { / / yes , fraction fract_loop : while ( true ) { if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break fract_loop ; } + + fractLen ; } if ( fractLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Decimal point not followed by a digit \" ) ; } }  int expLen = 0 ; if ( ch = = ' e ' | | ch = = ' E ' ) { / / and / or exponent if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch = = INT_MINUS | | ch = = INT_PLUS ) { / / yup , skip for now if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } while ( ch < = INT_9 & & ch > = INT_0 ) { + + expLen ; if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } if ( expLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Exponent indicator not followed by a digit \" ) ; } } - - ptr ; / / need to push back following separator _inputPtr = ptr ; if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( ch ) ; } int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; } while ( false ) ;  _inputPtr = negative ? ( startPtr + 1 ) : startPtr ; return _parseNumber2 ( negative ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "label": 1}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; } } \\ No newline at end of file", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( array [ i ] ! = null ) { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly } } \\ No newline at end of file", "fixed_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction outBuf [ outPtr + + ] = c ; fract_loop : / / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "fixed_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = c ; fract_loop : / / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "label": 1}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"buggy_code": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null ) { return scope ; } boolean hasLendsName = n . getJSDocInfo ( ) ! = null & & n . getJSDocInfo ( ) . getLendsName ( ) ! = null ; if ( objectType . hasReferenceName ( ) & & ! hasLendsName ) { return scope ; } } / / Prototype sets are always declared . boolean inferred = true ; if ( info ! = null ) {", "fixed_code": "/ / See CodingConvention # getObjectLiteralCase and goog . object . reflect . / / Ignore these types of literals . ObjectType objectType = ObjectType . cast ( type ) ; if ( objectType = = null | | n . getBooleanProp ( Node . REFLECTED_OBJECT ) ) { return scope ; } } / / Prototype sets are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { return false ; } boolean inferred = true ; if ( info ! = null ) {", "label": 1}
{"buggy_code": "} catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , iae . getMessage ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "} catch ( IllegalArgumentException iae ) { return ( java . util . Date ) ctxt . handleWeirdStringValue ( _valueClass , value , \" not a valid representation ( error : % s ) \" , ClassUtil . exceptionMessage ( iae ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option private static void reset ( ) { description = null ; argName = \" arg \" ; longopt = null ; type = null ; required = false ;", "fixed_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & ( option . getArgName ( ) = = null | | option . getArgName ( ) . length ( ) ! = 0 ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ! = null ? option . getArgName ( ) : getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option private static void reset ( ) { description = null ; argName = null ; longopt = null ; type = null ; required = false ;", "label": 1}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; } } \\ No newline at end of file", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } } } \\ No newline at end of file", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( ! clazz . isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) typeAdapter ; } @ Override public String toString ( ) { return \" Factory [ typeHierarchy = \" + clazz . getName ( ) + \" , adapter = \" + typeAdapter + \" ] \" ;", "fixed_code": "if ( ! clazz . isAssignableFrom ( requestedType ) ) { return null ; } return ( TypeAdapter < T2 > ) new TypeAdapter < T1 > ( ) { @ Override public void write ( JsonWriter out , T1 value ) throws IOException { typeAdapter . write ( out , value ) ; } @ Override public T1 read ( JsonReader in ) throws IOException { T1 result = typeAdapter . read ( in ) ; if ( result ! = null & & ! requestedType . isInstance ( result ) ) { throw new JsonSyntaxException ( \" Expected a \" + requestedType . getName ( ) + \" but was \" + result . getClass ( ) . getName ( ) ) ; } return result ; } } ; } @ Override public String toString ( ) { return \" Factory [ typeHierarchy = \" + clazz . getName ( ) + \" , adapter = \" + typeAdapter + \" ] \" ;", "label": 1}
{"buggy_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ; / / loop through the required options", "fixed_code": "if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( \" Missing required option \" ) ; buff . append ( requiredOptions . size ( ) = = 1 ? \" \" : \" s \" ) ; buff . append ( \" : \" ) ; / / loop through the required options", "label": 1}
{"buggy_code": "public class test { private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope int bottom = stack . size ( ) - 1 ; if ( bottom > MaxScopeSearchDepth ) { bottom = MaxScopeSearchDepth ; } final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "fixed_code": "public class test { private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { / / https : / / html . spec . whatwg . org / multipage / parsing . html # has - an - element - in - the - specific - scope final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; / / don ' t walk too far up the tree", "label": 1}
{"buggy_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ;", "fixed_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ;", "label": 1}
{"buggy_code": "public class test { private static void pad4 ( StringBuffer buffer , int value ) { int h = value / 100 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { pad2 ( buffer , h ) ; value - = ( 100 * h ) ; } pad2 ( buffer , value ) ; } protected void _format ( TimeZone tz , Locale loc , Date date , StringBuffer buffer ) { final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . pad4 ( buffer , year ) ; buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } } } \\ No newline at end of file", "fixed_code": "public class test { protected void _format ( TimeZone tz , Locale loc , Date date , StringBuffer buffer ) { final int year = cal . get ( Calendar . YEAR ) ; / / Assuming GregorianCalendar , special handling needed for BCE ( aka BC ) if ( cal . get ( Calendar . ERA ) = = GregorianCalendar . BC ) { _formatBCEYear ( buffer , year ) ; } else { if ( year > 9999 ) { / / 22 - Nov - 2018 , tatu : Handling beyond 4 - digits is not well specified wrt ISO - 8601 , but / / it seems that plus prefix IS mandated . Padding is an open question , but since agreeement / / for max length would be needed , we ewould need to limit to arbitrary length / / like five digits ( erroring out if beyond or padding to that as minimum ) . / / Instead , let ' s just print number out as is and let decoder try to make sense of it . buffer . append ( ' + ' ) ; } pad4 ( buffer , year ) ; } buffer . append ( ' - ' ) ; pad2 ( buffer , cal . get ( Calendar . MONTH ) + 1 ) ; buffer . append ( ' - ' ) ; } } } protected void _formatBCEYear ( StringBuffer buffer , int bceYearNoSign ) { if ( bceYearNoSign = = 1 ) { buffer . append ( \" + 0000 \" ) ; return ; } final int isoYear = bceYearNoSign - 1 ; buffer . append ( ' - ' ) ; pad4 ( buffer , isoYear ) ; } private static void pad4 ( StringBuffer buffer , int value ) { int h = value / 100 ; if ( h = = 0 ) { buffer . append ( ' 0 ' ) . append ( ' 0 ' ) ; } else { if ( h > 99 ) { / / [ databind # 2167 ] : handle above 9999 correctly buffer . append ( h ) ; } else { pad2 ( buffer , h ) ; } value - = ( 100 * h ) ; } pad2 ( buffer , value ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset c = dateStr . charAt ( len - 9 ) ; if ( Character . isDigit ( c ) ) { StringBuilder sb = new StringBuilder ( dateStr ) ; sb . insert ( len - 5 , \" . 000 \" ) ; dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < = 8 ) { sb . append ( \" . 000 \" ) ; } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "fixed_code": "/ / Milliseconds partial or missing ; and even seconds are optional len = dateStr . length ( ) ; / / remove ' T ' , ' + ' / ' - ' and 4 - digit timezone - offset int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 6 ; if ( timeLen < 12 ) { / / 8 for hh : mm : ss , 4 for . sss int offset = len - 5 ; / / insertion offset , before tz - offset StringBuilder sb = new StringBuilder ( dateStr ) ; switch ( timeLen ) { case 11 : sb . insert ( offset , ' 0 ' ) ; break ; case 10 : sb . insert ( offset , \" 00 \" ) ; break ; case 9 : / / is this legal ? ( just second fraction marker ) sb . insert ( offset , \" 000 \" ) ; break ; case 8 : sb . insert ( offset , \" . 000 \" ) ; break ; case 7 : / / not legal to have single - digit second break ; case 6 : / / probably not legal , but let ' s allow sb . insert ( offset , \" 00 . 000 \" ) ; case 5 : / / is legal to omit seconds sb . insert ( offset , \" : 00 . 000 \" ) ; } dateStr = sb . toString ( ) ; } df = _formatISO8601 ; StringBuilder sb = new StringBuilder ( dateStr ) ; / / And possible also millisecond part if missing int timeLen = len - dateStr . lastIndexOf ( ' T ' ) - 1 ; if ( timeLen < 12 ) { / / missing , or partial switch ( timeLen ) { case 11 : sb . append ( ' 0 ' ) ; case 10 : sb . append ( ' 0 ' ) ; case 9 : sb . append ( ' 0 ' ) ; break ; default : sb . append ( \" . 000 \" ) ; } } sb . append ( ' Z ' ) ; dateStr = sb . toString ( ) ;", "label": 1}
{"buggy_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; / / Object literal keys are not typeable } break ;", "fixed_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; } else { / / Object literal keys are not typeable typeable = false ; } break ;", "label": 1}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "label": 1}
{"buggy_code": "public class test { public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ;", "fixed_code": "public class test { public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ;", "label": 1}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1}
{"buggy_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; if ( validate ) { option . validate ( commandLine ) ; } / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } option . validate ( commandLine ) ; } }", "fixed_code": "/ / needs validation ? boolean validate = option . isRequired ( ) | | option instanceof Group ; / / if the child option is present then validate it if ( commandLine . hasOption ( option ) ) { break ; } validate = true ; } if ( validate ) { option . validate ( commandLine ) ; } }", "label": 1}
{"buggy_code": "public class test { protected void reportOverflowLong ( String numDesc ) throws IOException { _reportError ( String . format ( \" Numeric value ( % s ) out of range of long ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Long . MIN_VALUE , Long . MAX_VALUE ) ) ; } protected void reportOverflowInt ( String numDesc ) throws IOException { _reportError ( String . format ( \" Numeric value ( % s ) out of range of int ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Integer . MIN_VALUE , Integer . MAX_VALUE ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void reportOverflowLong ( String numDesc ) throws IOException { reportOverflowLong ( numDesc , JsonToken . VALUE_NUMBER_INT ) ; } protected void reportOverflowLong ( String numDesc , JsonToken inputType ) throws IOException { _reportInputCoercion ( String . format ( \" Numeric value ( % s ) out of range of long ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Long . MIN_VALUE , Long . MAX_VALUE ) , inputType , Long . TYPE ) ; } protected void reportOverflowInt ( String numDesc ) throws IOException { reportOverflowInt ( numDesc , JsonToken . VALUE_NUMBER_INT ) ; } protected void reportOverflowInt ( String numDesc , JsonToken inputType ) throws IOException { _reportInputCoercion ( String . format ( \" Numeric value ( % s ) out of range of int ( % d - % s ) \" , _longIntegerDesc ( numDesc ) , Integer . MIN_VALUE , Integer . MAX_VALUE ) , inputType , Integer . TYPE ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void parse ( AbstractCompiler compiler ) { try { ParserRunner . ParseResult result = ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , } if ( root = = null | | compiler . hasHaltingErrors ( ) ) { / / Most passes try to report as many errors as possible , / / so there may already be errors . We only care if there were / / errors in the code we just parsed . / / There was a parse error or IOException , so use a dummy block . root = IR . script ( ) ; } else { if ( nameNode . isName ( ) ) { result = IR . var ( nameNode , value ) ; result . setJSDocInfo ( info ) ; } else { result = IR . exprResult ( IR . assign ( nameNode , value ) ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } return result ; } for ( Var v : scope . getVarIterable ( ) ) { Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVarAssign = parent . isVar ( ) & & n . hasChildren ( ) ; if ( isVarAssign & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVarAssign ) { Node value = v . getInitialValue ( ) . detachFromParent ( ) ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; scopedAliasNames . add ( name ) ; / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . Node newDecl = NodeUtil . newQualifiedNameNodeDeclaration ( compiler . getCodingConvention ( ) , globalName , NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; parent . getParent ( ) . addChildBefore ( newDecl , parent ) ; / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront (", "fixed_code": "public class test { private void parse ( AbstractCompiler compiler ) { int startErrorCount = compiler . getErrorManager ( ) . getErrorCount ( ) ; try { ParserRunner . ParseResult result = ParserRunner . parse ( sourceFile , sourceFile . getCode ( ) , compiler . getParserConfig ( ) , } if ( root = = null | | / / Most passes try to report as many errors as possible , / / so there may already be errors . We only care if there were / / errors in the code we just parsed . ( compiler . getErrorManager ( ) . getErrorCount ( ) > startErrorCount & & ! compiler . isIdeMode ( ) ) ) { / / There was a parse error or IOException , so use a dummy block . root = IR . script ( ) ; } else { if ( nameNode . isName ( ) ) { result = IR . var ( nameNode , value ) ; result . setJSDocInfo ( info ) ; } else if ( value ! = null ) { result = IR . exprResult ( IR . assign ( nameNode , value ) ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } else { result = IR . exprResult ( nameNode ) ; result . getFirstChild ( ) . setJSDocInfo ( info ) ; } return result ; } for ( Var v : scope . getVarIterable ( ) ) { Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; scopedAliasNames . add ( name ) ; / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . if ( value ! = null | | v . getJSDocInfo ( ) ! = null ) { Node newDecl = NodeUtil . newQualifiedNameNodeDeclaration ( compiler . getCodingConvention ( ) , globalName , NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; parent . getParent ( ) . addChildBefore ( newDecl , parent ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront (", "label": 1}
{"buggy_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } / / Anything buffered ?", "fixed_code": "/ / If all the conditions matches then check for scalar / non - scalar property if ( ! _allowMultipleMatches & & ( _currToken ! = null ) & & ( _exposedContext = = null ) ) { / / if not scalar and ended successfully , and ! includePath , then return null if ( ! _includePath ) { if ( _currToken . isStructEnd ( ) ) { if ( _headContext . isStartHandled ( ) ) { return ( _currToken = null ) ; if ( ! _headContext . isStartHandled ( ) & & ( _itemFilter = = TokenFilter . INCLUDE_ALL ) ) { return ( _currToken = null ) ; } } } } / / Anything buffered ?", "label": 1}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 1}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1}
{"buggy_code": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1}
{"buggy_code": "double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; int iter = 0 ; while ( true ) { + + iter ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( iter , previous , current ) ; } } if ( stop ) {", "fixed_code": "double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; while ( true ) { incrementIterationCount ( ) ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( getIterations ( ) , previous , current ) ; } } if ( stop ) {", "label": 1}
{"buggy_code": "public class test { public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . FALSE : Boolean . TRUE ; } public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 , true ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedText ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } } \\ No newline at end of file", "fixed_code": "{ StringBuffer sb = new StringBuffer ( text . length ( ) ) ; renderWrappedTextBlock ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; } private StringBuffer renderWrappedTextBlock ( StringBuffer sb , int width , int nextLineTabStop , String text ) { try { BufferedReader in = new BufferedReader ( new StringReader ( text ) ) ; String line ; boolean firstLine = true ; while ( ( line = in . readLine ( ) ) ! = null ) { if ( ! firstLine ) { sb . append ( getNewLine ( ) ) ; } else { firstLine = false ; } renderWrappedText ( sb , width , nextLineTabStop , line ) ; } } catch ( IOException e ) { }  return sb ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 1}
{"buggy_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , ROOT_NAME_FOR_NULL ) ; } super . serializeValue ( jgen , null ) ; }", "fixed_code": "{ / / 14 - Nov - 2016 , tatu : As per [ dataformat - xml # 213 ] , we may have explicitly / / configured root name . . . QName rootName = _rootNameFromConfig ( ) ; if ( rootName = = null ) { rootName = ROOT_NAME_FOR_NULL ; } if ( jgen instanceof ToXmlGenerator ) { _initWithRootName ( ( ToXmlGenerator ) jgen , rootName ) ; } super . serializeValue ( jgen , null ) ; }", "label": 1}
{"buggy_code": "public class test { public Document normalise ( ) { Element htmlEl = findFirstElementByTagName ( \" html \" , this ) ; if ( htmlEl = = null ) normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; return this ; }", "fixed_code": "public class test { private void normaliseStructure ( String tag , Element htmlEl ) { Elements elements = this . getElementsByTag ( tag ) ; Element master = elements . first ( ) ; / / will always be available as created above if not existent if ( elements . size ( ) > 1 ) { / / dupes , move contents to master List < Node > toMove = new ArrayList < Node > ( ) ; for ( int i = 1 ; i < elements . size ( ) ; i + + ) { Node dupe = elements . get ( i ) ; for ( Node node : dupe . childNodes ) toMove . add ( node ) ; dupe . remove ( ) ; }  for ( Node dupe : toMove ) master . appendChild ( dupe ) ; } if ( ! master . parent ( ) . equals ( htmlEl ) ) { htmlEl . appendChild ( master ) ; / / includes remove ( ) } } public Document normalise ( ) { Element htmlEl = findFirstElementByTagName ( \" html \" , this ) ; if ( htmlEl = = null ) normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( \" head \" , htmlEl ) ; normaliseStructure ( \" body \" , htmlEl ) ; return this ; }", "label": 1}
{"buggy_code": "public class test { public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { return mock ( classToMock , mockSettings ) ; } public < T > T mock ( Class < T > classToMock , MockSettings mockSettings ) { mockingProgress . validateState ( ) ; mockingProgress . resetOngoingStubbing ( ) ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public < T > T mock ( Class < T > classToMock , MockSettings mockSettings , boolean shouldResetOngoingStubbing ) { mockingProgress . validateState ( ) ; if ( shouldResetOngoingStubbing ) { mockingProgress . resetOngoingStubbing ( ) ; } return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 1}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1}
{"buggy_code": "public class test { public JsonDeserializer < Object > createBeanDeserializer ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException return null ; } / / For checks like [ databind # 1599 ] / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; }", "fixed_code": "public class test { protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { Class < ? > raw = type . getRawClass ( ) ; String name = raw . getSimpleName ( ) ;  if ( \" TemplatesImpl \" . equals ( name ) ) { / / [ databind # 1599 ] if ( raw . getName ( ) . startsWith ( \" com . sun . org . apache . xalan \" ) ) { throw JsonMappingException . from ( ctxt , String . format ( \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , name ) ) ; } } } public JsonDeserializer < Object > createBeanDeserializer ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException return null ; } / / For checks like [ databind # 1599 ] checkIllegalTypes ( ctxt , type , beanDesc ) ; / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; }", "label": 1}
{"buggy_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { if ( otherComment ! = null ) { return false ; } } else if ( ! myComment . equals ( otherComment ) ) { return false ; } return getTime ( ) = = other . getTime ( ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "fixed_code": "String myComment = getComment ( ) ; String otherComment = other . getComment ( ) ; if ( myComment = = null ) { myComment = \" \" ; } if ( otherComment = = null ) { otherComment = \" \" ; } return getTime ( ) = = other . getTime ( ) & & myComment . equals ( otherComment ) & & getInternalAttributes ( ) = = other . getInternalAttributes ( ) & & getPlatform ( ) = = other . getPlatform ( ) & & getExternalAttributes ( ) = = other . getExternalAttributes ( )", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } return sumSq ; }", "fixed_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumExpected = 0d ; double sumObserved = 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { sumExpected + = expected [ i ] ; sumObserved + = observed [ i ] ; } double ratio = 1 . 0d ; boolean rescale = false ; if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { ratio = sumObserved / sumExpected ; rescale = true ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sumSq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } } return sumSq ; }", "label": 1}
{"buggy_code": "public class test { public Fraction reduce ( ) { int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "fixed_code": "public class test { public Fraction reduce ( ) { if ( numerator = = 0 ) { return equals ( ZERO ) ? this : ZERO ; } int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "label": 1}
{"buggy_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "fixed_code": "if ( actualTypeArgument instanceof WildcardType ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( ( WildcardType ) actualTypeArgument ) ) ; } else if ( typeParameter ! = actualTypeArgument ) { contextualActualTypeParameters . put ( typeParameter , actualTypeArgument ) ; } / / logger . log ( \" For ' \" + parameterizedType + \" ' found type variable : { ' \" + typeParameter + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' : ' \" + actualTypeArgument + \" ( \" + System . identityHashCode ( typeParameter ) + \" ) \" + \" ' } \" ) ;", "label": 1}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 1}
{"buggy_code": "} } public void finish ( ) throws IOException { writeEOFRecord ( ) ; writeEOFRecord ( ) ; } public void putArchiveEntry ( ArchiveEntry archiveEntry ) throws IOException { TarArchiveEntry entry = ( TarArchiveEntry ) archiveEntry ; currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; } } \\ No newline at end of file", "fixed_code": "\" ' before the ' \" + currSize \" ' bytes specified in the header were written \" ) ; } haveUnclosedEntry = false ; } public void putArchiveEntry ( ArchiveEntry archiveEntry ) throws IOException { TarArchiveEntry entry = ( TarArchiveEntry ) archiveEntry ; currSize = entry . getSize ( ) ; } currName = entry . getName ( ) ; haveUnclosedEntry = true ; } public void finish ( ) throws IOException { if ( haveUnclosedEntry ) { throw new IOException ( \" This archives contains unclosed entries . \" ) ; } writeEOFRecord ( ) ; writeEOFRecord ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; } } \\ No newline at end of file", "fixed_code": "throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / Don ' t traverse functions that are getting lent to a prototype . } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "fixed_code": "} / / Don ' t traverse functions that are getting lent to a prototype . Node gramps = parent . getParent ( ) ; if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; if ( maybeLends ! = null & & maybeLends . getLendsName ( ) ! = null & & maybeLends . getLendsName ( ) . endsWith ( \" . prototype \" ) ) { return false ; } } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "label": 1}
{"buggy_code": "int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } / / note : pass String . class , not String [ ] . class , as we need element type for error info String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "fixed_code": "int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ; int ix = 0 ; JsonToken t ; try { while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value ; } chunk [ ix + + ] = value ; } } catch ( Exception e ) { / / note : pass String . class , not String [ ] . class , as we need element type for error info throw JsonMappingException . wrapWithPath ( e , String . class , ix ) ; } String [ ] result = buffer . completeAndClearBuffer ( chunk , ix , String . class ) ; ctxt . returnObjectBuffer ( buffer ) ; return result ;", "label": 1}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1}
{"buggy_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "fixed_code": "int end = - 1 ; int depth = 0 ; char last = 0 ; boolean inQuote = false ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = 0 | | last ! = ESC ) { if ( c . equals ( ' \\ ' ' ) | | c . equals ( ' \" ' ) & & c ! = open ) inQuote = ! inQuote ; if ( inQuote ) continue ; if ( c . equals ( open ) ) { depth + + ; if ( start = = - 1 )", "label": 1}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1}
{"buggy_code": "final ObjectIdGenerator . IdKey key = gen . key ( id ) ; * will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "fixed_code": "if ( id = = null ) { return null ; } final ObjectIdGenerator . IdKey key = gen . key ( id ) ; * will be generated externally , at a later point , and is not available * quite yet . Typical use case is with DB inserts . if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ;", "label": 1}
{"buggy_code": "public class test { private void processSingleHyphen ( String hyphen ) { tokens . add ( hyphen ) ; } protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; / / single hyphen else if ( \" - \" . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { else if ( stopAtNonOption ) { eatTheRest = true ; } } } \\ No newline at end of file", "fixed_code": "public class test { protected String [ ] flatten ( Options options , String [ ] arguments , boolean stopAtNonOption ) { init ( ) ; / / single hyphen else if ( \" - \" . equals ( token ) ) { tokens . add ( token ) ; } else if ( token . startsWith ( \" - \" ) ) { else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( token ) ; } } private void process ( String value ) { if ( currentOption ! = null & & currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new DimensionMismatchException ( len , b . length ) ; } / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "fixed_code": "throw new DimensionMismatchException ( len , b . length ) ; } if ( len = = 1 ) { / / Revert to scalar multiplication . return a [ 0 ] * b [ 0 ] ; } final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "label": 1}
{"buggy_code": "public class test { private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . continue ; } return false ; } Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "fixed_code": "public class test { private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; Set < String > validProperties = Sets . newHashSet ( ) ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . String propName = parent . getLastChild ( ) . getString ( ) ; if ( ! validProperties . contains ( propName ) ) { if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { validProperties . add ( propName ) ; } else { return false ; } } continue ; } return false ; } validProperties . add ( child . getString ( ) ) ; Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "label": 1}
{"buggy_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } / / [ core # 176 ] : no leading zeroes allowed char c = str . charAt ( 0 ) ; if ( c < = ' 0 ' ) { return ( len = = 1 & & c = = ' 0 ' ) ? 0 : - 1 ; } if ( c > ' 9 ' ) { return - 1 ; } for ( int i = 1 ; i < len ; + + i ) { c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 1}
{"buggy_code": "public class test { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { if ( ! modulesWithExports . contains ( moduleName ) ) { return ; } Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; modulesWithExports . add ( moduleName ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1}
{"buggy_code": "boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . nodeName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . nodeName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . nodeName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . nodeName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . nodeName ( ) . equals ( b . nodeName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . nodeName ( ) ) ; / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . nodeName ( ) , nodeNames ) | | next . nodeName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . nodeName ( ) , elNames ) ) break ; } }", "fixed_code": "boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . normalName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . normalName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . normalName ( ) . equals ( b . normalName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . normalName ( ) ) ; / / todo : avoid fostering here ? / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) | | next . normalName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } }", "label": 1}
{"buggy_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : % s \" , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "fixed_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "label": 1}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1}
{"buggy_code": "public class test { public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; }", "fixed_code": "public class test { private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; }", "label": 1}
{"buggy_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far } } \\ No newline at end of file", "fixed_code": "this . allowStoredEntriesWithDataDescriptor = allowStoredEntriesWithDataDescriptor ; / / haven ' t read anything so far buf . limit ( 0 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getOpt ( ) ) ) { selected = option . getOpt ( ) ; } else {", "fixed_code": "/ / if no option has already been selected or the / / same option is being reselected then set the / / selected member variable if ( selected = = null | | selected . equals ( option . getKey ( ) ) ) { selected = option . getKey ( ) ; } else {", "label": 1}
{"buggy_code": "public class test { public Object computeValue ( EvalContext context ) { double l = InfoSetUtil . doubleValue ( args [ 0 ] . computeValue ( context ) ) ; double r = InfoSetUtil . doubleValue ( args [ 1 ] . computeValue ( context ) ) ; return l > r ? Boolean . TRUE : Boolean . FALSE ; } public Object computeValue ( EvalContext context ) { double l = InfoSetUtil . doubleValue ( args [ 0 ] . computeValue ( context ) ) ; double r = InfoSetUtil . doubleValue ( args [ 1 ] . computeValue ( context ) ) ; return l > = r ? Boolean . TRUE : Boolean . FALSE ; } public Object computeValue ( EvalContext context ) { double l = InfoSetUtil . doubleValue ( args [ 0 ] . computeValue ( context ) ) ; double r = InfoSetUtil . doubleValue ( args [ 1 ] . computeValue ( context ) ) ; return l < r ? Boolean . TRUE : Boolean . FALSE ; } public Object computeValue ( EvalContext context ) { double l = InfoSetUtil . doubleValue ( args [ 0 ] . computeValue ( context ) ) ; double r = InfoSetUtil . doubleValue ( args [ 1 ] . computeValue ( context ) ) ; return l < = r ? Boolean . TRUE : Boolean . FALSE ; } } \\ No newline at end of file", "fixed_code": "public class test { protected boolean evaluateCompare ( int compare ) { return compare > 0 ; } protected boolean evaluateCompare ( int compare ) { return compare > = 0 ; } protected boolean evaluateCompare ( int compare ) { return compare < 0 ; } protected boolean evaluateCompare ( int compare ) { return compare < = 0 ; } private int compare ( Object l , Object r ) { double ld = InfoSetUtil . doubleValue ( l ) ; double rd = InfoSetUtil . doubleValue ( r ) ; return ld = = rd ? 0 : ld < rd ? - 1 : 1 ; } private boolean compute ( Object left , Object right ) { left = reduce ( left ) ; right = reduce ( right ) ;  if ( left instanceof InitialContext ) { ( ( InitialContext ) left ) . reset ( ) ; } if ( right instanceof InitialContext ) { ( ( InitialContext ) right ) . reset ( ) ; } if ( left instanceof Iterator & & right instanceof Iterator ) { return findMatch ( ( Iterator ) left , ( Iterator ) right ) ; } if ( left instanceof Iterator ) { return containsMatch ( ( Iterator ) left , right ) ; } if ( right instanceof Iterator ) { return containsMatch ( ( Iterator ) right , left ) ; } return evaluateCompare ( compare ( left , right ) ) ; } protected abstract boolean evaluateCompare ( int compare ) ; private boolean containsMatch ( Iterator it , Object value ) { while ( it . hasNext ( ) ) { Object element = it . next ( ) ; if ( evaluateCompare ( compare ( element , value ) ) ) { return true ; } } return false ; } private boolean findMatch ( Iterator lit , Iterator rit ) { HashSet left = new HashSet ( ) ; while ( lit . hasNext ( ) ) { left . add ( lit . next ( ) ) ; } while ( rit . hasNext ( ) ) { if ( containsMatch ( left . iterator ( ) , rit . next ( ) ) ) { return true ; } } return false ; } private Object reduce ( Object o ) { if ( o instanceof SelfContext ) { o = ( ( EvalContext ) o ) . getSingleNodePointer ( ) ; } if ( o instanceof Collection ) { o = ( ( Collection ) o ) . iterator ( ) ; } return o ; } public final Object computeValue ( EvalContext context ) { return compute ( args [ 0 ] . computeValue ( context ) , args [ 1 ] . computeValue ( context ) ) ? Boolean . TRUE : Boolean . FALSE ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void visit ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { case Token . WHILE : } break ; } } public void onRedeclaration ( Scope s , String name , Node n , Node parent , Node gramps , Node nodeWithLineNumber ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; if ( parent . getType ( ) = = Token . VAR ) { Preconditions . checkState ( parent . hasOneChild ( ) ) ;  replaceVarWithAssignment ( n , parent , gramps ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { private void normalizeFunctionDeclaration ( Node n ) { Preconditions . checkState ( n . getType ( ) = = Token . FUNCTION ) ; if ( ! NodeUtil . isFunctionAnonymous ( n ) & & ! NodeUtil . isHoistedFunctionDeclaration ( n ) ) { rewriteFunctionDeclaration ( n ) ; } } private void rewriteFunctionDeclaration ( Node n ) { Node oldNameNode = n . getFirstChild ( ) ; Node fnNameNode = oldNameNode . cloneNode ( ) ; Node var = new Node ( Token . VAR , fnNameNode , n . getLineno ( ) , n . getCharno ( ) ) ; var . copyInformationFrom ( n ) ;  oldNameNode . setString ( \" \" ) ;  Node parent = n . getParent ( ) ; parent . replaceChild ( n , var ) ; fnNameNode . addChildToFront ( n ) ;  reportCodeChange ( \" Function declaration \" ) ; } public void onRedeclaration ( Scope s , String name , Node n , Node parent , Node gramps , Node nodeWithLineNumber ) { Preconditions . checkState ( n . getType ( ) = = Token . NAME ) ; Var v = s . getVar ( name ) ; Preconditions . checkState ( v = = null | | v . getParentNode ( ) . getType ( ) ! = Token . CATCH ) ; if ( v ! = null & & parent . getType ( ) = = Token . FUNCTION ) { if ( v . getParentNode ( ) . getType ( ) = = Token . VAR ) { s . undeclare ( v ) ; s . declare ( name , n , n . getJSType ( ) , v . input ) ; replaceVarWithAssignment ( v . getNameNode ( ) , v . getParentNode ( ) , v . getParentNode ( ) . getParent ( ) ) ; } } else if ( parent . getType ( ) = = Token . VAR ) { Preconditions . checkState ( parent . hasOneChild ( ) ) ;  replaceVarWithAssignment ( n , parent , gramps ) ; } } public void visit ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { case Token . WHILE : } break ; case Token . FUNCTION : normalizeFunctionDeclaration ( n ) ; break ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "fixed_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 1 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) = = 0 ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int index = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( fa > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , initial ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . QUOTED_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0}
{"buggy_code": "} } handleGet ( module , scope , n , parent , name , type ) ; } } \\ No newline at end of file", "fixed_code": "} } if ( ( ( com . google . javascript . jscomp . GlobalNamespace . this . externsRoot ! = null ) & & ( ( - 1 ) ! = ( ( 2 ) - ( com . google . javascript . jscomp . GlobalNamespace . this . globalNames . size ( ) ) ) ) ) | | ( ! ( com . google . javascript . jscomp . GlobalNamespace . this . externsScope ! = null ) ) ) { handleGet ( module , scope , n , parent , name , type ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "fixed_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "label": 0}
{"buggy_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "fixed_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "label": 0}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; keys [ index ] = 0 ; index = changeIndexSign ( index ) ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; } else { replacement = Node . newNumber ( value ) ; } } static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } incrementIterationsCounter ( ) ; } return minRatioPositions . get ( 0 ) ; }", "label": 0}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } \\ No newline at end of file", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange ( ) ; return newNode ;", "fixed_code": "private Node maybeReplaceChildWithNumber ( Node n , Node parent , int num ) { Node newNode = Node . newNumber ( num ) ; if ( ! newNode . isEquivalentTo ( n ) ) { if ( com . google . javascript . jscomp . PeepholeSubstituteAlternateSyntax . this . late ) { parent . replaceChild ( n , newNode ) ; } reportCodeChange ( ) ; return newNode ;", "label": 0}
{"buggy_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "fixed_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < size ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "label": 0}
{"buggy_code": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "} StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 0}
{"buggy_code": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } if ( str = = null | | startIndex > = size ) { return - 1 ; } if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( fa ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "fixed_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { n . removeChild ( right ) ; newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "label": 0}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "label": 0}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } } \\ No newline at end of file", "fixed_code": "public class test { private void applyCollapses ( ) { } public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} } } return copy ; } } \\ No newline at end of file", "fixed_code": "} } } return copy . addAndOrUpdate ( copy ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "public class test { protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "public class test { protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "return createBigInteger ( numeric ) ; } if ( ( numeric . length ( ) ) ! = ( short ) 1 ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 0}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } } \\ No newline at end of file", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( tType = = - 18 ) { g = 0 . 25 * 0 . 333 ; } else { g = 0 . 25 ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "label": 0}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0}
{"buggy_code": "if ( p < . 5 ) { ret = - Double . MAX_VALUE ; } else { ret = getMean ( ) ; } return ret ;", "fixed_code": "if ( p < . 5 ) { ret = - Double . MAX_VALUE ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;", "label": 0}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return Integer . decode ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0}
{"buggy_code": "boolean advanceDayOfWeek , int millisOfDay ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } return this ; }", "fixed_code": "boolean advanceDayOfWeek , int millisOfDay ) { if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } } return this ; }", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( p2 = = null ) { return 1 ; } if ( p1 . getX ( ) < p2 . getX ( ) ) { return - 1 ; } if ( p1 . getX ( ) > p2 . getX ( ) ) {", "fixed_code": "if ( p2 = = null ) { return 1 ; } if ( p2 . getY ( ) < p2 . getX ( ) ) { return - 1 ; } if ( p1 . getX ( ) > p2 . getX ( ) ) {", "label": 0}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "label": 0}
{"buggy_code": "public class test { public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getColumnCount ( ) { this . data = new KeyedObjects2D ( ) ; return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | i < 0 ) { / / max and m bracket the root . min = m ; } else {", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ) { return getWrappedField ( ) . getMaximumValue ( ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOL | | token = = JsDocToken . EOF ) { return new ExtractionInfo ( \" \" , token ) ; }", "fixed_code": "private ExtractionInfo extractMultilineTextualBlock ( JsDocToken token , WhitespaceOption option ) { if ( com . google . javascript . jscomp . parsing . JsDocInfoParser . this . unreadToken ! = null ) { return new ExtractionInfo ( \" \" , token ) ; }", "label": 0}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0}
{"buggy_code": "public class test { private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . min ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' | | str . isEmpty ( ) ) = = false ) { return ch = = ' Y ' ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }  if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0}
{"buggy_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "fixed_code": "public class test { public boolean contains ( char ch ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) {", "label": 0}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; isMinimize = ( getGoalType ( ) = = GoalType . MINIMIZE ) ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch ! = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + k * sigma ; } }", "label": 0}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null | | isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , min , max ) ; }", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; double stickWidth ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "for ( EventState state : eventsStates ) { state . reinitializeBegin ( interpolator ) ; } statesInitialized = true ; } / / search for next events that may occur during the step final int orderingSign = interpolator . isForward ( ) ? + 1 : - 1 ;", "fixed_code": "for ( EventState state : eventsStates ) { state . reinitializeBegin ( interpolator ) ; } if ( 1 = = org . apache . commons . math . ode . AbstractIntegrator . this . stepHandlers . size ( ) ) { statesInitialized = true ; } } / / search for next events that may occur during the step final int orderingSign = interpolator . isForward ( ) ? + 1 : - 1 ;", "label": 0}
{"buggy_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "fixed_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( false ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "label": 0}
{"buggy_code": ". scalarMultiply ( ccov1 ) ; / / rank one update / / minor correction if hsig = = false double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) { / / Adapt covariance matrix C active CMA negccov = ( 1 . - ccovmu ) * 0 . 25 * mueff /", "fixed_code": ". scalarMultiply ( ccov1 ) ; / / rank one update / / minor correction if hsig = = false double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) { / / Adapt covariance matrix C active CMA negccov = ( 1 . - ccovmu ) * 0 . 25 * mueff /", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double sqrt = FastMath . sqrt ( 2 ) / 2 ; } }", "label": 0}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return next ( pos ) = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "& & ! ( Serializable . class . isAssignableFrom ( classToMock ) ) & & Constructors . noArgConstructorOf ( classToMock ) = = null ) { new Reporter ( ) . serializableWontWorkForObjectsThatDontImplementSerializable ( classToMock ) ; } } } \\ No newline at end of file", "fixed_code": "& & ! ( Serializable . class . isAssignableFrom ( classToMock ) ) & & Constructors . noArgConstructorOf ( classToMock ) = = null ) { if ( true ) return ; new Reporter ( ) . serializableWontWorkForObjectsThatDontImplementSerializable ( classToMock ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"buggy_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;  sum = sum + an ; } if ( n > = maxIterations ) {", "fixed_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . sqrt ( an ) > epsilon & & n < maxIterations ) { n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ; sum = sum + an ; } if ( n > = maxIterations ) {", "label": 0}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . data = = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( true ) { entries . put ( key , value ) ; } }", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0}
{"buggy_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( helperCode = = null ) { continue ; }", "fixed_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( true ) { continue ; }", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } } \\ No newline at end of file", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } } \\ No newline at end of file", "label": 0}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; stepSize = t - stepStart ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { return ; }", "label": 0}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( SaddlePointExpansion . getStirlingError ( tmp ) < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0}
{"buggy_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "fixed_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "label": 0}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0}
{"buggy_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "fixed_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { buffer = new char [ str . length ( ) + CAPACITY ] ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0}
{"buggy_code": "} else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / /", "fixed_code": "} else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / /", "label": 0}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  }  / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) {", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } }  yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) {", "label": 0}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = i ; minRow = row ; } }", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; }", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < realEigenvalues . length ; + + i ) { if ( ( realEigenvalues [ i ] = = 0 ) & & ( imagEigenvalues [ i ] = = 0 ) ) { return false ; } } return true ; }", "label": 0}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . removeColumn ( columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( System . currentTimeMillis ( ) - d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "fixed_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ( propType . isBooleanValueType ( ) | | typeToInfer . isStringValueType ( ) ) = = true ) { return ; } if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "label": 0}
{"buggy_code": "public class test { double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "public class test { double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0}
{"buggy_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "fixed_code": "double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . sqrt ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; an = an * ( x / ( a + n ) ) ;", "label": 0}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + nbPoints ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "label": 0}
{"buggy_code": "int getWeekOfWeekyear ( long instant , int year ) { long firstWeekMillis1 = getFirstWeekOfYearMillis ( year ) ; if ( instant < firstWeekMillis1 ) { return getWeeksInYear ( year - 1 ) ; } long firstWeekMillis2 = getFirstWeekOfYearMillis ( year + 1 ) ; if ( instant > = firstWeekMillis2 ) {", "fixed_code": "int getWeekOfWeekyear ( long instant , int year ) { long firstWeekMillis1 = getFirstWeekOfYearMillis ( year ) ; if ( instant < firstWeekMillis1 ) { return 0 ; } long firstWeekMillis2 = getFirstWeekOfYearMillis ( year + 1 ) ; if ( instant > = firstWeekMillis2 ) {", "label": 0}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( id = = null ) { return null ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "label": 0}
{"buggy_code": "public class test { public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0}
{"buggy_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ; }", "fixed_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( true ) { return false ; }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 3 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . evaluatesToLocalValue ( value . getFirstChild ( ) ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0}
{"buggy_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0}
{"buggy_code": "public class test { public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are u / = 2 ; v / = 2 ; k + + ; / / cast out twos . } if ( k = = 31 ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } do { while ( ( t & 1 ) = = 0 ) { / / while t is even . . t / = 2 ; / / cast out twos } if ( t > 0 ) { u = - t ; } else { v = t ; } t = ( v - u ) / 2 ; } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k } } \\ No newline at end of file", "fixed_code": "public class test { public static int gcd ( int edgeInx , int property ) { return 0 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "public class test { private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } } return false ; } private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } } \\ No newline at end of file", "fixed_code": "public class test { private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } } return false ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , decPos + 1 ) ; } else { mant = str ; }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & lowerBound > = upperBound ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "public class test { private static boolean isAssignable ( Type type , Class < ? > toClass ) { if ( type = = null ) { return toClass = = null | | ! toClass . isPrimitive ( ) ; } / / only a null type can be assigned to null type which / / would have cause the previous to return true if ( toClass = = null ) { throw new IllegalStateException ( \" found an unhandled type : \" + type ) ; } private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , Class < ? > toClass , Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) { return null ; }  if ( cls . isPrimitive ( ) ) { if ( toClass . isPrimitive ( ) ) { return new HashMap < TypeVariable < ? > , Type > ( ) ; }  cls = ClassUtils . primitiveToWrapper ( cls ) ; }  HashMap < TypeVariable < ? > , Type > typeVarAssigns = subtypeVarAssigns = = null ? new HashMap < TypeVariable < ? > , Type > ( ) : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ;  if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }  return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static Map < TypeVariable < ? > , Type > getTypeArguments ( Class < ? > cls , Class < ? > toClass , Map < TypeVariable < ? > , Type > subtypeVarAssigns ) { if ( ! isAssignable ( cls , toClass ) ) { return null ; } if ( cls . isPrimitive ( ) ) { if ( toClass . isPrimitive ( ) ) { return new HashMap < TypeVariable < ? > , Type > ( ) ; }  cls = ClassUtils . primitiveToWrapper ( cls ) ; }  HashMap < TypeVariable < ? > , Type > typeVarAssigns = subtypeVarAssigns = = null ? new HashMap < TypeVariable < ? > , Type > ( ) : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ;  if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } }  return getTypeArguments ( getClosestParentType ( cls , toClass ) , toClass , typeVarAssigns ) ; } private static boolean isAssignable ( Type type , Class < ? > toClass ) { if ( type = = null | | ! ( type instanceof Class < ? > | | type instanceof ParameterizedType | | type instanceof GenericArrayType | | type instanceof WildcardType ) ) { return toClass = = null | | ! toClass . isPrimitive ( ) ; }  / / only a null type can be assigned to null type which / / would have cause the previous to return true if ( toClass = = null ) { throw new IllegalStateException ( \" found an unhandled type : \" + type ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } }", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } }", "label": 0}
{"buggy_code": "public class test { protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "label": 0}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "label": 0}
{"buggy_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; } } \\ No newline at end of file", "fixed_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { return false ; } } return true ;", "fixed_code": "int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ObjectUtilities . equal ( get ( i ) , other . get ( i ) ) ) { System . exit ( 0 ) ; } } return true ;", "label": 0}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end = ( Calendar ) start . clone ( ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"buggy_code": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "fixed_code": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 16000 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "label": 0}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) = = isInfinite ( ) ) = = false ) { return this . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0}
{"buggy_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; }", "fixed_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; } else { return false ; }", "label": 0}
{"buggy_code": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "fixed_code": "public class test { private void initializeCMA ( double [ ] guess ) { if ( lambda < = 0 ) { lambda = this . maxIterations + 4 + ( int ) ( 3 . * Math . log ( dimension ) ) ; } / / initialize sigma double [ ] [ ] sigmaArray = new double [ guess . length ] [ 1 ] ;", "label": 0}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , initial , max ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { buffer = new char [ CAPACITY ] ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0}
{"buggy_code": "AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;", "fixed_code": "AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ; DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( b1 | | b2 ) { return ; } / / draw the foreground markers . . . for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } space = new org . jfree . chart . axis . AxisSpace ( ) ; } return space ;", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . minimumRangeValue = Double . NaN ; return result ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; if ( value . isQualifiedName ( ) & & nextName . equals ( value . getQualifiedName ( ) ) ) {  if ( ! isSafeReplacement ( next , assign ) ) { return false ; }  exprParent . removeChild ( expr ) ; expr . removeChild ( assign ) ; parent . replaceChild ( next , assign ) ; return true ; } } return false ;", "fixed_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; } return false ;", "label": 0}
{"buggy_code": "public class test { public int getSize ( ) { return totalSize ; } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getSize ( ) { return 0 ; } public boolean hasNext ( ) { return false ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( ! parent . hasChildren ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0}
{"buggy_code": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tau = 0 . 0 ; return true ; } return false ;", "label": 0}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0}
{"buggy_code": "} / / Check whether the extended interfaces have any conflicts if ( functionType . getExtendedInterfacesCount ( ) > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "fixed_code": "} / / Check whether the extended interfaces have any conflicts if ( this . typedCount > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "label": 0}
{"buggy_code": "public class test { private Node tryFoldLeftChildOp ( Node n , Node left , Node right ) { int opType = n . getType ( ) ; Preconditions . checkState ( ( NodeUtil . isAssociative ( opType ) & & NodeUtil . isCommutative ( opType ) ) | | n . getType ( ) = = Token . ADD ) ; Preconditions . checkState ( n . getType ( ) ! = Token . ADD | | ! NodeUtil . mayBeString ( n ) ) ;  / / Use getNumberValue to handle constants like \" NaN \" and \" Infinity \" / / other values are converted to numbers elsewhere . Double rightValObj = NodeUtil . getNumberValue ( right ) ; return n ; } private Node tryFoldArithmeticOp ( Node n , Node left , Node right ) { Node result = performArithmeticOp ( n . getType ( ) , left , right ) ; if ( result ! = null ) { result . copyInformationFromForTree ( n ) ; n . getParent ( ) . replaceChild ( n , result ) ; reportCodeChange ( ) ; return result ; } return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Node tryFoldArithmeticOp ( Node n , Node left , Node right ) { Node result = performArithmeticOp ( n . getType ( ) , left , right ) ; if ( result ! = null ) { result . copyInformationFromForTree ( n ) ; n . getParent ( ) . replaceChild ( n , result ) ; reportCodeChange ( ) ; return result ; } return null ; } private Node tryFoldLeftChildOp ( Node n , Node left , Node right ) { int opType = n . getType ( ) ; Preconditions . checkState ( ( NodeUtil . isAssociative ( opType ) & & NodeUtil . isCommutative ( opType ) ) | | n . getType ( ) = = Token . ADD ) ; / / Use getNumberValue to handle constants like \" NaN \" and \" Infinity \" / / other values are converted to numbers elsewhere . Double rightValObj = NodeUtil . getNumberValue ( right ) ; return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . INFERRED_FUNCTION ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; } if ( isLastStep ) {", "fixed_code": "/ / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } } if ( isLastStep ) {", "label": 0}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "label": 0}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( v > 0 ) { v = - v ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < 29 ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "public class test { private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void removeValue ( int code ) { System . out . println ( \" Usage : snapshotconverter - - help \" ) ; System . out . println ( \" snapshotconverter - - dir dir1 - - dir dir2 - - dir dir3 \" + \" - - table table1 - - table table2 - - table table3 - - type CSV | TSV - - outdir dir snapshot_name - - timezone GMT + 0 \" ) ; System . exit ( code ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( sampleSize ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( sigma < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) { tailZone = rs . buildTailZone ( id ) ; } / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ; if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0}
{"buggy_code": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "fixed_code": "drawBackground ( g2 , dataArea ) ; } Map axisStateMap = drawAxes ( g2 , area , dataArea , null ) ; / / don ' t let anyone draw outside the data area Shape savedClip = g2 . getClip ( ) ;", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( ( new String ( ) ) . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; } } \\ No newline at end of file", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( locale ! = null ) { key = new Pair ( key , locale ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0}
{"buggy_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 0}
{"buggy_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) {       } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0}
{"buggy_code": "final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 0}
{"buggy_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . IS_DISPATCHER ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : boolean valid = false ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; j < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0}
{"buggy_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "/ / Revert to scalar multiplication . final double [ ] prodHigh = new double [ 64 ] ; double prodLowSum = 0 ; for ( int i = 0 ; i < len ; i + + ) {", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return Math . random ( ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1}
{"buggy_code": "public class test { public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; boolean stillPadding = true ; int end = offset + length ; int start = offset ; for ( int i = start ; i < end ; i + + ) { final byte currentByte = buffer [ i ] ; if ( currentByte = = 0 ) { break ; } / / Skip leading spaces if ( currentByte = = ( byte ) ' ' | | currentByte = = ' 0 ' ) { if ( stillPadding ) { continue ; } if ( currentByte = = ( byte ) ' ' ) { break ; } } / / Must have trailing NUL or space / / May have additional NUL or space stillPadding = false ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "public class test { public static long parseOctal ( final byte [ ] buffer , final int offset , final int length ) { long result = 0 ; int end = offset + length ; int start = offset ; if ( length < 2 ) { throw new IllegalArgumentException ( \" Length \" + length + \" must be at least 2 \" ) ; }  boolean allNUL = true ; for ( int i = start ; i < end ; i + + ) { if ( buffer [ i ] ! = 0 ) { allNUL = false ; break ; } } if ( allNUL ) { return 0L ; } / / Skip leading spaces while ( start < end ) { if ( buffer [ start ] = = ' ' ) { start + + ; } else { break ; } } / / Must have trailing NUL or space byte trailer ; trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } / / May have additional NUL or space trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1}
{"buggy_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "fixed_code": "return abs . toExternalForm ( ) ; } / / workaround : java resolves ' / / path / file + ? foo ' to ' / / path / ? foo ' , not ' / / path / file ? foo ' as desired if ( relUrl . startsWith ( \" ? \" ) ) relUrl = base . getPath ( ) + relUrl ; URL abs = new URL ( base , relUrl ) ; return abs . toExternalForm ( ) ; } catch ( MalformedURLException e ) {", "label": 1}
{"buggy_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { if ( buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ) { t = p . nextToken ( ) ; Object bean ; try { bean = creator . build ( ctxt , buffer ) ; } catch ( Exception e ) { wrapAndThrow ( e , _beanType . getRawClass ( ) , propName , ctxt ) ; continue ; } while ( t = = JsonToken . FIELD_NAME ) { p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { ctxt . reportMappingException ( \" Can not create polymorphic instances with unwrapped values \" ) ; return null ; } return _unwrappedPropertyHandler . processUnwrapped ( p , ctxt , bean , tokens ) ; } continue ; } / / Object Id property ?", "fixed_code": "/ / creator property ? SettableBeanProperty creatorProp = creator . findCreatorProperty ( propName ) ; if ( creatorProp ! = null ) { buffer . assignParameter ( creatorProp , creatorProp . deserialize ( p , ctxt ) ) ; continue ; } / / Object Id property ?", "label": 1}
{"buggy_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + undesired . getMock ( ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } private String exceptionCauseMessageIfAvailable ( Exception details ) { return details . getCause ( ) . getMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "throw new NoInteractionsWanted ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) , scenario ) ) ; throw new VerificationInOrderFailure ( join ( \" No interactions wanted here : \" , new LocationImpl ( ) , \" But found this interaction on mock ' \" + safelyGetMockName ( undesired . getMock ( ) ) + \" ' : \" , undesired . getLocation ( ) ) ) ; } private String exceptionCauseMessageIfAvailable ( Exception details ) { if ( details . getCause ( ) = = null ) { return details . getMessage ( ) ; } return details . getCause ( ) . getMessage ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / Analyze any @ lends object literals in this statement . } private void attachLiteralTypes ( NodeTraversal t , Node n ) { switch ( n . getType ( ) ) { break ; case Token . OBJECTLIT : defineObjectLiteral ( n ) ; break ; / / NOTE ( nicksantos ) : If we ever support Array tuples ,", "fixed_code": "} / / Analyze any @ lends object literals in this statement . if ( n . getParent ( ) ! = null & & NodeUtil . isStatement ( n ) & & lentObjectLiterals ! = null ) { for ( Node objLit : lentObjectLiterals ) { defineObjectLiteral ( objLit ) ; } lentObjectLiterals . clear ( ) ; } } private void attachLiteralTypes ( NodeTraversal t , Node n ) { switch ( n . getType ( ) ) { break ; case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; } lentObjectLiterals . add ( n ) ; } else { defineObjectLiteral ( n ) ; } break ; / / NOTE ( nicksantos ) : If we ever support Array tuples ,", "label": 1}
{"buggy_code": "public class test { String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) - 1 ) ; pos = input . length ( ) ; return data ; } CharacterReader ( String input ) { Validate . notNull ( input ) ; this . input = input ; this . length = input . length ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { CharacterReader ( String input ) { Validate . notNull ( input ) ; input = input . replaceAll ( \" \\ r \\ n ? \" , \" \\ n \" ) ; / / normalise carriage returns to newlines this . input = input ; this . length = input . length ( ) ; } String consumeToEnd ( ) { String data = input . substring ( pos , input . length ( ) ) ; pos = input . length ( ) ; return data ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1}
{"buggy_code": "df . setTimeZone ( tz ) ; } } return df ; } } \\ No newline at end of file", "fixed_code": "df . setTimeZone ( tz ) ; } } if ( lenient ! = null ) { df . setLenient ( lenient . booleanValue ( ) ) ; } return df ; } public void setLenient ( boolean enabled ) { Boolean newValue = enabled ; if ( _lenient ! = newValue ) { _lenient = newValue ; _clearFormats ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Warning about typeOfThis if it doesn ' t resolve to an ObjectType / / is handled further upstream . / / TODO ( nicksantos ) : Handle this correctly if we have a UnionType . typeOfThis = ( ObjectType ) safeResolve ( typeOfThis , t , scope ) ; boolean changed = false ; ImmutableList . Builder < ObjectType > resolvedInterfaces =", "fixed_code": "/ / Warning about typeOfThis if it doesn ' t resolve to an ObjectType / / is handled further upstream . / / TODO ( nicksantos ) : Handle this correctly if we have a UnionType . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; } boolean changed = false ; ImmutableList . Builder < ObjectType > resolvedInterfaces =", "label": 1}
{"buggy_code": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = tq . consumeToAny ( combinators ) ; Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private void combinator ( char combinator ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; / / support multi > childs Elements output ; if ( combinator = = ' > ' ) elements . clear ( ) ; elements . addAll ( output ) ; } private String consumeSubQuery ( ) { StringBuilder sq = new StringBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( \" ( \" ) ) sq . append ( \" ( \" ) . append ( tq . chompBalanced ( ' ( ' , ' ) ' ) ) . append ( \" ) \" ) ; else if ( tq . matches ( \" [ \" ) ) sq . append ( \" [ \" ) . append ( tq . chompBalanced ( ' [ ' , ' ] ' ) ) . append ( \" ] \" ) ; else if ( tq . matchesAny ( combinators ) ) break ; else sq . append ( tq . consume ( ) ) ; } return sq . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return Complex . INF ; } if ( isInfinite ) {", "label": 1}
{"buggy_code": "public class test { public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public UncheckedIOException ( String message ) { super ( new IOException ( message ) ) ; } public CharacterReader ( Reader input , int sz ) { Validate . notNull ( input ) ; Validate . isTrue ( input . markSupported ( ) ) ; charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; if ( isBinary ( ) ) { throw new UncheckedIOException ( \" Input is binary and unsupported \" ) ; } } boolean isBinary ( ) { int nullsSeen = 0 ;  for ( int i = bufPos ; i < bufLength ; i + + ) { if ( charBuf [ i ] = = ' \\ 0 ' ) nullsSeen + + ; }  return nullsSeen > = numNullsConsideredBinary ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Complex divide ( Complex divisor ) throws NullArgumentException { MathUtils . checkNotNull ( divisor ) ; return NaN ; } if ( divisor . getReal ( ) = = 0 . 0 & & divisor . getImaginary ( ) = = 0 . 0 ) { return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { ( imaginary - real * q ) / denominator ) ; } } public Complex divide ( double divisor ) { if ( isNaN | | Double . isNaN ( divisor ) ) { return NaN ; } if ( divisor = = 0d ) { return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ; } return createComplex ( real / divisor , imaginary / divisor ) ; } public Complex ( double real , double imaginary ) { this . real = real ; this . imaginary = imaginary ; isNaN = Double . isNaN ( real ) | | Double . isNaN ( imaginary ) ; isInfinite = ! isNaN & & ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Complex divide ( double divisor ) { if ( isNaN | | Double . isNaN ( divisor ) ) { return NaN ; } if ( divisor = = 0d ) { return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ; } return createComplex ( real / divisor , imaginary / divisor ) ; } public Complex divide ( Complex divisor ) throws NullArgumentException { MathUtils . checkNotNull ( divisor ) ; return NaN ; } if ( divisor . isZero ) { return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { ( imaginary - real * q ) / denominator ) ; } } public Complex ( double real , double imaginary ) { this . real = real ; this . imaginary = imaginary ; isNaN = Double . isNaN ( real ) | | Double . isNaN ( imaginary ) ; isInfinite = ! isNaN & & ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) ) ; isZero = real = = 0 & & imaginary = = 0 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; } } \\ No newline at end of file", "fixed_code": "public class test { static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Let ' s verify it ' s lossless conversion by simple roundtrip int result = ( int ) _numberLong ; if ( ( ( long ) result ) ! = _numberLong ) { _reportError ( \" Numeric value ( \" + getText ( ) + \" ) out of range of int \" ) ; } _numberInt = result ; } else if ( ( _numTypesValid & NR_BIGINT ) ! = 0 ) { } protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { final String numDesc = _longIntegerDesc ( rawNum ) ; _reportError ( \" Numeric value ( % s ) out of range of % s \" , numDesc , ( expType = = NR_LONG ) ? \" long \" : \" int \" ) ; } } \\ No newline at end of file", "fixed_code": "/ / Let ' s verify it ' s lossless conversion by simple roundtrip int result = ( int ) _numberLong ; if ( ( ( long ) result ) ! = _numberLong ) { reportOverflowInt ( getText ( ) , currentToken ( ) ) ; } _numberInt = result ; } else if ( ( _numTypesValid & NR_BIGINT ) ! = 0 ) { } protected void _reportTooLongIntegral ( int expType , String rawNum ) throws IOException { if ( expType = = NR_INT ) { reportOverflowInt ( rawNum ) ; } else { reportOverflowLong ( rawNum ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } else { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , end - 1 , trailer ) ) ; } trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "fixed_code": "/ / space but some implementations use the extra digit for big / / sizes / uids / gids . . . byte trailer = buffer [ end - 1 ] ; while ( start < end & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "label": 1}
{"buggy_code": "public class test { public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1}
{"buggy_code": "public class test { public TypeSerializer buildTypeSerializer ( SerializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeSerializer ( idRes , null ) ; case PROPERTY : return new AsPropertyTypeSerializer ( idRes , null , _typeProperty ) ; case WRAPPER_OBJECT : return new AsWrapperTypeSerializer ( idRes , null ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeSerializer ( idRes , null , _typeProperty ) ; case EXISTING_PROPERTY : return new AsExistingPropertyTypeSerializer ( idRes , null , _typeProperty ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } public TypeSerializer buildTypeSerializer ( SerializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeSerializer ( idRes , null ) ; case PROPERTY : return new AsPropertyTypeSerializer ( idRes , null , _typeProperty ) ; case WRAPPER_OBJECT : return new AsWrapperTypeSerializer ( idRes , null ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeSerializer ( idRes , null , _typeProperty ) ; case EXISTING_PROPERTY : return new AsExistingPropertyTypeSerializer ( idRes , null , _typeProperty ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "fixed_code": "/ / [ databind # 877 ] : explicitly prevent forced access to ` cause ` of ` Throwable ` ; / / never needed and attempts may cause problems on some platforms . / / ! ! ! NOTE : should be handled better for 2 . 8 and later if ( ( mutator instanceof AnnotatedField ) & & \" cause \" . equals ( mutator . getName ( ) ) ) { ; } else { mutator . fixAccess ( ctxt . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } } / / note : this works since we know there ' s exactly one argument for methods BeanProperty . Std property = new BeanProperty . Std ( propDef . getFullName ( ) ,", "label": 1}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "public class test { public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1}
{"buggy_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i + + ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "fixed_code": "return - 1 ; } for ( int i = 0 ; i < len ; + + i ) { char c = str . charAt ( i ) ; if ( c > ' 9 ' | | c < ' 0 ' ) { return - 1 ; }", "label": 1}
{"buggy_code": "} delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "fixed_code": "\" ) returned true for ' canCreateUsingDelegate ( ) ' , but null for ' getDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } else if ( _valueInstantiator . canCreateUsingArrayDelegate ( ) ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; if ( delegateType = = null ) { throw new IllegalArgumentException ( \" Invalid array - delegate - creator definition for \" + _collectionType + \" : value instantiator ( \" + _valueInstantiator . getClass ( ) . getName ( ) + \" ) returned true for ' canCreateUsingArrayDelegate ( ) ' , but null for ' getArrayDelegateType ( ) ' \" ) ; } delegateDeser = findDeserializer ( ctxt , delegateType , property ) ; } } / / [ databind # 1043 ] : allow per - property allow - wrapping of single overrides :", "label": 1}
{"buggy_code": "public class test { public DefaultPrettyPrinter createInstance ( ) { return new DefaultPrettyPrinter ( this ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public DefaultPrettyPrinter createInstance ( ) { if ( getClass ( ) ! = DefaultPrettyPrinter . class ) { / / since 2 . 10 throw new IllegalStateException ( \" Failed ` createInstance ( ) ` : \" + getClass ( ) . getName ( ) + \" does not override method ; it has to \" ) ; } return new DefaultPrettyPrinter ( this ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / } append ( newcode ) ;", "fixed_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / append ( \" \" ) ; } append ( newcode ) ;", "label": 1}
{"buggy_code": "public class test { private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } } cc . endSourceMapping ( n ) ; } void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "public class test { void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } } cc . endSourceMapping ( n ) ; } private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , e . getMessage ( ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , e . getMessage ( ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type", "fixed_code": "serializationType = findSerializationType ( am , defaultUseStaticTyping , declaredType ) ; } catch ( JsonMappingException e ) { if ( propDef = = null ) { return prov . reportBadDefinition ( declaredType , ClassUtil . exceptionMessage ( e ) ) ; } return prov . reportBadPropertyDefinition ( _beanDesc , propDef , ClassUtil . exceptionMessage ( e ) ) ; } / / Container types can have separate type serializers for content ( value / element ) type", "label": 1}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1}
{"buggy_code": "public class test { public String setValue ( String val ) { String oldVal = parent . get ( this . key ) ; if ( parent ! = null ) { int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "fixed_code": "public class test { public String setValue ( String val ) { String oldVal = this . val ; if ( parent ! = null ) { oldVal = parent . get ( this . key ) ; / / trust the container more int i = parent . indexOfKey ( this . key ) ; if ( i ! = Attributes . NotFound ) parent . vals [ i ] = val ;", "label": 1}
{"buggy_code": "} catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , t . getMessage ( ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = e . getMessage ( ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; }", "fixed_code": "} catch ( Throwable t ) { String msg = String . format ( \" Problem determining whether filter of type ' % s ' should filter out ` null ` values : ( % s ) % s \" , filter . getClass ( ) . getName ( ) , t . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( t ) ) ; reportBadDefinition ( filter . getClass ( ) , msg , t ) ; return false ; / / never gets here } if ( e instanceof IOException ) { return ( IOException ) e ; } String msg = ClassUtil . exceptionMessage ( e ) ; if ( msg = = null ) { msg = \" [ no message for \" + e . getClass ( ) . getName ( ) + \" ] \" ; }", "label": 1}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1}
{"buggy_code": "public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) return new CollectionType ( rawType , null , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , null , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } public static SimpleType construct ( Class < ? > cls ) if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } return new SimpleType ( cls , TypeBindings . emptyBindings ( ) , _bogusSuperClass ( cls ) , null , null , null , false ) ; } } \\ No newline at end of file", "fixed_code": "public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 1 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , elemT ) ; } return new CollectionType ( rawType , bindings , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ; { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 2 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , keyT , valueT ) ; } / / ! ! ! TODO : Wrong , does have supertypes return new MapType ( rawType , bindings , _bogusSuperClass ( rawType ) , null , keyT , valueT , null , null , false ) ; } public static SimpleType construct ( Class < ? > cls ) if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } TypeBindings b = TypeBindings . emptyBindings ( ) ; return new SimpleType ( cls , b , _buildSuperClass ( cls . getSuperclass ( ) , b ) , null , null , null , false ) ; } private static JavaType _buildSuperClass ( Class < ? > superClass , TypeBindings b ) { if ( superClass = = null ) { return null ; } if ( superClass = = Object . class ) { return TypeFactory . unknownType ( ) ; } JavaType superSuper = _buildSuperClass ( superClass . getSuperclass ( ) , b ) ; return new SimpleType ( superClass , b , superSuper , null , null , null , false ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; if ( el . tag . preserveWhitespace ( ) ) return true ; else return el . parent ( ) ! = null & & el . parent ( ) . tag . preserveWhitespace ( ) ; } return false ; }", "fixed_code": "/ / looks only at this element and five levels up , to prevent recursion & needless stack searches if ( node ! = null & & node instanceof Element ) { Element el = ( Element ) node ; int i = 0 ; do { if ( el . tag . preserveWhitespace ( ) ) return true ; el = el . parent ( ) ; i + + ; } while ( i < 6 & & el ! = null ) ; } return false ; }", "label": 1}
{"buggy_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1}
{"buggy_code": "while ( true ) { if ( toResolve instanceof TypeVariable ) { TypeVariable < ? > typeVariable = ( TypeVariable < ? > ) toResolve ; / / cannot reduce due to infinite recursion toResolve = resolveTypeVariable ( context , contextRawType , typeVariable ) ; if ( toResolve = = typeVariable ) { return toResolve ;", "fixed_code": "while ( true ) { if ( toResolve instanceof TypeVariable ) { TypeVariable < ? > typeVariable = ( TypeVariable < ? > ) toResolve ; if ( visitedTypeVariables . contains ( typeVariable ) ) { / / cannot reduce due to infinite recursion return toResolve ; } else { visitedTypeVariables . add ( typeVariable ) ; } toResolve = resolveTypeVariable ( context , contextRawType , typeVariable ) ; if ( toResolve = = typeVariable ) { return toResolve ;", "label": 1}
{"buggy_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } valueToSuppress = getPropertyDefaultValue ( propDef . getName ( ) , am , actualType ) ; } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "fixed_code": "/ / whereas for global defaults OR per - property overrides , we have more / / static definition . Sigh . / / First : case of class / type specifying it ; try to find POJO property defaults Object defaultBean ; / / 16 - Oct - 2016 , tatu : Note : if we can not for some reason create \" default instance \" , / / revert logic to the case of general / per - property handling , so both / / type - default AND null are to be excluded . / / ( as per [ databind # 1417 ] if ( _useRealPropertyDefaults & & ( defaultBean = getDefaultBean ( ) ) ! = null ) { / / 07 - Sep - 2016 , tatu : may also need to front - load access forcing now if ( prov . isEnabled ( MapperFeature . CAN_OVERRIDE_ACCESS_MODIFIERS ) ) { am . fixAccess ( _config . isEnabled ( MapperFeature . OVERRIDE_PUBLIC_ACCESS_MODIFIERS ) ) ; } try { valueToSuppress = am . getValue ( defaultBean ) ; } catch ( Exception e ) { _throwWrapped ( e , propDef . getName ( ) , defaultBean ) ; } } else { valueToSuppress = getDefaultValue ( actualType ) ; suppressNulls = true ;", "label": 1}
{"buggy_code": "public class test { public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "fixed_code": "public class test { public String generateToolTipFragment ( String instruction ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 & & inf . finished ( ) ) { return - 1 ; } crc . update ( buffer , start , read ) ; return read ;", "fixed_code": "} catch ( DataFormatException e ) { throw new ZipException ( e . getMessage ( ) ) ; } if ( read = = 0 ) { if ( inf . finished ( ) ) { return - 1 ; } else if ( lengthOfLastRead = = - 1 ) { throw new IOException ( \" Truncated ZIP file \" ) ; } } crc . update ( buffer , start , read ) ; return read ;", "label": 1}
{"buggy_code": "public class test { public double toDouble ( ) { if ( isInfinite ( ) ) { Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; } return x ; } protected Dfp ( final DfpField field , double x ) {  mant = new int [ field . getRadixDigits ( ) ] ; sign = 1 ; exp = 0 ; nans = FINITE ; this . field = field ;  long bits = Double . doubleToLongBits ( x ) ; long mantissa = bits & 0x000fffffffffffffL ; int exponent = ( int ) ( ( bits & 0x7ff0000000000000L ) > > 52 ) - 1023 ;  if ( exponent = = - 1023 ) { if ( x = = 0 ) { return ; }  exponent + + ;  while ( ( mantissa & 0x0010000000000000L ) = = 0 ) { exponent - - ; mantissa < < = 1 ; } mantissa & = 0x000fffffffffffffL ; }  if ( exponent = = 1024 ) { if ( x ! = x ) { sign = ( byte ) 1 ; nans = QNAN ; } else if ( x < 0 ) { sign = ( byte ) - 1 ; nans = INFINITE ; } else { sign = ( byte ) 1 ; nans = INFINITE ; } return ; }  Dfp xdfp = new Dfp ( field , mantissa ) ; xdfp = xdfp . divide ( new Dfp ( field , 4503599627370496l ) ) . add ( field . getOne ( ) ) ; / / Divide by 2 ^ 52 , then add one xdfp = xdfp . multiply ( DfpMath . pow ( field . getTwo ( ) , exponent ) ) ;  if ( ( bits & 0x8000000000000000L ) ! = 0 ) { xdfp = xdfp . negate ( ) ; }  System . arraycopy ( xdfp . mant , 0 , mant , 0 , mant . length ) ; sign = xdfp . sign ; exp = xdfp . exp ; nans = xdfp . nans ;  } } \\ No newline at end of file", "fixed_code": "public class test { protected Dfp ( final DfpField field , double x ) {  mant = new int [ field . getRadixDigits ( ) ] ; sign = 1 ; exp = 0 ; nans = FINITE ; this . field = field ;  long bits = Double . doubleToLongBits ( x ) ; long mantissa = bits & 0x000fffffffffffffL ; int exponent = ( int ) ( ( bits & 0x7ff0000000000000L ) > > 52 ) - 1023 ;  if ( exponent = = - 1023 ) { if ( x = = 0 ) { if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; }  exponent + + ;  while ( ( mantissa & 0x0010000000000000L ) = = 0 ) { exponent - - ; mantissa < < = 1 ; } mantissa & = 0x000fffffffffffffL ; }  if ( exponent = = 1024 ) { if ( x ! = x ) { sign = ( byte ) 1 ; nans = QNAN ; } else if ( x < 0 ) { sign = ( byte ) - 1 ; nans = INFINITE ; } else { sign = ( byte ) 1 ; nans = INFINITE ; } return ; }  Dfp xdfp = new Dfp ( field , mantissa ) ; xdfp = xdfp . divide ( new Dfp ( field , 4503599627370496l ) ) . add ( field . getOne ( ) ) ; / / Divide by 2 ^ 52 , then add one xdfp = xdfp . multiply ( DfpMath . pow ( field . getTwo ( ) , exponent ) ) ;  if ( ( bits & 0x8000000000000000L ) ! = 0 ) { xdfp = xdfp . negate ( ) ; }  System . arraycopy ( xdfp . mant , 0 , mant , 0 , mant . length ) ; sign = xdfp . sign ; exp = xdfp . exp ; nans = xdfp . nans ;  } public double toDouble ( ) { if ( isInfinite ( ) ) { Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; } return x ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , buffer ) ) { ; } else { / / Last creator property to set ?", "fixed_code": "/ / first : let ' s check to see if this might be part of value with external type id : / / 11 - Sep - 2015 , tatu : Important ; do NOT pass buffer as last arg , but null , / / since it is not the bean if ( ext . handlePropertyValue ( p , ctxt , propName , null ) ) { ; } else { / / Last creator property to set ?", "label": 1}
{"buggy_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { return new JarArchiveOutputStream ( out ) ; } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { return new ArjArchiveInputStream ( in ) ; } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; }", "fixed_code": "} } if ( JAR . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new JarArchiveOutputStream ( out , entryEncoding ) ; } else { return new JarArchiveOutputStream ( out ) ; } } if ( CPIO . equalsIgnoreCase ( archiverName ) ) { if ( entryEncoding ! = null ) { return new CpioArchiveInputStream ( in ) ; } } else if ( ArjArchiveInputStream . matches ( signature , signatureLength ) ) { if ( entryEncoding ! = null ) { return new ArjArchiveInputStream ( in , entryEncoding ) ; } else { return new ArjArchiveInputStream ( in ) ; } } else if ( SevenZFile . matches ( signature , signatureLength ) ) { throw new StreamingNotSupportedException ( SEVEN_Z ) ; }", "label": 1}
{"buggy_code": "public class test { public void addValue ( Object v ) {  Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Comparable < ? > v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ; throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } } public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "label": 1}
{"buggy_code": "public class test { private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "fixed_code": "public class test { private boolean inSpecificScope ( String [ ] targetNames , String [ ] baseTypes , String [ ] extraTypes ) { int depth = stack . size ( ) - 1 ; if ( depth > MaxScopeSearchDepth ) { depth = MaxScopeSearchDepth ; } for ( int pos = depth ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ;", "label": 1}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Object answer ( InvocationOnMock invocation ) throws Throwable { if ( Modifier . isAbstract ( invocation . getMethod ( ) . getModifiers ( ) ) ) { return new GloballyConfiguredAnswer ( ) . answer ( invocation ) ; } return invocation . callRealMethod ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop } return this ; } private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node   for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidParent ( childTag ) ) { return true ; } } return false ; } private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; stack . addLast ( child ) ; return parent ; } boolean canContain ( Tag child ) { Validate . notNull ( child ) ; return false ; / / don ' t allow children to contain their parent ( directly ) return true ; } } \\ No newline at end of file", "fixed_code": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop } return this ; } private Element addChildToParent ( Element child , boolean isEmptyElement ) { Element parent = popStackToSuitableContainer ( child . tag ( ) ) ; Tag childTag = child . tag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor & & ! relaxed ) { / / create implicit parent around this child Tag parentTag = childTag . getImplicitParent ( ) ; Element implicit = new Element ( parentTag , baseUri ) ; stack . addLast ( child ) ; return parent ; } public static Document parseBodyFragmentRelaxed ( String bodyHtml , String baseUri ) { Parser parser = new Parser ( bodyHtml , baseUri , true ) ; parser . relaxed = true ; return parser . parse ( ) ; } private boolean stackHasValidParent ( Tag childTag ) { if ( stack . size ( ) = = 1 & & childTag . equals ( htmlTag ) ) return true ; / / root is valid for html node  if ( childTag . requiresSpecificParent ( ) ) return stack . getLast ( ) . tag ( ) . isValidParent ( childTag ) ;  for ( int i = stack . size ( ) - 1 ; i > = 0 ; i - - ) { Element el = stack . get ( i ) ; Tag parent2 = el . tag ( ) ; if ( parent2 . isValidAncestor ( childTag ) ) { return true ; } } return false ; } boolean isValidAncestor ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag  for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) return true ; } return false ; } boolean canContain ( Tag child ) { Validate . notNull ( child ) ; return false ; / / don ' t allow children to contain their parent ( directly ) if ( this . requiresSpecificParent ( ) & & this . getImplicitParent ( ) . equals ( child ) ) return false ; return true ; } boolean isValidParent ( Tag child ) { return this . equals ( child . parent ) ; } private Tag setParent ( String tagName ) { parent = Tag . valueOf ( tagName ) ; setAncestor ( tagName ) ; return this ; } boolean requiresSpecificParent ( ) { return this . parent ! = null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1}
{"buggy_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1}
{"buggy_code": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "public class test { public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1}
{"buggy_code": "public class test { public boolean shouldTraverse ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { renamer . addDeclaredName ( name ) ; } / / Add the function parameters / / Add the function body declarations nameStack . push ( renamer ) ; } renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } Node functionBody = declarationRoot . getLastChild ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; } else if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; } nameStack . push ( renamer ) ; } public void visit ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { case Token . NAME : String newName = getReplacementName ( n . getString ( ) ) ; if ( newName ! = null ) { Renamer renamer = nameStack . peek ( ) ; if ( renamer . stripConstIfReplaced ( ) ) { n . removeProp ( Node . IS_CONSTANT_NAME ) ; } n . setString ( newName ) ; t . getCompiler ( ) . reportCodeChange ( ) ; } break ;  case Token . FUNCTION : nameStack . pop ( ) ; break ;   case Token . CATCH : nameStack . pop ( ) ; break ; } } } \\ No newline at end of file", "fixed_code": "public class test { public void visit ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { case Token . NAME : String newName = getReplacementName ( n . getString ( ) ) ; if ( newName ! = null ) { Renamer renamer = nameStack . peek ( ) ; if ( renamer . stripConstIfReplaced ( ) ) { n . removeProp ( Node . IS_CONSTANT_NAME ) ; } n . setString ( newName ) ; t . getCompiler ( ) . reportCodeChange ( ) ; } break ;  case Token . FUNCTION : nameStack . pop ( ) ; nameStack . pop ( ) ; break ;  case Token . LP : break ;  case Token . CATCH : nameStack . pop ( ) ; break ; } } public boolean shouldTraverse ( NodeTraversal t , Node n , Node parent ) { switch ( n . getType ( ) ) { renamer . addDeclaredName ( name ) ; } nameStack . push ( renamer ) ; } break ; case Token . LP : { Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; / / Add the function parameters for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } / / Add the function body declarations Node functionBody = n . getNext ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; nameStack . push ( renamer ) ; } renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; } nameStack . push ( renamer ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 1}
{"buggy_code": "return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( _inputStart > = 0 ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( _segmentSize = = 0 ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "fixed_code": "return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( ( _inputStart > = 0 ) & & ( _inputBuffer ! = null ) ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( ( _segmentSize = = 0 ) & & ( _currentSegment ! = null ) ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "label": 1}
{"buggy_code": "/ / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { return true ; } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "fixed_code": "/ / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) & & am . getParameterCount ( ) = = 1 ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { if ( am . getParameterCount ( ) = = 1 ) { return true ; } } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "label": 1}
{"buggy_code": "public class test { public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "fixed_code": "public class test { public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( ! values . isEmpty ( ) ) header ( name , values . get ( 0 ) ) ; } } }", "fixed_code": "cookie ( cookieName , cookieVal ) ; } } else { / / combine same header names with comma : http : / / www . w3 . org / Protocols / rfc2616 / rfc2616 - sec4 . html # sec4 . 2 if ( values . size ( ) = = 1 ) header ( name , values . get ( 0 ) ) ; else if ( values . size ( ) > 1 ) { StringBuilder accum = new StringBuilder ( ) ; for ( int i = 0 ; i < values . size ( ) ; i + + ) { final String val = values . get ( i ) ; if ( i ! = 0 ) accum . append ( \" , \" ) ; accum . append ( val ) ; } header ( name , accum . toString ( ) ) ; } } } }", "label": 1}
{"buggy_code": "public class test { private InputStream getCurrentStream ( ) throws IOException { if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "fixed_code": "public class test { private InputStream getCurrentStream ( ) throws IOException { if ( archive . files [ currentEntryIndex ] . getSize ( ) = = 0 ) { return new ByteArrayInputStream ( new byte [ 0 ] ) ; } if ( deferredBlockStreams . isEmpty ( ) ) { throw new IllegalStateException ( \" No current 7z entry ( call getNextEntry ( ) first ) . \" ) ; }", "label": 1}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; / / empty function case if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "label": 1}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return org . apache . commons . lang3 . math . NumberUtils . createBigDecimal ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1}
{"buggy_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "fixed_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression ,", "label": 1}
{"buggy_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "fixed_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "label": 1}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "label": 1}
{"buggy_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch return t ; } Class < ? > cls ;", "fixed_code": "/ / compatibility - - needed later anyway , and not doing so may open / / security issues . JavaType t = tf . constructFromCanonical ( id ) ; if ( ! t . isTypeOrSubTypeOf ( _baseType . getRawClass ( ) ) ) { / / Probably cleaner to have a method in ` TypeFactory ` but can ' t add in patch throw new IllegalArgumentException ( String . format ( \" Class % s not subtype of % s \" , t . getRawClass ( ) . getName ( ) , _baseType ) ) ; } return t ; } Class < ? > cls ;", "label": 1}
{"buggy_code": "public class test { public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; } } \\ No newline at end of file", "fixed_code": "public class test { public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < = src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer not owned by the context \" ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected final void _verifyRelease ( char [ ] toRelease , char [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } protected final void _verifyRelease ( byte [ ] toRelease , byte [ ] src ) { / / 07 - Mar - 2016 , tatu : As per [ core # 255 ] , only prevent shrinking of buffer if ( ( toRelease ! = src ) & & ( toRelease . length < src . length ) ) { throw wrongBuf ( ) ; } } private IllegalArgumentException wrongBuf ( ) { / / sanity check failed ; trying to return different , smaller buffer . return new IllegalArgumentException ( \" Trying to release buffer smaller than original \" ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void injectMockCandidate ( Class < ? > awaitingInjectionClazz , Set < Object > mocks , Object fieldInstance ) { for ( Field field : orderedInstanceFieldsFrom ( awaitingInjectionClazz ) ) { mockCandidateFilter . filterCandidate ( mocks , field , fieldInstance ) . thenInject ( ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { private void injectMockCandidate ( Class < ? > awaitingInjectionClazz , Set < Object > mocks , Object fieldInstance ) { for ( Field field : orderedInstanceFieldsFrom ( awaitingInjectionClazz ) ) { Object injected = mockCandidateFilter . filterCandidate ( mocks , field , fieldInstance ) . thenInject ( ) ; mocks . remove ( injected ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { return commandLine . looksLikeOption ( trigger ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { Option oldOption = commandLine . getCurrentOption ( ) ; try { commandLine . setCurrentOption ( this ) ; return commandLine . looksLikeOption ( trigger ) ; } finally { commandLine . setCurrentOption ( oldOption ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > - 1 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1}
{"buggy_code": "public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { Object id = _valueDeserializer . deserialize ( p , ctxt ) ; / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( id = = null ) { return null ; } ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "fixed_code": "public Object deserializeSetAndReturn ( JsonParser p , DeserializationContext ctxt , Object instance ) throws IOException { / / note : no null checks ( unlike usually ) ; deserializer should fail if one found if ( p . hasToken ( JsonToken . VALUE_NULL ) ) { return null ; } Object id = _valueDeserializer . deserialize ( p , ctxt ) ; ReadableObjectId roid = ctxt . findObjectId ( id , _objectIdReader . generator , _objectIdReader . resolver ) ; roid . bindItem ( instance ) ; / / also : may need to set a property value as well", "label": 1}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1}
{"buggy_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ;", "fixed_code": "if ( verificationMode ! = null ) { / / We need to check if verification was started on the correct mock / / - see VerifyingWithAnExtraCallToADifferentMockTest if ( verificationMode instanceof MockAwareVerificationMode & & ( ( MockAwareVerificationMode ) verificationMode ) . getMock ( ) = = invocation . getMock ( ) ) { VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations ( ) , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; } } invocationContainerImpl . setInvocationForPotentialStubbing ( invocationMatcher ) ;", "label": 1}
{"buggy_code": "results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } return results ; } } \\ No newline at end of file", "fixed_code": "results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } out . finish ( ) ; return results ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , null ) ; } return constructParametricType ( parametrized , pt ) ; } / / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , null ) ; } } \\ No newline at end of file", "fixed_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , EMPTY_BINDINGS ) ; } return constructParametricType ( parametrized , pt ) ; } / / can be comma that separates types , or closing ' > ' tokens . pushBack ( token ) ; } return _factory . _fromClass ( null , base , TypeBindings . emptyBindings ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return type . narrowBy ( dst ) ; } } \\ No newline at end of file", "fixed_code": "return null ; } / / 09 - Aug - 2015 , tatu : Instead of direct call via JavaType , better use TypeFactory return config . getTypeFactory ( ) . constructSpecializedType ( type , dst ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 1}
{"buggy_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction outBuf [ outPtr + + ] = c ; fract_loop :", "fixed_code": "int fractLen = 0 ; / / And then see if we get other parts if ( c = = ' . ' ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = c ; fract_loop :", "label": 1}
{"buggy_code": "public class test { < M extends Map < String , String > > M putIn ( final M map ) { for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "fixed_code": "public class test { < M extends Map < String , String > > M putIn ( final M map ) { if ( mapping = = null ) { return map ; } for ( final Entry < String , Integer > entry : mapping . entrySet ( ) ) { final int col = entry . getValue ( ) . intValue ( ) ; if ( col < values . length ) {", "label": 1}
{"buggy_code": "public class test { public Node previousSibling ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } public List < Node > siblingNodes ( ) {  return parent ( ) . childNodes ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public List < Node > siblingNodes ( ) { if ( parentNode = = null ) return Collections . emptyList ( ) ;  List < Node > nodes = parentNode . childNodes ; List < Node > siblings = new ArrayList < Node > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node ! = this ) siblings . add ( node ) ; return siblings ; } public Node previousSibling ( ) { if ( parentNode = = null ) return null ; / / root List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / next stages for ( int k = 1 ; k < stages ; + + k ) {  for ( int j = 0 ; j < y0 . length ; + + j ) { double sum = a [ k - 1 ] [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; + + l ) {", "fixed_code": "/ / next stages for ( int k = 1 ; k < stages ; + + k ) { if ( ( forward & & ( stepStart + stepSize > t ) ) | | ( ( ! forward ) & & ( stepStart + stepSize < t ) ) ) { stepSize = t - stepStart ; } for ( int j = 0 ; j < y0 . length ; + + j ) { double sum = a [ k - 1 ] [ 0 ] * yDotK [ 0 ] [ j ] ; for ( int l = 1 ; l < k ; + + l ) {", "label": 1}
{"buggy_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum tais . getNextEntry ( ) ; return new TarArchiveInputStream ( in ) ; } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "fixed_code": "try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; / / COMPRESS - 191 - verify the header checksum if ( tais . getNextTarEntry ( ) . isCheckSumOK ( ) ) { return new TarArchiveInputStream ( in ) ; } } catch ( Exception e ) { / / NOPMD / / can generate IllegalArgumentException as well / / as IOException", "label": 1}
{"buggy_code": "public class test { public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { public static int gcd ( int u , int v ) { if ( 1 . 0 * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1}
{"buggy_code": "} Node replacement ; / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "fixed_code": "} Node replacement ; if ( nodes . isEmpty ( ) ) { replacement = new Node ( Token . TRUE ) ; } else { / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; } Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "label": 1}
{"buggy_code": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "fixed_code": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ; } public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "label": 1}
{"buggy_code": "return phonemeBuilder ; } final Set < Rule . Phoneme > phonemes = new TreeSet < Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost phonemes . addAll ( subBuilder . getPhonemes ( ) ) ; } return new PhonemeBuilder ( phonemes ) ; } } \\ No newline at end of file", "fixed_code": "return phonemeBuilder ; } final Map < Rule . Phoneme , Rule . Phoneme > phonemes = new TreeMap < Rule . Phoneme , Rule . Phoneme > ( Rule . Phoneme . COMPARATOR ) ; for ( final Rule . Phoneme phoneme : phonemeBuilder . getPhonemes ( ) ) { PhonemeBuilder subBuilder = PhonemeBuilder . empty ( phoneme . getLanguages ( ) ) ; / / the phonemes map orders the phonemes only based on their text , but ignores the language set / / when adding new phonemes , check for equal phonemes and merge their language set , otherwise / / phonemes with the same text but different language set get lost for ( final Rule . Phoneme newPhoneme : subBuilder . getPhonemes ( ) ) { if ( phonemes . containsKey ( newPhoneme ) ) { final Rule . Phoneme oldPhoneme = phonemes . remove ( newPhoneme ) ; final Rule . Phoneme mergedPhoneme = oldPhoneme . mergeWithLanguage ( newPhoneme . getLanguages ( ) ) ; phonemes . put ( mergedPhoneme , mergedPhoneme ) ; } else { phonemes . put ( newPhoneme , newPhoneme ) ; } } } return new PhonemeBuilder ( phonemes . keySet ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currText = _xmlTokens . getText ( ) ; _currToken = JsonToken . VALUE_STRING ; break ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "fixed_code": "} break ; case XmlTokenStream . XML_ATTRIBUTE_VALUE : _currToken = JsonToken . VALUE_STRING ; return ( _currText = _xmlTokens . getText ( ) ) ; case XmlTokenStream . XML_TEXT : _currText = _xmlTokens . getText ( ) ; if ( _mayBeLeaf ) {", "label": 1}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1}
{"buggy_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = value . indexOf ( ' _ ' ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } throw new IllegalArgumentException ( ) ; } } \\ No newline at end of file", "fixed_code": "return Pattern . compile ( value ) ; case STD_LOCALE : { int ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / single argument return new Locale ( value ) ; } String first = value . substring ( 0 , ix ) ; value = value . substring ( ix + 1 ) ; ix = _firstHyphenOrUnderscore ( value ) ; if ( ix < 0 ) { / / two pieces return new Locale ( first , value ) ; } } throw new IllegalArgumentException ( ) ; } protected int _firstHyphenOrUnderscore ( String str ) { for ( int i = 0 , end = str . length ( ) ; i < end ; + + i ) { char c = str . charAt ( i ) ; if ( c = = ' _ ' | | c = = ' - ' ) { return i ; } } return - 1 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers MapSerializer anySer = MapSerializer . construct ( null , type , staticTyping , typeSer , null , null , null ) ; / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "fixed_code": "TypeSerializer typeSer = createTypeSerializer ( config , valueType ) ; / / last 2 nulls ; don ' t know key , value serializers ( yet ) / / 23 - Feb - 2015 , tatu : As per [ # 705 ] , need to support custom serializers JsonSerializer < ? > anySer = findSerializerFromAnnotation ( prov , anyGetter ) ; if ( anySer = = null ) { / / TODO : support ' @ JsonIgnoreProperties ' with any setter ? } / / TODO : can we find full PropertyName ? PropertyName name = new PropertyName ( anyGetter . getName ( ) ) ; BeanProperty . Std anyProp = new BeanProperty . Std ( name , valueType , null ,", "label": 1}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "label": 1}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1}
{"buggy_code": "while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of prop . removeNonVisible ( inferMutators ) ; } } } \\ No newline at end of file", "fixed_code": "while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of Access acc = prop . removeNonVisible ( inferMutators ) ; if ( ! _forSerialization & & ( acc = = Access . READ_ONLY ) ) { _collectIgnorals ( prop . getName ( ) ) ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "fixed_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { if ( c2 = = 0 ) { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; } a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "label": 1}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , externs , new ProcessExterns ( ) ) ; NodeTraversal . traverse ( compiler , root , new ProcessProperties ( ) ) ; for ( Property p : propertyMap . values ( ) ) { if ( ! p . skipAmbiguating ) { computeRelatedTypes ( p . type ) ; propsByFreq . add ( p ) ; } else { } public boolean isIndependentOf ( Property prop ) { if ( typesRelatedToSet . intersects ( prop . typesSet ) ) { return false ; } return ! getRelated ( prop . type ) . intersects ( typesInSet ) ; } private void addNonUnionType ( JSType newType ) { if ( skipAmbiguating | | isInvalidatingType ( newType ) ) { skipAmbiguating = true ; return ; } if ( type = = null ) { type = newType ; } else { type = type . getLeastSupertype ( newType ) ; } typesSet . set ( getIntForType ( newType ) ) ; } public void addNode ( Property prop ) { typesInSet . or ( prop . typesSet ) ; typesRelatedToSet . or ( getRelated ( prop . type ) ) ; } private FunctionType findOverriddenFunction ( ObjectType ownerType , String propName ) { JSType propType = ownerType . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } / / If it ' s not , then check to see if it ' s implemented / / on an implemented interface . return null ; }", "fixed_code": "public class test { public void addNode ( Property prop ) { typesInSet . or ( prop . typesSet ) ; typesRelatedToSet . or ( prop . relatedTypesSet ) ; } public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , externs , new ProcessExterns ( ) ) ; NodeTraversal . traverse ( compiler , root , new ProcessProperties ( ) ) ; for ( Property p : propertyMap . values ( ) ) { if ( ! p . skipAmbiguating ) { + numRenamedPropertyNames ; propsByFreq . add ( p ) ; } else { + numSkippedPropertyNames ; numNewPropertyNames + \" and skipped renaming \" numSkippedPropertyNames + \" properties . \" ) ; } private void addNonUnionType ( JSType newType ) { if ( skipAmbiguating | | isInvalidatingType ( newType ) ) { skipAmbiguating = true ; return ; } int typeInt = getIntForType ( newType ) ; if ( ! typesSet . get ( typeInt ) ) { computeRelatedTypes ( newType ) ; typesSet . set ( typeInt ) ; relatedTypesSet . or ( getRelatedTypesOnNonUnion ( newType ) ) ; } } public boolean isIndependentOf ( Property prop ) { if ( typesRelatedToSet . intersects ( prop . typesSet ) ) { return false ; } return ! prop . relatedTypesSet . intersects ( typesInSet ) ; } private FunctionType findOverriddenFunction ( ObjectType ownerType , String propName ) { JSType propType = ownerType . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } else { / / If it ' s not , then check to see if it ' s implemented / / on an implemented interface . for ( ObjectType iface : ownerType . getCtorImplementedInterfaces ( ) ) { propType = iface . getPropertyType ( propName ) ; if ( propType instanceof FunctionType ) { return ( FunctionType ) propType ; } } } return null ; }", "label": 1}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : safeSubtract ( 0 , val1 ) ; return - val1 ; case 0 : return 0L ;", "label": 1}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ;", "fixed_code": "public class test { public JsonWriter value ( double value ) throws IOException { writeDeferredName ( ) ; if ( ! lenient & & ( Double . isNaN ( value ) | | Double . isInfinite ( value ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ;", "label": 1}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "label": 1}
{"buggy_code": "public class test { protected String getLanguage ( ) { Node n = node ; while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( \" xml : lang \" ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } private String stringValue ( Node node ) { int nodeType = node . getNodeType ( ) ; if ( nodeType = = Node . COMMENT_NODE ) { String text = ( ( Comment ) node ) . getData ( ) ; return text = = null ? \" \" : text . trim ( ) ; } if ( nodeType = = Node . TEXT_NODE | | nodeType = = Node . CDATA_SECTION_NODE ) { String text = node . getNodeValue ( ) ; return text = = null ? \" \" : text . trim ( ) ; } if ( nodeType = = Node . PROCESSING_INSTRUCTION_NODE ) { String text = ( ( ProcessingInstruction ) node ) . getData ( ) ; return text = = null ? \" \" : text . trim ( ) ; } NodeList list = node . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( 16 ) ; for ( int i = 0 ; i < list . getLength ( ) ; i + + ) { Node child = list . item ( i ) ; if ( child . getNodeType ( ) = = Node . TEXT_NODE ) { buf . append ( child . getNodeValue ( ) ) ; } else { buf . append ( stringValue ( child ) ) ; } } return buf . toString ( ) . trim ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected static String findEnclosingAttribute ( Node n , String attrName ) { while ( n ! = null ) { if ( n . getNodeType ( ) = = Node . ELEMENT_NODE ) { Element e = ( Element ) n ; String attr = e . getAttribute ( attrName ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } private String stringValue ( Node node ) { int nodeType = node . getNodeType ( ) ; if ( nodeType = = Node . COMMENT_NODE ) { return \" \" ; } boolean trim = ! \" preserve \" . equals ( findEnclosingAttribute ( node , \" xml : space \" ) ) ; if ( nodeType = = Node . TEXT_NODE | | nodeType = = Node . CDATA_SECTION_NODE ) { String text = node . getNodeValue ( ) ; return text = = null ? \" \" : trim ? text . trim ( ) : text ; } if ( nodeType = = Node . PROCESSING_INSTRUCTION_NODE ) { String text = ( ( ProcessingInstruction ) node ) . getData ( ) ; return text = = null ? \" \" : trim ? text . trim ( ) : text ; } NodeList list = node . getChildNodes ( ) ; StringBuffer buf = new StringBuffer ( 16 ) ; for ( int i = 0 ; i < list . getLength ( ) ; i + + ) { Node child = list . item ( i ) ; buf . append ( stringValue ( child ) ) ; } return buf . toString ( ) ; } public Object getValue ( ) { if ( node . getNodeType ( ) = = Node . COMMENT_NODE ) { String text = ( ( Comment ) node ) . getData ( ) ; return text = = null ? \" \" : text . trim ( ) ; } return stringValue ( node ) ; } protected String getLanguage ( ) { return findEnclosingAttribute ( node , \" xml : lang \" ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1}
{"buggy_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } } } \\ No newline at end of file", "fixed_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "- _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intPartLength ) ; } private int _skipWSOrEnd ( ) throws IOException { final int [ ] codes = _icWS ; while ( ( _inputPtr < _inputEnd ) | | loadMore ( ) ) { final int i = _inputBuffer [ _inputPtr + + ] & 0xFF ; switch ( codes [ i ] ) { case 0 : / / done ! return i ; case 1 : / / skip continue ; case 2 : / / 2 - byte UTF _skipUtf8_2 ( i ) ; break ; case 3 : / / 3 - byte UTF _skipUtf8_3 ( i ) ; break ; case 4 : / / 4 - byte UTF _skipUtf8_4 ( i ) ; break ; case INT_LF : + + _currInputRow ; _currInputRowStart = _inputPtr ; break ; case INT_CR : _skipCR ( ) ; break ; case ' / ' : _skipComment ( ) ; break ; case ' # ' : if ( ! _skipYAMLComment ( ) ) { return i ; } break ; default : / / e . g . - 1 if ( i < 32 ) { _throwInvalidSpace ( i ) ; } _reportInvalidChar ( i ) ; } } _handleEOF ( ) ; return - 1 ; } private JsonToken _parseFloat ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException if ( ! eof ) { - _inputPtr ; / / As per # 105 , need separating space between root values ; check here } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; } protected JsonToken _parseNumber ( int c ) throws IOException , JsonParseException { - _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intLen ) ;", "fixed_code": "_textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( _inputBuffer [ _inputPtr + + ] & 0xFF ) ; } / / And there we have it ! return resetInt ( negative , intPartLength ) ; } private JsonToken _parseFloat ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException if ( ! eof ) { / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; } private final void _verifyRootSpace ( int ch ) throws IOException { + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; } private int _skipWSOrEnd ( ) throws IOException { final int [ ] codes = _icWS ; while ( ( _inputPtr < _inputEnd ) | | loadMore ( ) ) { final int i = _inputBuffer [ _inputPtr + + ] & 0xFF ; switch ( codes [ i ] ) { case 0 : / / done ! return i ; case 1 : / / skip continue ; case 2 : / / 2 - byte UTF _skipUtf8_2 ( i ) ; break ; case 3 : / / 3 - byte UTF _skipUtf8_3 ( i ) ; break ; case 4 : / / 4 - byte UTF _skipUtf8_4 ( i ) ; break ; case INT_LF : + + _currInputRow ; _currInputRowStart = _inputPtr ; break ; case INT_CR : _skipCR ( ) ; break ; case ' / ' : _skipComment ( ) ; break ; case ' # ' : if ( ! _skipYAMLComment ( ) ) { return i ; } break ; default : / / e . g . - 1 _reportInvalidChar ( i ) ; } } _handleEOF ( ) ; return - 1 ; } protected JsonToken _parseNumber ( int c ) throws IOException , JsonParseException { _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } / / And there we have it ! return resetInt ( negative , intLen ) ;", "label": 1}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdValueProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdValueProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1}
{"buggy_code": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "fixed_code": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1}
{"buggy_code": "return offsetLocal ; } } } return offsetAdjusted ; }", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "label": 1}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 1}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 1}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" +", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" +", "label": 1}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return total ; }", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : break ; case 0 : return 0L ; case 1 : return val1 ; } long total = val1 * val2 ; if ( total / val2 ! = val1 | | val1 = = Long . MIN_VALUE & & val2 = = - 1 | | val2 = = Long . MIN_VALUE & & val1 = = - 1 ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return total ; }", "label": 1}
{"buggy_code": "public class test { public ZipShort getCentralDirectoryLength ( ) { return getLocalFileDataLength ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public ZipShort getCentralDirectoryLength ( ) { return ZERO ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' ' ) { / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "fixed_code": "int read = 0 ; while ( ( ch = i . read ( ) ) ! = - 1 ) { read + + ; if ( ch = = ' \\ n ' ) { / / blank line in header break ; } else if ( ch = = ' ' ) { / / End of length string / / Get keyword final ByteArrayOutputStream coll = new ByteArrayOutputStream ( ) ; while ( ( ch = i . read ( ) ) ! = - 1 ) {", "label": 1}
{"buggy_code": "public class test { public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double percentageValue ( ) { return 100 * doubleValue ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } } } \\ No newline at end of file", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; + i ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public JavaType constructType ( Type type , JavaType contextType ) { return _fromAny ( null , type , contextType . getBindings ( ) ) ; } public JavaType constructType ( Type type , Class < ? > contextClass ) { return constructType ( type , constructType ( contextClass ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public JavaType constructType ( Type type , Class < ? > contextClass ) { TypeBindings bindings = ( contextClass = = null ) ? TypeBindings . emptyBindings ( ) : constructType ( contextClass ) . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } public JavaType constructType ( Type type , JavaType contextType ) { TypeBindings bindings = ( contextType = = null ) ? TypeBindings . emptyBindings ( ) : contextType . getBindings ( ) ; return _fromAny ( null , type , bindings ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void writeObject ( Object value ) throws IOException { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void writeObject ( Object value ) throws IOException { if ( value = = null ) { writeNull ( ) ; return ; } Class < ? > raw = value . getClass ( ) ; if ( raw = = byte [ ] . class ) { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; return ; } else if ( _objectCodec = = null ) { / / throw new JsonMappingException ( \" No ObjectCodec configured for TokenBuffer , writeObject ( ) called \" ) ; _append ( JsonToken . VALUE_EMBEDDED_OBJECT , value ) ; } else { _objectCodec . writeValue ( this , value ) ; } } public void writeTree ( TreeNode node ) throws IOException { if ( node = = null ) { writeNull ( ) ; return ; }  if ( _objectCodec = = null ) { _append ( JsonToken . VALUE_EMBEDDED_OBJECT , node ) ; } else { _objectCodec . writeTree ( this , node ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "data . get ( t . getScopeRoot ( ) ) . recordNonEmptyReturn ( ) ; } if ( t . getScopeDepth ( ) < = 2 ) { / / The first - order function analyzer looks at two types of variables : / / / / 1 ) Local variables that are assigned in inner scopes ( \" escaped vars \" )", "fixed_code": "data . get ( t . getScopeRoot ( ) ) . recordNonEmptyReturn ( ) ; } if ( t . getScopeDepth ( ) < = 1 ) { / / The first - order function analyzer looks at two types of variables : / / / / 1 ) Local variables that are assigned in inner scopes ( \" escaped vars \" )", "label": 1}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { XYAnnotation a = ( XYAnnotation ) i . next ( ) ; includedAnnotations . add ( a ) ; } } }  } }", "label": 1}
{"buggy_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ; if ( pos = = - 1 ) {", "fixed_code": "while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , 0 ) ; if ( pos = = - 1 ) {", "label": 1}
{"buggy_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "fixed_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "label": 1}
{"buggy_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) ; } return false ; }", "fixed_code": "| | testName . getName ( ) . equals ( DOMNodePointer . getLocalName ( node ) ) ) { String nodeNS = DOMNodePointer . getNamespaceURI ( node ) ; return equalStrings ( namespaceURI , nodeNS ) | | nodeNS = = null & & equalStrings ( testPrefix , getPrefix ( node ) ) ; } return false ; }", "label": 1}
{"buggy_code": "{ try { return NumberUtils . createNumber ( str ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "{ try { if ( str ! = null ) { if ( str . indexOf ( ' . ' ) ! = - 1 ) { return Double . valueOf ( str ) ; } else { return Long . valueOf ( str ) ; } } } catch ( NumberFormatException nfe ) {", "label": 1}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1}
{"buggy_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; if ( trailer = = 0 | | trailer = = ' ' ) { end - - ; } for ( ; start < end ; start + + ) {", "fixed_code": "} / / May have additional NULs or spaces trailer = buffer [ end - 1 ] ; while ( start < end - 1 & & ( trailer = = 0 | | trailer = = ' ' ) ) { end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) {", "label": 1}
{"buggy_code": "_collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) { } / / then annotated types for property itself Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } NamedType rootType = new NamedType ( rawBase , null ) ;", "fixed_code": "_collectAndResolveByTypeId ( ac , rootType , config , typesHandled , byName ) ; / / then with definitions from property if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { ac = AnnotatedClassResolver . resolveWithoutSuperTypes ( config , nt . getType ( ) ) ; _collectAndResolveByTypeId ( ac , nt , config , typesHandled , byName ) ; } } } / / and finally explicit type registrations ( highest precedence ) if ( _registeredSubtypes ! = null ) { } / / then annotated types for property itself if ( property ! = null ) { Collection < NamedType > st = ai . findSubtypes ( property ) ; if ( st ! = null ) { for ( NamedType nt : st ) { nt . getType ( ) ) ; _collectAndResolve ( ac , nt , config , ai , collected ) ; } } } NamedType rootType = new NamedType ( rawBase , null ) ;", "label": 1}
{"buggy_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; return ( Class ) actual ; / / in case of nested generics we don ' t go deep } return Object . class ;", "fixed_code": "Type generic = field . getGenericType ( ) ; if ( generic ! = null & & generic instanceof ParameterizedType ) { Type actual = ( ( ParameterizedType ) generic ) . getActualTypeArguments ( ) [ 0 ] ; if ( actual instanceof Class ) { return ( Class ) actual ; } else if ( actual instanceof ParameterizedType ) { / / in case of nested generics we don ' t go deep return ( Class ) ( ( ParameterizedType ) actual ) . getRawType ( ) ; } } return Object . class ;", "label": 1}
{"buggy_code": "public class test { public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public NodePointer createAttribute ( JXPathContext context , QName name ) { if ( ! ( node instanceof Element ) ) { return super . createAttribute ( context , name ) ; Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = getNamespaceURI ( prefix ) ; if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "fixed_code": "public class test { public synchronized NamespaceResolver getNamespaceResolver ( ) { if ( localNamespaceResolver = = null ) { localNamespaceResolver = new NamespaceResolver ( super . getNamespaceResolver ( ) ) ; localNamespaceResolver . setNamespaceContextPointer ( this ) ; } return localNamespaceResolver ; } public NodePointer createAttribute ( JXPathContext context , QName name ) { if ( ! ( node instanceof Element ) ) { return super . createAttribute ( context , name ) ; Element element = ( Element ) node ; String prefix = name . getPrefix ( ) ; if ( prefix ! = null ) { String ns = null ; NamespaceResolver nsr = getNamespaceResolver ( ) ; if ( nsr ! = null ) { ns = nsr . getNamespaceURI ( prefix ) ; } if ( ns = = null ) { throw new JXPathException ( \" Unknown namespace prefix : \" + prefix ) ;", "label": 1}
{"buggy_code": "if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( c > 0 & & b . length = = len ) { base64 . setInitialBuffer ( b , offset , len ) ; } if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "fixed_code": "if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; if ( doEncode ) { base64 . encode ( buf , 0 , c ) ; } else {", "label": 1}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { boolean expectCanAssignToPropertyOf ( NodeTraversal t , Node n , JSType rightType , JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; } return false ; } return true ; } boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "fixed_code": "public class test { boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { mismatch ( t , n , msg , rightType , leftType ) ; return false ; } return true ; } boolean expectCanAssignToPropertyOf ( NodeTraversal t , Node n , JSType rightType , JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; return false ; } return true ;", "label": 1}
{"buggy_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1}
{"buggy_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "fixed_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1}
{"buggy_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { return attr . getValue ( ) ; } } aNode = aNode . getParentNode ( ) ; } return null ; } return uri ; } } \\ No newline at end of file", "fixed_code": "if ( aNode . getNodeType ( ) = = Node . ELEMENT_NODE ) { Attr attr = ( ( Element ) aNode ) . getAttributeNode ( qname ) ; if ( attr ! = null ) { uri = attr . getValue ( ) ; break ; } } aNode = aNode . getParentNode ( ) ; } } return \" \" . equals ( uri ) ? null : uri ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1}
{"buggy_code": "/ / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , iae . getMessage ( ) ) ; } if ( ser ! = null ) {", "fixed_code": "/ / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) { / / We better only expose checked exceptions , since those / / are what caller is expected to handle ser = null ; / / doesn ' t matter but compiler whines otherwise reportMappingProblem ( iae , ClassUtil . exceptionMessage ( iae ) ) ; } if ( ser ! = null ) {", "label": 1}
{"buggy_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too return super . _deserializeFromEmptyString ( ) ; } } \\ No newline at end of file", "fixed_code": "return URI . create ( \" \" ) ; } / / As per [ databind # 1123 ] , Locale too if ( _kind = = STD_LOCALE ) { return Locale . ROOT ; } return super . _deserializeFromEmptyString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; buff . append ( \" , \" ) ; } throw new MissingOptionException ( buff . substring ( 0 , buff . length ( ) - 2 ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) . trim ( ) ; } } \\ No newline at end of file", "fixed_code": "public String html ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / ensure that all parent options are also added } } \\ No newline at end of file", "fixed_code": "} / / ensure that all parent options are also added Option parent = option . getParent ( ) ; while ( parent ! = null & & ! options . contains ( parent ) ) { options . add ( parent ) ; parent = parent . getParent ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; return null ; } } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : } } } } \\ No newline at end of file", "fixed_code": "public class test { public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default : } } } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; return null ; } } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; return index ! = null ? values [ index . intValue ( ) ] : null ; } } \\ No newline at end of file", "fixed_code": "\" No header mapping was specified , the record values can ' t be accessed by name \" ) ; } final Integer index = mapping . get ( name ) ; try { return index ! = null ? values [ index . intValue ( ) ] : null ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new IllegalArgumentException ( String . format ( \" Index for header ' % s ' is % d but CSVRecord only has % d values ! \" , name , index . intValue ( ) , values . length ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "fixed_code": "int kind ; / / first common types : if ( raw = = String . class | | raw = = Object . class | | raw = = CharSequence . class ) { return StringKD . forType ( raw ) ; } else if ( raw = = UUID . class ) { kind = TYPE_UUID ;", "label": 1}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1}
{"buggy_code": "public class test { public void smartNullPointerException ( Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , \" Because this method was * not * stubbed correctly : \" , location , \" \" return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( location ) ; return null ; } } \\ No newline at end of file", "fixed_code": "public class test { public void smartNullPointerException ( Object obj , Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , obj , \" Because this method was * not * stubbed correctly : \" , location , \" \" return \" SmartNull returned by unstubbed \" + formatMethodCall ( ) + \" method on mock \" ; } new Reporter ( ) . smartNullPointerException ( obj , location ) ; return null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "fixed_code": "start = ' ' ; } } } else { if ( end < = start ) { throw new IllegalArgumentException ( \" Parameter end ( \" + end + \" ) must be greater than start ( \" + start + \" ) \" ) ; } } char [ ] buffer = new char [ count ] ;", "label": 1}
{"buggy_code": "public class test { public long roundFloor ( long instant ) { if ( iTimeField ) { int offset = getOffsetToAdd ( instant ) ; } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , String text , Locale locale ) { / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public long add ( long instant , long value ) { if ( iTimeField ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long add ( long instant , int value ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long roundCeiling ( long instant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iBase . getZone ( ) . convertUTCToLocal ( instant ) ; long difference = FieldUtils . safeSubtract ( value , get ( instant ) ) ; localInstant = getType ( ) . getField ( iBase . withUTC ( ) ) . add ( localInstant , difference ) ; return iBase . getZone ( ) . convertLocalToUTC ( localInstant , false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public long convertLocalToUTC ( long instantLocal , boolean strict , long originalInstantUTC ) { int offsetOriginal = getOffset ( originalInstantUTC ) ; long instantUTC = instantLocal - offsetOriginal ; int offsetLocalFromOriginal = getOffset ( instantUTC ) ; if ( offsetLocalFromOriginal = = offsetOriginal ) { return instantUTC ; } return convertLocalToUTC ( instantLocal , strict ) ; } public long roundFloor ( long instant ) { if ( iTimeField ) { int offset = getOffsetToAdd ( instant ) ; } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , String text , Locale locale ) { / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public long add ( long instant , long value ) { if ( iTimeField ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long add ( long instant , int value ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long roundCeiling ( long instant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iBase . getZone ( ) . convertUTCToLocal ( instant ) ; long difference = FieldUtils . safeSubtract ( value , get ( instant ) ) ; localInstant = getType ( ) . getField ( iBase . withUTC ( ) ) . add ( localInstant , difference ) ; return iBase . getZone ( ) . convertLocalToUTC ( localInstant , false , instant ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > doc . outputSettings ( ) . charset ( charsetName ) ; } return doc ; } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( getWholeDeclaration ( ) ) . append ( \" > \" ) ; } public String getWholeDeclaration ( ) { final String decl = this . name ; if ( decl . equals ( \" xml \" ) & & attributes . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( decl ) ; final String version = attributes . get ( \" version \" ) ; if ( version ! = null ) { sb . append ( \" version = \\ \" \" ) . append ( version ) . append ( \" \\ \" \" ) ; } final String encoding = attributes . get ( \" encoding \" ) ; if ( encoding ! = null ) { sb . append ( \" encoding = \\ \" \" ) . append ( encoding ) . append ( \" \\ \" \" ) ; } return sb . toString ( ) ; } else { return this . name ; } } void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "fixed_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? > doc . outputSettings ( ) . charset ( charsetName ) ; } return doc ; } public String getWholeDeclaration ( ) { return attributes . html ( ) . trim ( ) ; / / attr html starts with a \" \" } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( name ) ; attributes . html ( accum , out ) ; accum . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( \" > \" ) ; } void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; / / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "label": 1}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( j = = 4 * ( n - 1 ) ) = = false ) { j = 4 * ( n - 1 ) ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"buggy_code": "public class test { public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "fixed_code": "public class test { public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; long lRow = ( long ) rowDimension ; long lCol = ( long ) columnDimension ; if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; } this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "label": 1}
{"buggy_code": "public class test { static String stripLeadingHyphens ( String str ) { if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "fixed_code": "public class test { static String stripLeadingHyphens ( String str ) { if ( str = = null ) { return null ; } if ( str . startsWith ( \" - - \" ) ) { return str . substring ( 2 , str . length ( ) ) ;", "label": 1}
{"buggy_code": "public class test { private void add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isEmpty ( ) { return size = = 0 ; } public Attributes add ( String key , String value ) { checkCapacity ( size + 1 ) ; keys [ size ] = key ; vals [ size ] = value ; size + + ; return this ; } public int deduplicate ( ParseSettings settings ) { if ( isEmpty ( ) ) return 0 ; boolean preserve = settings . preserveAttributeCase ( ) ; int dupes = 0 ; OUTER : for ( int i = 0 ; i < keys . length ; i + + ) { for ( int j = i + 1 ; j < keys . length ; j + + ) { if ( keys [ j ] = = null ) continue OUTER ; / / keys . length doesn ' t shrink when removing , so re - test if ( ( preserve & & keys [ i ] . equals ( keys [ j ] ) ) | | ( ! preserve & & keys [ i ] . equalsIgnoreCase ( keys [ j ] ) ) ) { dupes + + ; remove ( j ) ; j - - ; } } } return dupes ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else { return null ; } } } \\ No newline at end of file", "fixed_code": "} else { throw new ParseException ( \" Unable to handle the class : \" + clazz ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 1}
{"buggy_code": "public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? titleEl . text ( ) . trim ( ) : \" \" ; } } \\ No newline at end of file", "fixed_code": "public String title ( ) { / / title is a preserve whitespace tag ( for document output ) , but normalised here Element titleEl = getElementsByTag ( \" title \" ) . first ( ) ; return titleEl ! = null ? StringUtil . normaliseWhitespace ( titleEl . text ( ) ) . trim ( ) : \" \" ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Node fnParam = NodeUtil . getFunctionParameters ( fnNode ) . getFirstChild ( ) ; while ( cArg ! = null | | fnParam ! = null ) { if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) { return CanInlineResult . NO ; } } fnParam = fnParam . getNext ( ) ; } / / Limit the inlining if ( cArg ! = null ) { if ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) { return CanInlineResult . NO ; } cArg = cArg . getNext ( ) ; } } } if ( mode = = InliningMode . DIRECT ) { return canInlineReferenceDirectly ( callNode , fnNode ) ; } else { return canInlineReferenceAsStatementBlock ( t , callNode , fnNode , needAliases ) ;", "fixed_code": "public class test { private CanInlineResult canInlineReferenceDirectly ( Node callNode , Node fnNode , Set < String > namesToAlias ) { if ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) { return CanInlineResult . NO ; } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; } } Map < String , Node > args = FunctionArgumentInjector . getFunctionCallParameterMap ( fnNode , callNode , this . throwawayNameSupplier ) ; boolean hasArgs = ! args . isEmpty ( ) ; if ( hasArgs ) { / / Limit the inlining Set < String > allNamesToAlias = Sets . newHashSet ( namesToAlias ) ; FunctionArgumentInjector . maybeAddTempsForCallArguments ( fnNode , args , allNamesToAlias , compiler . getCodingConvention ( ) ) ; if ( ! allNamesToAlias . isEmpty ( ) ) { return CanInlineResult . NO ; } } } if ( mode = = InliningMode . DIRECT ) { return canInlineReferenceDirectly ( callNode , fnNode , needAliases ) ; } else { return canInlineReferenceAsStatementBlock ( t , callNode , fnNode , needAliases ) ;", "label": 1}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 1}
{"buggy_code": "if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } return new SimpleType ( cls , TypeBindings . emptyBindings ( ) , _bogusSuperClass ( cls ) , null , null , null , false ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls . isArray ( ) ) { throw new IllegalArgumentException ( \" Can not construct SimpleType for an array ( class : \" + cls . getName ( ) + \" ) \" ) ; } TypeBindings b = TypeBindings . emptyBindings ( ) ; return new SimpleType ( cls , b , _buildSuperClass ( cls . getSuperclass ( ) , b ) , null , null , null , false ) ; } private static JavaType _buildSuperClass ( Class < ? > superClass , TypeBindings b ) { if ( superClass = = null ) { return null ; } if ( superClass = = Object . class ) { return TypeFactory . unknownType ( ) ; } JavaType superSuper = _buildSuperClass ( superClass . getSuperclass ( ) , b ) ; return new SimpleType ( superClass , b , superSuper , null , null , null , false ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1}
{"buggy_code": "} } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "fixed_code": "} } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "label": 1}
{"buggy_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening throw new IllegalStateException ( \" Total width is less than the width of the argument and indent \" + \" - no room for the description \" ) ; } / / all following lines must be padded with nextLineTabStop space", "fixed_code": "if ( nextLineTabStop > = width ) { / / stops infinite loop happening nextLineTabStop = width - 1 ; } / / all following lines must be padded with nextLineTabStop space", "label": 1}
{"buggy_code": "public class test { public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class test { public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1}
{"buggy_code": "} } / / first , sanity checks if ( p . getCurrentToken ( ) ! = JsonToken . START_OBJECT ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "fixed_code": "} } / / first , sanity checks JsonToken t = p . getCurrentToken ( ) ; if ( t = = JsonToken . START_OBJECT ) { / / should always get field name , but just in case . . . if ( p . nextToken ( ) ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . FIELD_NAME , \" need JSON String that contains type id ( for subtype of \" + baseTypeName ( ) + \" ) \" ) ; } } else if ( t ! = JsonToken . FIELD_NAME ) { throw ctxt . wrongTokenException ( p , JsonToken . START_OBJECT , \" need JSON Object to contain As . WRAPPER_OBJECT type information for class \" + baseTypeName ( ) ) ; } final String typeId = p . getText ( ) ; JsonDeserializer < Object > deser = _findDeserializer ( ctxt , typeId ) ; p . nextToken ( ) ;", "label": 1}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName (", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName (", "label": 1}
{"buggy_code": "public class test { protected Object _deserializeUsingPropertyBased ( final JsonParser p , final DeserializationContext ctxt ) throws IOException { TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { } return bean ; } } \\ No newline at end of file", "fixed_code": "public class test { private BeanReferring handleUnresolvedReference ( JsonParser p , SettableBeanProperty prop , PropertyValueBuffer buffer , UnresolvedForwardReference reference ) throws JsonMappingException { BeanReferring referring = new BeanReferring ( reference , prop . getType ( ) . getRawClass ( ) , buffer , prop ) ; reference . getRoid ( ) . appendReferring ( referring ) ; return referring ; } public void setBean ( Object bean ) { _bean = bean ; } BeanReferring ( UnresolvedForwardReference ref , Class < ? > valueType , PropertyValueBuffer buffer , SettableBeanProperty prop ) { super ( ref , valueType ) ; _prop = prop ; } protected Object _deserializeUsingPropertyBased ( final JsonParser p , final DeserializationContext ctxt ) throws IOException { TokenBuffer unknown = null ; JsonToken t = p . getCurrentToken ( ) ; List < BeanReferring > referrings = null ; for ( ; t = = JsonToken . FIELD_NAME ; t = p . nextToken ( ) ) { String propName = p . getCurrentName ( ) ; p . nextToken ( ) ; / / to point to value / / regular property ? needs buffering SettableBeanProperty prop = _beanProperties . find ( propName ) ; if ( prop ! = null ) { try { buffer . bufferProperty ( prop , _deserializeWithErrorWrapping ( p , ctxt , prop ) ) ; } catch ( UnresolvedForwardReference reference ) { / / 14 - Jun - 2016 , tatu : As per [ databind # 1261 ] , looks like we need additional / / handling of forward references here . Not exactly sure why existing / / facilities did not cover , but this does appear to solve the problem BeanReferring referring = handleUnresolvedReference ( p , prop , buffer , reference ) ; if ( referrings = = null ) { referrings = new ArrayList < BeanReferring > ( ) ; } referrings . add ( referring ) ; } continue ; } / / Things marked as ignorable should not be passed to any setter wrapInstantiationProblem ( e , ctxt ) ; bean = null ; / / never gets here } if ( referrings ! = null ) { for ( BeanReferring referring : referrings ) { referring . setBean ( bean ) ; } } if ( unknown ! = null ) { / / polymorphic ? if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { } return bean ; } public void handleResolvedForwardReference ( Object id , Object value ) throws IOException { _prop . set ( _bean , value ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Integer . parseInt ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Integer . parseInt ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "fixed_code": "} else if ( \" linkpath \" . equals ( key ) ) { currEntry . setLinkName ( val ) ; } else if ( \" gid \" . equals ( key ) ) { currEntry . setGroupId ( Long . parseLong ( val ) ) ; } else if ( \" gname \" . equals ( key ) ) { currEntry . setGroupName ( val ) ; } else if ( \" uid \" . equals ( key ) ) { currEntry . setUserId ( Long . parseLong ( val ) ) ; } else if ( \" uname \" . equals ( key ) ) { currEntry . setUserName ( val ) ; } else if ( \" size \" . equals ( key ) ) {", "label": 1}
{"buggy_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { try { if ( Charset . isSupported ( meta . attr ( \" charset \" ) ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } catch ( IllegalCharsetNameException e ) { foundCharset = null ; } } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? >", "fixed_code": "foundCharset = getCharsetFromContentType ( meta . attr ( \" content \" ) ) ; } if ( foundCharset = = null & & meta . hasAttr ( \" charset \" ) ) { foundCharset = meta . attr ( \" charset \" ) ; } } / / look for < ? xml encoding = ' ISO - 8859 - 1 ' ? >", "label": 1}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1}
{"buggy_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) . toLowerCase ( ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; }", "fixed_code": "} catch ( NumberFormatException e ) { } / / skip } else { String name = m . group ( 1 ) ; if ( full . containsKey ( name ) ) charval = full . get ( name ) ; }", "label": 1}
{"buggy_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( declaredType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( declaredType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "fixed_code": "/ / always suppress nulls suppressNulls = true ; / / and for referential types , also \" empty \" , which in their case means \" absent \" if ( actualType . isReferenceType ( ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; } break ; case ALWAYS : / / default default : / / we may still want to suppress empty collections , as per [ JACKSON - 254 ] : if ( actualType . isContainerType ( ) & & ! _config . isEnabled ( SerializationFeature . WRITE_EMPTY_JSON_ARRAYS ) ) { valueToSuppress = BeanPropertyWriter . MARKER_FOR_EMPTY ; }", "label": 1}
{"buggy_code": "} } return reportGenericTypeSyntaxWarning ( ) ; } private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } } break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } }", "fixed_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } } break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } }", "label": 1}
{"buggy_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; throw new UnsupportedOperationException ( ) ; } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "fixed_code": "public void captureArgumentsFrom ( Invocation invocation ) { if ( invocation . getMethod ( ) . isVarArgs ( ) ) { int indexOfVararg = invocation . getRawArguments ( ) . length - 1 ; for ( int position = 0 ; position < indexOfVararg ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { for ( int position = 0 ; position < matchers . size ( ) ; position + + ) {", "label": 1}
{"buggy_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src ) , true ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( _dataFormatReaders ! = null ) { return _detectBindAndReadValues ( _dataFormatReaders . findFormat ( src , offset , length ) , false ) ; } return _bindAndReadValues ( _considerFilter ( _parserFactory . createParser ( src , offset , length ) , true ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public MockSettings serializable ( ) { return this . extraInterfaces ( java . io . Serializable . class ) ; } public boolean isSerializable ( ) { return extraInterfaces ! = null & & java . util . Arrays . asList ( extraInterfaces ) . contains ( java . io . Serializable . class ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSerializable ( ) { return serializable ; } public MockSettings serializable ( ) { this . serializable = true ; return this ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1}
{"buggy_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "fixed_code": "String data = getData ( ) ; Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ;", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "label": 1}
{"buggy_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher m = matchers . get ( position ) ; if ( m instanceof CapturesArguments ) { ( ( CapturesArguments ) m ) . captureFrom ( invocation . getRawArguments ( ) [ position - indexOfVararg ] ) ; } } } else { } } } } \\ No newline at end of file", "fixed_code": "( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; } } for ( Matcher m : uniqueMatcherSet ( indexOfVararg ) ) { if ( m instanceof CapturesArguments ) { Object rawArgument = invocation . getRawArguments ( ) [ indexOfVararg ] ; for ( int i = 0 ; i < Array . getLength ( rawArgument ) ; i + + ) { ( ( CapturesArguments ) m ) . captureFrom ( Array . get ( rawArgument , i ) ) ; } } } } else { } } } private Set < Matcher > uniqueMatcherSet ( int indexOfVararg ) { HashSet < Matcher > set = new HashSet < Matcher > ( ) ; for ( int position = indexOfVararg ; position < matchers . size ( ) ; position + + ) { Matcher matcher = matchers . get ( position ) ; if ( matcher instanceof MatcherDecorator ) { set . add ( ( ( MatcherDecorator ) matcher ) . getActualMatcher ( ) ) ; } else { set . add ( matcher ) ; } } return set ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "label": 1}
{"buggy_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . INC : case Token . DEC : isSet = true ;", "fixed_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . CATCH : case Token . INC : case Token . DEC : isSet = true ;", "label": 1}
{"buggy_code": "public class test { void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "public class test { void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1}
{"buggy_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "fixed_code": "Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; if ( dirtyDocument . body ( ) ! = null ) / / frameset documents won ' t have a body . the clean doc will have empty body . copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return clean ;", "label": 1}
{"buggy_code": "public class test { public MockSettings serializable ( ) { return this . extraInterfaces ( java . io . Serializable . class ) ; } public boolean isSerializable ( ) { return extraInterfaces ! = null & & java . util . Arrays . asList ( extraInterfaces ) . contains ( java . io . Serializable . class ) ; } public < T > T createMock ( Class < T > classToMock , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;", "fixed_code": "public class test { public boolean isSerializable ( ) { return serializable ; } public MockSettings serializable ( ) { this . serializable = true ; return this ; } public < T > T createMock ( Class < T > classToMock , MockSettingsImpl settings ) { creationValidator . validateType ( classToMock ) ; Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; if ( settings . isSerializable ( ) ) { ancillaryTypes = interfaces = = null ? new Class < ? > [ ] { Serializable . class } : new ArrayUtils ( ) . concat ( interfaces , Serializable . class ) ; } else { ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; } Object spiedInstance = settings . getSpiedInstance ( ) ;", "label": 1}
{"buggy_code": "public class test { private boolean isOneExactlyFunctionOrDo ( Node n ) { / / For labels with block children , we need to ensure that a / / labeled FUNCTION or DO isn ' t generated when extraneous BLOCKs / / are skipped . / / Either a empty statement or an block with more than one child , / / way it isn ' t a FUNCTION or DO . return ( n . getType ( ) = = Token . FUNCTION | | n . getType ( ) = = Token . DO ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean isOneExactlyFunctionOrDo ( Node n ) { if ( n . getType ( ) = = Token . LABEL ) { Node labeledStatement = n . getLastChild ( ) ; if ( labeledStatement . getType ( ) ! = Token . BLOCK ) { return isOneExactlyFunctionOrDo ( labeledStatement ) ; } else { / / For labels with block children , we need to ensure that a / / labeled FUNCTION or DO isn ' t generated when extraneous BLOCKs / / are skipped . if ( getNonEmptyChildCount ( n , 2 ) = = 1 ) { return isOneExactlyFunctionOrDo ( getFirstNonEmptyChild ( n ) ) ; } else { / / Either a empty statement or an block with more than one child , / / way it isn ' t a FUNCTION or DO . return false ; } } } else { return ( n . getType ( ) = = Token . FUNCTION | | n . getType ( ) = = Token . DO ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 1}
{"buggy_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( format . getShape ( ) = = JsonFormat . Shape . STRING ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "fixed_code": "return withFormat ( Boolean . TRUE , null ) ; } if ( ( shape = = JsonFormat . Shape . STRING ) | | format . hasPattern ( ) | | format . hasLocale ( ) | | format . hasTimeZone ( ) ) { TimeZone tz = format . getTimeZone ( ) ; final String pattern = format . hasPattern ( ) ? format . getPattern ( )", "label": 1}
{"buggy_code": "public class test { public String getValueAsString ( String defValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; } public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } public String getValueAsString ( String defValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / butt - ugly for arrays . / / 06 - Oct - 2016 , tatu : as per [ databind # 1403 ] , ` getSimpleName ( ) ` not so good / / as it drops enclosing class . So let ' s try bit different approach } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "fixed_code": "/ / butt - ugly for arrays . / / 06 - Oct - 2016 , tatu : as per [ databind # 1403 ] , ` getSimpleName ( ) ` not so good / / as it drops enclosing class . So let ' s try bit different approach int arrays = 0 ; while ( cls . isArray ( ) ) { cls = cls . getComponentType ( ) ; + + arrays ; } sb . append ( cls . getName ( ) ) ; while ( - - arrays > = 0 ) { sb . append ( \" [ ] \" ) ; } } sb . append ( ' [ ' ) ; if ( _fieldName ! = null ) {", "label": 1}
{"buggy_code": "private static void reset ( ) { description = null ; argName = \" arg \" ; longopt = null ; type = null ; required = false ;", "fixed_code": "private static void reset ( ) { description = null ; argName = null ; longopt = null ; type = null ; required = false ;", "label": 1}
{"buggy_code": "public class test { public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; } } \\ No newline at end of file", "fixed_code": "public class test { public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } Token reset ( ) { reset ( name ) ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return this ; } void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; } } \\ No newline at end of file", "fixed_code": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) accum . append ( \" \" ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String pubSysKey , String publicId , String systemId , String baseUri ) { super ( baseUri ) ;  attr ( NAME , name ) ; if ( pubSysKey ! = null ) { attr ( PUB_SYS_KEY , pubSysKey ) ; } attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; if ( has ( PUBLIC_ID ) ) { attr ( PUB_SYS_KEY , PUBLIC_KEY ) ; } attr ( SYSTEM_ID , systemId ) ; } Token reset ( ) { reset ( name ) ; pubSysKey = null ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return this ; } String getPubSysKey ( ) { return pubSysKey ; } void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ;", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1}
{"buggy_code": "} / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; } } \\ No newline at end of file", "fixed_code": "} / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1}
{"buggy_code": "for ( Node child : node . children ( ) ) { if ( NodeUtil . isThis ( child ) ) { Node newName = Node . newString ( Token . NAME , name ) ; node . replaceChild ( child , newName ) ; } else { replaceReferencesToThis ( child , name ) ; } } } boolean defineProperty ( String name , JSType type , boolean inferred , boolean inExterns ) { if ( \" prototype \" . equals ( name ) ) { ObjectType objType = type . toObjectType ( ) ; if ( objType ! = null ) { return setPrototype ( new FunctionPrototypeType ( registry , this , objType , isNativeObjectType ( ) ) ) ;", "fixed_code": "for ( Node child : node . children ( ) ) { if ( NodeUtil . isThis ( child ) ) { Node newName = Node . newString ( Token . NAME , name ) ; newName . setJSType ( child . getJSType ( ) ) ; node . replaceChild ( child , newName ) ; } else { replaceReferencesToThis ( child , name ) ; } } } public boolean hasOwnProperty ( String name ) { return super . hasOwnProperty ( name ) | | \" prototype \" . equals ( name ) ; } boolean defineProperty ( String name , JSType type , boolean inferred , boolean inExterns ) { if ( \" prototype \" . equals ( name ) ) { ObjectType objType = type . toObjectType ( ) ; if ( objType ! = null ) { if ( objType . equals ( prototype ) ) { return true ; } return setPrototype ( new FunctionPrototypeType ( registry , this , objType , isNativeObjectType ( ) ) ) ;", "label": 1}
{"buggy_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = _elementDeserializer . getNullValue ( ) ; } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? null : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "fixed_code": "if ( t = = JsonToken . VALUE_STRING ) { value = jp . getText ( ) ; } else if ( t = = JsonToken . VALUE_NULL ) { value = null ; / / since we have established that ' _elementDeserializer = = null ' earlier } else { value = _parseString ( jp , ctxt ) ; } while ( ( t = jp . nextToken ( ) ) ! = JsonToken . END_ARRAY ) { / / Ok : no need to convert Strings , but must recognize nulls String value = ( t = = JsonToken . VALUE_NULL ) ? deser . getNullValue ( ) : deser . deserialize ( jp , ctxt ) ; if ( ix > = chunk . length ) { chunk = buffer . appendCompletedChunk ( chunk ) ; ix = 0 ;", "label": 1}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 1}
{"buggy_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1}
{"buggy_code": "public class test { protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } boolean cachable = ( bindings = = null ) | | bindings . isEmpty ( ) ; if ( cachable ) { result = _typeCache . get ( rawType ) ; if ( result ! = null ) { return result ; } }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ; if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; if ( cachable ) { _typeCache . putIfAbsent ( rawType , result ) ; } return result ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { TypeBindings tb = null ; if ( baseType . containedTypeCount ( ) = = typeParamCount ) { if ( typeParamCount = = 1 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } else if ( typeParamCount = = 2 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } } newType = _fromClass ( null , subclass , ( tb = = null ) ? TypeBindings . emptyBindings ( ) : tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Object asKey ( Class < ? > rawBase ) { return new AsKey ( rawBase , _types , _hashCode ) ; } public int hashCode ( ) { return _hash ; } public boolean equals ( Object o ) { if ( o = = this ) return true ; if ( o = = null ) return false ; if ( o . getClass ( ) ! = getClass ( ) ) return false ; AsKey other = ( AsKey ) o ; if ( ( _hash = = other . _hash ) & & ( _raw = = other . _raw ) ) { final JavaType [ ] otherParams = other . _params ; final int len = _params . length ; if ( len = = otherParams . length ) { for ( int i = 0 ; i < len ; + + i ) { if ( ! _params [ i ] . equals ( otherParams [ i ] ) ) { return false ; } } return true ; } } return false ; } public String toString ( ) { return _raw . getName ( ) + \" < > \" ; } public AsKey ( Class < ? > raw , JavaType [ ] params , int hash ) { _raw = raw ; _params = params ; _hash = hash ; } private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } return TypeBindings . emptyBindings ( ) ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now TypeBindings tb = _bindingsForSubtype ( baseType , typeParamCount , subclass ) ; if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , tb , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , tb , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { newType = _fromClass ( null , subclass , tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } final Object key ; if ( ( bindings = = null ) | | bindings . isEmpty ( ) ) { key = rawType ; result = _typeCache . get ( key ) ; / / ok , cache object is synced } else { key = bindings . asKey ( rawType ) ; } result = _typeCache . get ( key ) ; / / ok , cache object is synced if ( result ! = null ) { return result ; }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; _typeCache . putIfAbsent ( key , result ) ; / / cache object syncs return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void insert ( Token . Doctype d ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public boolean hasClass ( String className ) { final String classAttr = attributes . get ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "fixed_code": "public class test { public boolean hasClass ( String className ) { final String classAttr = attributes . getIgnoreCase ( \" class \" ) ; final int len = classAttr . length ( ) ; final int wantLen = className . length ( ) ;", "label": 1}
{"buggy_code": "/ / iterate until convergence is reached PointVectorValuePair current = null ; int iter = 0 ; for ( boolean converged = false ; ! converged ; ) { + + iter ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( iter , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ;", "fixed_code": "/ / iterate until convergence is reached PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ;", "label": 1}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) = = null ) | | ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = null ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } }", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . this . epsilon = = org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE ) entries . remove ( index ) ; } }", "label": 0}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { end . add ( Calendar . DATE , - 1 ) ; int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState > 1 ) = = true ) { this . runningState = 1 ; } else { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 5 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0}
{"buggy_code": "} if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "} if ( parent . isAssign ( ) ) { } }", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; }  return this ; } } \\ No newline at end of file", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; } this . propListHead = other . propListHead ; return this ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "fixed_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0}
{"buggy_code": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "fixed_code": "} TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; copy = new TimeSeries ( start ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) { TimeSeriesDataItem item = ( TimeSeriesDataItem ) this . data . get ( index ) ;", "label": 0}
{"buggy_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "fixed_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "label": 0}
{"buggy_code": "private void extractForInitializer ( Node n , Node before , Node beforeParent ) { for ( Node next , c = n . getFirstChild ( ) ; c ! = null ; c = next ) { next = c . getNext ( ) ; Node insertBefore = ( before = = null ) ? c : before ; Node insertBeforeParent = ( before = = null ) ? n : beforeParent ;", "fixed_code": "private void extractForInitializer ( Node n , Node before , Node beforeParent ) { for ( Node next , c = n . getFirstChild ( ) ; c ! = null ; c = n ) { next = c . getNext ( ) ; Node insertBefore = ( before = = null ) ? c : before ; Node insertBeforeParent = ( before = = null ) ? n : beforeParent ;", "label": 0}
{"buggy_code": "if ( partial instanceof LocalDate ) { LocalDate other = ( LocalDate ) partial ; if ( iChronology . equals ( other . iChronology ) ) { return iLocalMillis = = other . iLocalMillis ; } } return super . equals ( partial ) ;", "fixed_code": "if ( partial instanceof LocalDate ) { LocalDate other = ( LocalDate ) partial ; if ( iChronology . equals ( other . iChronology ) ) { return iLocalMillis > = other . iLocalMillis ; } } return super . equals ( partial ) ;", "label": 0}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , solve ( initial , initial ) , yInitial ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getColumnCount ( ) { return this . data . getRowCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & expPos < numeric . length ( ) - 1 ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , writer ! = null ) ) ; } } }", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } }  / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } }", "fixed_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) ; else break ; } }", "label": 0}
{"buggy_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "fixed_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "label": 0}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return Short . parseShort ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . put ( index , value ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( id = = null ) { throw new IllegalArgumentException ( ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone (", "label": 0}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 0 ; } else { repaired [ i ] = x [ i ] ; }", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p = = 1 . 0 ) { return upper ; } }", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & ! ( dataset instanceof SelectableCategoryDataset ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "fixed_code": "if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { if ( com . google . javascript . rhino . jstype . PrototypeObjectType . this . prettyPrint ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } defineInferredProperty ( prop , typeToInfer , null ) ; } }", "label": 0}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN | | Double . isNaN ( imaginary ) ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { diagD = diag ( D ) ; } else { repaired [ i ] = x [ i ] ; }", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; }", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( ( com . google . javascript . rhino . Node . this . type ) ! = ( node2 . type ) ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } b2 = work [ nn - 5 ] / work [ nn - 7 ] ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "fixed_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "label": 0}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else { oldDelta = delta ;", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ; } else { oldDelta = delta ;", "label": 0}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } } \\ No newline at end of file", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} / / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "fixed_code": "} / / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return FastMath . log ( n ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced start = textIndex + searchList [ replaceIndex ] . length ( ) ; / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0}
{"buggy_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } } \\ No newline at end of file", "fixed_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = true ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( CompilerOptions options ) { / / Does not call applyBasicCompilationOptions ( options ) because the call to / / skipAllCompilerPasses ( ) cannot be easily undone . options . closurePass = false ; options . variableRenaming = VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = CheckLevel . OFF ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { + + i ; } return out ;", "label": 0}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > lower ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "public class test { NodeMismatch checkTreeEqualsImpl ( Node node2 ) { if ( ! isEquivalentTo ( node2 , false , false ) ) { return new NodeMismatch ( this , node2 ) ; } NodeMismatch res = null ; Node n , n2 ;", "fixed_code": "public class test { NodeMismatch checkTreeEqualsImpl ( Node node2 ) { if ( ! isEquivalentTo ( node2 , false , false ) ) { if ( com . google . javascript . rhino . Node . this . sourcePosition < = 1 ) { return new NodeMismatch ( this , node2 ) ; } } NodeMismatch res = null ; Node n , n2 ;", "label": 0}
{"buggy_code": "public class test { public int getSize ( ) { return totalSize ; } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ; } public int getSize ( ) { return 0 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) {", "fixed_code": "/ / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 6 - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) {", "label": 0}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ;", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ;", "label": 0}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } } }", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } }", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } this . splitState = STATE_UNSPLIT ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "fixed_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin = dN1 ; return true ; } return false ;", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < node2 . type ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return factorials [ n ] ; } } \\ No newline at end of file", "fixed_code": "public class test { public static long factorial ( int position ) { return position ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { v = u ; fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "fixed_code": "} else if ( fu < = fv | | MathUtils . equals ( v , x ) | | MathUtils . equals ( v , w ) ) { fv = fu ; } } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) {", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = sampleSize ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0}
{"buggy_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone ! = null ) { break ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; sigmaLow = 0 ; return true ; } return false ;", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( ( node2 . type ) ! = ( com . google . javascript . rhino . Node . this . type ) ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; if ( id . startsWith ( \" + \" ) | | id . startsWith ( \" - \" ) ) { int offset = parseOffset ( id ) ; if ( offset = = 0L ) { return DateTimeZone . UTC ; } else { id = printOffset ( offset ) ; return fixedOffsetZone ( id , offset ) ; } } return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ;", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; key = new Pair ( key , locale ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ;", "label": 0}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i > searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ; boolean lastStep = false ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = t ; interpolator . rescale ( hNew ) ; boolean lastStep = false ;", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return a + b ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return this . evaluations . getCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x = = 0 . 0 ? 0 . 0 : x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; if ( str . startsWith ( \" - \" ) ) { hexDigits - - ; } if ( hexDigits > 8 ) { return createLong ( str ) ; } return createInteger ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0}
{"buggy_code": "} / / Requesting a specific type . . String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "fixed_code": "} / / Requesting a specific type . . String numeric = str . substring ( 0 , str . length ( ) - 1 ) ; try { return createInteger ( str ) ; } catch ( NumberFormatException nfe ) { } boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; switch ( lastChar ) { case ' l ' :", "label": 0}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } b2 = work [ nn - 5 ] / work [ nn - 7 ] ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "fixed_code": "if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; } org . apache . commons . math . linear . EigenDecompositionImpl . this . splitTolerance = splitTolerance ; np = nn - 9 ; } else { np = nn - 2 * pingPong ;", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( shouldGrowTable ( ) ) { growTable ( ) ; } return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; mu = lambda / 2 ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) { if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } return new double [ ] { a , b } ; }", "label": 0}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0}
{"buggy_code": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; }", "fixed_code": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; if ( strLen > size ) { return - 1 ; }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0}
{"buggy_code": "/ / Update by at least \" tol1 \" . if ( FastMath . abs ( d ) < tol1 ) { if ( d > = 0 ) { u = x + tol1 ; } else { u = x - tol1 ; } else if ( fu < = fv | | Precision . equals ( v , x ) | | Precision . equals ( v , w ) ) { v = u ; fv = fu ; } }", "fixed_code": "/ / Update by at least \" tol1 \" . if ( FastMath . abs ( d ) < tol1 ) { if ( d > = 0 ) { b = x ; u = x + tol1 ; } else { u = x - tol1 ; } else if ( fu < = fv | | Precision . equals ( v , x ) | | Precision . equals ( v , w ) ) { u = u ; fv = fu ; } }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "label": 0}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; ensureCapacity ( size + 4 ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"buggy_code": "public class test { public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  }  / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } }  yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = - 1 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : v = - v ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "label": 0}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( ( provided ! = null ) | | ( ! ( ns . length ( ) < 10 ) ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 0}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0}
{"buggy_code": "return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ; getPropertyNode ( property ) ) ; } for ( String property : thatRecord . properties . keySet ( ) ) { if ( ! hasProperty ( property ) ) { builder . addProperty ( property , thatRecord . getPropertyType ( property ) , thatRecord . getPropertyNode ( property ) ) ; } }  return builder . build ( ) ; } } return greatestSubtype ; } public boolean isEquivalentTo ( JSType other ) { if ( ! other . isRecordType ( ) ) { return false ; }  RecordType otherRecord = other . toMaybeRecordType ( ) ; if ( otherRecord = = this ) { return true ; }  Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return false ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { return false ; } } return true ; } } \\ No newline at end of file", "fixed_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; } public boolean isEquivalentTo ( JSType other ) { if ( ! other . isRecordType ( ) ) { return false ; }  RecordType otherRecord = other . toMaybeRecordType ( ) ; if ( otherRecord = = this ) { return true ; }  Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return true ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { return false ; } } return true ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ; getPropertyNode ( property ) ) ; } return builder . build ( ) ; } } return greatestSubtype ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ; } }", "fixed_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ; } }", "label": 0}
{"buggy_code": "public class test { public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ; } private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } } \\ No newline at end of file", "fixed_code": "public class test { private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } return true ; } return false ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "continue ; } checkDescendantNames ( name , name . globalSets + name . localSets > 0 ) ; } } } \\ No newline at end of file", "fixed_code": "continue ; } checkDescendantNames ( name , 256 + name . globalSets + name . localSets > 0 ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( ! body . hasOneChild ( ) ) { return null ; }", "fixed_code": "public class test { protected final Node maybeGetSingleReturnRValue ( Node functionNode ) { Node body = functionNode . getLastChild ( ) ; if ( body . getLineno ( ) ! = 1 | | ! body . hasOneChild ( ) ) { return null ; }", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0}
{"buggy_code": "public class test { public CMAESOptimizer ( ) { this ( 0 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CMAESOptimizer ( ) {  } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "} else if ( Double . isNaN ( previousEventTime ) | | ( Math . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; if ( pendingEvent & & ( Math . abs ( t1 - pendingEventTime ) < = convergence ) ) { return false ; } / / either we were not waiting for the event or it has", "fixed_code": "} else if ( Double . isNaN ( previousEventTime ) | | ( Math . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; if ( pendingEvent & & ( Math . abs ( t1 - pendingEventTime ) < = maxIterationCount ) ) { return false ; } / / either we were not waiting for the event or it has", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , str . length ( ) - 1 ) ; } else { mant = str ; }", "label": 0}
{"buggy_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;  / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "fixed_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( minRatio , 0 . 0 ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } }", "label": 0}
{"buggy_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "fixed_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 127 ) { / / accept the contracted simplex / / check convergence", "label": 0}
{"buggy_code": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' | | ( ch = = str . charAt ( 0 ) ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ;", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ;", "label": 0}
{"buggy_code": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( axis ! = null ) { axis . configure ( ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 0}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio | | ( minRatio > = rhs / entry ) = = true ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0}
{"buggy_code": "public class test { public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } if ( className . length ( ) = = 0 ) { return StringUtils . EMPTY ; }     int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( INNER_CLASS_SEPARATOR_CHAR , lastDotIdx = = - 1 ? 0 : lastDotIdx + 1 ) ; String out = className . substring ( lastDotIdx + 1 ) ; if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } } \\ No newline at end of file", "fixed_code": "public class test { public static String getShortClassName ( String name ) { int end = name . lastIndexOf ( ' . ' ) ; if ( end > 0 ) { return name . substring ( end + 1 ) ; } else return name ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount + 1 , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean contains ( char ch ) { return ch = = ' \\ u0622 ' | | ch = = ' \\ u0623 ' | | ch = = ' \\ u0625 ' | | ch = = ' \\ u0627 ' ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "fixed_code": "if ( isResultUsed ) { return ; } if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;", "label": 0}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double x = Math . random ( ) * 10 ; } }", "label": 0}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( ! parent . hasChildren ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"buggy_code": "return true ; } if ( ! ( obj instanceof Pair ) ) { return false ; } key . mObj2 = = null : mObj2 . equals ( key . mObj2 ) ) ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ;", "fixed_code": "return true ; } if ( ! ( cDateInstanceCache instanceof Pair ) ) { return false ; } key . mObj2 = = null : mObj2 . equals ( key . mObj2 ) ) ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ;", "label": 0}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0}
{"buggy_code": "int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; }", "fixed_code": "int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < 0 | | i > 1 ) { minIndex = i ; minRow = row ; }", "label": 0}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0}
{"buggy_code": "public class test { public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return doubleMetaphone ( value1 , alternate ) . equals ( doubleMetaphone ( value2 , alternate ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isDoubleMetaphoneEqual ( final String value1 , final String value2 , final boolean alternate ) { return StringUtils . equals ( doubleMetaphone ( value1 , alternate ) , doubleMetaphone ( value2 , alternate ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; this . key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . val = val ; this . parent = parent ; }", "fixed_code": "public class test { public Attribute ( String key , String val , Attributes parent ) { Validate . notNull ( key ) ; key = key . trim ( ) ; Validate . notEmpty ( key ) ; / / trimming could potentially make empty , so validate here this . key = key ; this . val = val ; this . parent = parent ; }", "label": 1}
{"buggy_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option", "fixed_code": "} / / if the Option has a value and a non blank argname if ( option . hasArg ( ) & & ( option . getArgName ( ) = = null | | option . getArgName ( ) . length ( ) ! = 0 ) ) { buff . append ( option . getOpt ( ) = = null ? longOptSeparator : \" \" ) ; buff . append ( \" < \" ) . append ( option . getArgName ( ) ! = null ? option . getArgName ( ) : getArgName ( ) ) . append ( \" > \" ) ; } / / if the Option is not a required option", "label": 1}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } \\ No newline at end of file", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; if ( ch0 = = ' _ ' ) { if ( len < 3 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( len = = 3 ) { return new Locale ( \" \" , str . substring ( 1 , 3 ) ) ; } if ( len < 5 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( str . charAt ( 3 ) ! = ' _ ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( \" \" , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; } else { final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / We ' ve read a complete number . Decide if it ' s a PEEKED_LONG or a PEEKED_NUMBER . if ( last = = NUMBER_CHAR_DIGIT & & fitsInLong & & ( value ! = Long . MIN_VALUE | | negative ) ) { peekedLong = negative ? value : - value ; pos + = i ; return peeked = PEEKED_LONG ;", "fixed_code": "} / / We ' ve read a complete number . Decide if it ' s a PEEKED_LONG or a PEEKED_NUMBER . if ( last = = NUMBER_CHAR_DIGIT & & fitsInLong & & ( value ! = Long . MIN_VALUE | | negative ) & & ( value ! = 0 | | false = = negative ) ) { peekedLong = negative ? value : - value ; pos + = i ; return peeked = PEEKED_LONG ;", "label": 1}
{"buggy_code": "public class test { private Node tryFoldComparison ( Node n , Node left , Node right ) { if ( ! NodeUtil . isLiteralValue ( left , false ) | | ! NodeUtil . isLiteralValue ( right , false ) ) { & & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "fixed_code": "public class test { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; } private Node tryFoldComparison ( Node n , Node left , Node right ) { if ( ! NodeUtil . isLiteralValue ( left , false ) | | ! NodeUtil . isLiteralValue ( right , false ) ) { & & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "label": 1}
{"buggy_code": "public class test { protected String _asString ( BigDecimal value ) throws IOException { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector return value . toString ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected String _asString ( BigDecimal value ) throws IOException { if ( Feature . WRITE_BIGDECIMAL_AS_PLAIN . enabledIn ( _features ) ) { / / 24 - Aug - 2016 , tatu : [ core # 315 ] prevent possible DoS vector int scale = value . scale ( ) ; if ( ( scale < - MAX_BIG_DECIMAL_SCALE ) | | ( scale > MAX_BIG_DECIMAL_SCALE ) ) { _reportError ( String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , scale , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ) ; } return value . toPlainString ( ) ; } return value . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1}
{"buggy_code": "public class test { public void addMonths ( final int months ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } public void addMinutes ( final int minutes ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } public void add ( DurationFieldType type , int amount ) { if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } public void addWeekyears ( final int weekyears ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } public void addSeconds ( final int seconds ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } public void addMillis ( final int millis ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } public void addWeeks ( final int weeks ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } public void addDays ( final int days ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } public void addYears ( final int years ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } public void addHours ( final int hours ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addWeeks ( final int weeks ) { if ( weeks ! = 0 ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } } public void addMonths ( final int months ) { if ( months ! = 0 ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } } public void addMinutes ( final int minutes ) { if ( minutes ! = 0 ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } } public void addMillis ( final int millis ) { if ( millis ! = 0 ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } } public void addYears ( final int years ) { if ( years ! = 0 ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } } public void add ( DurationFieldType type , int amount ) { if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } if ( amount ! = 0 ) { setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } } public void addSeconds ( final int seconds ) { if ( seconds ! = 0 ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } } public void addHours ( final int hours ) { if ( hours ! = 0 ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } public void addDays ( final int days ) { if ( days ! = 0 ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } } public void addWeekyears ( final int weekyears ) { if ( weekyears ! = 0 ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; / / calculate hash : int hash = 0 ;", "fixed_code": "/ / limit ( no cache ) : if ( count > maxStringCacheLen ) return new String ( charBuf , start , count ) ; if ( count < 1 ) return \" \" ; / / calculate hash : int hash = 0 ;", "label": 1}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1}
{"buggy_code": "} } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + t . getMessage ( ) , t ) ; } } \\ No newline at end of file", "fixed_code": "} } return new JsonMappingException ( null , \" Instantiation of \" + getValueTypeDesc ( ) + \" value failed : \" + ClassUtil . exceptionMessage ( t ) , t ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "else value = null ; / / note that we add , not put . So that the first is kept , and rest are deduped , once in a context where case sensitivity is known ( the appropriate tree builder ) . attributes . put ( pendingAttributeName , value ) ; } } pendingAttributeName = null ;", "fixed_code": "else value = null ; / / note that we add , not put . So that the first is kept , and rest are deduped , once in a context where case sensitivity is known ( the appropriate tree builder ) . attributes . add ( pendingAttributeName , value ) ; } } pendingAttributeName = null ;", "label": 1}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "label": 1}
{"buggy_code": "public class test { public static String sanitize ( String s ) { final char [ ] chars = s . toCharArray ( ) ; final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "fixed_code": "public class test { public static String sanitize ( String s ) { final char [ ] cs = s . toCharArray ( ) ; final char [ ] chars = cs . length < = MAX_SANITIZED_NAME_LENGTH ? cs : Arrays . copyOf ( cs , MAX_SANITIZED_NAME_LENGTH ) ; if ( cs . length > MAX_SANITIZED_NAME_LENGTH ) { for ( int i = MAX_SANITIZED_NAME_LENGTH - 3 ; i < MAX_SANITIZED_NAME_LENGTH ; i + + ) { chars [ i ] = ' . ' ; } } final int len = chars . length ; final StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < len ; i + + ) {", "label": 1}
{"buggy_code": "/ / Prototypes of constructors and interfaces are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { return false ; } boolean inferred = true ;", "fixed_code": "/ / Prototypes of constructors and interfaces are always declared . if ( qName ! = null & & qName . endsWith ( \" . prototype \" ) ) { String className = qName . substring ( 0 , qName . lastIndexOf ( \" . prototype \" ) ) ; Var slot = scope . getSlot ( className ) ; JSType classType = slot = = null ? null : slot . getType ( ) ; if ( classType ! = null & & ( classType . isConstructor ( ) | | classType . isInterface ( ) ) ) { return false ; } } boolean inferred = true ;", "label": 1}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "label": 1}
{"buggy_code": "public class test { public void setPrototypeBasedOn ( ObjectType baseType ) { if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) {  baseType = new PrototypeObjectType ( registry , this . getReferenceName ( ) + \" . prototype \" , baseType ) ; } setPrototype ( ( PrototypeObjectType ) baseType ) ; } public boolean setPrototype ( PrototypeObjectType prototype ) { if ( prototype = = null ) { return false ; return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ; return true ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean setPrototype ( PrototypeObjectType prototype ) { if ( prototype = = null ) { return false ; return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ; return true ; } public void setPrototypeBasedOn ( ObjectType baseType ) { if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) {  baseType = new PrototypeObjectType ( registry , this . getReferenceName ( ) + \" . prototype \" , baseType ) ; } setPrototype ( ( PrototypeObjectType ) baseType ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; return charset ; } return null ; }", "fixed_code": "Matcher m = charsetPattern . matcher ( contentType ) ; if ( m . find ( ) ) { String charset = m . group ( 1 ) . trim ( ) ; if ( Charset . isSupported ( charset ) ) return charset ; charset = charset . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( charset ) ) return charset ; } return null ; }", "label": 1}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1}
{"buggy_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; if ( currentByte = = 0 ) { break ; } / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "fixed_code": "for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ; / / CheckStyle : MagicNumber OFF if ( currentByte < ' 0 ' | | currentByte > ' 7 ' ) { throw new IllegalArgumentException (", "label": 1}
{"buggy_code": "Document doc = null ; / / look for BOM - overrides any other header or input if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( docData . length ( ) > 0 & & docData . charAt ( 0 ) = = UNICODE_BOM ) { byteData . rewind ( ) ; docData = Charset . forName ( defaultCharset ) . decode ( byteData ) . toString ( ) ; docData = docData . substring ( 1 ) ; charsetName = defaultCharset ; doc = null ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "fixed_code": "Document doc = null ; / / look for BOM - overrides any other header or input byteData . mark ( ) ; byte [ ] bom = new byte [ 4 ] ; byteData . get ( bom ) ; byteData . rewind ( ) ; if ( bom [ 0 ] = = 0x00 & & bom [ 1 ] = = 0x00 & & bom [ 2 ] = = ( byte ) 0xFE & & bom [ 3 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE & & bom [ 2 ] = = 0x00 & & bom [ 3 ] = = 0x00 ) { / / LE charsetName = \" UTF - 32 \" ; / / and I hope it ' s on your system } else if ( bom [ 0 ] = = ( byte ) 0xFE & & bom [ 1 ] = = ( byte ) 0xFF | | / / BE bom [ 0 ] = = ( byte ) 0xFF & & bom [ 1 ] = = ( byte ) 0xFE ) { charsetName = \" UTF - 16 \" ; / / in all Javas } else if ( bom [ 0 ] = = ( byte ) 0xEF & & bom [ 1 ] = = ( byte ) 0xBB & & bom [ 2 ] = = ( byte ) 0xBF ) { charsetName = \" UTF - 8 \" ; / / in all Javas byteData . position ( 3 ) ; / / 16 and 32 decoders consume the BOM to determine be / le ; utf - 8 should be consumed } if ( charsetName = = null ) { / / determine from meta . safe parse as UTF - 8 / / look for < meta http - equiv = \" Content - Type \" content = \" text / html ; charset = gb2312 \" > or HTML5 < meta charset = \" gb2312 \" > Validate . notEmpty ( charsetName , \" Must set charset arg to character set of file to parse . Set to null to attempt to detect from HTML \" ) ; docData = Charset . forName ( charsetName ) . decode ( byteData ) . toString ( ) ; } if ( doc = = null ) { doc = parser . parseInput ( docData , baseUri ) ; doc . outputSettings ( ) . charset ( charsetName ) ;", "label": 1}
{"buggy_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine break ; } cmd . addOption ( opt ) ;", "fixed_code": "{ / / if the value is not yes , true or 1 then don ' t add the / / option to the CommandLine continue ; } cmd . addOption ( opt ) ;", "label": 1}
{"buggy_code": "generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ;", "fixed_code": "generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ;", "label": 1}
{"buggy_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "fixed_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } if ( NodeUtil . isName ( lhs ) ) { addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; } else { computeGenKill ( lhs , gen , kill , conditional ) ; } computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "label": 1}
{"buggy_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; count ( totalRead ) ; if ( totalRead = = - 1 ) { hasHitEOF = true ; } else { entryOffset + = totalRead ; }", "fixed_code": "numToRead = Math . min ( numToRead , available ( ) ) ; totalRead = is . read ( buf , offset , numToRead ) ; if ( totalRead = = - 1 ) { if ( numToRead > 0 ) { throw new IOException ( \" Truncated TAR archive \" ) ; } hasHitEOF = true ; } else { count ( totalRead ) ; entryOffset + = totalRead ; }", "label": 1}
{"buggy_code": "public class test { private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ; / / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; } String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ; / / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; } String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ; if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) {", "fixed_code": "} if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ; if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) {", "label": 1}
{"buggy_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; } reindexChildren ( index ) ; } } \\ No newline at end of file", "fixed_code": "Node in = children [ i ] ; reparentChild ( in ) ; childNodes . add ( index , in ) ; reindexChildren ( index ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected List < Node > ensureChildNodes ( ) { throw new UnsupportedOperationException ( \" Leaf Nodes do not have child nodes . \" ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected List < Node > ensureChildNodes ( ) { return EmptyNodes ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) { / / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) {", "fixed_code": "public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) { / / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) {", "label": 1}
{"buggy_code": "public class test { public WriteableCommandLineImpl ( final Option rootOption , final List arguments ) { this . prefixes = rootOption . getPrefixes ( ) ; this . normalised = arguments ; } public boolean looksLikeOption ( final String trigger ) { / / this is a reentrant call for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { return true ; } } return false ; } private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { return commandLine . looksLikeOption ( trigger ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void setCurrentOption ( Option currentOption ) ; Option getCurrentOption ( ) ; public void setCurrentOption ( Option currentOption ) { this . currentOption = currentOption ; } public boolean looksLikeOption ( final String trigger ) { if ( checkForOption ! = null ) { / / this is a reentrant call return ! checkForOption . equals ( trigger ) ; } checkForOption = trigger ; try { for ( final Iterator i = prefixes . iterator ( ) ; i . hasNext ( ) ; ) { final String prefix = ( String ) i . next ( ) ; if ( trigger . startsWith ( prefix ) ) { if ( getCurrentOption ( ) . canProcess ( this , trigger ) | | getCurrentOption ( ) . findOption ( trigger ) ! = null ) { return true ; } } }  return false ; } finally { checkForOption = null ; } } public WriteableCommandLineImpl ( final Option rootOption , final List arguments ) { this . prefixes = rootOption . getPrefixes ( ) ; this . normalised = arguments ; setCurrentOption ( rootOption ) ; } public Option getCurrentOption ( ) { return currentOption ; } private boolean looksLikeOption ( final WriteableCommandLine commandLine , final String trigger ) { Option oldOption = commandLine . getCurrentOption ( ) ; try { commandLine . setCurrentOption ( this ) ; return commandLine . looksLikeOption ( trigger ) ; } finally { commandLine . setCurrentOption ( oldOption ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" @ JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference . \" ) ; } typeAdapter = typeAdapter . nullSafe ( ) ; return typeAdapter ; } } \\ No newline at end of file", "fixed_code": "throw new IllegalArgumentException ( \" @ JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference . \" ) ; } if ( typeAdapter ! = null ) { typeAdapter = typeAdapter . nullSafe ( ) ; } return typeAdapter ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } } } \\ No newline at end of file", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return binaryData ; } long len = getEncodeLength ( binaryData , MIME_CHUNK_SIZE , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "fixed_code": "return binaryData ; } long len = getEncodeLength ( binaryData , isChunked ? MIME_CHUNK_SIZE : 0 , CHUNK_SEPARATOR ) ; if ( len > maxResultSize ) { throw new IllegalArgumentException ( \" Input array too big , the output array would be bigger ( \" + len +", "label": 1}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ;", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ;", "label": 1}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1}
{"buggy_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "fixed_code": "JsonDeserializer < Object > delegate = null ; if ( _valueInstantiator ! = null ) { / / [ databind # 2324 ] : check both array - delegating and delegating AnnotatedWithParams delegateCreator = _valueInstantiator . getArrayDelegateCreator ( ) ; if ( delegateCreator ! = null ) { JavaType delegateType = _valueInstantiator . getArrayDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; } else if ( ( delegateCreator = _valueInstantiator . getDelegateCreator ( ) ) ! = null ) { JavaType delegateType = _valueInstantiator . getDelegateType ( ctxt . getConfig ( ) ) ; delegate = findDeserializer ( ctxt , delegateType , property ) ; }", "label": 1}
{"buggy_code": "case Token . GETELEM : return true ; / / Anonymous functions definitions are not changed by side - effects , / / and named functions are not part of expressions . } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { } private static Collection < Definition > getCallableDefinitions ( DefinitionProvider definitionProvider , Node name ) { List < Definition > result = Lists . newArrayList ( ) ; if ( ! NodeUtil . isGetProp ( name ) & & ! NodeUtil . isName ( name ) ) { return null ; } Collection < Definition > decls = definitionProvider . getDefinitionsReferencedAt ( name ) ; if ( decls = = null ) { } return result ; } } \\ No newline at end of file", "fixed_code": "case Token . GETELEM : return true ; case Token . FUNCTION : / / Anonymous functions definitions are not changed by side - effects , / / and named functions are not part of expressions . Preconditions . checkState ( NodeUtil . isAnonymousFunction ( n ) ) ; return false ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { } private static Collection < Definition > getCallableDefinitions ( DefinitionProvider definitionProvider , Node name ) { if ( NodeUtil . isGetProp ( name ) | | NodeUtil . isName ( name ) ) { List < Definition > result = Lists . newArrayList ( ) ; Collection < Definition > decls = definitionProvider . getDefinitionsReferencedAt ( name ) ; if ( decls = = null ) { } return result ; } else if ( name . getType ( ) = = Token . OR | | name . getType ( ) = = Token . HOOK ) { Node firstVal ; if ( name . getType ( ) = = Token . HOOK ) { firstVal = name . getFirstChild ( ) . getNext ( ) ; } else { firstVal = name . getFirstChild ( ) ; }  Collection < Definition > defs1 = getCallableDefinitions ( definitionProvider , firstVal ) ; Collection < Definition > defs2 = getCallableDefinitions ( definitionProvider , firstVal . getNext ( ) ) ; if ( defs1 ! = null & & defs2 ! = null ) { defs1 . addAll ( defs2 ) ; return defs1 ; } else { return null ; } } else { return null ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return null ; } / / minus signs should be leading , invalid expression / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } / / minus signs must be leading , invalid int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "fixed_code": "return null ; } if ( num . intValue ( ) < 0 ) { / / minus signs should be leading , invalid expression pos . setIndex ( initialIndex ) ; return null ; } / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } if ( den . intValue ( ) < 0 ) { / / minus signs must be leading , invalid pos . setIndex ( initialIndex ) ; return null ; } int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "label": 1}
{"buggy_code": "/ / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing { if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; JsonNode result ; try { writeValue ( buf , fromValue ) ;", "fixed_code": "/ / Then use TokenBuffer , which is a JsonGenerator : TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } try { / / inlined ' writeValue ' with minor changes : / / first : disable wrapping when writing { if ( fromValue = = null ) return null ; TokenBuffer buf = new TokenBuffer ( this , false ) ; if ( isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ) { buf = buf . forceUseOfBigDecimal ( true ) ; } JsonNode result ; try { writeValue ( buf , fromValue ) ;", "label": 1}
{"buggy_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "fixed_code": "for ( Attribute attribute : source . attributes ( ) ) { / / valid xml attribute names are : ^ [ a - zA - Z_ : ] [ - a - zA - Z0 - 9_ : . ] String key = attribute . getKey ( ) . replaceAll ( \" [ ^ - a - zA - Z0 - 9_ : . ] \" , \" \" ) ; if ( key . matches ( \" [ a - zA - Z_ : ] { 1 } [ - a - zA - Z0 - 9_ : . ] * \" ) ) el . setAttribute ( key , attribute . getValue ( ) ) ; } }", "label": 1}
{"buggy_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix ! = null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; }", "fixed_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( testPrefix = = null | | equalStrings ( testPrefix , nodePrefix ) ) { return true ; } if ( nodePrefix = = null ) { return false ; } return equalStrings ( parent . getNamespaceURI ( testPrefix ) , parent . getNamespaceURI ( nodePrefix ) ) ; } return false ; }", "label": 1}
{"buggy_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "fixed_code": "} else { / / can NOT suppress entries in tabular output jgen . writeNull ( ) ; } return ; } / / otherwise find serializer to use JsonSerializer < Object > ser = _serializer ;", "label": 1}
{"buggy_code": "public class test { public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ n ' ) { lineCounter + + ; } lastChar = current ;", "fixed_code": "public class test { public int read ( ) throws IOException { int current = super . read ( ) ; if ( current = = ' \\ r ' | | ( current = = ' \\ n ' & & lastChar ! = ' \\ r ' ) ) { lineCounter + + ; } lastChar = current ;", "label": 1}
{"buggy_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "fixed_code": "break ; case ' < ' : / / escape when in character data or when in a xml attribue val ; not needed in html attr val if ( ! inAttribute | | escapeMode = = EscapeMode . xhtml ) accum . append ( \" & lt ; \" ) ; else accum . append ( c ) ;", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ;  } else { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & true ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "label": 1}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 1 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1}
{"buggy_code": "public class test { protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = options . getRequiredOptions ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void setOptions ( final Options options ) { this . options = options ; this . requiredOptions = new ArrayList ( options . getRequiredOptions ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( tag . isSelfClosing ( ) ) tokeniser . acknowledgeSelfClosingFlag ( ) ; } else { tag . setSelfClosing ( ) ; tokeniser . acknowledgeSelfClosingFlag ( ) ; } } return el ; }", "fixed_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( \" Tag cannot be self closing ; not a void tag \" ) ; } else / / unknown tag , remember this is self closing for output tag . setSelfClosing ( ) ; } return el ; }", "label": 1}
{"buggy_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS : return t . isJavaLangObject ( ) ; } } public TypeSerializer buildTypeSerializer ( SerializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeSerializer ( idRes , null ) ; case PROPERTY : return new AsPropertyTypeSerializer ( idRes , null , _typeProperty ) ; case WRAPPER_OBJECT : return new AsWrapperTypeSerializer ( idRes , null ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeSerializer ( idRes , null , _typeProperty ) ; case EXISTING_PROPERTY : return new AsExistingPropertyTypeSerializer ( idRes , null , _typeProperty ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } } \\ No newline at end of file", "fixed_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless if ( t . isPrimitive ( ) ) { return false ; } switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS : return t . isJavaLangObject ( ) ; } } public TypeDeserializer buildTypeDeserializer ( DeserializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] better prevent use for primitives , / / regardless of setting if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , false , true ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } public TypeSerializer buildTypeSerializer ( SerializationConfig config , JavaType baseType , Collection < NamedType > subtypes ) { if ( _idType = = JsonTypeInfo . Id . NONE ) { return null ; } if ( baseType . isPrimitive ( ) ) { return null ; } TypeIdResolver idRes = idResolver ( config , baseType , subtypes , true , false ) ; switch ( _includeAs ) { case WRAPPER_ARRAY : return new AsArrayTypeSerializer ( idRes , null ) ; case PROPERTY : return new AsPropertyTypeSerializer ( idRes , null , _typeProperty ) ; case WRAPPER_OBJECT : return new AsWrapperTypeSerializer ( idRes , null ) ; case EXTERNAL_PROPERTY : return new AsExternalTypeSerializer ( idRes , null , _typeProperty ) ; case EXISTING_PROPERTY : return new AsExistingPropertyTypeSerializer ( idRes , null , _typeProperty ) ; } throw new IllegalStateException ( \" Do not know how to construct standard type serializer for inclusion type : \" + _includeAs ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static double sinh ( double x ) { boolean negate = false ; if ( x ! = x ) { / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) { return result ; } public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } public static double sinh ( double x ) { boolean negate = false ; if ( x ! = x ) { / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) { return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected String getLanguage ( ) { Object n = node ; while ( n ! = null ) { if ( n instanceof Element ) { Element e = ( Element ) n ; String attr = e . getAttributeValue ( \" lang \" , Namespace . XML_NAMESPACE ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } } n = nodeParent ( n ) ; } return null ; } public Object getValue ( ) { if ( node instanceof Element ) { return ( ( Element ) node ) . getTextTrim ( ) ; } if ( node instanceof Comment ) { String text = ( ( Comment ) node ) . getText ( ) ; } return text ; } if ( node instanceof Text ) { return ( ( Text ) node ) . getTextTrim ( ) ; } if ( node instanceof CDATA ) { return ( ( CDATA ) node ) . getTextTrim ( ) ; } if ( node instanceof ProcessingInstruction ) { String text = ( ( ProcessingInstruction ) node ) . getData ( ) ; if ( text ! = null ) { text = text . trim ( ) ; } return text ; } return null ; }", "fixed_code": "public class test { public Object getValue ( ) { if ( node instanceof Element ) { StringBuffer buf = new StringBuffer ( ) ; for ( NodeIterator children = childIterator ( null , false , null ) ; children . setPosition ( children . getPosition ( ) + 1 ) ; ) { NodePointer ptr = children . getNodePointer ( ) ; if ( ptr . getImmediateNode ( ) instanceof Element | | ptr . getImmediateNode ( ) instanceof Text ) { buf . append ( ptr . getValue ( ) ) ; } } return buf . toString ( ) ; } if ( node instanceof Comment ) { String text = ( ( Comment ) node ) . getText ( ) ; } return text ; } String result = null ; if ( node instanceof Text ) { result = ( ( Text ) node ) . getText ( ) ; } if ( node instanceof ProcessingInstruction ) { result = ( ( ProcessingInstruction ) node ) . getData ( ) ; } boolean trim = ! \" preserve \" . equals ( findEnclosingAttribute ( node , \" space \" , Namespace . XML_NAMESPACE ) ) ; return result ! = null & & trim ? result . trim ( ) : result ; } protected String getLanguage ( ) { return findEnclosingAttribute ( node , \" lang \" , Namespace . XML_NAMESPACE ) ; } protected static String findEnclosingAttribute ( Object n , String attrName , Namespace ns ) { while ( n ! = null ) { if ( n instanceof Element ) { Element e = ( Element ) n ; String attr = e . getAttributeValue ( attrName , ns ) ; if ( attr ! = null & & ! attr . equals ( \" \" ) ) { return attr ; } } n = nodeParent ( n ) ; } return null ; }", "label": 1}
{"buggy_code": "public class test { Token reset ( ) { reset ( name ) ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return this ; } } \\ No newline at end of file", "fixed_code": "public class test { Token reset ( ) { reset ( name ) ; pubSysKey = null ; reset ( publicIdentifier ) ; reset ( systemIdentifier ) ; forceQuirks = false ; return this ; } String getPubSysKey ( ) { return pubSysKey ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "fixed_code": "return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; / / new instances are used instead of Collections . emptyList ( ) , etc . / / to avoid UnsupportedOperationException if code under test modifies returned collection } else if ( type = = Iterable . class ) { return new ArrayList < Object > ( 0 ) ; } else if ( type = = Collection . class ) { return new LinkedList < Object > ( ) ; } else if ( type = = Set . class ) {", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new FieldProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new FieldProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex | | ( endIndex < 0 ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "label": 1}
{"buggy_code": "public class test { public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }", "fixed_code": "public class test { public Complex reciprocal ( ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( isNaN ) { return NaN ; }", "label": 1}
{"buggy_code": "* * These special cases are handled below . return res ; } public OpenMapRealVector ebeDivide ( RealVector v ) { * this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; }", "fixed_code": "* * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; } public OpenMapRealVector ebeDivide ( RealVector v ) { * this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; }", "label": 1}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \"", "label": 1}
{"buggy_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 1}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; int iter = 0 ; while ( true ) { + + iter ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( iter , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; int iter = 0 ; for ( boolean converged = false ; ! converged ; ) { + + iter ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( iter , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; while ( true ) { incrementIterationCount ( ) ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( getIterations ( ) , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "label": 1}
{"buggy_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! ( out . syntax ( ) = = Document . OutputSettings . Syntax . html & & ( val = = null | | val . equals ( key ) & & Attribute . isBooleanAttribute ( key ) ) ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "fixed_code": "accum . append ( ' ' ) . append ( key ) ; / / collapse checked = null , checked = \" \" , checked = checked ; write out others if ( ! Attribute . shouldCollapseAttribute ( key , val , out ) ) { accum . append ( \" = \\ \" \" ) ; Entities . escape ( accum , val = = null ? EmptyString : val , out , true , false , false ) ; accum . append ( ' \" ' ) ;", "label": 1}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = FastMath . abs ( r * FastMath . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = FastMath . abs ( r * FastMath . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 1}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } } \\ No newline at end of file", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; } public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void add ( BoxAndWhiskerItem item , Comparable rowKey , Comparable columnKey ) { & & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; fireDatasetChanged ( ) ; } private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames ( ) ; return clone ; } } \\ No newline at end of file", "fixed_code": "public class test { public Element clone ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames = null ; / / derived on first hit , otherwise gets a pointer to source classnames return clone ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( b = = ESCAPE_CHAR ) { try { / / if the next octet is a CR we have found a soft line break int u = Utils . digit16 ( bytes [ + + i ] ) ; int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( \" Invalid quoted - printable encoding \" , e ) ; } } else { / / every other octet is appended except for CR & LF buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; } private static final void encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; } public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; / / encode up to buffer . length - 3 , the last three octets will be treated / / separately for simplification of note # 3 / / up to this length it is safe to add any byte , encoded or not for ( byte c : bytes ) { int b = c ; if ( b < 0 ) { b = 256 + b ; } if ( printable . get ( b ) ) { buffer . write ( b ) ; } else { / / rule # 3 : whitespace at the end of a line * must * be encoded / / rule # 5 : soft line break encodeQuotedPrintable ( b , buffer ) ; } } / / rule # 3 : whitespace at the end of a line * must * be encoded / / if we would do a soft break line after this octet , encode whitespace / / note # 3 : ' = ' * must not * be the ultimate or penultimate character / / simplification : if < 6 bytes left , do a soft line break as we may need / / exactly 6 bytes space for the last 2 bytes / / rule # 3 : trailing whitespace shall be encoded return buffer . toByteArray ( ) ; }", "fixed_code": "if ( b = = ESCAPE_CHAR ) { try { / / if the next octet is a CR we have found a soft line break if ( bytes [ + + i ] = = CR ) { continue ; } int u = Utils . digit16 ( bytes [ i ] ) ; int l = Utils . digit16 ( bytes [ + + i ] ) ; buffer . write ( ( char ) ( ( u < < 4 ) + l ) ) ; } catch ( ArrayIndexOutOfBoundsException e ) { throw new DecoderException ( \" Invalid quoted - printable encoding \" , e ) ; } } else if ( b ! = CR & & b ! = LF ) { / / every other octet is appended except for CR & LF buffer . write ( b ) ; } } return buffer . toByteArray ( ) ; } private static final int encodeQuotedPrintable ( int b , ByteArrayOutputStream buffer ) { buffer . write ( ESCAPE_CHAR ) ; char hex1 = Character . toUpperCase ( Character . forDigit ( ( b > > 4 ) & 0xF , 16 ) ) ; char hex2 = Character . toUpperCase ( Character . forDigit ( b & 0xF , 16 ) ) ; buffer . write ( hex1 ) ; buffer . write ( hex2 ) ; return 3 ; } private static boolean isWhitespace ( final int b ) { return b = = SPACE | | b = = TAB ; } private static int getUnsignedOctet ( final int index , final byte [ ] bytes ) { int b = bytes [ index ] ; if ( b < 0 ) { b = 256 + b ; } return b ; } private static int encodeByte ( final int b , final boolean encode , final ByteArrayOutputStream buffer ) { if ( encode ) { return encodeQuotedPrintable ( b , buffer ) ; } else { buffer . write ( b ) ; return 1 ; } } public static final byte [ ] encodeQuotedPrintable ( BitSet printable , byte [ ] bytes ) { if ( bytes = = null ) { printable = PRINTABLE_CHARS ; } ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; int pos = 1 ; / / encode up to buffer . length - 3 , the last three octets will be treated / / separately for simplification of note # 3 for ( int i = 0 ; i < bytes . length - 3 ; i + + ) { int b = getUnsignedOctet ( i , bytes ) ; if ( pos < SAFE_LENGTH ) { / / up to this length it is safe to add any byte , encoded or not pos + = encodeByte ( b , ! printable . get ( b ) , buffer ) ; } else { / / rule # 3 : whitespace at the end of a line * must * be encoded encodeByte ( b , ! printable . get ( b ) | | isWhitespace ( b ) , buffer ) ; / / rule # 5 : soft line break buffer . write ( ESCAPE_CHAR ) ; buffer . write ( CR ) ; buffer . write ( LF ) ; pos = 1 ; } } / / rule # 3 : whitespace at the end of a line * must * be encoded / / if we would do a soft break line after this octet , encode whitespace int b = getUnsignedOctet ( bytes . length - 3 , bytes ) ; boolean encode = ! printable . get ( b ) | | ( isWhitespace ( b ) & & pos > SAFE_LENGTH - 5 ) ; pos + = encodeByte ( b , encode , buffer ) ; / / note # 3 : ' = ' * must not * be the ultimate or penultimate character / / simplification : if < 6 bytes left , do a soft line break as we may need / / exactly 6 bytes space for the last 2 bytes if ( pos > SAFE_LENGTH - 2 ) { buffer . write ( ESCAPE_CHAR ) ; buffer . write ( CR ) ; buffer . write ( LF ) ; } for ( int i = bytes . length - 2 ; i < bytes . length ; i + + ) { b = getUnsignedOctet ( i , bytes ) ; / / rule # 3 : trailing whitespace shall be encoded encode = ! printable . get ( b ) | | ( i > bytes . length - 2 & & isWhitespace ( b ) ) ; encodeByte ( b , encode , buffer ) ; } return buffer . toByteArray ( ) ; }", "label": 1}
{"buggy_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; / / but above intended maximum , slow to increase by 25 % int newLen = ( len = = MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + 1 ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > 1 ) ) ; return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; } } \\ No newline at end of file", "fixed_code": "final char [ ] curr = _currentSegment ; / / Let ' s grow by 50 % by default final int len = curr . length ; int newLen = len + ( len > > 1 ) ; / / but above intended maximum , slow to increase by 25 % if ( newLen > MAX_SEGMENT_LEN ) { newLen = len + ( len > > 2 ) ; } return ( _currentSegment = Arrays . copyOf ( curr , newLen ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "fixed_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; while ( node . isGetProp ( ) ) { node = node . getFirstChild ( ) ; } if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "label": 1}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) { @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) ! = true & & x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1}
{"buggy_code": "public class test { private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1}
{"buggy_code": "/ / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "fixed_code": "/ / And then see if we get other parts if ( c = = INT_PERIOD ) { / / yes , fraction if ( outPtr > = outBuf . length ) { outBuf = _textBuffer . finishCurrentSegment ( ) ; outPtr = 0 ; } outBuf [ outPtr + + ] = ( char ) c ; fract_loop :", "label": 1}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1}
{"buggy_code": "return true ; } if ( getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "fixed_code": "return true ; } if ( ! isPaxHeader ( ) & & ! isGlobalPaxHeader ( ) & & getName ( ) . endsWith ( \" / \" ) ) { return true ; }", "label": 1}
{"buggy_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "fixed_code": "String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( settings . normalizeTag ( el . tagName ( ) ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } / / else , we couldn ' t parse it as a decl , so leave as a comment } } insertNode ( insert ) ;", "label": 1}
{"buggy_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . getIgnored ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "fixed_code": "boolean ignoreAny = ignorals . getIgnoreUnknown ( ) ; builder . setIgnoreUnknownProperties ( ignoreAny ) ; / / Or explicit / implicit definitions ? ignored = ignorals . findIgnoredForDeserialization ( ) ; for ( String propName : ignored ) { builder . addIgnorable ( propName ) ; }", "label": 1}
{"buggy_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) return token . startsWith ( \" - \" ) & & token . length ( ) > = 2 & & options . hasShortOption ( token . substring ( 1 , 2 ) ) ; / / remove leading \" - \" and \" = value \" } } \\ No newline at end of file", "fixed_code": "private boolean isShortOption ( String token ) { / / short options ( - S , - SV , - S = V , - SV1 = V2 , - S1S2 ) if ( ! token . startsWith ( \" - \" ) | | token . length ( ) = = 1 ) { return false ; } / / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "fixed_code": "return new TarArchiveInputStream ( in ) ; } / / COMPRESS - 117 - improve auto - recognition if ( signatureLength > = 512 ) { try { TarArchiveInputStream tais = new TarArchiveInputStream ( new ByteArrayInputStream ( tarheader ) ) ; tais . getNextEntry ( ) ; / / autodetection , simply not a TAR / / ignored } } } catch ( IOException e ) { throw new ArchiveException ( \" Could not use reset and mark operations . \" , e ) ; }", "label": 1}
{"buggy_code": "StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , t . getMessage ( ) , t ) ; } } \\ No newline at end of file", "fixed_code": "StringBuilder msg = new StringBuilder ( \" Problem deserializing \\ \" any \\ \" property ' \" ) . append ( propName ) ; msg . append ( \" ' of class \" + getClassName ( ) + \" ( expected type : \" ) . append ( _type ) ; msg . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; } else { ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable t = ClassUtil . getRootCause ( e ) ; throw new JsonMappingException ( null , ClassUtil . exceptionMessage ( t ) , t ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < = maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "fixed_code": "} char c = _inputBuffer [ _inputPtr ] ; int i = ( int ) c ; if ( i < maxCode ) { if ( codes [ i ] ! = 0 ) { break ; }", "label": 1}
{"buggy_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; return out ; } public static Evaluator parse ( String query ) { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } } \\ No newline at end of file", "fixed_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; if ( depth > 0 ) { / / ran out of queue before seeing enough ) Validate . fail ( \" Did not find balanced maker at \" + out ) ; } return out ; } public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS :", "fixed_code": "{ / / 03 - Oct - 2016 , tatu : As per [ databind # 1395 ] , need to skip / / primitive types too , regardless if ( t . isPrimitive ( ) ) { return false ; } switch ( _appliesFor ) { case NON_CONCRETE_AND_ARRAYS :", "label": 1}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } cc . endSourceMapping ( n ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } cc . endSourceMapping ( n ) ; } private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { return new BigDecimal ( buffer , offset , len ) ; } public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { return new BigDecimal ( numStr ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static NumberFormatException _badBigDecimal ( String str ) { return new NumberFormatException ( \" Value \\ \" \" + str + \" \\ \" can not be represented as BigDecimal \" ) ; } public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { try { return new BigDecimal ( numStr ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( numStr ) ; } } public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { try { return new BigDecimal ( buffer , offset , len ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( new String ( buffer , offset , len ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow final long bitsOut ; if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; return bitsOut ; } } \\ No newline at end of file", "fixed_code": "if ( count < 0 | | count > MAXIMUM_CACHE_SIZE ) { throw new IllegalArgumentException ( \" count must not be negative or greater than \" + MAXIMUM_CACHE_SIZE ) ; } while ( bitsCachedSize < count & & bitsCachedSize < 57 ) { final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } bitsCachedSize + = 8 ; } int overflowBits = 0 ; long overflow = 0l ; if ( bitsCachedSize < count ) { / / bitsCachedSize > = 57 and left - shifting it 8 bits would cause an overflow int bitsToAddCount = count - bitsCachedSize ; overflowBits = 8 - bitsToAddCount ; final long nextByte = in . read ( ) ; if ( nextByte < 0 ) { return nextByte ; } if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { long bitsToAdd = nextByte & MASKS [ bitsToAddCount ] ; bitsCached | = ( bitsToAdd < < bitsCachedSize ) ; overflow = ( nextByte > > > bitsToAddCount ) & MASKS [ overflowBits ] ; } else { bitsCached < < = bitsToAddCount ; long bitsToAdd = ( nextByte > > > ( overflowBits ) ) & MASKS [ bitsToAddCount ] ; bitsCached | = bitsToAdd ; overflow = nextByte & MASKS [ overflowBits ] ; } bitsCachedSize = count ; } final long bitsOut ; if ( overflowBits = = 0 ) { if ( byteOrder = = ByteOrder . LITTLE_ENDIAN ) { bitsOut = ( bitsCached & MASKS [ count ] ) ; bitsCached > > > = count ; bitsOut = ( bitsCached > > ( bitsCachedSize - count ) ) & MASKS [ count ] ; } bitsCachedSize - = count ; } else { bitsOut = bitsCached & MASKS [ count ] ; bitsCached = overflow ; bitsCachedSize = overflowBits ; } return bitsOut ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1}
{"buggy_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "fixed_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "label": 1}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1}
{"buggy_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; } return injectionOccurred ; } public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fieldInstance ) ; } } \\ No newline at end of file", "fixed_code": "private boolean injectMockCandidatesOnFields ( Set < Object > mocks , Object instance , boolean injectionOccurred , List < Field > orderedInstanceFields ) { for ( Iterator < Field > it = orderedInstanceFields . iterator ( ) ; it . hasNext ( ) ; ) { Field field = it . next ( ) ; Object injected = mockCandidateFilter . filterCandidate ( mocks , field , orderedInstanceFields , instance ) . thenInject ( ) ; if ( injected ! = null ) { injectionOccurred | = true ; mocks . remove ( injected ) ; } return injectionOccurred ; } public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , List < Field > fields , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockTypeMatches = new ArrayList < Object > ( ) ; for ( Object mock : mocks ) { if ( field . getType ( ) . isAssignableFrom ( mock . getClass ( ) ) ) { } } return next . filterCandidate ( mockTypeMatches , field , fields , fieldInstance ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" The Integer did not match any specified value \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" The Integer did not match any specified value \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new CreatorProperty ( this , deser , _nullProvider ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new FieldProperty ( this , deser , _nullProvider ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new MethodProperty ( this , deser , _nullProvider ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdReferenceProperty ( this , deser , _nullProvider ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdValueProperty ( this , deser , _nullProvider ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new SetterlessProperty ( this , deser , _nullProvider ) ; } public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new CreatorProperty ( this , deser , nvp ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new FieldProperty ( this , deser , nvp ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new MethodProperty ( this , deser , nvp ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdReferenceProperty ( this , deser , nvp ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdValueProperty ( this , deser , nvp ) ; } public SettableBeanProperty withValueDeserializer ( JsonDeserializer < ? > deser ) { if ( _valueDeserializer = = deser ) { return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new SetterlessProperty ( this , deser , nvp ) ; } public AtomicReference < Object > getNullValue ( DeserializationContext ctxt ) throws JsonMappingException { return new AtomicReference < Object > ( _valueDeserializer . getNullValue ( ctxt ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 1}
{"buggy_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext | | l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext | | r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "fixed_code": "/ / ( l = = null ? \" null \" : l . getClass ( ) . getName ( ) ) + \" \" + / / ( r = = null ? \" null \" : r . getClass ( ) . getName ( ) ) ) ; if ( l instanceof InitialContext ) { ( ( EvalContext ) l ) . reset ( ) ; }  if ( l instanceof SelfContext ) { l = ( ( EvalContext ) l ) . getSingleNodePointer ( ) ; } if ( r instanceof InitialContext ) { ( ( EvalContext ) r ) . reset ( ) ; }  if ( r instanceof SelfContext ) { r = ( ( EvalContext ) r ) . getSingleNodePointer ( ) ; }", "label": 1}
{"buggy_code": "public class test { public Map < String , Integer > getHeaderMap ( ) { return new LinkedHashMap < String , Integer > ( this . headerMap ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Map < String , Integer > getHeaderMap ( ) { return this . headerMap = = null ? null : new LinkedHashMap < String , Integer > ( this . headerMap ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; } private Node tryRemoveUnconditionalBranching ( Node n ) { return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ;", "fixed_code": "public class test { private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; } private Node tryRemoveUnconditionalBranching ( Node n ) { return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ;", "label": 1}
{"buggy_code": "settings . getTypeToMock ( ) , settings . getExtraInterfaces ( ) ) ; T mockInstance = null ; try { mockInstance = classInstantiator . instantiate ( mockedProxyType ) ; MockMethodInterceptor . MockAccess mockAccess = ( MockMethodInterceptor . MockAccess ) mockInstance ; mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ; \" class to mock : \" + describeClass ( mockedProxyType ) , \" created class : \" + describeClass ( settings . getTypeToMock ( ) ) , \" proxy instance class : \" + describeClass ( mockInstance ) , \" instance creation by : \" + classInstantiator . getClass ( ) . getSimpleName ( ) , \" \" , \" You might experience classloading issues , please ask the mockito mailing - list . \" , \" \"", "fixed_code": "settings . getTypeToMock ( ) , settings . getExtraInterfaces ( ) ) ; Instantiator instantiator = new InstantiatorProvider ( ) . getInstantiator ( settings ) ; T mockInstance = null ; try { mockInstance = instantiator . newInstance ( mockedProxyType ) ; MockMethodInterceptor . MockAccess mockAccess = ( MockMethodInterceptor . MockAccess ) mockInstance ; mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ; \" class to mock : \" + describeClass ( mockedProxyType ) , \" created class : \" + describeClass ( settings . getTypeToMock ( ) ) , \" proxy instance class : \" + describeClass ( mockInstance ) , \" instance creation by : \" + instantiator . getClass ( ) . getSimpleName ( ) , \" \" , \" You might experience classloading issues , please ask the mockito mailing - list . \" , \" \"", "label": 1}
{"buggy_code": "/ / 25 - Sep - 2016 , tatu : As per [ databind # 1384 ] also need to ensure handlers get / / copied as well return newType ; / / 20 - Oct - 2015 , tatu : Old simplistic approach", "fixed_code": "/ / 25 - Sep - 2016 , tatu : As per [ databind # 1384 ] also need to ensure handlers get / / copied as well newType = newType . withHandlersFrom ( baseType ) ; return newType ; / / 20 - Oct - 2015 , tatu : Old simplistic approach", "label": 1}
{"buggy_code": "public class test { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ; } public int read ( ) throws IOException { final int ret = input . read ( ) ; offset + = ( ret > 0 ? 1 : 0 ) ; return ret ; } public ArArchiveEntry getNextArEntry ( ) throws IOException { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } / / hit eof if ( input . available ( ) = = 0 ) { return null ; } if ( offset % 2 ! = 0 ) { read ( ) ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } return new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int read ( byte [ ] b , final int off , final int len ) throws IOException { int toRead = len ; if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; if ( len > 0 & & entryEnd > offset ) { toRead = ( int ) Math . min ( len , entryEnd - offset ) ; } else { return - 1 ; } } final int ret = this . input . read ( b , off , toRead ) ; offset + = ( ret > 0 ? ret : 0 ) ; return ret ; } public ArArchiveEntry getNextArEntry ( ) throws IOException { if ( currentEntry ! = null ) { final long entryEnd = entryOffset + currentEntry . getLength ( ) ; while ( offset < entryEnd ) { int x = read ( ) ; if ( x = = - 1 ) { / / hit EOF before previous entry was complete / / TODO : throw an exception instead ? return null ; } } currentEntry = null ; } if ( offset = = 0 ) { final byte [ ] expected = ArArchiveEntry . HEADER . getBytes ( ) ; } } if ( offset % 2 ! = 0 ) { if ( read ( ) < 0 ) { / / hit eof return null ; } } if ( input . available ( ) = = 0 ) { return null ; } final byte [ ] name = new byte [ 16 ] ; final byte [ ] lastmodified = new byte [ 12 ] ; final byte [ ] userid = new byte [ 6 ] ; } } entryOffset = offset ; currentEntry = new ArArchiveEntry ( new String ( name ) . trim ( ) , Long . parseLong ( new String ( length ) . trim ( ) ) ) ; return currentEntry ; } public int read ( ) throws IOException { byte [ ] single = new byte [ 1 ] ; int num = read ( single , 0 , 1 ) ; return num = = - 1 ? - 1 : single [ 0 ] & 0xff ; } public void close ( ) throws IOException { if ( ! closed ) { closed = true ; input . close ( ) ; } currentEntry = null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : byte [ ] data = n . binaryValue ( ) ; if ( data ! = null ) { return data ; } if ( n . isPojo ( ) ) { Object ob = ( ( POJONode ) n ) . getPojo ( ) ; if ( ob instanceof byte [ ] ) { return ( byte [ ] ) ob ; } } } / / otherwise return null to mark we have no binary content return null ;", "fixed_code": "if ( n ! = null ) { / / [ databind # 2096 ] : although ` binaryValue ( ) ` works for real binary node / / and embedded \" POJO \" node , coercion from TextNode may require variant , so : if ( n instanceof TextNode ) { return ( ( TextNode ) n ) . getBinaryValue ( b64variant ) ; } return n . binaryValue ( ) ; } / / otherwise return null to mark we have no binary content return null ;", "label": 1}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 1}
{"buggy_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; / / Check if problem is incompatible types return joinedArray ; } } \\ No newline at end of file", "fixed_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; try { System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; } catch ( ArrayStoreException ase ) { / / Check if problem is incompatible types final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; if ( ! type1 . isAssignableFrom ( type2 ) ) { throw new IllegalArgumentException ( \" Cannot store \" + type2 . getName ( ) + \" in an array of \" + type1 . getName ( ) ) ; } throw ase ; / / No , so rethrow original } return joinedArray ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ;", "fixed_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ;", "label": 1}
{"buggy_code": "public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ;", "fixed_code": "public TarArchiveOutputStream ( OutputStream os , int blockSize , int recordSize , String encoding ) { out = new CountingOutputStream ( os ) ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . assemLen = 0 ;", "label": 1}
{"buggy_code": "public class test { public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1}
{"buggy_code": "public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) return new CollectionType ( rawType , null , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ;", "fixed_code": "public static CollectionType construct ( Class < ? > rawType , JavaType elemT ) { / / First : may need to fabricate TypeBindings ( needed for refining into / / concrete collection types , as per [ databind # 1102 ] ) TypeVariable < ? > [ ] vars = rawType . getTypeParameters ( ) ; TypeBindings bindings ; if ( ( vars = = null ) | | ( vars . length ! = 1 ) ) { bindings = TypeBindings . emptyBindings ( ) ; } else { bindings = TypeBindings . create ( rawType , elemT ) ; } return new CollectionType ( rawType , bindings , / / ! ! ! TODO : Wrong , does have supertypes , but : _bogusSuperClass ( rawType ) , null , elemT , null , null , false ) ;", "label": 1}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value if ( property = = null ) { return this ; } JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "fixed_code": "{ / / Note ! Should not skip if ` property ` null since that ' d skip check / / for config overrides , in case of root value JsonFormat . Value format = findFormatOverrides ( serializers , property , handledType ( ) ) ; if ( format = = null ) { return this ;", "label": 1}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1}
{"buggy_code": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "fixed_code": "public class test { public boolean canInstantiate ( ) { return canCreateUsingDefault ( ) | | canCreateUsingDelegate ( ) | | canCreateUsingArrayDelegate ( ) | | canCreateFromObjectWith ( ) | | canCreateFromString ( ) | | canCreateFromInt ( ) | | canCreateFromLong ( ) | | canCreateFromDouble ( ) | | canCreateFromBoolean ( ) ;", "label": 1}
{"buggy_code": "} / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "} / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1}
{"buggy_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "fixed_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { int functionType = functionNode . getFunctionType ( ) ; if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { errorReporter . error ( \" unnamed function statement \" , sourceName , functionNode . getLineno ( ) , \" \" , 0 ) ; } name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "label": 1}
{"buggy_code": "JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; if ( ser ! = null ) { return ser ; } final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . } if ( ser = = null ) {", "fixed_code": "JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = null ; final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } } if ( ser = = null ) {", "label": 1}
{"buggy_code": "| | \" AbstractApplicationContext \" . equals ( name ) ) { break main_check ; } / / [ databind # 1737 ] ; more 3rd party / / s . add ( \" com . mchange . v2 . c3p0 . JndiRefForwardingDataSource \" ) ; / / s . add ( \" com . mchange . v2 . c3p0 . WrapperConnectionPoolDataSource \" ) ; / / [ databind # 1931 ] ; more 3rd party / / com . mchange . v2 . c3p0 . ComboPooledDataSource / / com . mchange . v2 . c3p0 . debug . AfterCloseLoggingComboPooledDataSource } } return ;", "fixed_code": "| | \" AbstractApplicationContext \" . equals ( name ) ) { break main_check ; } } } else if ( full . startsWith ( PREFIX_C3P0 ) ) { / / [ databind # 1737 ] ; more 3rd party / / s . add ( \" com . mchange . v2 . c3p0 . JndiRefForwardingDataSource \" ) ; / / s . add ( \" com . mchange . v2 . c3p0 . WrapperConnectionPoolDataSource \" ) ; / / [ databind # 1931 ] ; more 3rd party / / com . mchange . v2 . c3p0 . ComboPooledDataSource / / com . mchange . v2 . c3p0 . debug . AfterCloseLoggingComboPooledDataSource if ( full . endsWith ( \" DataSource \" ) ) { break main_check ; } } return ;", "label": 1}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; } }", "label": 1}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleSet ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "fixed_code": "/ / generic type with custom type resolvers . If so , should try to retain them . / / Whether this is sufficient to avoid problems remains to be seen , but for / / now it should improve things . if ( ! type . hasGenericTypes ( ) ) { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( _baseType , type . getRawClass ( ) ) ; } } deser = ctxt . findContextualValueDeserializer ( type , _property ) ; }", "label": 1}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "label": 1}
{"buggy_code": "public class test { void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( getWholeDeclaration ( ) ) . append ( \" > \" ) ; } public String getWholeDeclaration ( ) { final String decl = this . name ; if ( decl . equals ( \" xml \" ) & & attributes . size ( ) > 1 ) { StringBuilder sb = new StringBuilder ( decl ) ; final String version = attributes . get ( \" version \" ) ; if ( version ! = null ) { sb . append ( \" version = \\ \" \" ) . append ( version ) . append ( \" \\ \" \" ) ; } final String encoding = attributes . get ( \" encoding \" ) ; if ( encoding ! = null ) { sb . append ( \" encoding = \\ \" \" ) . append ( encoding ) . append ( \" \\ \" \" ) ; } return sb . toString ( ) ; } else { return this . name ; } } } \\ No newline at end of file", "fixed_code": "public class test { public String getWholeDeclaration ( ) { return attributes . html ( ) . trim ( ) ; / / attr html starts with a \" \" } void outerHtmlHead ( Appendable accum , int depth , Document . OutputSettings out ) throws IOException { accum . append ( \" < \" ) . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( name ) ; attributes . html ( accum , out ) ; accum . append ( isProcessingInstruction ? \" ! \" : \" ? \" ) . append ( \" > \" ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; } } private void computeShiftIncrement ( final int start , final int end , final int deflated ) { double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { } } private void computeGershgorinCircles ( ) {  final int m = main . length ; final int lowerStart = 4 * m ; final int upperStart = 5 * m ; lowerSpectra = Double . POSITIVE_INFINITY ; upperSpectra = Double . NEGATIVE_INFINITY ; double eMax = 0 ;  double eCurrent = 0 ; for ( int i = 0 ; i < m - 1 ; + + i ) {  final double dCurrent = main [ i ] ; final double ePrevious = eCurrent ; eCurrent = Math . abs ( secondary [ i ] ) ; eMax = Math . max ( eMax , eCurrent ) ; final double radius = ePrevious + eCurrent ;  final double lower = dCurrent - radius ; work [ lowerStart + i ] = lower ; lowerSpectra = Math . min ( lowerSpectra , lower ) ;  final double upper = dCurrent + radius ; work [ upperStart + i ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ;  }  final double dCurrent = main [ m - 1 ] ; final double lower = dCurrent - eCurrent ; work [ lowerStart + m - 1 ] = lower ; lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ;  } } \\ No newline at end of file", "fixed_code": "diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; } } private void computeGershgorinCircles ( ) {  final int m = main . length ; final int lowerStart = 4 * m ; final int upperStart = 5 * m ; lowerSpectra = Double . POSITIVE_INFINITY ; upperSpectra = Double . NEGATIVE_INFINITY ; double eMax = 0 ;  double eCurrent = 0 ; for ( int i = 0 ; i < m - 1 ; + + i ) {  final double dCurrent = main [ i ] ; final double ePrevious = eCurrent ; eCurrent = Math . abs ( secondary [ i ] ) ; eMax = Math . max ( eMax , eCurrent ) ; final double radius = ePrevious + eCurrent ;  final double lower = dCurrent - radius ; work [ lowerStart + i ] = lower ; lowerSpectra = Math . min ( lowerSpectra , lower ) ;  final double upper = dCurrent + radius ; work [ upperStart + i ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ;  }  final double dCurrent = main [ m - 1 ] ; final double lower = dCurrent - eCurrent ; work [ lowerStart + m - 1 ] = lower ; lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ;  } private void computeShiftIncrement ( final int start , final int end , final int deflated ) { double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ;", "fixed_code": "public class test { public OngoingInjecter filterCandidate ( final Collection < Object > mocks , final Field field , List < Field > fields , final Object fieldInstance ) { if ( mocks . size ( ) = = 1 ) { final Object matchingMock = mocks . iterator ( ) . next ( ) ;", "label": 1}
{"buggy_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters return c ; / / indicate unexpected char - available from in . getLastChar ( ) } } } \\ No newline at end of file", "fixed_code": "throw new IOException ( \" EOF whilst processing escape sequence \" ) ; default : / / Now check for meta - characters if ( isDelimiter ( c ) | | isEscape ( c ) | | isQuoteChar ( c ) | | isCommentStart ( c ) ) { return c ; } / / indicate unexpected char - available from in . getLastChar ( ) return END_OF_STREAM ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { Character consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; } } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "fixed_code": "public class test { String consumeLetterThenDigitSequence ( ) { int start = pos ; while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ) pos + + ; else break ; } while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( c > = ' 0 ' & & c < = ' 9 ' ) pos + + ; else break ; }  return input . substring ( start , pos ) ; } Character consumeCharacterReference ( Character additionalAllowedCharacter , boolean inAttribute ) { if ( reader . isEmpty ( ) ) return null ; } } else { / / named / / get as many letters as possible , and look for matching entities . unconsume backwards till a match is found String nameRef = reader . consumeLetterThenDigitSequence ( ) ; String origNameRef = new String ( nameRef ) ; / / for error reporting . nameRef gets chomped looking for matches boolean looksLegit = reader . matches ( ' ; ' ) ; boolean found = false ;", "label": 1}
{"buggy_code": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "label": 1}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1}
{"buggy_code": "pathNames [ stackSize - 2 ] = \" null \" ; } else { popStack ( ) ; pathNames [ stackSize - 1 ] = \" null \" ; } pathIndices [ stackSize - 1 ] + + ; } } \\ No newline at end of file", "fixed_code": "pathNames [ stackSize - 2 ] = \" null \" ; } else { popStack ( ) ; if ( stackSize > 0 ) { pathNames [ stackSize - 1 ] = \" null \" ; } } if ( stackSize > 0 ) { pathIndices [ stackSize - 1 ] + + ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "fixed_code": "/ / see issue 184 . / / mocks by default should return 0 if references are the same , otherwise some other value because they are not the same . Hence we return 1 ( anything but 0 is good ) . / / Only for compareTo ( ) method by the Comparable interface return invocation . getMock ( ) = = invocation . getArguments ( ) [ 0 ] ? 0 : 1 ; } Class < ? > returnType = invocation . getMethod ( ) . getReturnType ( ) ;", "label": 1}
{"buggy_code": "/ / Assume date is Gregorian . long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "fixed_code": "/ / Assume date is Gregorian . long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { throw ex ; } instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "label": 1}
{"buggy_code": "public class test { public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ; } void outerHtmlHead ( StringBuilder accum , int depth , Document . OutputSettings out ) { accum . append ( \" < ! DOCTYPE html \" ) ; if ( ! StringUtil . isBlank ( attr ( \" publicId \" ) ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( \" publicId \" ) ) . append ( \" \\ \" \" ) ; if ( ! StringUtil . isBlank ( attr ( \" systemId \" ) ) ) accum . append ( ' ' ) . append ( attr ( \" systemId \" ) ) . append ( \" \\ \" \" ) ; accum . append ( ' > ' ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void outerHtmlHead ( StringBuilder accum , int depth , Document . OutputSettings out ) { accum . append ( \" < ! DOCTYPE \" ) . append ( attr ( \" name \" ) ) ; if ( ! StringUtil . isBlank ( attr ( \" publicId \" ) ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( \" publicId \" ) ) . append ( \" \\ \" \" ) ; if ( ! StringUtil . isBlank ( attr ( \" systemId \" ) ) ) accum . append ( \" \\ \" \" ) . append ( attr ( \" systemId \" ) ) . append ( \" \\ \" \" ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; Validate . notEmpty ( name ) ; attr ( \" name \" , name ) ; attr ( \" publicId \" , publicId ) ; attr ( \" systemId \" , systemId ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c < 0x7F & & c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1}
{"buggy_code": "public class test { void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void clearStackToTableBodyContext ( ) { clearStackToContext ( \" tbody \" , \" tfoot \" , \" thead \" , \" template \" ) ; } void clearStackToTableRowContext ( ) { clearStackToContext ( \" tr \" , \" template \" ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; description . appendText ( wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "fixed_code": "public void describeTo ( Description description ) { description . appendText ( \" same ( \" ) ; appendQuoting ( description ) ; description . appendText ( wanted = = null ? \" null \" : wanted . toString ( ) ) ; appendQuoting ( description ) ; description . appendText ( \" ) \" ) ; }", "label": 1}
{"buggy_code": "public class test { public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = 0 ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { if ( ' 0 ' < = b & & b < = ' 7 ' & & digits + + < 6 ) { storedSum = storedSum * 8 + b - ' 0 ' ; } else if ( digits > 0 ) { digits = 6 ; } b = ' ' ; } unsignedSum + = 0xff & b ;", "fixed_code": "public class test { public static boolean verifyCheckSum ( byte [ ] header ) { long storedSum = parseOctal ( header , CHKSUM_OFFSET , CHKSUMLEN ) ; long unsignedSum = 0 ; long signedSum = 0 ; for ( int i = 0 ; i < header . length ; i + + ) { byte b = header [ i ] ; if ( CHKSUM_OFFSET < = i & & i < CHKSUM_OFFSET + CHKSUMLEN ) { b = ' ' ; } unsignedSum + = 0xff & b ;", "label": 1}
{"buggy_code": "HIDDEN_INTERFACE_PROPERTY , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) ) ) ; } if ( interfaceHasProperty ) { JSType interfacePropType = interfaceType . getPrototype ( ) . getPropertyType ( propertyName ) ; if ( ! propertyType . canAssignTo ( interfacePropType ) ) { compiler . report ( t . makeError ( n , HIDDEN_INTERFACE_PROPERTY_MISMATCH , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) , interfacePropType . toString ( ) , propertyType . toString ( ) ) ) ; } } } } prop , implementedInterface . toString ( ) , instance . toString ( ) ) ) ; } registerMismatch ( instance , implementedInterface ) ; / / Implemented , but not correctly typed } } } \\ No newline at end of file", "fixed_code": "HIDDEN_INTERFACE_PROPERTY , propertyName , interfaceType . getTopMostDefiningType ( propertyName ) . toString ( ) ) ) ; } } } prop , implementedInterface . toString ( ) , instance . toString ( ) ) ) ; } registerMismatch ( instance , implementedInterface ) ; } else { JSType found = instance . getPropertyType ( prop ) ; JSType required = implementedInterface . getImplicitPrototype ( ) . getPropertyType ( prop ) ; found = found . restrictByNotNullOrUndefined ( ) ; required = required . restrictByNotNullOrUndefined ( ) ; if ( ! found . canAssignTo ( required ) ) { / / Implemented , but not correctly typed if ( shouldReport ) { FunctionType constructor = implementedInterface . toObjectType ( ) . getConstructor ( ) ; compiler . report ( t . makeError ( n , HIDDEN_INTERFACE_PROPERTY_MISMATCH , prop , constructor . getTopMostDefiningType ( prop ) . toString ( ) , required . toString ( ) , found . toString ( ) ) ) ; } registerMismatch ( found , required ) ; } } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static boolean toBoolean ( String str ) { if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean toBoolean ( String arg0 ) { return ! ( arg0 . startsWith ( \" ( \" ) & & arg0 . endsWith ( \" ) \" ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( header = = null ) { this . header = null ; } else { this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } if ( header ! = null ) { final Set < String > set = new HashSet < String > ( header . length ) ; set . addAll ( Arrays . asList ( header ) ) ; if ( set . size ( ) ! = header . length ) { throw new IllegalStateException ( \" The header contains duplicate names : \" + Arrays . toString ( header ) ) ; } } } } \\ No newline at end of file", "fixed_code": "if ( header = = null ) { this . header = null ; } else { Set < String > dupCheck = new HashSet < String > ( ) ; for ( String hdr : header ) { if ( ! dupCheck . add ( hdr ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate entry : ' \" + hdr + \" ' in \" + Arrays . toString ( header ) ) ; } } this . header = header . clone ( ) ; } this . skipHeaderRecord = skipHeaderRecord ; throw new IllegalStateException ( \" No quotes mode set but no escape character is set \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } }", "fixed_code": "Converter < Object , Object > conv = provider . converterInstance ( prop . getMember ( ) , convDef ) ; JavaType delegateType = conv . getOutputType ( provider . getTypeFactory ( ) ) ; / / [ databind # 731 ] : Should skip if nominally java . lang . Object JsonSerializer < ? > ser = delegateType . isJavaLangObject ( ) ? null : provider . findValueSerializer ( delegateType , prop ) ; return new StdDelegatingSerializer ( conv , delegateType , ser ) ; } }", "label": 1}
{"buggy_code": "public class test { private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . insert ( startTag ) ; tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static void handleRawtext ( Token . StartTag startTag , HtmlTreeBuilder tb ) { tb . tokeniser . transition ( TokeniserState . Rawtext ) ; tb . markInsertionMode ( ) ; tb . transition ( Text ) ; tb . insert ( startTag ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "fixed_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "label": 1}
{"buggy_code": "public class test { protected JsonToken _parseNumber ( int ch ) throws IOException { boolean negative = ( ch = = INT_MINUS ) ; int ptr = _inputPtr ; int startPtr = ptr - 1 ; / / to include sign / digit already read final int inputLen = _inputEnd ;  dummy_loop : do { / / dummy loop , to be able to break out if ( negative ) { / / need to read the next digit if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = _inputBuffer [ ptr + + ] ; if ( ch > INT_9 | | ch < INT_0 ) { _inputPtr = ptr ; return _handleInvalidNumberStart ( ch , true ) ; } } if ( ch = = INT_0 ) { break dummy_loop ; }   int intLen = 1 ; / / already got one   int_loop : while ( true ) { if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break int_loop ; } + + intLen ; }  int fractLen = 0 ;  if ( ch = = ' . ' ) { / / yes , fraction fract_loop : while ( true ) { if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break fract_loop ; } + + fractLen ; } if ( fractLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Decimal point not followed by a digit \" ) ; } }  int expLen = 0 ; if ( ch = = ' e ' | | ch = = ' E ' ) { / / and / or exponent if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch = = INT_MINUS | | ch = = INT_PLUS ) { / / yup , skip for now if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } while ( ch < = INT_9 & & ch > = INT_0 ) { + + expLen ; if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } if ( expLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Exponent indicator not followed by a digit \" ) ; } } - - ptr ; / / need to push back following separator _inputPtr = ptr ; int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; } while ( false ) ;  _inputPtr = negative ? ( startPtr + 1 ) : startPtr ; return _parseNumber2 ( negative ) ; } private JsonToken _parseNumber2 ( boolean negative ) throws IOException { / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { - _inputPtr ; } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return reset ( negative , intLen , fractLen , expLen ) ; } private JsonToken _parserNumber2 ( char [ ] outBuf , int outPtr , boolean negative , int intPartLength ) throws IOException , JsonParseException - _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intPartLength ) ; } private int _skipWSOrEnd ( ) throws IOException { final int [ ] codes = _icWS ; while ( ( _inputPtr < _inputEnd ) | | loadMore ( ) ) { final int i = _inputBuffer [ _inputPtr + + ] & 0xFF ; switch ( codes [ i ] ) { case 0 : / / done ! return i ; case 1 : / / skip continue ; case 2 : / / 2 - byte UTF _skipUtf8_2 ( i ) ; break ; case 3 : / / 3 - byte UTF _skipUtf8_3 ( i ) ; break ; case 4 : / / 4 - byte UTF _skipUtf8_4 ( i ) ; break ; case INT_LF : + + _currInputRow ; _currInputRowStart = _inputPtr ; break ; case INT_CR : _skipCR ( ) ; break ; case ' / ' : _skipComment ( ) ; break ; case ' # ' : if ( ! _skipYAMLComment ( ) ) { return i ; } break ; default : / / e . g . - 1 if ( i < 32 ) { _throwInvalidSpace ( i ) ; } _reportInvalidChar ( i ) ; } } _handleEOF ( ) ; return - 1 ; } private JsonToken _parseFloat ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException if ( ! eof ) { - _inputPtr ; / / As per # 105 , need separating space between root values ; check here } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; } protected JsonToken _parseNumber ( int c ) throws IOException , JsonParseException { - _inputPtr ; / / to push back trailing char ( comma etc ) _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here / / And there we have it ! return resetInt ( negative , intLen ) ;", "fixed_code": "public class test { private final void _verifyRootSpace ( int ch ) throws IOException { + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; } private JsonToken _parseNumber2 ( boolean negative ) throws IOException { / / Ok ; unless we hit end - of - input , need to push last char read back if ( ! eof ) { if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return reset ( negative , intLen , fractLen , expLen ) ; } protected JsonToken _parseNumber ( int ch ) throws IOException { boolean negative = ( ch = = INT_MINUS ) ; int ptr = _inputPtr ; int startPtr = ptr - 1 ; / / to include sign / digit already read final int inputLen = _inputEnd ;  dummy_loop : do { / / dummy loop , to be able to break out if ( negative ) { / / need to read the next digit if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = _inputBuffer [ ptr + + ] ; if ( ch > INT_9 | | ch < INT_0 ) { _inputPtr = ptr ; return _handleInvalidNumberStart ( ch , true ) ; } } if ( ch = = INT_0 ) { break dummy_loop ; }   int intLen = 1 ; / / already got one   int_loop : while ( true ) { if ( ptr > = _inputEnd ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break int_loop ; } + + intLen ; }  int fractLen = 0 ;  if ( ch = = ' . ' ) { / / yes , fraction fract_loop : while ( true ) { if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch < INT_0 | | ch > INT_9 ) { break fract_loop ; } + + fractLen ; } if ( fractLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Decimal point not followed by a digit \" ) ; } }  int expLen = 0 ; if ( ch = = ' e ' | | ch = = ' E ' ) { / / and / or exponent if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; if ( ch = = INT_MINUS | | ch = = INT_PLUS ) { / / yup , skip for now if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } while ( ch < = INT_9 & & ch > = INT_0 ) { + + expLen ; if ( ptr > = inputLen ) { break dummy_loop ; } ch = ( int ) _inputBuffer [ ptr + + ] ; } if ( expLen = = 0 ) { reportUnexpectedNumberChar ( ch , \" Exponent indicator not followed by a digit \" ) ; } } - - ptr ; / / need to push back following separator _inputPtr = ptr ; if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( ch ) ; } int len = ptr - startPtr ; _textBuffer . resetWithShared ( _inputBuffer , startPtr , len ) ; return reset ( negative , intLen , fractLen , expLen ) ; } while ( false ) ;  _inputPtr = negative ? ( startPtr + 1 ) : startPtr ; return _parseNumber2 ( negative ) ; } private JsonToken _parserNumber2 ( char [ ] outBuf , int outPtr , boolean negative , int intPartLength ) throws IOException , JsonParseException _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( _inputBuffer [ _inputPtr + + ] & 0xFF ) ; } / / And there we have it ! return resetInt ( negative , intPartLength ) ; } private JsonToken _parseFloat ( char [ ] outBuf , int outPtr , int c , boolean negative , int integerPartLength ) throws IOException , JsonParseException if ( ! eof ) { / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } } _textBuffer . setCurrentLength ( outPtr ) ; / / And there we have it ! return resetFloat ( negative , integerPartLength , fractLen , expLen ) ; } private final void _verifyRootSpace ( int ch ) throws IOException { + + _inputPtr ; switch ( ch ) { case ' ' : case ' \\ t ' : return ; case ' \\ r ' : _skipCR ( ) ; return ; case ' \\ n ' : + + _currInputRow ; _currInputRowStart = _inputPtr ; return ; } _reportMissingRootWS ( ch ) ; } private int _skipWSOrEnd ( ) throws IOException { final int [ ] codes = _icWS ; while ( ( _inputPtr < _inputEnd ) | | loadMore ( ) ) { final int i = _inputBuffer [ _inputPtr + + ] & 0xFF ; switch ( codes [ i ] ) { case 0 : / / done ! return i ; case 1 : / / skip continue ; case 2 : / / 2 - byte UTF _skipUtf8_2 ( i ) ; break ; case 3 : / / 3 - byte UTF _skipUtf8_3 ( i ) ; break ; case 4 : / / 4 - byte UTF _skipUtf8_4 ( i ) ; break ; case INT_LF : + + _currInputRow ; _currInputRowStart = _inputPtr ; break ; case INT_CR : _skipCR ( ) ; break ; case ' / ' : _skipComment ( ) ; break ; case ' # ' : if ( ! _skipYAMLComment ( ) ) { return i ; } break ; default : / / e . g . - 1 _reportInvalidChar ( i ) ; } } _handleEOF ( ) ; return - 1 ; } protected JsonToken _parseNumber ( int c ) throws IOException , JsonParseException { _textBuffer . setCurrentLength ( outPtr ) ; / / As per # 105 , need separating space between root values ; check here if ( _parsingContext . inRoot ( ) ) { _verifyRootSpace ( c ) ; } / / And there we have it ! return resetInt ( negative , intLen ) ;", "label": 1}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 1}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "fixed_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1}
{"buggy_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; }", "fixed_code": "if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_IS_GETTERS ) ) { vchecker = vchecker . withIsGetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_FIELDS ) ) { vchecker = vchecker . withFieldVisibility ( Visibility . NONE ) ; }", "label": 1}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1}
{"buggy_code": "Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; Object spiedInstance = settings . getSpiedInstance ( ) ;", "fixed_code": "Class < ? > [ ] interfaces = settings . getExtraInterfaces ( ) ; Class < ? > [ ] ancillaryTypes ; if ( settings . isSerializable ( ) ) { ancillaryTypes = interfaces = = null ? new Class < ? > [ ] { Serializable . class } : new ArrayUtils ( ) . concat ( interfaces , Serializable . class ) ; } else { ancillaryTypes = interfaces = = null ? new Class < ? > [ 0 ] : interfaces ; } Object spiedInstance = settings . getSpiedInstance ( ) ;", "label": 1}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 1}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default : / / Should never happen .", "label": 1}
{"buggy_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { super . close ( ) ; this . closed = true ; }", "fixed_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; super . close ( ) ; this . closed = true ; }", "label": 1}
{"buggy_code": "public class test { final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; if ( inputCharset = = Charsets . UTF_8 ) { options . outputCharset = Charsets . US_ASCII ; } else { options . outputCharset = inputCharset ; } boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; } private String toSource ( Node n , SourceMap sourceMap ) { builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private String getOutputCharset ( ) throws FlagUsageException { if ( ! config . charset . isEmpty ( ) ) { if ( ! Charset . isSupported ( config . charset ) ) { throw new FlagUsageException ( config . charset + \" is not a valid charset name . \" ) ; } return config . charset ; } return \" US - ASCII \" ; } final protected void setRunOptions ( CompilerOptions options ) throws FlagUsageException , IOException { DiagnosticGroups diagnosticGroups = getDiagnosticGroups ( ) ; options . setCodingConvention ( config . codingConvention ) ; options . setSummaryDetailLevel ( config . summaryDetailLevel ) ; options . outputCharset = getOutputCharset ( ) ; inputCharset = getInputCharset ( ) ; if ( config . jsOutputFile . length ( ) > 0 ) { Result result ; setRunOptions ( options ) ; boolean writeOutputToFile = ! options . jsOutputFile . isEmpty ( ) ; if ( writeOutputToFile ) { } options . closurePass = flags . process_closure_primitives ; return options ; } private String toSource ( Node n , SourceMap sourceMap ) { builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; Charset charset = options . outputCharset ! = null ? Charset . forName ( options . outputCharset ) : null ; builder . setOutputCharset ( charset ) ; return builder . build ( ) ; } public void setOutputCharset ( String charsetName ) { this . outputCharset = charsetName ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "fixed_code": "return new OngoingInjecter ( ) { public boolean thenInject ( ) { try { if ( ! new BeanPropertySetter ( fieldInstance , field ) . set ( matchingMock ) ) { new FieldSetter ( fieldInstance , field ) . set ( matchingMock ) ; } } catch ( Exception e ) { throw new MockitoException ( \" Problems injecting dependency in \" + field . getName ( ) , e ) ; }", "label": 1}
{"buggy_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "fixed_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; if ( implicitProto = = null ) { / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = ImmutableSet . of ( ) ; } else { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; } for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "label": 1}
{"buggy_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "label": 1}
{"buggy_code": "public class test { public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( currBytes + numToWrite ) > currSize ) { throw new IOException ( \" request to write ' \" + numToWrite numToWrite - = num ; wOffset + = num ; } count ( numToWrite ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public long getBytesWritten ( ) { return ( ( CountingOutputStream ) out ) . getBytesWritten ( ) ; } public void write ( byte [ ] wBuf , int wOffset , int numToWrite ) throws IOException { if ( ( currBytes + numToWrite ) > currSize ) { throw new IOException ( \" request to write ' \" + numToWrite numToWrite - = num ; wOffset + = num ; } } public int getCount ( ) { return ( int ) getBytesWritten ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : return _unknownType ( ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name ) ; if ( actualType ! = null ) { return actualType ; }", "fixed_code": "/ / 19 - Mar - 2015 : Without context , all we can check are bounds . if ( context = = null ) { / / And to prevent infinite loops , now need this : context = new TypeBindings ( this , ( Class < ? > ) null ) ; } else { / / Ok : here ' s where context might come in handy ! JavaType actualType = context . findType ( name , false ) ; if ( actualType ! = null ) { return actualType ; }", "label": 1}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1}
{"buggy_code": "public class test { public Elements siblingElements ( ) {  return parent ( ) . children ( ) ; } public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Element previousElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ;", "fixed_code": "public class test { public Element nextElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Elements siblingElements ( ) { if ( parentNode = = null ) return new Elements ( 0 ) ;  List < Element > elements = parent ( ) . children ( ) ; Elements siblings = new Elements ( elements . size ( ) - 1 ) ; for ( Element el : elements ) if ( el ! = this ) siblings . add ( el ) ; return siblings ; } public Element previousElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ;", "label": 1}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1}
{"buggy_code": "while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of prop . removeNonVisible ( inferMutators ) ; } } public void removeNonVisible ( boolean inferMutators ) {", "fixed_code": "while ( it . hasNext ( ) ) { POJOPropertyBuilder prop = it . next ( ) ; / / 26 - Jan - 2017 , tatu : [ databind # 935 ] : need to denote removal of Access acc = prop . removeNonVisible ( inferMutators ) ; if ( ! _forSerialization & & ( acc = = Access . READ_ONLY ) ) { _collectIgnorals ( prop . getName ( ) ) ; } } } public JsonProperty . Access removeNonVisible ( boolean inferMutators ) {", "label": 1}
{"buggy_code": "public class test { public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ; FastMath . sin ( imaginary2 ) / d ) ; } public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ;", "fixed_code": "public class test { public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ; FastMath . sin ( imaginary2 ) / d ) ; } public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ;", "label": 1}
{"buggy_code": "public class test { public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ;", "label": 1}
{"buggy_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findRootDeserializer ( ctxt , JSON_NODE_TYPE ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { jp . clearCurrentToken ( ) ; return result ; } } \\ No newline at end of file", "fixed_code": "result = NullNode . instance ; } else { DeserializationContext ctxt = createDeserializationContext ( jp , _config ) ; JsonDeserializer < Object > deser = _findTreeDeserializer ( ctxt ) ; if ( _unwrapRoot ) { result = ( JsonNode ) _unwrapAndDeserialize ( jp , ctxt , JSON_NODE_TYPE , deser ) ; } else { jp . clearCurrentToken ( ) ; return result ; } protected JsonDeserializer < Object > _findTreeDeserializer ( DeserializationContext ctxt ) throws JsonMappingException { JsonDeserializer < Object > deser = _rootDeserializers . get ( JSON_NODE_TYPE ) ; if ( deser = = null ) { deser = ctxt . findRootValueDeserializer ( JSON_NODE_TYPE ) ; if ( deser = = null ) { / / can this happen ? throw new JsonMappingException ( \" Can not find a deserializer for type \" + JSON_NODE_TYPE ) ; } _rootDeserializers . put ( JSON_NODE_TYPE , deser ) ; } return deser ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Iterator iterate ( EvalContext context ) { Object result = compute ( context ) ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } return ValueUtils . iterate ( result ) ; } public Iterator iteratePointers ( EvalContext context ) { Object result = compute ( context ) ; if ( result = = null ) { if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Iterator iteratePointers ( EvalContext context ) { Object result = compute ( context ) ; if ( result = = null ) { if ( result instanceof EvalContext ) { return ( EvalContext ) result ; } if ( result instanceof NodeSet ) { return new PointerIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; } return new PointerIterator ( ValueUtils . iterate ( result ) , new QName ( null , \" value \" ) , context . getRootContext ( ) . getCurrentNodePointer ( ) . getLocale ( ) ) ; } public Iterator iterate ( EvalContext context ) { Object result = compute ( context ) ; if ( result instanceof EvalContext ) { return new ValueIterator ( ( EvalContext ) result ) ; } if ( result instanceof NodeSet ) { return new ValueIterator ( ( ( NodeSet ) result ) . getPointers ( ) . iterator ( ) ) ; } return ValueUtils . iterate ( result ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . findImplicitParamName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "fixed_code": "/ / 25 - May - 2018 , tatu : as per [ databind # 2051 ] , looks like we have to get / / not implicit name , but name with possible strategy - based - rename / / paramName = candidate . findImplicitParamName ( 0 ) ; paramName = candidate . paramName ( 0 ) ; useProps = ( paramName ! = null ) & & paramDef . couldSerialize ( ) ; } if ( useProps ) {", "label": 1}
{"buggy_code": "return ; } attachLiteralTypes ( n ) ; switch ( n . getType ( ) ) { case Token . FUNCTION : if ( parent . getType ( ) = = Token . NAME ) { return ; } defineDeclaredFunction ( n , parent ) ; break ; case Token . CATCH : defineCatch ( n , parent ) ; break ; case Token . VAR : defineVar ( n , parent ) ; break ; } } } \\ No newline at end of file", "fixed_code": "return ; } super . visit ( t , n , parent ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return cs1 . length ( ) = = cs2 . length ( ) & & CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , cs1 . length ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1}
{"buggy_code": "public class test { public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { return new BigDecimal ( buffer , offset , len ) ; } public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { return new BigDecimal ( numStr ) ; } public BigDecimal contentsAsDecimal ( ) throws NumberFormatException return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( _inputStart > = 0 ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( _segmentSize = = 0 ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "fixed_code": "public class test { private static NumberFormatException _badBigDecimal ( String str ) { return new NumberFormatException ( \" Value \\ \" \" + str + \" \\ \" can not be represented as BigDecimal \" ) ; } public static BigDecimal parseBigDecimal ( String numStr ) throws NumberFormatException { try { return new BigDecimal ( numStr ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( numStr ) ; } } public static BigDecimal parseBigDecimal ( char [ ] buffer , int offset , int len ) throws NumberFormatException { try { return new BigDecimal ( buffer , offset , len ) ; } catch ( NumberFormatException e ) { throw _badBigDecimal ( new String ( buffer , offset , len ) ) ; } } public BigDecimal contentsAsDecimal ( ) throws NumberFormatException return NumberInput . parseBigDecimal ( _resultArray ) ; } / / Or a shared buffer ? if ( ( _inputStart > = 0 ) & & ( _inputBuffer ! = null ) ) { return NumberInput . parseBigDecimal ( _inputBuffer , _inputStart , _inputLen ) ; } / / Or if not , just a single buffer ( the usual case ) if ( ( _segmentSize = = 0 ) & & ( _currentSegment ! = null ) ) { return NumberInput . parseBigDecimal ( _currentSegment , 0 , _currentSize ) ; } / / If not , let ' s just get it aggregated . . .", "label": 1}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS", "label": 1}
{"buggy_code": "public class test { public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong = = Long . MAX_VALUE ) { return ; } int value = ( int ) valueLong ; if ( iFieldType > = SECONDS_MILLIS ) { value = ( int ) ( valueLong / DateTimeConstants . MILLIS_PER_SECOND ) ; }  if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; } else { FormatUtils . appendPaddedInteger ( buf , value , minDigits ) ; } if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; } } if ( iSuffix ! = null ) { iSuffix . printTo ( buf , value ) ; } } public int calculatePrintedLength ( ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong = = Long . MAX_VALUE ) { if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & return sum ; } } \\ No newline at end of file", "fixed_code": "public class test { public int calculatePrintedLength ( ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong = = Long . MAX_VALUE ) { if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & return sum ; } public void printTo ( StringBuffer buf , ReadablePeriod period , Locale locale ) { long valueLong = getFieldValue ( period ) ; if ( valueLong = = Long . MAX_VALUE ) { return ; } int value = ( int ) valueLong ; if ( iFieldType > = SECONDS_MILLIS ) { value = ( int ) ( valueLong / DateTimeConstants . MILLIS_PER_SECOND ) ; }  if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; } else { FormatUtils . appendPaddedInteger ( buf , value , minDigits ) ; } if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; } } if ( iSuffix ! = null ) { iSuffix . printTo ( buf , value ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { return _createEnumKeyDeserializer ( ctxt , type ) ; } deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } / / and then post - processing if ( deser ! = null ) {", "fixed_code": "/ / the only non - standard thing is this : if ( deser = = null ) { if ( type . isEnumType ( ) ) { deser = _createEnumKeyDeserializer ( ctxt , type ) ; } else { deser = StdKeyDeserializers . findStringBasedKeyDeserializer ( config , type ) ; } } / / and then post - processing if ( deser ! = null ) {", "label": 1}
{"buggy_code": "public class test { public static Number createNumber ( final String str ) throws NumberFormatException { if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ;", "fixed_code": "public class test { public static Number createNumber ( final String str ) throws NumberFormatException { if ( str = = null ) { return createLong ( str ) ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ;", "label": 1}
{"buggy_code": "if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : return ToStringSerializer . instance ; default : }", "fixed_code": "if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return NumberSerializer . bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "label": 1}
{"buggy_code": "public class test { private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; } } \\ No newline at end of file", "fixed_code": "public class test { private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : % s \" , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { return true ; } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "fixed_code": "return result ; } } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ; / / So , of all single - arg static methods : for ( AnnotatedMethod am : _classInfo . getStaticMethods ( ) ) { / / 24 - Oct - 2016 , tatu : Better ensure it only takes 1 arg , no matter what if ( isFactoryMethod ( am ) & & am . getParameterCount ( ) = = 1 ) { / / And must take one of expected arg types ( or supertype ) Class < ? > actualArgType = am . getRawParameterType ( 0 ) ; for ( Class < ? > expArgType : expArgTypes ) { final String name = am . getName ( ) ; / / 24 - Oct - 2016 , tatu : As per [ databind # 1429 ] must ensure takes exactly one arg if ( \" valueOf \" . equals ( name ) ) { if ( am . getParameterCount ( ) = = 1 ) { return true ; } } / / [ databind # 208 ] Also accept \" fromString ( ) \" , if takes String or CharSequence if ( \" fromString \" . equals ( name ) ) {", "label": 1}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! ( hasDecPoint ) & & ( ! hasExp ) ; } / / last character is illegal return false ;", "label": 1}
{"buggy_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; / / some charsets can read but not encode ; switch to an encodable charset and update the meta el } input . close ( ) ; return doc ;", "fixed_code": "} Charset charset = Charset . forName ( charsetName ) ; doc . outputSettings ( ) . charset ( charset ) ; if ( ! charset . canEncode ( ) ) { / / some charsets can read but not encode ; switch to an encodable charset and update the meta el doc . charset ( Charset . forName ( defaultCharset ) ) ; } } input . close ( ) ; return doc ;", "label": 1}
{"buggy_code": "public class test { public void removeNonVisible ( boolean inferMutators ) {", "fixed_code": "public class test { public JsonProperty . Access removeNonVisible ( boolean inferMutators ) {", "label": 1}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1}
{"buggy_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } } } } n = n . getParent ( ) ; } } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : / / With a AND / OR the first branch always runs , but the second is / / may not . case Token . HOOK : return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } } return VariableLiveness . MAYBE_LIVE ;", "fixed_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . if ( n . getNext ( ) ! = null ) { state = isVariableReadBeforeKill ( n . getNext ( ) , variable ) ; if ( state = = VariableLiveness . KILL ) { state = VariableLiveness . MAYBE_LIVE ; } } break ; case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { state = checkHookBranchReadBeforeKill ( n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; } break ; default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { break ; } } } / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } n = n . getParent ( ) ; } } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION return VariableLiveness . MAYBE_LIVE ; } if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : VariableLiveness v1 = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; VariableLiveness v2 = isVariableReadBeforeKill ( n . getLastChild ( ) , variable ) ; / / With a AND / OR the first branch always runs , but the second is / / may not . if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { return v1 ; } else if ( v2 = = VariableLiveness . READ ) { return VariableLiveness . READ ; } else { return VariableLiveness . MAYBE_LIVE ; } case Token . HOOK : VariableLiveness first = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; if ( first ! = VariableLiveness . MAYBE_LIVE ) { return first ; } return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } return VariableLiveness . MAYBE_LIVE ;", "label": 1}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new CreatorProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new CreatorProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1}
{"buggy_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent } if ( _needRehash ) { rehash ( ) ;", "fixed_code": "_hashShared = false ; / / 09 - Sep - 2015 , tatu : As per [ jackson - core # 216 ] , also need to ensure / / we rehash as needed , as need - rehash flag is not copied from parent _verifyNeedForRehash ( ) ; } if ( _needRehash ) { rehash ( ) ;", "label": 1}
{"buggy_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { return null ; } int off = WORD ;", "fixed_code": "if ( sig . equals ( ZipLong . CFH_SIG ) | | sig . equals ( ZipLong . AED_SIG ) ) { hitCentralDirectory = true ; skipRemainderOfArchive ( ) ; return null ; } if ( ! sig . equals ( ZipLong . LFH_SIG ) ) { throw new ZipException ( String . format ( \" Unexpected record signature : 0X % X \" , sig . getValue ( ) ) ) ; } int off = WORD ;", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ( T ) ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "label": 1}
{"buggy_code": "Node param = condition . getLastChild ( ) ; if ( callee . getType ( ) = = GETPROP & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; if ( paramType ! = null ) { Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ; if ( left . getType ( ) = = NAME & & \" goog \" . equals ( left . getString ( ) ) & & if ( restricter ! = null ) { return restrictParameter ( param , paramType , blindScope , restricter , outcome ) ; } } } } return scope ; } else { StaticSlot < JSType > var = scope . getSlot ( varName ) ; if ( var ! = null & & ! ( var . isTypeInferred ( ) & & unflowableVarNames . contains ( varName ) ) ) { / / There are two situations where we don ' t want to use type information / / from the scope , even if we have it . / / 1 ) The var is escaped in a weird way , e . g . , / / function f ( ) { var x = 3 ; function g ( ) { x = null } ( x ) ; } / / 2 ) We ' re reading type information from another scope for an / / inferred variable . / / var t = null ; function f ( ) { ( t ) ; } type = var . getType ( ) ; if ( type = = null ) { type = getNativeType ( UNKNOWN_TYPE ) ; } } }", "fixed_code": "Node param = condition . getLastChild ( ) ; if ( callee . getType ( ) = = GETPROP & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ; if ( left . getType ( ) = = NAME & & \" goog \" . equals ( left . getString ( ) ) & & if ( restricter ! = null ) { return restrictParameter ( param , paramType , blindScope , restricter , outcome ) ; } } } return scope ; } else { StaticSlot < JSType > var = scope . getSlot ( varName ) ; if ( var ! = null ) { / / There are two situations where we don ' t want to use type information / / from the scope , even if we have it . / / 1 ) The var is escaped in a weird way , e . g . , / / function f ( ) { var x = 3 ; function g ( ) { x = null } ( x ) ; } boolean isInferred = var . isTypeInferred ( ) ; boolean unflowable = isInferred & & unflowableVarNames . contains ( varName ) ; / / 2 ) We ' re reading type information from another scope for an / / inferred variable . / / var t = null ; function f ( ) { ( t ) ; } boolean nonLocalInferredSlot = isInferred & & syntacticScope . getParent ( ) ! = null & & var = = syntacticScope . getParent ( ) . getSlot ( varName ) ; if ( ! unflowable & & ! nonLocalInferredSlot ) { type = var . getType ( ) ; if ( type = = null ) { type = getNativeType ( UNKNOWN_TYPE ) ; } } } }", "label": 1}
{"buggy_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( token ) ; } } } \\ No newline at end of file", "fixed_code": "if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; }  tokens . add ( token ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } return getValueAsString ( null ) ; } public String getValueAsString ( String defaultValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } return getText ( ) ; } public final String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } public final String getValueAsString ( String defValue ) throws IOException { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; } public String getValueAsString ( String defValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( defValue ) ; } public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } return super . getValueAsString ( null ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getValueAsString ( String defaultValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } if ( _currToken = = null | | _currToken = = JsonToken . VALUE_NULL | | ! _currToken . isScalarValue ( ) ) { return defaultValue ; } return getText ( ) ; } public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { return getText ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return getValueAsString ( null ) ; } public final String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } public final String getValueAsString ( String defValue ) throws IOException { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; } public String getValueAsString ( ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( null ) ; } public String getValueAsString ( String defValue ) throws IOException { if ( _currToken = = JsonToken . VALUE_STRING ) { if ( _tokenIncomplete ) { } return _textBuffer . contentsAsString ( ) ; } if ( _currToken = = JsonToken . FIELD_NAME ) { return getCurrentName ( ) ; } return super . getValueAsString ( defValue ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return new ZCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { throw new CompressorException ( \" No Compressor found for the stream signature . \" ) ; } } \\ No newline at end of file", "fixed_code": "return new ZCompressorInputStream ( in ) ; } if ( DeflateCompressorInputStream . matches ( signature , signatureLength ) ) { return new DeflateCompressorInputStream ( in ) ; } if ( XZUtils . matches ( signature , signatureLength ) & & XZUtils . isXZCompressionAvailable ( ) ) { throw new CompressorException ( \" No Compressor found for the stream signature . \" ) ; } public static boolean matches ( byte [ ] signature , int length ) { return length > 3 & & signature [ 0 ] = = MAGIC_1 & & ( signature [ 1 ] = = ( byte ) MAGIC_2a | | signature [ 1 ] = = ( byte ) MAGIC_2b | | signature [ 1 ] = = ( byte ) MAGIC_2c | | signature [ 1 ] = = ( byte ) MAGIC_2d ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; return attributes . hasKey ( attributeKey ) ; } } \\ No newline at end of file", "fixed_code": "public boolean hasAttr ( String attributeKey ) { Validate . notNull ( attributeKey ) ; if ( attributeKey . toLowerCase ( ) . startsWith ( \" abs : \" ) ) { String key = attributeKey . substring ( \" abs : \" . length ( ) ) ; if ( attributes . hasKey ( key ) & & ! absUrl ( key ) . equals ( \" \" ) ) return true ; } return attributes . hasKey ( attributeKey ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { boolean canContain ( Tag child ) { Validate . notNull ( child ) ; return false ; / / don ' t allow children to contain their parent ( directly ) return true ; } } \\ No newline at end of file", "fixed_code": "public class test { boolean isValidAncestor ( Tag child ) { if ( child . ancestors . isEmpty ( ) ) return true ; / / HTML tag  for ( Tag tag : child . ancestors ) { if ( this . equals ( tag ) ) return true ; } return false ; } boolean canContain ( Tag child ) { Validate . notNull ( child ) ; return false ; / / don ' t allow children to contain their parent ( directly ) if ( this . requiresSpecificParent ( ) & & this . getImplicitParent ( ) . equals ( child ) ) return false ; return true ; } boolean isValidParent ( Tag child ) { return this . equals ( child . parent ) ; } private Tag setParent ( String tagName ) { parent = Tag . valueOf ( tagName ) ; setAncestor ( tagName ) ; return this ; } boolean requiresSpecificParent ( ) { return this . parent ! = null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; Node finallyStmt = finallyBlock . getFirstChild ( ) ; } }", "label": 1}
{"buggy_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; if ( ! ( nodeTest instanceof NodeNameTest ) ) { return false ; } QName name = ( ( NodeNameTest ) nodeTest ) . getNodeName ( ) ; iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( name ) ; } if ( iterator = = null ) { return false ;", "fixed_code": "super . setPosition ( getCurrentPosition ( ) + 1 ) ; if ( ! setStarted ) { setStarted = true ; NodeNameTest nodeNameTest = null ; if ( nodeTest instanceof NodeTypeTest ) { if ( ( ( NodeTypeTest ) nodeTest ) . getNodeType ( ) = = Compiler . NODE_TYPE_NODE ) { nodeNameTest = WILDCARD_TEST ; } } else if ( nodeTest instanceof NodeNameTest ) { nodeNameTest = ( NodeNameTest ) nodeTest ; } if ( nodeNameTest = = null ) { return false ; } iterator = parentContext . getCurrentNodePointer ( ) . attributeIterator ( nodeNameTest . getNodeName ( ) ) ; } if ( iterator = = null ) { return false ;", "label": 1}
{"buggy_code": "public class test { public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1}
{"buggy_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "fixed_code": "if ( name . length ( ) = = 0 ) continue ; String type = el . attr ( \" type \" ) ; if ( type . equalsIgnoreCase ( \" button \" ) ) continue ; / / browsers don ' t submit these if ( \" select \" . equals ( el . normalName ( ) ) ) { Elements options = el . select ( \" option [ selected ] \" ) ;", "label": 1}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( v > 0 ) { v = - v ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 1}
{"buggy_code": "public class test { static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } } \\ No newline at end of file", "fixed_code": "public class test { static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; return out ; } } \\ No newline at end of file", "fixed_code": "last = c ; } while ( depth > 0 ) ; final String out = ( end > = 0 ) ? queue . substring ( start , end ) : \" \" ; if ( depth > 0 ) { / / ran out of queue before seeing enough ) Validate . fail ( \" Did not find balanced maker at \" + out ) ; } return out ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . getRemainingRegion ( ) . checkPoint ( line2 . toSubSpace ( v2D ) ) ;", "fixed_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line if ( v2D = = null ) { return null ; } Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . getRemainingRegion ( ) . checkPoint ( line2 . toSubSpace ( v2D ) ) ;", "label": 1}
{"buggy_code": "ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" + t . getMessage ( ) , t ) ; } } } \\ No newline at end of file", "fixed_code": "ClassUtil . throwIfRTE ( t ) ; throw new IllegalArgumentException ( \" Failed to instantiate bean of type \" _classInfo . getAnnotated ( ) . getName ( ) + \" : ( \" + t . getClass ( ) . getName ( ) + \" ) \" + ClassUtil . exceptionMessage ( t ) , t ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1}
{"buggy_code": "return null ; } / / For checks like [ databind # 1599 ] / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } } \\ No newline at end of file", "fixed_code": "return null ; } / / For checks like [ databind # 1599 ] checkIllegalTypes ( ctxt , type , beanDesc ) ; / / Use generic bean introspection to build deserializer return buildBeanDeserializer ( ctxt , type , beanDesc ) ; } protected void checkIllegalTypes ( DeserializationContext ctxt , JavaType type , BeanDescription beanDesc ) throws JsonMappingException { String full = type . getRawClass ( ) . getName ( ) ;  if ( _cfgIllegalClassNames . contains ( full ) ) { ctxt . reportBadTypeDefinition ( beanDesc , \" Illegal type ( % s ) to deserialize : prevented for security reasons \" , full ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double r = FastMath . sqrt ( 2 ) / 2 ; } }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + 4 ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0}
{"buggy_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } / / prepare handling of the remaining part of the step previousT = eventT ;", "fixed_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } if ( ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) ) ! = ( eventY . length ) ) { return eventT ; } } / / prepare handling of the remaining part of the step previousT = eventT ;", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0}
{"buggy_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "fixed_code": "if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { if ( state . evaluateStep ( interpolator ) ) { if ( first = = null ) { first = state ; } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) { first = state ; } } else { if ( state . getEventTime ( ) > first . getEventTime ( ) ) { first = state ; } } } } } else { if ( interpolator . isForward ( ) ) { if ( state . getEventTime ( ) < first . getEventTime ( ) ) {", "label": 0}
{"buggy_code": "public RealMatrix computeCorrelationMatrix ( RealMatrix matrix ) { int nVars = matrix . getColumnDimension ( ) ; RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ; }", "fixed_code": "public RealMatrix computeCorrelationMatrix ( RealMatrix matrix ) { int nVars = matrix . getColumnDimension ( ) ; RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } } return outMatrix ; }", "label": 0}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ; } else { return 0 ;", "label": 0}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0}
{"buggy_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "label": 0}
{"buggy_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) & & x < y ) | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "double var = Double . NaN ; if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } } return var ;", "fixed_code": "double var = Double . NaN ; if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } } } return var ;", "label": 0}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getPlus ( ) . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; g + = 0 . 333 * ( 1 - g ) ; return true ; } return false ;", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } this . splitState = STATE_SPLIT ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . getFirstChild ( ) ! = null ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( u > 0 ) { u = - u ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1", "label": 0}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . this . epsilon = = org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE ) { entries . remove ( index ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row ! = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0}
{"buggy_code": "Node nameNode = Node . newString ( Token . NAME , propAlias ) ; Node newVar = new Node ( Token . VAR , nameNode ) . copyInformationFromForTree ( addAfter ) ; parent . addChildAfter ( newVar , addAfter ) ; addAfter = newVar ; numStubs + + ; compiler . reportCodeChange ( ) ;", "fixed_code": "Node nameNode = Node . newString ( Token . NAME , propAlias ) ; Node newVar = new Node ( Token . VAR , nameNode ) . copyInformationFromForTree ( addAfter ) ; newVar . addChildAfter ( newVar , addAfter ) ; addAfter = newVar ; numStubs + + ; compiler . reportCodeChange ( ) ;", "label": 0}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "fixed_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getDateInstance ( style , null , null ) ; } } \\ No newline at end of file", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static FastDateFormat getDateInstance ( int style ) { return getInstance ( getDefaultPattern ( ) , null , null ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1d ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "} / / Add the property to the record . if ( builder . addProperty ( fieldName , fieldType , fieldNameNode ) = = null ) { / / Duplicate field name , warning and skip reporter . warning ( n . getLineno ( ) , fieldNameNode . getCharno ( ) ) ; } } return builder . build ( ) ; }", "fixed_code": "} / / Add the property to the record . if ( ( fieldName . length ( ) ) ! = ( 5 ) ) { if ( builder . addProperty ( fieldName , fieldType , fieldNameNode ) = = null ) { / / Duplicate field name , warning and skip reporter . warning ( n . getLineno ( ) , fieldNameNode . getCharno ( ) ) ; } } } return builder . build ( ) ; }", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 + 1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"buggy_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "fixed_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "label": 0}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0}
{"buggy_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "fixed_code": "xNorm = Math . sqrt ( xNorm ) ; } else { / / failed iteration , reset the previous values if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } cost = previousCost ; for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ;", "label": 0}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0}
{"buggy_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } } }", "fixed_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } } }", "label": 0}
{"buggy_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . add ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . addWrapPartial ( this , index , newValues , amount ) ; return new MonthDay ( this , newValues ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | str . isEmpty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; }", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return x / 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; buffer = new char [ CAPACITY ] ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0}
{"buggy_code": "public class test { public boolean equals ( Object obj ) {  if ( obj = = this ) { return true ; } if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ;  } } \\ No newline at end of file", "fixed_code": "public class test { public boolean equals ( Object o ) { return false ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . SIDE_EFFECT_FLAGS ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0}
{"buggy_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMinimumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0}
{"buggy_code": "token = next ( ) ; typeNode = parseAndRecordTypeNode ( token ) ; if ( annotation = = Annotation . THIS ) { typeNode = wrapNode ( Token . BANG , typeNode ) ; } type = createJSTypeExpression ( typeNode ) ;", "fixed_code": "token = next ( ) ; typeNode = parseAndRecordTypeNode ( token ) ; canSkipTypeAnnotation & = ! hasType ; if ( annotation = = Annotation . THIS ) { typeNode = wrapNode ( Token . BANG , typeNode ) ; } type = createJSTypeExpression ( typeNode ) ;", "label": 0}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { return createBigDecimal ( str ) ; } else { mant = str ; }", "label": 0}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0}
{"buggy_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . withUTC ( ) . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 0}
{"buggy_code": "} if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "} if ( parent . isAssign ( ) ) { } } parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; pingPong = 1 - pingPong ; return true ; } return false ;", "label": 0}
{"buggy_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 0}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0}
{"buggy_code": "public class test { public void setShape ( int index , Shape shape ) { set ( index , shape ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else {", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else {", "label": 0}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "label": 0}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { double h = FastMath . sqrt ( 3 . 0 ) / 2 . 0 ; } }", "label": 0}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( error ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0}
{"buggy_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "fixed_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( false ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0}
{"buggy_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "fixed_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . toDegrees ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "label": 0}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( epsilon ) ) { entries . put ( key , value ) ; } }", "label": 0}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; } }", "label": 0}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; return newdiff ; } else { return 0 ;", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { throw new IllegalArgumentException ( \" The string must not be null \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 0}
{"buggy_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = 4 ; }", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) { for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int outIndex = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( data = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0}
{"buggy_code": "public class test { public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } private static Object remove ( Object array , int index ) { int length = getLength ( array ) ; if ( index < 0 | | index > = length ) { throw new IndexOutOfBoundsException ( \" Index : \" + index + \" , Length : \" + length ) ; }  Object result = Array . newInstance ( array . getClass ( ) . getComponentType ( ) , length - 1 ) ; System . arraycopy ( array , 0 , result , 0 , index ) ; if ( index < length - 1 ) { System . arraycopy ( array , index + 1 , result , index , length - index - 1 ) ; }  return result ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ;", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ;", "label": 0}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; } }", "label": 0}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0}
{"buggy_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static float max ( final float a , final float b ) { return a < = b ? b : Float . isNaN ( ( a + b ) ) ? Float . NaN : a ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }   return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , initial ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 1 . 0 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { if ( com . google . javascript . jscomp . CheckSideEffects . PROTECTOR_FN . length ( ) = = 0 ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; else break ; } } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; }", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; }", "label": 0}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "label": 0}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "fixed_code": "existing . setY ( y ) ; } else { if ( isEmpty ( ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . .", "label": 0}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CMAESOptimizer ( int lambda ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_MAXITERATIONS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 1 ] = w [ 0 ] ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p < 0 | | p > 1 ) { throw new OutOfRangeException ( p , 0 , 1 ) ; } } }", "label": 0}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0}
{"buggy_code": "x ) ; } infinite = true ; for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { p2 = p1 / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * q0 ) ; } else if ( b ! = 0 ) { p2 = ( a / scaleFactor * p1 ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + q0 / lastScaleFactor ; } infinite = Double . isInfinite ( p2 ) | | Double . isInfinite ( q2 ) ; if ( ! infinite ) { break ; } } } if ( infinite ) { double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "x ) ; } infinite = true ; continue ; } if ( infinite ) { double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { return 0 . 0 ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "label": 0}
{"buggy_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "fixed_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "label": 0}
{"buggy_code": "public class test { public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "public class test { public void stop ( ) { notifyRefreshFiles ( null ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { org . jfree . data . xy . XYSeries . this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState = = 1 ) = = false ) { return ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private void doPercentTypedAccounting ( NodeTraversal t , Node n ) { JSType type = n . getJSType ( ) ; if ( type = = null ) { nullCount + + ; } else if ( type . isUnknownType ( ) ) { if ( reportUnknownTypes . isOn ( ) ) { compiler . report (", "fixed_code": "private void doPercentTypedAccounting ( NodeTraversal t , Node n ) { JSType type = n . getJSType ( ) ; if ( type = = null ) { if ( com . google . javascript . jscomp . TypeCheck . this . inExterns ) { nullCount + + ; } } else if ( type . isUnknownType ( ) ) { if ( reportUnknownTypes . isOn ( ) ) { compiler . report (", "label": 0}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio & & ratio > = 0 ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { buffer = new char [ CAPACITY ] ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 4 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; if ( ( 2 > = w . length - 1 ) ) { w [ 2 ] = size . width ; } else { w [ 2 + 1 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } } return minRatioPositions . get ( 0 ) ; }", "label": 0}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 0}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } }", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( true ) { assignedToUnknownValue = true ; } }", "label": 0}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) { / / accept the contracted simplex / / check convergence", "label": 0}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0}
{"buggy_code": "break ; case Token . THIS : ensureTyped ( t , n , t . getScope ( ) . getTypeOfThis ( ) ) ; break ; case Token . REF_SPECIAL :", "fixed_code": "break ; case Token . THIS : checkEnumInitializer ( t , n , t . getScope ( ) . getTypeOfThis ( ) ) ; break ; case Token . REF_SPECIAL :", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : return \" GT \" ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "label": 0}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( node2 . type < com . google . javascript . rhino . Node . FUNCTION_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) { / / we cannot do anything on such a small step , don ' t trigger any events", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) { / / we cannot do anything on such a small step , don ' t trigger any events", "label": 0}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "fixed_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "} / / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return getMaximumValue ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ! parent . isCall ( ) ) continue ; int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ;  if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ; } }  logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "fixed_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int eIndex = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; logMu2 = Math . log ( mu + 0 . 5 ) ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 5 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ;", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ;", "label": 0}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; states [ index ] = REMOVED ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "} millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( addTransition ( transitions , next ) ) { if ( tailZone ! = null ) { break ; } / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"buggy_code": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; properties . putAll ( currentProperties ) ; } }", "fixed_code": "= new HashMap < String , ObjectType > ( ) ; for ( ObjectType interfaceType : functionType . getExtendedInterfaces ( ) ) { currentProperties . clear ( ) ; if ( com . google . javascript . jscomp . TypeCheck . this . unknownCount < com . google . javascript . jscomp . TypeCheck . this . typedCount ) { checkInterfaceConflictProperties ( t , n , functionPrivateName , properties , currentProperties , interfaceType ) ; } properties . putAll ( currentProperties ) ; } }", "label": 0}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( n . getFirstChild ( ) , Token . BREAK , null ) ; } }", "label": 0}
{"buggy_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; } public void process ( Node externs , Node root ) { List < Reducer > reducers = ImmutableList . of ( new ReturnConstantReducer ( ) , / / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } / / Compare estimated savings against the helper cost . Apply", "fixed_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return false ; } public void process ( Node externs , Node root ) { List < Reducer > reducers = ImmutableList . of ( new ReturnConstantReducer ( ) , / / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { } / / Compare estimated savings against the helper cost . Apply", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } } return out ;", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRatioPositions = new ArrayList < Integer > ( ) ; minRow = row ; } }", "label": 0}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "label": 0}
{"buggy_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res = = null ) { return res ; } }", "label": 0}
{"buggy_code": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { return objectType . toString ( ) + \" . \" + propName ; } } }", "fixed_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { } } }", "label": 0}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < 3 ) { upper = lower ; }", "label": 0}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0}
{"buggy_code": "public void stepAccepted ( final double t , final double [ ] y ) throws EventException { t0 = t ; g0 = handler . g ( t , y ) ; if ( pendingEvent ) {", "fixed_code": "public void stepAccepted ( final double t , final double [ ] y ) throws EventException { g0 = handler . g ( t , y ) ; if ( pendingEvent ) {", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p - 1 ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return org . jfree . data . time . TimePeriodValues . this . maxStartIndex ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , true ) ) ; } } }", "label": 0}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : ; { if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; } break ; default : out . write ( ch ) ;", "label": 0}
{"buggy_code": "public class test { private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "fixed_code": "public class test { private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; } reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have", "label": 1}
{"buggy_code": "public class test { static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "fixed_code": "public class test { static Type getSupertype ( Type context , Class < ? > contextRawType , Class < ? > supertype ) { if ( context instanceof WildcardType ) { / / wildcards are useless for resolving supertypes . As the upper bound has the same raw type , use it instead context = ( ( WildcardType ) context ) . getUpperBounds ( ) [ 0 ] ; } checkArgument ( supertype . isAssignableFrom ( contextRawType ) ) ; return resolve ( context , contextRawType , $ Gson $ Types . getGenericSupertype ( context , contextRawType , supertype ) ) ;", "label": 1}
{"buggy_code": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; } public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & ! restrictedType . equals ( originalType ) ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseAndOrNotShortCircuiting ( Node left , Node right , FlowScope blindScope , boolean condition ) { / / left type / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , restrictedLeftType , right , rightIsRefineable , restrictedRightType ) ; } return blindScope ; } private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , boolean leftIsRefineable , JSType restrictedLeftType , Node right , boolean rightIsRefineable , JSType restrictedRightType ) { boolean shouldRefineLeft = leftIsRefineable & & restrictedLeftType ! = null ; boolean shouldRefineRight = rightIsRefineable & & restrictedRightType ! = null ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { } return blindScope ; } private FlowScope caseNameOrGetProp ( Node name , FlowScope blindScope , boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { JSType restrictedType = type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ; FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , name , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseEquality ( Node left , Node right , FlowScope blindScope , Function < TypePair , TypePair > merging ) { / / left type if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftIsRefineable , merged . typeA , right , rightIsRefineable , merged . typeB ) ; } return blindScope ; } public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "fixed_code": "public class test { private FlowScope maybeRestrictName ( FlowScope blindScope , Node node , JSType originalType , JSType restrictedType ) { if ( restrictedType ! = null & & restrictedType ! = originalType ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; declareNameInScope ( informed , node , restrictedType ) ; return informed ; } return blindScope ; } private FlowScope caseNameOrGetProp ( Node name , FlowScope blindScope , boolean outcome ) { JSType type = getTypeIfRefinable ( name , blindScope ) ; if ( type ! = null ) { return maybeRestrictName ( blindScope , name , type , type . getRestrictedTypeGivenToBooleanOutcome ( outcome ) ) ; } return blindScope ; } private FlowScope caseAndOrNotShortCircuiting ( Node left , Node right , FlowScope blindScope , boolean condition ) { / / left type / / creating new scope return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? restrictedLeftType : null , right , rightType , rightIsRefineable ? restrictedRightType : null ) ; } return blindScope ; } private FlowScope maybeRestrictTwoNames ( FlowScope blindScope , Node left , JSType originalLeftType , JSType restrictedLeftType , Node right , JSType originalRightType , JSType restrictedRightType ) { boolean shouldRefineLeft = restrictedLeftType ! = null & & restrictedLeftType ! = originalLeftType ; boolean shouldRefineRight = restrictedRightType ! = null & & restrictedRightType ! = originalRightType ; if ( shouldRefineLeft | | shouldRefineRight ) { FlowScope informed = blindScope . createChildFlowScope ( ) ; if ( shouldRefineLeft ) { } return blindScope ; } private FlowScope caseEquality ( Node left , Node right , FlowScope blindScope , Function < TypePair , TypePair > merging ) { / / left type if ( merged ! = null ) { return maybeRestrictTwoNames ( blindScope , left , leftType , leftIsRefineable ? merged . typeA : null , right , rightType , rightIsRefineable ? merged . typeB : null ) ; } return blindScope ; } public JSType getRestrictedTypeGivenToBooleanOutcome ( boolean outcome ) { if ( outcome & & this = = getNativeType ( JSTypeNative . UNKNOWN_TYPE ) ) { return getNativeType ( JSTypeNative . CHECKED_UNKNOWN_TYPE ) ; } BooleanLiteralSet literals = getPossibleToBooleanOutcomes ( ) ; if ( literals . contains ( outcome ) ) {", "label": 1}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "label": 1}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } break ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1}
{"buggy_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = src . _rootNameLookup ; } } \\ No newline at end of file", "fixed_code": "super ( src ) ; / / 21 - May - 2018 , tatu : As per [ dataformat - xml # 282 ] , should NOT really copy / / root name lookup as that may link back to diff version , configuration _rootNameLookup = new XmlRootNameLookup ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { String raw = isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ? value . toPlainString ( ) : value . toString ( ) ; _writeQuotedRaw ( raw ) ; } else if ( isEnabled ( Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { writeRaw ( value . toPlainString ( ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "fixed_code": "if ( value = = null ) { _writeNull ( ) ; } else if ( _cfgNumbersAsStrings ) { _writeQuotedRaw ( _asString ( value ) ) ; } else { writeRaw ( _asString ( value ) ) ; }", "label": 1}
{"buggy_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "fixed_code": "JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { return null ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; JsonParser p2 = _tokens [ index ] . asParser ( p ) ; JsonToken t = p2 . nextToken ( ) ; / / 29 - Sep - 2015 , tatu : As per [ databind # 942 ] , nulls need special support if ( t = = JsonToken . VALUE_NULL ) { _properties [ index ] . getProperty ( ) . set ( bean , null ) ; return ; } TokenBuffer merged = new TokenBuffer ( p ) ; merged . writeStartArray ( ) ; merged . writeString ( typeId ) ;", "label": 1}
{"buggy_code": "return pointer ; } else { if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "return pointer ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } if ( newParent instanceof PropertyOwnerPointer ) { PropertyOwnerPointer pop = ( PropertyOwnerPointer ) newParent ; newParent = pop . getPropertyPointer ( ) ; return newParent . createAttribute ( context , getName ( ) ) ; } else { if ( parent instanceof NullPointer & & parent . equals ( newParent ) ) { throw createBadFactoryException ( context . getFactory ( ) ) ; } / / Consider these two use cases : / / 1 . The parent pointer of NullPropertyPointer is / / a PropertyOwnerPointer other than NullPointer . When we call return newParent . createChild ( context , getName ( ) , getIndex ( ) ) ; } } private JXPathAbstractFactoryException createBadFactoryException ( AbstractFactory factory ) { return new JXPathAbstractFactoryException ( \" Factory \" + factory + \" reported success creating object for path : \" + asPath ( ) + \" but object was null . Terminating to avoid stack recursion . \" ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1}
{"buggy_code": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "fixed_code": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "label": 1}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return true ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ;", "label": 1}
{"buggy_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify / / otherwise only verify if neither explicitly annotated . } / / one more thing : ok to override in sub - class if ( oldOne . getClass ( ) = = newOne . getClass ( ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] / / otherwise , which one to choose ? / / new type more generic , use old / / new type more specific , use it } }", "fixed_code": "AnnotatedWithParams oldOne = _creators [ typeIndex ] ; / / already had an explicitly marked one ? if ( oldOne ! = null ) { boolean verify ; if ( ( _explicitCreators & mask ) ! = 0 ) { / / already had explicitly annotated , leave as - is / / but skip , if new one not annotated return ; } / / both explicit : verify verify = true ; } else { / / otherwise only verify if neither explicitly annotated . verify = ! explicit ; } / / one more thing : ok to override in sub - class if ( verify & & ( oldOne . getClass ( ) = = newOne . getClass ( ) ) ) { / / [ databind # 667 ] : avoid one particular class of bogus problems Class < ? > oldType = oldOne . getRawParameterType ( 0 ) ; Class < ? > newType = newOne . getRawParameterType ( 0 ) ; if ( oldType = = newType ) { throw new IllegalArgumentException ( \" Conflicting \" + TYPE_DESCS [ typeIndex ] \" creators : already had explicitly marked \" + oldOne + \" , encountered \" + newOne ) ; } / / otherwise , which one to choose ? if ( newType . isAssignableFrom ( oldType ) ) { / / new type more generic , use old return ; } / / new type more specific , use it } }", "label": 1}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1}
{"buggy_code": "} / / if the Option has a value if ( option . hasArg ( ) & & ( option . getArgName ( ) ! = null ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "fixed_code": "} / / if the Option has a value if ( option . hasArg ( ) & & option . hasArgName ( ) ) { buff . append ( \" < \" ) . append ( option . getArgName ( ) ) . append ( \" > \" ) ; }", "label": 1}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1}
{"buggy_code": "public class test { public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k } public static int lcm ( int a , int b ) { if ( a = = 0 | | b = = 0 ) { return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "fixed_code": "public class test { public static int lcm ( int a , int b ) { if ( a = = 0 | | b = = 0 ) { return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to } while ( t ! = 0 ) ; return - u * ( 1 < < k ) ; / / gcd is u * 2 ^ k } } \\ No newline at end of file", "label": 1}
{"buggy_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( ' ; ' ) ; return sb ; } } \\ No newline at end of file", "fixed_code": "_classSignature ( _class , sb , false ) ; sb . append ( ' < ' ) ; sb = _referencedType . getGenericSignature ( sb ) ; sb . append ( \" > ; \" ) ; return sb ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "public class test { public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array ! = null ) & & ( classes ! = null ) & & ( array [ i ] ! = null ) ) { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1}
{"buggy_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , java . util . Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new MethodProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new MethodProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; accum . append ( ' ' ) ; lastWasWhite = true ; } else { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ;", "fixed_code": "public class test { public static boolean isInvisibleChar ( int c ) { return Character . getType ( c ) = = 16 & & ( c = = 8203 | | c = = 8204 | | c = = 8205 | | c = = 173 ) ; } public static void appendNormalisedWhitespace ( StringBuilder accum , String string , boolean stripLeading ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; accum . append ( ' ' ) ; lastWasWhite = true ; } else if ( ! isInvisibleChar ( c ) ) { accum . appendCodePoint ( c ) ; lastWasWhite = false ; reachedNonWhite = true ;", "label": 1}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1}
{"buggy_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( prop . getName ( ) ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "fixed_code": "if ( ! found ) { / / 09 - Jan - 2017 , tatu : Important : must check name slot and NOT property name , / / as only former is lower - case in case - insensitive case found = key . equals ( _hashArea [ i - 1 ] ) ; if ( found ) { / / need to leave a hole here _propsInOrder [ _findFromOrdered ( prop ) ] = null ;", "label": 1}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1}
{"buggy_code": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1}
{"buggy_code": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "fixed_code": "ser = findSerializerFromAnnotation ( prov , beanDesc . getClassInfo ( ) ) ; } / / [ databind # 731 ] : Should skip if nominally java . lang . Object if ( ser = = null & & ! delegateType . isJavaLangObject ( ) ) { ser = _createSerializer2 ( prov , delegateType , beanDesc , true ) ; } return new StdDelegatingSerializer ( conv , delegateType , ser ) ;", "label": 1}
{"buggy_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "fixed_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } } } \\ No newline at end of file", "fixed_code": "Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; } public void removeObject ( Comparable rowKey , Comparable columnKey ) { setObject ( null , rowKey , columnKey ) ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public Object getObject ( Comparable rowKey , Comparable columnKey ) { if ( rowKey = = null ) { throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = e . getMessage ( ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , th . getMessage ( ) , th ) ; } } \\ No newline at end of file", "fixed_code": ". append ( getType ( ) ) . append ( \" ; actual type : \" ) . append ( actType ) . append ( \" ) \" ) ; String origMsg = ClassUtil . exceptionMessage ( e ) ; if ( origMsg ! = null ) { msg . append ( \" , problem : \" ) . append ( origMsg ) ; ClassUtil . throwIfRTE ( e ) ; / / let ' s wrap the innermost problem Throwable th = ClassUtil . getRootCause ( e ) ; throw JsonMappingException . from ( p , ClassUtil . exceptionMessage ( th ) , th ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; return options . hasShortOption ( optName ) ; / / check for several concatenated short options } } \\ No newline at end of file", "fixed_code": "/ / remove leading \" - \" and \" = value \" int pos = token . indexOf ( \" = \" ) ; String optName = pos = = - 1 ? token . substring ( 1 ) : token . substring ( 1 , pos ) ; if ( options . hasShortOption ( optName ) ) { return true ; } / / check for several concatenated short options return optName . length ( ) > 0 & & options . hasShortOption ( String . valueOf ( optName . charAt ( 0 ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith ( \" \\ \" \" ) ) { str = str . substring ( 1 , str . length ( ) ) ; } int length = str . length ( ) ; if ( str . endsWith ( \" \\ \" \" ) ) { str = str . substring ( 0 , length - 1 ) ; } return str ;", "fixed_code": "public class test { static String stripLeadingAndTrailingQuotes ( String str ) { int length = str . length ( ) ; if ( length > 1 & & str . startsWith ( \" \\ \" \" ) & & str . endsWith ( \" \\ \" \" ) & & str . substring ( 1 , length - 1 ) . indexOf ( ' \" ' ) = = - 1 ) { str = str . substring ( 1 , length - 1 ) ; } return str ;", "label": 1}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1}
{"buggy_code": "public class test { public void smartNullPointerException ( Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "fixed_code": "public class test { public void smartNullPointerException ( Object obj , Location location ) { throw new SmartNullPointerException ( join ( \" You have a NullPointerException here : \" , new Location ( ) , obj , \" Because this method was * not * stubbed correctly : \" , location , \" \"", "label": 1}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ;", "label": 1}
{"buggy_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . appendChild ( new TextNode ( \" \" , \" \" ) ) ; body ( ) . appendChild ( node ) ; } } } \\ No newline at end of file", "fixed_code": "for ( Node node : toMove ) { element . removeChild ( node ) ; body ( ) . prependChild ( node ) ; body ( ) . prependChild ( new TextNode ( \" \" , \" \" ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; }   int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) { return StringUtils . EMPTY ; } return className . substring ( 0 , i ) ; } public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } } \\ No newline at end of file", "fixed_code": "public class test { public static String getShortClassName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; }  while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; }  int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) { return StringUtils . EMPTY ; } return className . substring ( 0 , i ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1}
{"buggy_code": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fieldInstance ) ; } return next . filterCandidate ( mocks , field , fieldInstance ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public OngoingInjecter filterCandidate ( Collection < Object > mocks , Field field , List < Field > fields , Object fieldInstance ) { List < Object > mockNameMatches = new ArrayList < Object > ( ) ; if ( mocks . size ( ) > 1 ) { for ( Object mock : mocks ) { mockNameMatches . add ( mock ) ; } } return next . filterCandidate ( mockNameMatches , field , fields , fieldInstance ) ; } else if ( mocks . size ( ) = = 1 ) { String mockName = mockUtil . getMockName ( mocks . iterator ( ) . next ( ) ) . toString ( ) ;  for ( Field otherField : fields ) { if ( ! otherField . equals ( field ) & & otherField . getType ( ) . equals ( field . getType ( ) ) & & otherField . getName ( ) . equals ( mockName ) ) {  return new OngoingInjecter ( ) { public Object thenInject ( ) { return null ; } } ; } } } return next . filterCandidate ( mocks , field , fields , fieldInstance ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "fixed_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "label": 1}
{"buggy_code": "public class test { public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash > > > 12 ) ; return hash ; } private int _findOffsetForAdd ( int hash ) { / / first , check the primary : if ( _spilloverEnd > = hashArea . length ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } } \\ No newline at end of file", "fixed_code": "public class test { private int _findOffsetForAdd ( int hash ) { / / first , check the primary : final int end = ( _hashSize < < 3 ) ; if ( _spilloverEnd > = end ) { if ( _failOnDoS ) { _reportTooManyCollisions ( ) ; } } return offset ; } public int calcHash ( int q1 ) { int hash = q1 ^ _seed ; hash + = ( hash > > > 16 ) ; / / to xor hi - and low - 16 - bits hash ^ = ( hash < < 3 ) ; / / shuffle back a bit hash + = ( hash > > > 12 ) ; / / and bit more return hash ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; }   } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public String getValue ( ) { return val ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getValue ( ) { return Attributes . checkNotNull ( val ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ) { return _initStartElement ( ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _textValue = text ; return ( _currentState = XML_TEXT ) ; } return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "fixed_code": "public class test { protected boolean _allWs ( String str ) { final int len = ( str = = null ) ? 0 : str . length ( ) ; if ( len > 0 ) { for ( int i = 0 ; i < len ; + + i ) { if ( str . charAt ( i ) > ' ' ) { return false ; } } } return true ; } private final int _next ( ) throws XMLStreamException { switch ( _currentState ) { } / / otherwise need to find START / END_ELEMENT or text String text = _collectUntilTag ( ) ; final boolean startElementNext = _xmlReader . getEventType ( ) = = XMLStreamReader . START_ELEMENT ; / / If we have no / all - whitespace text followed by START_ELEMENT , ignore text if ( startElementNext ) { if ( text = = null | | _allWs ( text ) ) { _mixedText = false ; return _initStartElement ( ) ; } _mixedText = true ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } / / For END_ELEMENT we will return text , if any if ( text ! = null ) { _mixedText = false ; _textValue = text ; return ( _currentState = XML_TEXT ) ; } _mixedText = false ; return _handleEndElement ( ) ; case XML_ATTRIBUTE_NAME : return ( _currentState = XML_ATTRIBUTE_VALUE ) ; case XML_TEXT : / / mixed text with other elements if ( _mixedText ) { _mixedText = false ; return _initStartElement ( ) ; } / / text followed by END_ELEMENT return _handleEndElement ( ) ; case XML_END :", "label": 1}
{"buggy_code": "public class test { protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] } } \\ No newline at end of file", "fixed_code": "public class test { protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "fixed_code": "/ / or , something for which \" as - property \" won ' t work , changed into \" wrapper - array \" type : if ( p . getCurrentToken ( ) = = JsonToken . START_ARRAY ) { return super . deserializeTypedFromAny ( p , ctxt ) ; } else if ( p . getCurrentToken ( ) = = JsonToken . VALUE_STRING ) { if ( ctxt . isEnabled ( DeserializationFeature . ACCEPT_EMPTY_STRING_AS_NULL_OBJECT ) ) { String str = p . getText ( ) . trim ( ) ; if ( str . isEmpty ( ) ) { return null ; } } } ctxt . reportWrongTokenException ( p , JsonToken . FIELD_NAME , \" missing property ' \" + _typePropertyName + \" ' that is to contain type id ( for class \" + baseTypeName ( ) + \" ) \" ) ;", "label": 1}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1}
{"buggy_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; return sb . toString ( ) ; } } \\ No newline at end of file", "fixed_code": "sb . append ( _class . getName ( ) ) ; sb . append ( ' < ' ) ; sb . append ( _referencedType . toCanonical ( ) ) ; sb . append ( ' > ' ) ; return sb . toString ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1}
{"buggy_code": "return ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "fixed_code": "return ( _valueDeserializer = = null ) & & ( _keyDeserializer = = null ) & & ( _valueTypeDeserializer = = null ) & & ( _ignorableProperties = = null ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "label": 1}
{"buggy_code": "public class test { public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } } } \\ No newline at end of file", "fixed_code": "public class test { public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { FunctionType buildAndRegister ( ) { if ( returnType = = null ) { returnType = typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; . withName ( fnName ) . withSourceNode ( sourceNode ) . withParamsNode ( parametersNode ) . withReturnType ( returnType ) . withTypeOfThis ( thisType ) . withTemplateName ( templateTypeName ) . build ( ) ; return fnType ; } FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; if ( templateTypeName ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } return this ; } Node fnRoot = isFnLiteral ? rValue : null ; Node parametersNode = isFnLiteral ? rValue . getFirstChild ( ) . getNext ( ) : null ; if ( functionType = = null & & info ! = null & & info . hasType ( ) ) { JSType type = info . getType ( ) . evaluate ( scope , typeRegistry ) ; . setSourceNode ( fnRoot ) . inferFromOverriddenFunction ( propType , parametersNode ) . inferThisType ( info , owner ) . buildAndRegister ( ) ; } } . inferInheritance ( info ) . inferThisType ( info , owner ) . inferParameterTypes ( parametersNode , info ) . buildAndRegister ( ) ; } / / all done return functionType ; } FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , null , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "fixed_code": "public class test { FunctionTypeBuilder inferReturnType ( @ Nullable JSDocInfo info ) { returnType = info ! = null & & info . hasReturnType ( ) ? info . getReturnType ( ) . evaluate ( scope , typeRegistry ) : null ; if ( templateTypeName ! = null & & returnType ! = null & & returnType . restrictByNotNullOrUndefined ( ) . isTemplateType ( ) ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ; } return this ; } FunctionType buildAndRegister ( ) { if ( returnType = = null ) { returnType = typeRegistry . getNativeType ( UNKNOWN_TYPE ) ; . withName ( fnName ) . withSourceNode ( sourceNode ) . withParamsNode ( parametersNode ) . withReturnType ( returnType , returnTypeInferred ) . withTypeOfThis ( thisType ) . withTemplateName ( templateTypeName ) . build ( ) ; return fnType ; } FunctionTypeBuilder inferReturnStatements ( @ Nullable Node functionBlock ) { if ( functionBlock = = null | | compiler . getInput ( sourceName ) . isExtern ( ) ) { return this ; } Preconditions . checkArgument ( functionBlock . getType ( ) = = Token . BLOCK ) ; if ( returnType = = null ) { boolean hasNonEmptyReturns = false ; List < Node > worklist = Lists . newArrayList ( functionBlock ) ; while ( ! worklist . isEmpty ( ) ) { Node current = worklist . remove ( worklist . size ( ) - 1 ) ; int cType = current . getType ( ) ; if ( cType = = Token . RETURN & & current . getFirstChild ( ) ! = null | | cType = = Token . THROW ) { hasNonEmptyReturns = true ; break ; } else if ( NodeUtil . isStatementBlock ( current ) | | NodeUtil . isControlStructure ( current ) ) { for ( Node child = current . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { worklist . add ( child ) ; } } }  if ( ! hasNonEmptyReturns ) { returnType = typeRegistry . getNativeType ( VOID_TYPE ) ; returnTypeInferred = true ; } } return this ; } Node fnRoot = isFnLiteral ? rValue : null ; Node parametersNode = isFnLiteral ? rValue . getFirstChild ( ) . getNext ( ) : null ; Node fnBlock = isFnLiteral ? parametersNode . getNext ( ) : null ; if ( functionType = = null & & info ! = null & & info . hasType ( ) ) { JSType type = info . getType ( ) . evaluate ( scope , typeRegistry ) ; . setSourceNode ( fnRoot ) . inferFromOverriddenFunction ( propType , parametersNode ) . inferThisType ( info , owner ) . inferReturnStatements ( fnBlock ) . buildAndRegister ( ) ; } } . inferInheritance ( info ) . inferThisType ( info , owner ) . inferParameterTypes ( parametersNode , info ) . inferReturnStatements ( fnBlock ) . buildAndRegister ( ) ; } / / all done return functionType ; } public FunctionBuilder withReturnType ( JSType returnType , boolean inferred ) { this . returnType = returnType ; this . inferredReturnType = inferred ; return this ; } FunctionType cloneWithNewReturnType ( JSType newReturnType , boolean inferred ) { return new FunctionType ( registry , null , source , new ArrowType ( registry , call . parameters , newReturnType , inferred ) , typeOfThis , null , false , false ) ;", "label": 1}
{"buggy_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" ^ mb \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "fixed_code": "txt = txt . replaceAll ( \" ^ gn \" , \" 2n \" ) ; / / End txt = txt . replaceAll ( \" mb $ \" , \" m2 \" ) ; / / 4 . Handle replacements txt = txt . replaceAll ( \" cq \" , \" 2q \" ) ;", "label": 1}
{"buggy_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } } } \\ No newline at end of file", "fixed_code": "validateDoNothing ( ( DoesNothing ) answer , invocation ) ; } if ( answer instanceof CallsRealMethods ) { validateMockingConcreteClass ( ( CallsRealMethods ) answer , invocation ) ; } } private void validateMockingConcreteClass ( CallsRealMethods answer , Invocation invocation ) { if ( invocation . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { reporter . cannotCallRealMethodOnInterface ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , e . getMessage ( ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = cause . getMessage ( ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "fixed_code": "} catch ( ParseException e ) { throw new IllegalArgumentException ( String . format ( \" Failed to parse Date value ' % s ' : % s \" , dateStr , ClassUtil . exceptionMessage ( e ) ) ) ; } } public JsonMappingException instantiationException ( Class < ? > instClass , Throwable cause ) { String excMsg ; if ( cause = = null ) { excMsg = \" N / A \" ; } else if ( ( excMsg = ClassUtil . exceptionMessage ( cause ) ) = = null ) { excMsg = ClassUtil . nameOf ( cause . getClass ( ) ) ; } String msg = String . format ( \" Cannot construct instance of % s , problem : % s \" ,", "label": 1}
{"buggy_code": "{ String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; if ( ! cmd . hasOption ( option ) ) { Option opt = getOptions ( ) . getOption ( option ) ; / / if the option is part of a group , check if another option of the group has been selected / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "fixed_code": "{ String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties String value = properties . getProperty ( option ) ; { String option = e . nextElement ( ) . toString ( ) ; Option opt = options . getOption ( option ) ; if ( opt = = null ) { throw new UnrecognizedOptionException ( \" Default option wasn ' t defined \" , option ) ; } / / if the option is part of a group , check if another option of the group has been selected OptionGroup group = options . getOptionGroup ( opt ) ; boolean selected = group ! = null & & group . getSelected ( ) ! = null ; if ( ! cmd . hasOption ( option ) & & ! selected ) { / / get the value from the properties instance String value = properties . getProperty ( option ) ;", "label": 1}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 1}
{"buggy_code": "public class test { public void addOption ( Option option ) { options . add ( option ) ; nameToOption . put ( option . getPreferredName ( ) , option ) ; } / / ensure that all parent options are also added } public GroupImpl ( final List options , final String name , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; if ( option instanceof Argument ) { i . remove ( ) ; this . optionMap = Collections . unmodifiableSortedMap ( newOptionMap ) ; this . prefixes = Collections . unmodifiableSet ( newPrefixes ) ; } } \\ No newline at end of file", "fixed_code": "public class test { void setParent ( Option parent ) ; Option getParent ( ) ; public void addOption ( Option option ) { options . add ( option ) ; nameToOption . put ( option . getPreferredName ( ) , option ) ; } / / ensure that all parent options are also added Option parent = option . getParent ( ) ; while ( parent ! = null & & ! options . contains ( parent ) ) { options . add ( parent ) ; parent = parent . getParent ( ) ; } } public GroupImpl ( final List options , final String name , / / process the options for ( final Iterator i = options . iterator ( ) ; i . hasNext ( ) ; ) { final Option option = ( Option ) i . next ( ) ; option . setParent ( this ) ; if ( option instanceof Argument ) { i . remove ( ) ; this . optionMap = Collections . unmodifiableSortedMap ( newOptionMap ) ; this . prefixes = Collections . unmodifiableSet ( newPrefixes ) ; } public Option getParent ( ) { return parent ; } public void setParent ( Option parent ) { this . parent = parent ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 1}
{"buggy_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "fixed_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "label": 1}
{"buggy_code": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token ) ; } else { tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else if ( stopAtNonOption ) { processNonOptionToken ( token ) ; } else { tokens . add ( token ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { Option currentOption ; for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) ) ; break ; } else } } } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }   tokens . add ( token ) ; } private void processNonOptionToken ( String value ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; tokens . add ( value ) ; }", "fixed_code": "if ( ! options . hasOption ( opt ) ) { processNonOptionToken ( token , stopAtNonOption ) ; } else { currentOption = options . getOption ( opt ) ; tokens . add ( opt ) ; if ( pos ! = - 1 ) burstToken ( token , stopAtNonOption ) ; } } else { processNonOptionToken ( token , stopAtNonOption ) ; } gobble ( iter ) ; return ( String [ ] ) tokens . toArray ( new String [ tokens . size ( ) ] ) ; } private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( stopAtNonOption & & ! options . hasOption ( token ) ) { eatTheRest = true ; }  if ( options . hasOption ( token ) ) { currentOption = options . getOption ( token ) ; }  tokens . add ( token ) ; } protected void burstToken ( String token , boolean stopAtNonOption ) { for ( int i = 1 ; i < token . length ( ) ; i + + ) { String ch = String . valueOf ( token . charAt ( i ) ) ; } else if ( stopAtNonOption ) { processNonOptionToken ( token . substring ( i ) , true ) ; break ; } else } } } private void processNonOptionToken ( String value , boolean stopAtNonOption ) { if ( stopAtNonOption & & ( currentOption = = null | | ! currentOption . hasArg ( ) ) ) { eatTheRest = true ; tokens . add ( \" - - \" ) ; } tokens . add ( value ) ; }", "label": 1}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1}
{"buggy_code": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "fixed_code": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1}
{"buggy_code": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; if ( value instanceof Date ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else { str = value . toString ( ) ; }", "fixed_code": "public class test { public void serialize ( Object value , JsonGenerator jgen , SerializerProvider provider ) throws IOException { String str ; Class < ? > cls = value . getClass ( ) ; if ( cls = = String . class ) { str = ( String ) value ; } else if ( Date . class . isAssignableFrom ( cls ) ) { provider . defaultSerializeDateKey ( ( Date ) value , jgen ) ; return ; } else if ( cls = = Class . class ) { str = ( ( Class < ? > ) value ) . getName ( ) ; } else { str = value . toString ( ) ; }", "label": 1}
{"buggy_code": "} if ( depth1 = = 1 ) { throw new JXPathException ( \" Cannot compare pointers that do not belong to the same tree : ' \" + p1 + \" ' and ' \" + p2 + \" ' \" ) ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "fixed_code": "} if ( depth1 = = 1 ) { return 0 ; } int r = compareNodePointers ( p1 . parent , depth1 - 1 , p2 . parent , depth2 - 1 ) ; if ( r ! = 0 ) {", "label": 1}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1}
{"buggy_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "fixed_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "label": 1}
{"buggy_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } formatBigIntegerBinary ( value , buf , offset , length , negative ) ; buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "fixed_code": "if ( length < 9 ) { formatLongBinary ( value , buf , offset , length , negative ) ; } else { formatBigIntegerBinary ( value , buf , offset , length , negative ) ; } buf [ offset ] = ( byte ) ( negative ? 0xff : 0x80 ) ; return offset + length ;", "label": 1}
{"buggy_code": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValid ( parseBodyFragment ( bodyHtml , \" \" ) ) ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isValid ( String bodyHtml , Whitelist whitelist ) { return new Cleaner ( whitelist ) . isValidBodyHtml ( bodyHtml ) ; } public static List < Node > parseFragment ( String fragmentHtml , Element context , String baseUri , ParseErrorList errorList ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( fragmentHtml , context , baseUri , errorList , treeBuilder . defaultSettings ( ) ) ; } public boolean isValidBodyHtml ( String bodyHtml ) { Document clean = Document . createShell ( \" \" ) ; Document dirty = Document . createShell ( \" \" ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( bodyHtml , dirty . body ( ) , \" \" , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & errorList . size ( ) = = 0 ; } public boolean isValid ( Document dirtyDocument ) { Validate . notNull ( dirtyDocument ) ; Document clean = Document . createShell ( dirtyDocument . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( dirtyDocument . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & dirtyDocument . head ( ) . childNodes ( ) . size ( ) = = 0 ; / / because we only look at the body , but we start from a shell , make sure there ' s nothing in the head } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; cls ! = Object . class ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "fixed_code": "/ / 18 - Dec - 2017 , tatu : As per [ databind # 1855 ] , need bit more sophisticated handling / / for some Spring framework types / / 05 - Jan - 2017 , tatu : . . . also , only applies to classes , not interfaces if ( ! raw . isInterface ( ) & & full . startsWith ( PREFIX_STRING ) ) { for ( Class < ? > cls = raw ; ( cls ! = null ) & & ( cls ! = Object . class ) ; cls = cls . getSuperclass ( ) ) { String name = cls . getSimpleName ( ) ; / / looking for \" AbstractBeanFactoryPointcutAdvisor \" but no point to allow any is there ? if ( \" AbstractPointcutAdvisor \" . equals ( name )", "label": 1}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1}
{"buggy_code": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; } } \\ No newline at end of file", "fixed_code": "getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } boolean cachable = ( bindings = = null ) | | bindings . isEmpty ( ) ; if ( cachable ) { result = _typeCache . get ( rawType ) ; if ( result ! = null ) { return result ; } }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; if ( cachable ) { _typeCache . putIfAbsent ( rawType , result ) ; } return result ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , TypeBindings . emptyBindings ( ) , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { TypeBindings tb = null ; if ( baseType . containedTypeCount ( ) = = typeParamCount ) { if ( typeParamCount = = 1 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } else if ( typeParamCount = = 2 ) { tb = TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } } newType = _fromClass ( null , subclass , ( tb = = null ) ? TypeBindings . emptyBindings ( ) : tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private TypeBindings _bindingsForSubtype ( JavaType baseType , int typeParamCount , Class < ? > subclass ) { int baseCount = baseType . containedTypeCount ( ) ; if ( baseCount = = typeParamCount ) { if ( typeParamCount = = 1 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) ) ; } if ( typeParamCount = = 2 ) { return TypeBindings . create ( subclass , baseType . containedType ( 0 ) , baseType . containedType ( 1 ) ) ; } List < JavaType > types = new ArrayList < JavaType > ( baseCount ) ; for ( int i = 0 ; i < baseCount ; + + i ) { types . add ( baseType . containedType ( i ) ) ; } return TypeBindings . create ( subclass , types ) ; } return TypeBindings . emptyBindings ( ) ; } public JavaType constructSpecializedType ( JavaType baseType , Class < ? > subclass ) { / / for a case where this code does get invoked : not ideal / / 29 - Jun - 2016 , tatu : As to bindings , this works for [ databind # 1215 ] , but / / not certain it would reliably work . . . but let ' s hope for best for now TypeBindings tb = _bindingsForSubtype ( baseType , typeParamCount , subclass ) ; if ( baseType . isInterface ( ) ) { newType = baseType . refine ( subclass , tb , null , new JavaType [ ] { baseType } ) ; } else { newType = baseType . refine ( subclass , tb , baseType , NO_TYPES ) ; } / / Only SimpleType returns null , but if so just resolve regularly if ( newType = = null ) { newType = _fromClass ( null , subclass , tb ) ; } } while ( false ) ; return baseType . narrowBy ( subclass ) ; } protected JavaType _fromClass ( ClassStack context , Class < ? > rawType , TypeBindings bindings ) { JavaType result = _findWellKnownSimple ( rawType ) ; if ( result ! = null ) { return result ; } final Object key ; if ( ( bindings = = null ) | | bindings . isEmpty ( ) ) { key = rawType ; result = _typeCache . get ( key ) ; / / ok , cache object is synced } else { key = bindings . asKey ( rawType ) ; } result = _typeCache . get ( key ) ; / / ok , cache object is synced if ( result ! = null ) { return result ; }  if ( context = = null ) { context = new ClassStack ( rawType ) ; } else { ClassStack prev = context . find ( rawType ) ; if ( prev ! = null ) { ResolvedRecursiveType selfRef = new ResolvedRecursiveType ( rawType , EMPTY_BINDINGS ) ; prev . addSelfReference ( selfRef ) ; return selfRef ; } context = context . child ( rawType ) ; }  if ( rawType . isArray ( ) ) { result = ArrayType . construct ( _fromAny ( context , rawType . getComponentType ( ) , bindings ) , bindings ) ; } else {  JavaType superClass ; JavaType [ ] superInterfaces ;  if ( rawType . isInterface ( ) ) { superClass = null ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; } else { superClass = _resolveSuperClass ( context , rawType , bindings ) ; superInterfaces = _resolveSuperInterfaces ( context , rawType , bindings ) ; }  if ( rawType = = Properties . class ) { result = MapType . construct ( rawType , bindings , superClass , superInterfaces , CORE_TYPE_STRING , CORE_TYPE_STRING ) ; } else if ( superClass ! = null ) { result = superClass . refine ( rawType , bindings , superClass , superInterfaces ) ; } if ( result = = null ) { result = _fromWellKnownClass ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _fromWellKnownInterface ( context , rawType , bindings , superClass , superInterfaces ) ; if ( result = = null ) { result = _newSimpleType ( rawType , bindings , superClass , superInterfaces ) ; } } } } context . resolveSelfReferences ( result ) ; _typeCache . putIfAbsent ( key , result ) ; / / cache object syncs return result ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; insertNode ( insert ) ; } } \\ No newline at end of file", "fixed_code": "void insert ( Token . Comment commentToken ) { Comment comment = new Comment ( commentToken . getData ( ) , baseUri ) ; Node insert = comment ; if ( commentToken . bogus ) { / / xml declarations are emitted as bogus comments ( which is right for html , but not xml ) String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MockHandler < T > newMockHandler = new MockHandler < T > ( oldMockHandler ) ; MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler , ( MockSettingsImpl ) org . mockito . Mockito . withSettings ( ) . defaultAnswer ( org . mockito . Mockito . RETURNS_DEFAULTS ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public < T > void resetMock ( T mock ) { MockHandlerInterface < T > oldMockHandler = getMockHandler ( mock ) ; MethodInterceptorFilter newFilter = newMethodInterceptorFilter ( oldMockHandler . getMockSettings ( ) ) ; ( ( Factory ) mock ) . setCallback ( 0 , newFilter ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , ownerDocument ( ) . outputSettings ( ) ) ) . traverse ( this ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Document . OutputSettings getOutputSettings ( ) { return ownerDocument ( ) ! = null ? ownerDocument ( ) . outputSettings ( ) : ( new Document ( \" \" ) ) . outputSettings ( ) ; } protected void outerHtml ( StringBuilder accum ) { new NodeTraversor ( new OuterHtmlVisitor ( accum , getOutputSettings ( ) ) ) . traverse ( this ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { tq . consume ( ) ; return null ; }", "fixed_code": "if ( key . length ( ) ! = 0 ) return Attribute . createFromEncoded ( key , value ) ; else { if ( value . length ( ) = = 0 ) / / no key , no val ; unknown char , keep popping so not get stuck tq . advance ( ) ; return null ; }", "label": 1}
{"buggy_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . if ( _deserialize ( text , ctxt ) ! = null ) { return _deserialize ( text , ctxt ) ; } } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "fixed_code": "/ / 19 - May - 2017 , tatu : Used to require non - null result ( assuming ` null ` / / indicated error ; but that seems wrong . Should be able to return / / ` null ` as value . return _deserialize ( text , ctxt ) ; } catch ( IllegalArgumentException iae ) { cause = iae ; } catch ( MalformedURLException me ) {", "label": 1}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 1}
{"buggy_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } return ser ; } protected JsonSerializer < ? > _createSerializer2 ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; if ( ser ! = null ) { return ser ; } final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . } if ( ser = = null ) {", "fixed_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } } return ser ; } protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > _createSerializer2 ( SerializerProvider prov , JavaType type , BeanDescription beanDesc , boolean staticTyping ) throws JsonMappingException { JsonSerializer < ? > ser = null ; final SerializationConfig config = prov . getConfig ( ) ; / / Container types differ from non - container types } / / 25 - Jun - 2015 , tatu : Then JsonSerializable , @ JsonValue etc . NOTE ! Prior to 2 . 6 , / / this call was BEFORE custom serializer lookup , which was wrong . if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } } if ( ser = = null ) {", "label": 1}
{"buggy_code": "XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "fixed_code": "XmlDeclaration decl = null ; if ( first instanceof XmlDeclaration ) decl = ( XmlDeclaration ) first ; else if ( first instanceof Comment ) { Comment comment = ( Comment ) first ; if ( comment . isXmlDeclaration ( ) ) decl = comment . asXmlDeclaration ( ) ; } if ( decl ! = null ) { if ( decl . name ( ) . equalsIgnoreCase ( \" xml \" ) ) foundCharset = decl . attr ( \" encoding \" ) ;", "label": 1}
{"buggy_code": "public class test { public JsonWriter jsonValue ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( value ) ; return this ; } private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( true ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; } private void beforeValue ( boolean root ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document if ( ! lenient & & ! root ) { throw new IllegalStateException ( \" JSON must start with an array or an object . \" ) ; } replaceTop ( NONEMPTY_DOCUMENT ) ; break ; throw new IllegalStateException ( \" Nesting problem . \" ) ; } } public JsonWriter value ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; string ( value ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( false ) ; out . append ( string ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( false ) ; out . append ( Double . toString ( value ) ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( false ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( false ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; }", "fixed_code": "public class test { private void beforeValue ( ) throws IOException { switch ( peek ( ) ) { case NONEMPTY_DOCUMENT : if ( ! lenient ) { } / / fall - through case EMPTY_DOCUMENT : / / first in document replaceTop ( NONEMPTY_DOCUMENT ) ; break ; throw new IllegalStateException ( \" Nesting problem . \" ) ; } } public JsonWriter jsonValue ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( value ) ; return this ; } private JsonWriter open ( int empty , String openBracket ) throws IOException { beforeValue ( ) ; push ( empty ) ; out . write ( openBracket ) ; return this ; } public JsonWriter value ( String value ) throws IOException { if ( value = = null ) { return nullValue ( ) ; } writeDeferredName ( ) ; beforeValue ( ) ; string ( value ) ; return this ; } public JsonWriter value ( long value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( Long . toString ( value ) ) ; return this ; } & & ( string . equals ( \" - Infinity \" ) | | string . equals ( \" Infinity \" ) | | string . equals ( \" NaN \" ) ) ) { throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } beforeValue ( ) ; out . append ( string ) ; return this ; } throw new IllegalArgumentException ( \" Numeric values must be finite , but was \" + value ) ; } writeDeferredName ( ) ; beforeValue ( ) ; out . append ( Double . toString ( value ) ) ; return this ; } return this ; / / skip the name and the value } } beforeValue ( ) ; out . write ( \" null \" ) ; return this ; } public JsonWriter value ( boolean value ) throws IOException { writeDeferredName ( ) ; beforeValue ( ) ; out . write ( value ? \" true \" : \" false \" ) ; return this ; }", "label": 1}
{"buggy_code": "public class test { public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; }", "fixed_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; }", "label": 1}
{"buggy_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return null ; } } } \\ No newline at end of file", "fixed_code": "} else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return openFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return null ; } } public static FileInputStream openFile ( String str ) throws ParseException { try { return new FileInputStream ( str ) ; } catch ( FileNotFoundException e ) { throw new ParseException ( \" Unable to find file : \" + str ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else {", "fixed_code": "else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; break ; } else {", "label": 1}
{"buggy_code": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static double distance ( int [ ] low , int [ ] high ) { int n = low . length ;  int max = high [ 0 ] ; for ( int i = 0 ; i < n ; i + + ) { max = Math . max ( max , high [ i ] ) ; }  long [ ] sums = new long [ max + 2 ] ; for ( int i = 2 ; i < sums . length ; i + + ) { sums [ i ] = sums [ i - 1 ] + ( i - 1 ) ; }  double prev = 0 ; for ( int i = 1 ; i < n ; i + + ) {  double p1 = 1 . 0 / ( high [ i - 1 ] - low [ i - 1 ] + 1 ) ; double p2 = 1 . 0 / ( high [ i ] - low [ i ] + 1 ) ; double p = p1 * p2 ;  double curr = 0 ;  for ( int a = low [ i ] ; a < high [ i ] + 1 ; a + + ) { long lo = low [ i - 1 ] ; long hi = high [ i - 1 ] ; int l = 0 ; int r = 0 ;  if ( lo < = a & & a < = hi ) { l = ( int ) ( a - lo ) ; r = ( int ) ( hi - a ) ; } else if ( a > hi ) { l = ( int ) ( hi - lo + 1 ) ; } else if ( a < lo ) { r = ( int ) ( hi - lo + 1 ) ; }  long addl = sums [ l ] ; long addr = ( l > 0 | | a = = lo ) ? ( sums [ l + 1 + r ] - sums [ l + 1 ] ) : sums [ r ] ;  curr + = p * l * a ; curr - = p * r * a ;  curr - = p * ( l * lo + addl ) ; curr + = p * ( r * lo + addr ) ;  curr + = p2 * prev ; }  prev = curr ; }  return prev ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1}
{"buggy_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) attributes . remove ( attrKey ) ; } } } \\ No newline at end of file", "fixed_code": "for ( Iterator < String > it = attributes . keySet ( ) . iterator ( ) ; it . hasNext ( ) ; ) { String attrKey = it . next ( ) ; if ( attrKey . equalsIgnoreCase ( key ) ) it . remove ( ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately p . skipChildren ( ) ; return null ; } } \\ No newline at end of file", "fixed_code": "{ / / 29 - Jan - 2016 , tatu : Simple skipping for all other tokens , but FIELD_NAME bit / / special unfortunately if ( p . hasToken ( JsonToken . FIELD_NAME ) ) { while ( true ) { JsonToken t = p . nextToken ( ) ; if ( ( t = = null ) | | ( t = = JsonToken . END_OBJECT ) ) { break ; } p . skipChildren ( ) ; } } else { p . skipChildren ( ) ; } return null ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1}
{"buggy_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( tag . isSelfClosing ( ) ) tokeniser . acknowledgeSelfClosingFlag ( ) ; } else { tag . setSelfClosing ( ) ; tokeniser . acknowledgeSelfClosingFlag ( ) ; } } return el ; } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } } \\ No newline at end of file", "fixed_code": "insertNode ( el ) ; if ( startTag . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( \" Tag cannot be self closing ; not a void tag \" ) ; } else / / unknown tag , remember this is self closing for output tag . setSelfClosing ( ) ; } return el ; } Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; lowerBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; } public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; upperBounds = new Type [ ] { bound } ; return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static WildcardType subtypeOf ( Type bound ) { Type [ ] upperBounds ; if ( bound instanceof WildcardType ) { upperBounds = ( ( WildcardType ) bound ) . getUpperBounds ( ) ; } else { upperBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( upperBounds , EMPTY_TYPE_ARRAY ) ; } public static WildcardType supertypeOf ( Type bound ) { Type [ ] lowerBounds ; if ( bound instanceof WildcardType ) { lowerBounds = ( ( WildcardType ) bound ) . getLowerBounds ( ) ; } else { lowerBounds = new Type [ ] { bound } ; } return new WildcardTypeImpl ( new Type [ ] { Object . class } , lowerBounds ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; if ( startTag . selfClosing ) selfClosingFlagAcknowledged = false ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } void acknowledgeSelfClosingFlag ( ) { selfClosingFlagAcknowledged = true ; } Token read ( ) { if ( ! selfClosingFlagAcknowledged ) { error ( \" Self closing flag not acknowledged \" ) ; selfClosingFlagAcknowledged = true ; } while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } } \\ No newline at end of file", "fixed_code": "public class test { Token read ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; return emitPending ; } } void emit ( Token token ) { Validate . isFalse ( isEmitPending , \" There is an unread token pending ! \" ) ;  emitPending = token ; isEmitPending = true ;  if ( token . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) token ; lastStartTag = startTag . tagName ; } else if ( token . type = = Token . TokenType . EndTag ) { Token . EndTag endTag = ( Token . EndTag ) token ; if ( endTag . attributes ! = null ) error ( \" Attributes incorrectly present on end tag \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "fixed_code": "if ( tag . isData ( ) ) { String data = tq . chompTo ( \" < / \" + tagName ) ; tq . chompTo ( \" > \" ) ; popStackToClose ( tag ) ; Node dataNode ; if ( tag . equals ( titleTag ) | | tag . equals ( textareaTag ) ) / / want to show as text , but not contain inside tags ( so not a data tag ? )", "label": 1}
{"buggy_code": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" PUBLIC \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } } \\ No newline at end of file", "fixed_code": "} if ( has ( NAME ) ) accum . append ( \" \" ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) accum . append ( \" \" ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( PUBLIC_ID ) ) . append ( ' \" ' ) ; if ( has ( SYSTEM_ID ) ) accum . append ( \" \\ \" \" ) . append ( attr ( SYSTEM_ID ) ) . append ( ' \" ' ) ; accum . append ( ' > ' ) ; } public DocumentType ( String name , String pubSysKey , String publicId , String systemId , String baseUri ) { super ( baseUri ) ;  attr ( NAME , name ) ; if ( pubSysKey ! = null ) { attr ( PUB_SYS_KEY , pubSysKey ) ; } attr ( PUBLIC_ID , publicId ) ; attr ( SYSTEM_ID , systemId ) ; } public DocumentType ( String name , String publicId , String systemId , String baseUri ) { super ( baseUri ) ; attr ( NAME , name ) ; attr ( PUBLIC_ID , publicId ) ; if ( has ( PUBLIC_ID ) ) { attr ( PUB_SYS_KEY , PUBLIC_KEY ) ; } attr ( SYSTEM_ID , systemId ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1}
{"buggy_code": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = 0 ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "fixed_code": "final Option option ) throws OptionException { / / count of arguments processed for this option . int argumentCount = commandLine . getUndefaultedValues ( option ) . size ( ) ; while ( arguments . hasNext ( ) & & ( argumentCount < maximum ) ) { final String allValuesQuoted = ( String ) arguments . next ( ) ;", "label": 1}
{"buggy_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "fixed_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1}
{"buggy_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "fixed_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "label": 1}
{"buggy_code": "return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ; / / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ;", "fixed_code": "return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ; / / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ;", "label": 1}
{"buggy_code": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "label": 1}
{"buggy_code": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "fixed_code": "public class test { public static boolean areEqual ( Object o1 , Object o2 ) { if ( o1 = = o2 ) { return true ; } else if ( o1 = = null | | o2 = = null ) { return o1 = = null & & o2 = = null ; } else if ( isArray ( o1 ) ) { return isArray ( o2 ) & & areArraysEqual ( o1 , o2 ) ;", "label": 1}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1}
{"buggy_code": "} } if ( count = = len ) { return str . toUpperCase ( ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "fixed_code": "} } if ( count = = len ) { return str . toUpperCase ( java . util . Locale . ENGLISH ) ; } return new String ( chars , 0 , count ) . toUpperCase ( java . util . Locale . ENGLISH ) ; }", "label": 1}
{"buggy_code": "public class test { public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1}
{"buggy_code": "public class test { private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg . toString ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private boolean toStringEquals ( Matcher m , Object arg ) { return StringDescription . toString ( m ) . equals ( arg = = null ? \" null \" : arg . toString ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable {  container . addAnswer ( new Answer < Object > ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ;  return mock ; } private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? : withSettings ( ) ; return mockSettings . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } protected GenericMetadataSupport actualParameterizedType ( Object mock ) { CreationSettings mockSettings = ( CreationSettings ) new MockUtil ( ) . getMockHandler ( mock ) . getMockSettings ( ) ; return GenericMetadataSupport . inferFrom ( mockSettings . getTypeToMock ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private MockSettings withSettingsUsing ( GenericMetadataSupport returnTypeGenericMetadata ) { MockSettings mockSettings = returnTypeGenericMetadata . rawExtraInterfaces ( ) . length > 0 ? : withSettings ( ) ; return mockSettings . serializable ( ) . defaultAnswer ( returnsDeepStubsAnswerUsing ( returnTypeGenericMetadata ) ) ; } private synchronized void instantiateDelegateIfNeeded ( ) { if ( delegate = = null ) { delegate = new ReturnsEmptyValues ( ) ; } } public Object answer ( InvocationOnMock invocation ) throws Throwable { GenericMetadataSupport returnTypeGenericMetadata = actualParameterizedType ( invocation . getMock ( ) ) . resolveGenericReturnType ( invocation . getMethod ( ) ) ;  Class < ? > rawType = returnTypeGenericMetadata . rawType ( ) ; instantiateMockitoCoreIfNeeded ( ) ; instantiateDelegateIfNeeded ( ) ; if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }  return getMock ( invocation , returnTypeGenericMetadata ) ; } private Object getMock ( InvocationOnMock invocation , GenericMetadataSupport returnTypeGenericMetadata ) throws Throwable { InternalMockHandler < Object > handler = new MockUtil ( ) . getMockHandler ( invocation . getMock ( ) ) ; InvocationContainerImpl container = ( InvocationContainerImpl ) handler . getInvocationContainer ( ) ;  for ( StubbedInvocationMatcher stubbedInvocationMatcher : container . getStubbedInvocations ( ) ) { if ( container . getInvocationForStubbing ( ) . matches ( stubbedInvocationMatcher . getInvocation ( ) ) ) { return stubbedInvocationMatcher . answer ( invocation ) ; } }  return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ; } private synchronized void instantiateMockitoCoreIfNeeded ( ) { if ( mockitoCore = = null ) { mockitoCore = new MockitoCore ( ) ; } } protected GenericMetadataSupport actualParameterizedType ( Object mock ) { CreationSettings mockSettings = ( CreationSettings ) new MockUtil ( ) . getMockHandler ( mock ) . getMockSettings ( ) ; return GenericMetadataSupport . inferFrom ( mockSettings . getTypeToMock ( ) ) ; } private Object recordDeepStubMock ( final Object mock , InvocationContainerImpl container ) throws Throwable {  container . addAnswer ( new SerializableAnswer ( ) { public Object answer ( InvocationOnMock invocation ) throws Throwable { return mock ; } } , false ) ;  return mock ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "fixed_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1}
{"buggy_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "label": 1}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1}
{"buggy_code": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; } } \\ No newline at end of file", "fixed_code": "charBuf = new char [ sz > maxBufferLen ? maxBufferLen : sz ] ; bufferUp ( ) ; if ( isBinary ( ) ) { throw new UncheckedIOException ( \" Input is binary and unsupported \" ) ; } } boolean isBinary ( ) { int nullsSeen = 0 ;  for ( int i = bufPos ; i < bufLength ; i + + ) { if ( charBuf [ i ] = = ' \\ 0 ' ) nullsSeen + + ; }  return nullsSeen > = numNullsConsideredBinary ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo ) ; } } } private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; } } } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v = t . getScope ( ) . getVar ( n . getString ( ) ) ; if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; blockStack . pop ( ) ; } } } \\ No newline at end of file", "fixed_code": "public class test { private boolean isLValue ( Node n ) { Node parent = n . getParent ( ) ; return ( parent . getType ( ) = = Token . INC | | parent . getType ( ) = = Token . DEC | | ( NodeUtil . isAssignmentOp ( parent ) & & parent . getFirstChild ( ) = = n ) ) ; } private void doInlinesForScope ( NodeTraversal t , Map < Var , ReferenceCollection > referenceMap ) { boolean maybeModifiedArguments = maybeEscapedOrModifiedArguments ( t . getScope ( ) , referenceMap ) ; for ( Iterator < Var > it = t . getScope ( ) . getVars ( ) ; it . hasNext ( ) ; ) { Var v = it . next ( ) ; / / inlining heuristics . See InlineConstantsTest . continue ; } else { inlineNonConstants ( v , referenceInfo , maybeModifiedArguments ) ; } } } private void inlineNonConstants ( Var v , ReferenceCollection referenceInfo , boolean maybeModifiedArguments ) { int refCount = referenceInfo . references . size ( ) ; Reference declaration = referenceInfo . references . get ( 0 ) ; Reference init = referenceInfo . getInitializingReference ( ) ; / / inline an alias of it . ( If the variable was inlined , then the / / reference data is out of sync . We ' re better off just waiting for / / the next pass . ) if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { List < Reference > refs = referenceInfo . references ; } } } private boolean maybeEscapedOrModifiedArguments ( Scope scope , Map < Var , ReferenceCollection > referenceMap ) { if ( scope . isLocal ( ) ) { Var arguments = scope . getArgumentsVar ( ) ; ReferenceCollection refs = referenceMap . get ( arguments ) ; if ( refs ! = null & & ! refs . references . isEmpty ( ) ) { for ( Reference ref : refs . references ) { Node refNode = ref . getNameNode ( ) ; Node refParent = ref . getParent ( ) ; if ( ! ( NodeUtil . isGet ( refParent ) & & refNode = = ref . getParent ( ) . getFirstChild ( ) & & ! isLValue ( refParent ) ) ) { return true ; } } } } return false ; } public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . getType ( ) = = Token . NAME ) { Var v ; if ( n . getString ( ) . equals ( \" arguments \" ) ) { v = t . getScope ( ) . getArgumentsVar ( ) ; } else { v = t . getScope ( ) . getVar ( n . getString ( ) ) ; } if ( v ! = null & & varFilter . apply ( v ) ) { addReference ( t , v , new Reference ( n , parent , t , blockStack . peek ( ) ) ) ; blockStack . pop ( ) ; } } Arguments ( Scope scope ) { super ( false , / / no inferred \" arguments \" , / / always arguments null , / / no declaration node null , / / no type info scope , - 1 , / / no variable index null , / / input , false , / / not a define null / / no jsdoc ) ; } @ Override public boolean equals ( Object other ) { if ( ! ( other instanceof Arguments ) ) { return false ; }  Arguments otherVar = ( Arguments ) other ; return otherVar . scope . getRootNode ( ) = = scope . getRootNode ( ) ; } @ Override public int hashCode ( ) { return System . identityHashCode ( this ) ; } public Var getArgumentsVar ( ) { if ( arguments = = null ) { arguments = new Arguments ( this ) ; } return arguments ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "fixed_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "label": 1}
{"buggy_code": "} PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "fixed_code": "} PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ;", "label": 1}
{"buggy_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { this . finish ( ) ; out . close ( ) ; this . closed = true ; } } public void close ( ) throws IOException { if ( ! closed ) { finish ( ) ; buffer . close ( ) ; out . close ( ) ; closed = true ; } } public void close ( ) throws IOException { finish ( ) ; if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } return results ; } } \\ No newline at end of file", "fixed_code": "public class test { public void close ( ) throws IOException { if ( ! this . closed ) { out . close ( ) ; this . closed = true ; } } public void close ( ) throws IOException { if ( ! closed ) { buffer . close ( ) ; out . close ( ) ; closed = true ; } } public void close ( ) throws IOException { if ( raf ! = null ) { raf . close ( ) ; } results . addedFromChangeSet ( change . getEntry ( ) . getName ( ) ) ; } } out . finish ( ) ; return results ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public static Option create ( String opt ) throws IllegalArgumentException { / / create the option Option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; / / return the Option instance return option ;", "fixed_code": "public class test { public static Option create ( String opt ) throws IllegalArgumentException { Option option = null ; try { / / create the option option = new Option ( opt , description ) ; / / set the option properties option . setLongOpt ( longopt ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ; } finally { / / reset the OptionBuilder properties OptionBuilder . reset ( ) ; } / / return the Option instance return option ;", "label": 1}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1}
{"buggy_code": "public class test { private void tryRemoveUnconditionalBranching ( Node n ) {", "fixed_code": "public class test { private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private void tryRemoveUnconditionalBranching ( Node n ) {", "label": 1}
{"buggy_code": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return null ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return null ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected static Boolean _isShapeWrittenUsingIndex ( Class < ? > enumClass , JsonFormat . Value format , boolean fromClass , Boolean defaultValue ) { JsonFormat . Shape shape = ( format = = null ) ? null : format . getShape ( ) ; if ( shape = = null ) { return defaultValue ; } / / i . e . \" default \" , check dynamically if ( shape = = Shape . ANY | | shape = = Shape . SCALAR ) { return defaultValue ; } / / 19 - May - 2016 , tatu : also consider \" natural \" shape if ( shape = = Shape . STRING | | shape = = Shape . NATURAL ) { property , handledType ( ) ) ; if ( format ! = null ) { Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( property . getType ( ) . getRawClass ( ) , format , false , _serializeAsIndex ) ; if ( serializeAsIndex ! = _serializeAsIndex ) { return new EnumSerializer ( _values , serializeAsIndex ) ; } * handle toString ( ) case dynamically ( for example ) EnumValues v = EnumValues . constructFromName ( config , ( Class < Enum < ? > > ) enumClass ) ; Boolean serializeAsIndex = _isShapeWrittenUsingIndex ( enumClass , format , true , null ) ; return new EnumSerializer ( v , serializeAsIndex ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "label": 1}
{"buggy_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; - - shift ; if ( shift = = 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( length > 0 & & shift > 0 ) { header . write ( cache ) ; } }", "fixed_code": "int shift = 7 ; for ( int i = 0 ; i < length ; i + + ) { cache | = ( ( bits . get ( i ) ? 1 : 0 ) < < shift ) ; if ( - - shift < 0 ) { header . write ( cache ) ; shift = 7 ; cache = 0 ; } } if ( shift ! = 7 ) { header . write ( cache ) ; } }", "label": 1}
{"buggy_code": "public class test { static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "fixed_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "label": 1}
{"buggy_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return node instanceof Element ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "fixed_code": "int nodeType = node . getNodeType ( ) ; switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return nodeType = = Node . ELEMENT_NODE | | nodeType = = Node . DOCUMENT_NODE ; case Compiler . NODE_TYPE_TEXT : return nodeType = = Node . CDATA_SECTION_NODE | | nodeType = = Node . TEXT_NODE ; else if ( test instanceof NodeTypeTest ) { switch ( ( ( NodeTypeTest ) test ) . getNodeType ( ) ) { case Compiler . NODE_TYPE_NODE : return ( node instanceof Element ) | | ( node instanceof Document ) ; case Compiler . NODE_TYPE_TEXT : return ( node instanceof Text ) | | ( node instanceof CDATA ) ; case Compiler . NODE_TYPE_COMMENT :", "label": 1}
{"buggy_code": "public class test { public void writeRaw ( String text , int offset , int len ) throws IOException { final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . while ( len > 0 ) { int len2 = Math . min ( buf . length , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; writeRaw ( buf , 0 , len2 ) ; / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it offset + = len2 ; len - = len2 ; } if ( ch < = SURR2_LAST ) { / / yes , outside of BMP / / Do we have second part ? if ( inputOffset > = inputEnd | | cbuf = = null ) { / / nope . . . have to note down _reportError ( \" Split surrogate on writeRaw ( ) input ( last character ) \" ) ; } _outputSurrogates ( ch , cbuf [ inputOffset ] ) ; return inputOffset + 1 ;", "fixed_code": "public class test { private void _writeRawSegment ( char [ ] cbuf , int offset , int end ) throws IOException { main_loop : while ( offset < end ) { inner_loop : while ( true ) { int ch = ( int ) cbuf [ offset ] ; if ( ch > 0x7F ) { break inner_loop ; } _outputBuffer [ _outputTail + + ] = ( byte ) ch ; if ( + + offset > = end ) { break main_loop ; } } char ch = cbuf [ offset + + ] ; if ( ch < 0x800 ) { / / 2 - byte ? _outputBuffer [ _outputTail + + ] = ( byte ) ( 0xc0 | ( ch > > 6 ) ) ; _outputBuffer [ _outputTail + + ] = ( byte ) ( 0x80 | ( ch & 0x3f ) ) ; } else { offset = _outputRawMultiByteChar ( ch , cbuf , offset , end ) ; } } } public void writeRaw ( String text , int offset , int len ) throws IOException { final char [ ] buf = _charBuffer ; / / minor optimization : see if we can just get and copy if ( len < = buf . length ) { text . getChars ( offset , offset + len , buf , 0 ) ; _writeRawSegment ( buf , 0 , len ) ; return ; } / / If not , need segmented approach . For speed , let ' s also use input buffer / / size that is guaranteed to fit in output buffer ; each char can expand to / / at most 3 bytes , so at most 1 / 3 of buffer size . final int maxChunk = ( _outputEnd > > 2 ) + ( _outputEnd > > 4 ) ; / / = = ( 1 / 4 + 1 / 16 ) = = 5 / 16 final int maxBytes = maxChunk * 3 ; while ( len > 0 ) { int len2 = Math . min ( maxChunk , len ) ; text . getChars ( offset , offset + len2 , buf , 0 ) ; if ( ( _outputTail + maxBytes ) > _outputEnd ) { _flushBuffer ( ) ; } / / If this is NOT the last segment and if the last character looks like / / split surrogate second half , drop it if ( len > 0 ) { char ch = buf [ len2 - 1 ] ; if ( ( ch > = SURR1_FIRST ) & & ( ch < = SURR1_LAST ) ) { - - len2 ; } } _writeRawSegment ( buf , 0 , len2 ) ; offset + = len2 ; len - = len2 ; } if ( ch < = SURR2_LAST ) { / / yes , outside of BMP / / Do we have second part ? if ( inputOffset > = inputEnd | | cbuf = = null ) { / / nope . . . have to note down _reportError ( String . format ( \" Split surrogate on writeRaw ( ) input ( last character ) : first character 0x % 4x \" , ch ) ) ; } _outputSurrogates ( ch , cbuf [ inputOffset ] ) ; return inputOffset + 1 ;", "label": 1}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 1}
{"buggy_code": "public class test { public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; } } \\ No newline at end of file", "fixed_code": "public class test { public TokenBuffer forceUseOfBigDecimal ( boolean b ) { _forceBigDecimal = b ; return this ; } public TokenBuffer ( JsonParser p , DeserializationContext ctxt ) { _objectCodec = p . getCodec ( ) ; _generatorFeatures = DEFAULT_GENERATOR_FEATURES ; _writeContext = JsonWriteContext . createRootContext ( null ) ; _first = _last = new Segment ( ) ; _appendAt = 0 ; _hasNativeTypeIds = p . canReadTypeId ( ) ; _hasNativeObjectIds = p . canReadObjectId ( ) ; _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds ; _forceBigDecimal = ( ctxt = = null ) ? false : ctxt . isEnabled ( DeserializationFeature . USE_BIG_DECIMAL_FOR_FLOATS ) ; } public void copyCurrentEvent ( JsonParser p ) throws IOException { if ( _mayHaveNativeIds ) { } break ; case VALUE_NUMBER_FLOAT : if ( _forceBigDecimal ) { writeNumber ( p . getDecimalValue ( ) ) ; } else { switch ( p . getNumberType ( ) ) { case BIG_DECIMAL : writeNumber ( p . getDecimalValue ( ) ) ; break ; default : writeNumber ( p . getDoubleValue ( ) ) ; } } break ; case VALUE_TRUE : throw new RuntimeException ( \" Internal error : should never end up through this code path \" ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = type . narrowBy ( subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "fixed_code": "Class < ? > subclass = intr . findDeserializationType ( a , type ) ; if ( subclass ! = null ) { try { type = ctxt . getTypeFactory ( ) . constructSpecializedType ( type , subclass ) ; } catch ( IllegalArgumentException iae ) { throw new JsonMappingException ( \" Failed to narrow type \" + type + \" with concrete - type annotation ( value \" + subclass . getName ( ) + \" ) , method ' \" + a . getName ( ) + \" ' : \" + iae . getMessage ( ) , null , iae ) ; }", "label": 1}
{"buggy_code": "public class test { public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "public class test { public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "label": 1}
{"buggy_code": "public class test { public double getResult ( ) { return optimizer . getResult ( ) ; } public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getResult ( ) { return optima [ 0 ] ; } public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( upper < lower ) { upper = lower ; }  StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "fixed_code": "if ( upper < lower ) { upper = lower ; } if ( upper = = - 1 | | upper > str . length ( ) ) { upper = str . length ( ) ; } StringBuffer result = new StringBuffer ( ) ; int index = StringUtils . indexOf ( str , \" \" , lower ) ; if ( index = = - 1 ) {", "label": 1}
{"buggy_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "fixed_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "label": 1}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1}
{"buggy_code": "public class test { public void tail ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element & & dest . getParentNode ( ) instanceof Element ) { dest = ( Element ) dest . getParentNode ( ) ; / / undescend . cromulent . } } public void head ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespaces . get ( prefix ) ; Element el = doc . createElementNS ( namespace , sourceEl . tagName ( ) ) ; copyAttributes ( sourceEl , el ) ; / / unhandled } } private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = \" \" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespaces . put ( prefix , attr . getValue ( ) ) ; }  int pos = el . tagName ( ) . indexOf ( \" : \" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : \" \" ; } } \\ No newline at end of file", "fixed_code": "public class test { private String updateNamespaces ( org . jsoup . nodes . Element el ) { Attributes attributes = el . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = \" \" ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; }  int pos = el . tagName ( ) . indexOf ( \" : \" ) ; return pos > 0 ? el . tagName ( ) . substring ( 0 , pos ) : \" \" ; } public void head ( org . jsoup . nodes . Node source , int depth ) { namespacesStack . push ( new HashMap < > ( namespacesStack . peek ( ) ) ) ; / / inherit from above on the stack if ( source instanceof org . jsoup . nodes . Element ) { org . jsoup . nodes . Element sourceEl = ( org . jsoup . nodes . Element ) source ; String prefix = updateNamespaces ( sourceEl ) ; String namespace = namespacesStack . peek ( ) . get ( prefix ) ; Element el = doc . createElementNS ( namespace , sourceEl . tagName ( ) ) ; copyAttributes ( sourceEl , el ) ; / / unhandled } } public W3CBuilder ( Document doc ) { this . doc = doc ; this . namespacesStack . push ( new HashMap < String , String > ( ) ) ; } public void tail ( org . jsoup . nodes . Node source , int depth ) { if ( source instanceof org . jsoup . nodes . Element & & dest . getParentNode ( ) instanceof Element ) { dest = ( Element ) dest . getParentNode ( ) ; / / undescend . cromulent . } namespacesStack . pop ( ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) ; } } \\ No newline at end of file", "fixed_code": "if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = ' A ' & & c < = ' Z ' ) | | ( c > = ' a ' & & c < = ' z ' ) | | Character . isLetter ( c ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; return buf ; } private boolean usesDataDescriptor ( final int zipMethod ) { return zipMethod = = DEFLATED & & channel = = null ; } protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ze . getMethod ( ) ! = DEFLATED | | channel ! = null ) { return ; } writeCounted ( DD_SIG ) ;", "fixed_code": "final long localHeaderStart = streamCompressor . getTotalBytesWritten ( ) ; final byte [ ] localHeader = createLocalFileHeader ( ze , name , encodable , phased , localHeaderStart ) ; metaData . put ( ze , new EntryMetaData ( localHeaderStart , usesDataDescriptor ( ze . getMethod ( ) , phased ) ) ) ; entry . localDataStart = localHeaderStart + LFH_CRC_OFFSET ; / / At crc offset writeCounted ( localHeader ) ; entry . dataStart = streamCompressor . getTotalBytesWritten ( ) ; / / store method in local variable to prevent multiple method calls final int zipMethod = ze . getMethod ( ) ; final boolean dataDescriptor = usesDataDescriptor ( zipMethod , phased ) ; putShort ( versionNeededToExtract ( zipMethod , hasZip64Extra ( ze ) , dataDescriptor ) , buf , LFH_VERSION_NEEDED_OFFSET ) ; return buf ; } private boolean usesDataDescriptor ( final int zipMethod , boolean phased ) { return ! phased & & zipMethod = = DEFLATED & & channel = = null ; } protected void writeDataDescriptor ( final ZipArchiveEntry ze ) throws IOException { if ( ! usesDataDescriptor ( ze . getMethod ( ) , false ) ) { return ; } writeCounted ( DD_SIG ) ;", "label": 1}
{"buggy_code": "public class test { public static Evaluator parse ( String query ) { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static Evaluator parse ( String query ) { try { QueryParser p = new QueryParser ( query ) ; return p . parse ( ) ; } catch ( IllegalArgumentException e ) { throw new Selector . SelectorParseException ( e . getMessage ( ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else { tokens . add ( \" - \" + ch ) ; } } }", "fixed_code": "} else { tokens . add ( token ) ; break ; } } }", "label": 1}
{"buggy_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "fixed_code": "String namespace = namespacesStack . peek ( ) . get ( prefix ) ; String tagName = sourceEl . tagName ( ) ; Element el = namespace = = null & & tagName . contains ( \" : \" ) ? doc . createElementNS ( \" \" , tagName ) : / / doesn ' t have a real namespace defined doc . createElementNS ( namespace , tagName ) ; copyAttributes ( sourceEl , el ) ; if ( dest = = null ) { / / sets up the root", "label": 1}
{"buggy_code": "public class test { protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer & & r instanceof Pointer ) { if ( l . equals ( r ) ) { return true ; } } if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } if ( l = = r ) { return true ; } if ( l instanceof Boolean | | r instanceof Boolean ) { return ( InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ) ; } / / if either side is NaN , no comparison returns true : if ( l instanceof Number | | r instanceof Number ) { return ( InfoSetUtil . doubleValue ( l ) = = InfoSetUtil . doubleValue ( r ) ) ; } if ( l instanceof String | | r instanceof String ) { return ( InfoSetUtil . stringValue ( l ) . equals ( InfoSetUtil . stringValue ( r ) ) ) ; } return l ! = null & & l . equals ( r ) ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . FALSE : Boolean . TRUE ; } public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CoreOperationCompare ( Expression arg1 , Expression arg2 ) { this ( arg1 , arg2 , false ) ; } protected CoreOperationCompare ( Expression arg1 , Expression arg2 , boolean invert ) { super ( new Expression [ ] { arg1 , arg2 } ) ; this . invert = invert ; } protected boolean equal ( Object l , Object r ) { if ( l instanceof Pointer ) { l = ( ( Pointer ) l ) . getValue ( ) ; } r = ( ( Pointer ) r ) . getValue ( ) ; } boolean result ; if ( l instanceof Boolean | | r instanceof Boolean ) { result = l = = r | | InfoSetUtil . booleanValue ( l ) = = InfoSetUtil . booleanValue ( r ) ; } else if ( l instanceof Number | | r instanceof Number ) { / / if either side is NaN , no comparison returns true : double ld = InfoSetUtil . doubleValue ( l ) ; if ( Double . isNaN ( ld ) ) { return false ; } double rd = InfoSetUtil . doubleValue ( r ) ; if ( Double . isNaN ( rd ) ) { return false ; } result = ld = = rd ; } else { if ( l instanceof String | | r instanceof String ) { l = InfoSetUtil . stringValue ( l ) ; r = InfoSetUtil . stringValue ( r ) ; } result = l = = r | | l ! = null & & l . equals ( r ) ; } return result ^ invert ; } public Object computeValue ( EvalContext context ) { return equal ( context , args [ 0 ] , args [ 1 ] ) ? Boolean . TRUE : Boolean . FALSE ; } public CoreOperationNotEqual ( Expression arg1 , Expression arg2 ) { super ( arg1 , arg2 , true ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "fixed_code": "String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "label": 1}
{"buggy_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" td \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "fixed_code": "if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag } else if ( ( \" td \" . equals ( name ) | | \" th \" . equals ( name ) & & ! last ) ) { transition ( HtmlTreeBuilderState . InCell ) ; break ; } else if ( \" tr \" . equals ( name ) ) {", "label": 1}
{"buggy_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { } } \\ No newline at end of file", "fixed_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "end - - ; trailer = buffer [ end - 1 ] ; } if ( start = = end ) { throw new IllegalArgumentException ( exceptionMessage ( buffer , offset , length , start , trailer ) ) ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "fixed_code": "end - - ; trailer = buffer [ end - 1 ] ; } for ( ; start < end ; start + + ) { final byte currentByte = buffer [ start ] ;", "label": 1}
{"buggy_code": "public class test { public Object callRealMethod ( ) throws Throwable { return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Object callRealMethod ( ) throws Throwable { if ( this . getMethod ( ) . getDeclaringClass ( ) . isInterface ( ) ) { new Reporter ( ) . cannotCallRealMethodOnInterface ( ) ; } return realMethod . invoke ( mock , rawArguments ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "fixed_code": "for ( int i = 0 ; i < headerRecord . length ; i + + ) { final String header = headerRecord [ i ] ; final boolean containsHeader = hdrMap . containsKey ( header ) ; final boolean emptyHeader = header = = null | | header . trim ( ) . isEmpty ( ) ; if ( containsHeader & & ( ! emptyHeader | | ( emptyHeader & & ! this . format . getIgnoreEmptyHeaders ( ) ) ) ) { throw new IllegalArgumentException ( \" The header contains a duplicate name : \\ \" \" + header + \" \\ \" in \" + Arrays . toString ( headerRecord ) ) ;", "label": 1}
{"buggy_code": "public class test { public Elements siblingElements ( ) {  return parent ( ) . children ( ) ; } public Element nextElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Element previousElementSibling ( ) { List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Node previousSibling ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } public List < Node > siblingNodes ( ) {  return parent ( ) . childNodes ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Element nextElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public Elements siblingElements ( ) { if ( parentNode = = null ) return new Elements ( 0 ) ;  List < Element > elements = parent ( ) . children ( ) ; Elements siblings = new Elements ( elements . size ( ) - 1 ) ; for ( Element el : elements ) if ( el ! = this ) siblings . add ( el ) ; return siblings ; } public Element previousElementSibling ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . children ( ) ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; else return null ; } public List < Node > siblingNodes ( ) { if ( parentNode = = null ) return Collections . emptyList ( ) ;  List < Node > nodes = parentNode . childNodes ; List < Node > siblings = new ArrayList < Node > ( nodes . size ( ) - 1 ) ; for ( Node node : nodes ) if ( node ! = this ) siblings . add ( node ) ; return siblings ; } public Node previousSibling ( ) { if ( parentNode = = null ) return null ; / / root List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; else return null ; } public Elements ( int initialCapacity ) { contents = new ArrayList < Element > ( initialCapacity ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( equalStrings ( testPrefix , nodePrefix ) ) { return true ; } String testNS = null ; if ( testPrefix ! = null ) { testNS = parent . getNamespaceURI ( testPrefix ) ; } String nodeNS = null ; if ( nodePrefix ! = null ) { nodeNS = parent . getNamespaceURI ( nodePrefix ) ; } return equalStrings ( testNS , nodeNS ) ; } return false ; } String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; if ( ns ! = null ) { Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "fixed_code": "if ( testLocalName . equals ( \" * \" ) | | testLocalName . equals ( nodeLocalName ) ) { String testPrefix = name . getPrefix ( ) ; if ( testPrefix = = null | | equalStrings ( testPrefix , nodePrefix ) ) { return true ; } if ( nodePrefix = = null ) { return false ; } return equalStrings ( parent . getNamespaceURI ( testPrefix ) , parent . getNamespaceURI ( nodePrefix ) ) ; } return false ; } String lname = name . getName ( ) ; if ( ! lname . equals ( \" * \" ) ) { attributes = new ArrayList ( ) ; Attribute attr = element . getAttribute ( lname , ns ) ; if ( attr ! = null ) { attributes . add ( attr ) ; } } else { List allAttributes = element . getAttributes ( ) ; for ( int i = 0 ; i < allAttributes . size ( ) ; i + + ) { Attribute attr = ( Attribute ) allAttributes . get ( i ) ; if ( ns = = Namespace . NO_NAMESPACE | | attr . getNamespace ( ) . equals ( ns ) ) { attributes . add ( attr ) ; } }", "label": 1}
{"buggy_code": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragment ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "fixed_code": "public Element prepend ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; List < Node > nodes = fragment . childNodes ( ) ; for ( int i = nodes . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = nodes . get ( i ) ; public Element append ( String html ) { Validate . notNull ( html ) ; Element fragment = Parser . parseBodyFragmentRelaxed ( html , baseUri ( ) ) . body ( ) ; for ( Node node : fragment . childNodes ( ) ) { node . parentNode = null ; appendChild ( node ) ; public Element wrap ( String html ) { Validate . notEmpty ( html ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( html , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) / / nothing to wrap with ; noop", "label": 1}
{"buggy_code": "public class test { private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; } } \\ No newline at end of file", "fixed_code": "public class test { private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . getCurrentToken ( ) = = JsonToken . START_OBJECT ) { p . nextToken ( ) ; return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . getCurrentToken ( ) = = JsonToken . FIELD_NAME ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "fixed_code": "public class test { public ObjectNode deserialize ( JsonParser p , DeserializationContext ctxt ) throws IOException { if ( p . isExpectedStartObjectToken ( ) | | p . hasToken ( JsonToken . FIELD_NAME ) ) { return deserializeObject ( p , ctxt , ctxt . getNodeFactory ( ) ) ; } / / 23 - Sep - 2015 , tatu : Ugh . We may also be given END_OBJECT ( similar to FIELD_NAME ) , / / if caller has advanced to the first token of Object , but for empty Object if ( p . hasToken ( JsonToken . END_OBJECT ) ) { return ctxt . getNodeFactory ( ) . objectNode ( ) ; } throw ctxt . mappingException ( ObjectNode . class ) ; }", "label": 1}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } } \\ No newline at end of file", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 4 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "label": 1}
{"buggy_code": "String encoding ) { this . is = is ; this . hasHitEOF = false ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ;", "fixed_code": "String encoding ) { this . is = is ; this . hasHitEOF = false ; this . encoding = encoding ; this . zipEncoding = ZipEncodingHelper . getZipEncoding ( encoding ) ; this . recordSize = recordSize ; this . blockSize = blockSize ;", "label": 1}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 1}
{"buggy_code": "return false ; } while ( i < end ) { i + + ;", "fixed_code": "return false ; } if ( end > = input . length ) return false ; while ( i < end ) { i + + ;", "label": 1}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 1}
{"buggy_code": "/ / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { String declaration = data . substring ( 1 ) ; insert = new XmlDeclaration ( declaration , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; } } insertNode ( insert ) ;", "fixed_code": "/ / so we do a bit of a hack and parse the data as an element to pull the attributes out String data = comment . getData ( ) ; if ( data . length ( ) > 1 & & ( data . startsWith ( \" ! \" ) | | data . startsWith ( \" ? \" ) ) ) { Document doc = Jsoup . parse ( \" < \" + data . substring ( 1 , data . length ( ) - 1 ) + \" > \" , baseUri , Parser . xmlParser ( ) ) ; Element el = doc . child ( 0 ) ; insert = new XmlDeclaration ( el . tagName ( ) , comment . baseUri ( ) , data . startsWith ( \" ! \" ) ) ; insert . attributes ( ) . addAll ( el . attributes ( ) ) ; } } insertNode ( insert ) ;", "label": 1}
{"buggy_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "fixed_code": "while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = ' \\ t ' | | c = = ' \\ n ' | | c = = ' \\ r ' | | c = = ' \\ f ' | | c = = ' ' | | c = = ' / ' | | c = = ' > ' | | c = = ' < ' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; }", "label": 1}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1}
{"buggy_code": "public class test { private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "public class test { private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1}
{"buggy_code": "public class test { public int hashCode ( ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int hashCode ( ) { return method . hashCode ( ) ; } public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o instanceof DelegatingMethod ) { DelegatingMethod that = ( DelegatingMethod ) o ; return method . equals ( that . method ) ; } else { return method . equals ( o ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} } } if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "fixed_code": "} } } findBoundsByIteration ( ) ; if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "label": 1}
{"buggy_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; / / If we have offset , need to omit that from byte offset , so : _bufferRecyclable = bufferRecyclable ; } } \\ No newline at end of file", "fixed_code": "_inputBuffer = inputBuffer ; _inputPtr = start ; _inputEnd = end ; _currInputRowStart = start ; / / If we have offset , need to omit that from byte offset , so : _currInputProcessed = - start ; _bufferRecyclable = bufferRecyclable ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1}
{"buggy_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "fixed_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( v1D = = null ) { return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line Location loc2 = subLine . remainingRegion . checkPoint ( subLine . line . toSubSpace ( v1D ) ) ;", "label": 1}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "fixed_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "label": 1}
{"buggy_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( config , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom MapLikeType mlType = ( MapLikeType ) type ; ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( config , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } return ser ; } } return null ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( config , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildArraySerializer ( SerializationConfig config , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializationConfig config , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } return ser ; } } \\ No newline at end of file", "fixed_code": "JsonSerializer < Object > keySerializer = _findKeySerializer ( prov , beanDesc . getClassInfo ( ) ) ; if ( mlt . isTrueMapType ( ) ) { return buildMapSerializer ( prov , ( MapType ) mlt , beanDesc , staticTyping , keySerializer , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations JsonSerializer < ? > ser = null ; MapLikeType mlType = ( MapLikeType ) type ; for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findMapLikeSerializer ( config , mlType , beanDesc , keySerializer , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyMapLikeSerializer ( config , mlType , beanDesc , ser ) ; } } } return ser ; } if ( type . isCollectionLikeType ( ) ) { CollectionLikeType clt = ( CollectionLikeType ) type ; if ( clt . isTrueCollectionType ( ) ) { return buildCollectionSerializer ( prov , ( CollectionType ) clt , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } / / With Map - like , just 2 options : ( 1 ) Custom , ( 2 ) Annotations for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findCollectionLikeSerializer ( config , clType , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } } if ( ser = = null ) { / / ( 2 ) Annotations - based ones : ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; } if ( ser ! = null ) { if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyCollectionLikeSerializer ( config , clType , beanDesc , ser ) ; } } } return ser ; } if ( type . isArrayType ( ) ) { return buildArraySerializer ( prov , ( ArrayType ) type , beanDesc , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } return null ; } protected JsonSerializer < ? > buildCollectionSerializer ( SerializerProvider prov , CollectionType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ; / / Order of lookups : / / 1 . Custom serializers } if ( ser = = null ) { ser = findSerializerByAnnotations ( prov , type , beanDesc ) ; / / ( 2 ) Annotations if ( ser = = null ) { / / We may also want to use serialize Collections \" as beans \" , if ( and only if ) / / this is specified with ` @ JsonFormat ( shape = Object ) ` JsonFormat . Value format = beanDesc . findExpectedFormat ( null ) ; if ( ser = = null ) { ser = buildCollectionSerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } } } } return ser ; } protected JsonSerializer < ? > buildArraySerializer ( SerializerProvider prov , ArrayType type , BeanDescription beanDesc , boolean staticTyping , TypeSerializer elementTypeSerializer , JsonSerializer < Object > elementValueSerializer ) throws JsonMappingException { SerializationConfig config = prov . getConfig ( ) ; JsonSerializer < ? > ser = null ;  for ( Serializers serializers : customSerializers ( ) ) { / / ( 1 ) Custom ser = serializers . findArraySerializer ( config , type , beanDesc , elementTypeSerializer , elementValueSerializer ) ; if ( ser ! = null ) { break ; } }  if ( ser = = null ) { Class < ? > raw = type . getRawClass ( ) ; if ( elementValueSerializer = = null | | ClassUtil . isJacksonStdImpl ( elementValueSerializer ) ) { if ( String [ ] . class = = raw ) { ser = StringArraySerializer . instance ; } else { ser = StdArraySerializers . findStandardImpl ( raw ) ; } } if ( ser = = null ) { ser = new ObjectArraySerializer ( type . getContentType ( ) , staticTyping , elementTypeSerializer , elementValueSerializer ) ; } } if ( _factoryConfig . hasSerializerModifiers ( ) ) { for ( BeanSerializerModifier mod : _factoryConfig . serializerModifiers ( ) ) { ser = mod . modifyArraySerializer ( config , type , beanDesc , ser ) ; } } return ser ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , _superClass , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } } \\ No newline at end of file", "fixed_code": "} / / 15 - Jan - 2015 , tatu : Not correct ; should really re - resolve . . . return new SimpleType ( subclass , _bindings , this , _superInterfaces , _valueHandler , _typeHandler , _asStatic ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1}
{"buggy_code": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "fixed_code": "@ Override void write ( JsonWriter writer , Object value ) throws IOException , IllegalAccessException { Object fieldValue = field . get ( value ) ; TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper ( context , typeAdapter , fieldType . getType ( ) ) ; t . write ( writer , fieldValue ) ; } @ Override void read ( JsonReader reader , Object value )", "label": 1}
{"buggy_code": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; return new JsonLocation ( src , - 1L , getTokenCharacterOffset ( ) , getTokenLineNr ( ) , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public JsonLocation getTokenLocation ( ) { final Object src = _ioContext . getSourceReference ( ) ; if ( _currToken = = JsonToken . FIELD_NAME ) { return new JsonLocation ( src , - 1L , _nameInputTotal , _nameInputRow , _tokenInputCol ) ; } return new JsonLocation ( src , - 1L , _tokenInputTotal , _tokenInputRow , getTokenColumnNr ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were return new ObjectIdReferenceProperty ( this , deser , _nullProvider ) ; } } \\ No newline at end of file", "fixed_code": "return this ; } / / 07 - May - 2019 , tatu : As per [ databind # 2303 ] , must keep VD / NVP in - sync if they were NullValueProvider nvp = ( _valueDeserializer = = _nullProvider ) ? deser : _nullProvider ; return new ObjectIdReferenceProperty ( this , deser , nvp ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1}
{"buggy_code": "} else if ( len = = 0 ) { return 0 ; } else { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } return base64 . readResults ( b , offset , len ) ; } } } \\ No newline at end of file", "fixed_code": "} else if ( len = = 0 ) { return 0 ; } else { int readLen = 0 ; while ( readLen = = 0 ) { if ( ! base64 . hasData ( ) ) { byte [ ] buf = new byte [ doEncode ? 4096 : 8192 ] ; int c = in . read ( buf ) ; base64 . decode ( buf , 0 , c ) ; } } readLen = base64 . readResults ( b , offset , len ) ; } return readLen ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } } \\ No newline at end of file", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; } + iter ;", "label": 1}
{"buggy_code": "public class test { public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : }", "fixed_code": "public class test { public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } public String valueToString ( Object value ) { throw new IllegalStateException ( ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; if ( ! _verifyBigDecimalRange ( gen , bd ) ) { final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "label": 1}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1}
{"buggy_code": "public class test { public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * 6D - 15D ) + 10D ) ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "fixed_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1}
{"buggy_code": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "fixed_code": "{ VisibilityChecker < ? > vchecker = super . getDefaultVisibilityChecker ( ) ; / / then global overrides ( disabling ) if ( ! isEnabled ( MapperFeature . AUTO_DETECT_SETTERS ) ) { vchecker = vchecker . withSetterVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_CREATORS ) ) { vchecker = vchecker . withCreatorVisibility ( Visibility . NONE ) ; } if ( ! isEnabled ( MapperFeature . AUTO_DETECT_GETTERS ) ) { vchecker = vchecker . withGetterVisibility ( Visibility . NONE ) ; }", "label": 1}
{"buggy_code": "public class test { protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , e . getMessage ( ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , re . getMessage ( ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "fixed_code": "public class test { protected Object _weirdKey ( DeserializationContext ctxt , String key , Exception e ) throws IOException { return ctxt . handleWeirdKey ( _keyClass , key , \" problem : % s \" , ClassUtil . exceptionMessage ( e ) ) ; } public Object deserializeKey ( String key , DeserializationContext ctxt ) throws IOException } catch ( Exception re ) { return ctxt . handleWeirdKey ( _keyClass , key , \" not a valid representation , problem : ( % s ) % s \" , re . getClass ( ) . getName ( ) , ClassUtil . exceptionMessage ( re ) ) ; } if ( _keyClass . isEnum ( ) & & ctxt . getConfig ( ) . isEnabled ( DeserializationFeature . READ_UNKNOWN_ENUM_VALUES_AS_NULL ) ) { return null ;", "label": 1}
{"buggy_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that p . nextToken ( ) ; tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "fixed_code": "/ / if so , need to copy all remaining tokens into buffer while ( t = = JsonToken . FIELD_NAME ) { / / NOTE : do NOT skip name as it needs to be copied ; ` copyCurrentStructure ` does that tokens . copyCurrentStructure ( p ) ; t = p . nextToken ( ) ; } / / 28 - Aug - 2018 , tatu : Let ' s add sanity check here , easier to catch off - by - some / / problems if we maintain invariants if ( t ! = JsonToken . END_OBJECT ) { ctxt . reportWrongTokenException ( this , JsonToken . END_OBJECT , \" Attempted to unwrap ' % s ' value \" , handledType ( ) . getName ( ) ) ; } tokens . writeEndObject ( ) ; if ( bean . getClass ( ) ! = _beanType . getRawClass ( ) ) { / / ! ! ! 08 - Jul - 2011 , tatu : Could probably support ; but for now", "label": 1}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1}
{"buggy_code": "public class test { boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . nodeName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . nodeName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . nodeName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . nodeName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . nodeName ( ) . equals ( b . nodeName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . nodeName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . nodeName ( ) ) ; / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . nodeName ( ) , nodeNames ) | | next . nodeName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . nodeName ( ) , elNames ) ) break ; } } private Tag ( String tagName ) { this . tagName = tagName ; } } \\ No newline at end of file", "fixed_code": "public class test { public String normalName ( ) { return tag . normalName ( ) ; } boolean inSelectScope ( String targetName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . normalName ( ) ; if ( elName . equals ( targetName ) ) return true ; if ( ! inSorted ( elName , TagSearchSelectScope ) ) / / all elements except for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) break ; } } Element next = formattingElements . get ( pos ) ; if ( next = = null ) / / scope marker break ; else if ( next . normalName ( ) . equals ( nodeName ) ) return next ; } return null ; last = true ; node = contextElement ; } String name = node . normalName ( ) ; if ( \" select \" . equals ( name ) ) { transition ( HtmlTreeBuilderState . InSelect ) ; break ; / / frag / / don ' t walk too far up the tree for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . normalName ( ) ; if ( inSorted ( elName , targetNames ) ) return true ; if ( inSorted ( elName , baseTypes ) ) boolean isSpecial ( Element el ) { / / todo : mathml ' s mi , mo , mn / / todo : svg ' s foreigObject , desc , title String name = el . normalName ( ) ; return inSorted ( name , TagSearchSpecial ) ; } private boolean isSameFormattingElement ( Element a , Element b ) { / / same if : same namespace , tag , and attributes . Element . equals only checks tag , might in future check children return a . normalName ( ) . equals ( b . normalName ( ) ) & & / / a . namespace ( ) . equals ( b . namespace ( ) ) & & a . attributes ( ) . equals ( b . attributes ( ) ) ; / / todo : namespaces Element getFromStack ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { return next ; } } void popStackToBefore ( String elName ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next . normalName ( ) . equals ( elName ) ) { break ; } else { stack . remove ( pos ) ; / / 8 . create new element from element , 9 insert into current node , onto stack skip = false ; / / can only skip increment from 4 . Element newEl = insertStartTag ( entry . normalName ( ) ) ; / / todo : avoid fostering here ? / / newEl . namespace ( entry . namespace ( ) ) ; / / todo : namespaces newEl . attributes ( ) . addAll ( entry . attributes ( ) ) ; private void clearStackToContext ( String . . . nodeNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( StringUtil . in ( next . normalName ( ) , nodeNames ) | | next . normalName ( ) . equals ( \" html \" ) ) break ; else stack . remove ( pos ) ; } } void generateImpliedEndTags ( String excludeTag ) { while ( ( excludeTag ! = null & & ! currentElement ( ) . normalName ( ) . equals ( excludeTag ) ) & & inSorted ( currentElement ( ) . normalName ( ) , TagSearchEndTags ) ) pop ( ) ; } void popStackToClose ( String . . . elNames ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; stack . remove ( pos ) ; if ( inSorted ( next . normalName ( ) , elNames ) ) break ; } } private Tag ( String tagName ) { this . tagName = tagName ; normalName = Normalizer . lowerCase ( tagName ) ; } public String normalName ( ) { return normalName ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1}
{"buggy_code": "public class test { void addNumber ( double x ) { / / This is not pretty printing . This is to prevent misparsing of x - - 4 as / / x - - 4 ( which is a syntax error ) . add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; }  } } \\ No newline at end of file", "fixed_code": "public class test { static boolean isNegativeZero ( double x ) { return x = = 0 . 0 & & Math . copySign ( 1 , x ) = = - 1 . 0 ; } void addNumber ( double x ) { / / This is not pretty printing . This is to prevent misparsing of x - - 4 as / / x - - 4 ( which is a syntax error ) . add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ; } else { add ( String . valueOf ( x ) ) ; } } } \\ No newline at end of file", "label": 1}
{"buggy_code": "public class test { public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` return ToStringSerializer . instance ; default : } if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : return ToStringSerializer . instance ; default : }", "fixed_code": "public class test { public boolean isEmpty ( SerializerProvider prov , Object value ) { return valueToString ( value ) . isEmpty ( ) ; } public String valueToString ( Object value ) { throw new IllegalStateException ( ) ; } public void serialize ( Object value , JsonGenerator gen , SerializerProvider provider ) throws IOException { final String text ; if ( gen . isEnabled ( JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) ) { final BigDecimal bd = ( BigDecimal ) value ; if ( ! _verifyBigDecimalRange ( gen , bd ) ) { final String errorMsg = String . format ( \" Attempt to write plain ` java . math . BigDecimal ` ( see JsonGenerator . Feature . WRITE_BIGDECIMAL_AS_PLAIN ) with illegal scale ( % d ) : needs to be between [ - % d , % d ] \" , bd . scale ( ) , MAX_BIG_DECIMAL_SCALE , MAX_BIG_DECIMAL_SCALE ) ; provider . reportMappingProblem ( errorMsg ) ; } text = bd . toPlainString ( ) ; } else { text = value . toString ( ) ; } gen . writeString ( text ) ; } public BigDecimalAsStringSerializer ( ) { super ( BigDecimal . class ) ; } public static JsonSerializer < ? > bigDecimalAsStringSerializer ( ) { return BigDecimalAsStringSerializer . BD_INSTANCE ; } protected boolean _verifyBigDecimalRange ( JsonGenerator gen , BigDecimal value ) throws IOException { int scale = value . scale ( ) ; return ( ( scale > = - MAX_BIG_DECIMAL_SCALE ) & & ( scale < = MAX_BIG_DECIMAL_SCALE ) ) ; } public JsonSerializer < ? > createContextual ( SerializerProvider prov , BeanProperty property ) throws JsonMappingException { switch ( format . getShape ( ) ) { case STRING : / / [ databind # 2264 ] : Need special handling for ` BigDecimal ` if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : } if ( format ! = null ) { switch ( format . getShape ( ) ) { case STRING : if ( ( ( Class < ? > ) handledType ( ) ) = = BigDecimal . class ) { return NumberSerializer . bigDecimalAsStringSerializer ( ) ; } return ToStringSerializer . instance ; default : }", "label": 1}
{"buggy_code": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "fixed_code": "| | chars [ i ] = = ' F ' ) ) { return foundDigit ; } if ( hasDecPoint | | hasExp ) { return false ; } if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point", "label": 1}
{"buggy_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , TypeBindings . emptyBindings ( ) ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , null ) ; } return constructParametricType ( parametrized , pt ) ; }", "fixed_code": "/ / also : if we start from untyped , not much to save do { / / bogus loop to be able to break if ( rawBase = = Object . class ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } if ( ! rawBase . isAssignableFrom ( subclass ) ) { / / ( 1 ) Original target type has no generics - - just resolve subtype if ( baseType . getBindings ( ) . isEmpty ( ) ) { newType = _fromClass ( null , subclass , EMPTY_BINDINGS ) ; break ; } / / ( 2 ) A small set of \" well - known \" List / Map subtypes where can take a short - cut int len = parameterClasses . length ; JavaType [ ] pt = new JavaType [ len ] ; for ( int i = 0 ; i < len ; + + i ) { pt [ i ] = _fromClass ( null , parameterClasses [ i ] , EMPTY_BINDINGS ) ; } return constructParametricType ( parametrized , pt ) ; }", "label": 1}
{"buggy_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "fixed_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "label": 1}
{"buggy_code": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref ! = null ) { objectIdInfo = objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } return objectIdInfo ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , new ObjectIdInfo ( NAME_FOR_OBJECT_REF , null , null , null ) ) ; oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "fixed_code": "public class test { public ObjectIdInfo findObjectReferenceInfo ( Annotated ann , ObjectIdInfo objectIdInfo ) { JsonIdentityReference ref = _findAnnotation ( ann , JsonIdentityReference . class ) ; if ( ref = = null ) { return objectIdInfo ; } if ( objectIdInfo = = null ) { objectIdInfo = ObjectIdInfo . empty ( ) ; } return objectIdInfo . withAlwaysAsId ( ref . alwaysAsId ( ) ) ; } public static ObjectIdInfo empty ( ) { return EMPTY ; } public JsonSerializer < ? > createContextual ( SerializerProvider provider , BeanProperty property ) if ( objectIdInfo = = null ) { / / no ObjectId override , but maybe ObjectIdRef ? if ( oiw ! = null ) { objectIdInfo = intr . findObjectReferenceInfo ( accessor , null ) ; if ( objectIdInfo ! = null ) { oiw = _objectIdWriter . withAlwaysAsId ( objectIdInfo . getAlwaysAsId ( ) ) ; } } } else { / / Ugh : mostly copied from BeanDeserializerBase : but can ' t easily change it", "label": 1}
{"buggy_code": ": new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; } toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the", "fixed_code": ": new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; } toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the", "label": 1}
{"buggy_code": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "fixed_code": "/ / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "label": 1}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; }", "label": 1}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "label": 1}
{"buggy_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "fixed_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "label": 1}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1}
{"buggy_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "fixed_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "label": 1}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 1}
{"buggy_code": "public class test { protected void setName ( String name ) { this . name = name ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void setName ( String name ) { if ( name ! = null & & getPlatform ( ) = = PLATFORM_FAT & & name . indexOf ( \" / \" ) = = - 1 ) { name = name . replace ( ' \\ \\ ' , ' / ' ) ; } this . name = name ; } } \\ No newline at end of file", "label": 1}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0}
{"buggy_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } } } \\ No newline at end of file", "fixed_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "label": 0}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0}
{"buggy_code": "public class test { public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , inputSigma , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CMAESOptimizer ( int lambda , double [ ] inputSigma ) { this ( lambda , null , DEFAULT_MAXITERATIONS , DEFAULT_STOPFITNESS , DEFAULT_ISACTIVECMA , DEFAULT_DIAGONALONLY , DEFAULT_CHECKFEASABLECOUNT , DEFAULT_RANDOMGENERATOR , false ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; }", "fixed_code": "if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return 0 ; } else { return 0 ; }", "label": 0}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } } return out ;", "label": 0}
{"buggy_code": "public class test { private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } sb . append ( quote ) ; return sb . toString ( ) ; } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "fixed_code": "public class test { static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } sb . append ( quote ) ; return sb . toString ( ) ; } private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0}
{"buggy_code": "/ / we have more points before the sign change , drop the lowest point } else { / / we have more points after sign change , drop the highest point - end ; }", "fixed_code": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; / / we have more points after sign change , drop the highest point }", "label": 0}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0}
{"buggy_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; } } \\ No newline at end of file", "fixed_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; ensureCapacity ( size + 5 ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "label": 0}
{"buggy_code": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 0}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; dMin = Math . min ( dMin , dN1 ) ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0}
{"buggy_code": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "fixed_code": "String typeName = aliasReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( typeName ) ) ; String replacement = aliasExpanded + typeName . substring ( aliasName . length ( ) ) ; aliasReference . setString ( replacement ) ;", "label": 0}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "label": 0}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "public class test { protected double getInitialDomain ( double y ) { return Math . PI ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i > j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int mIndex = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } } \\ No newline at end of file", "fixed_code": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 0}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "fixed_code": "public class test { public final void translate ( CharSequence input , Writer out ) throws IOException { if ( out ! = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } if ( input = = null ) {", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < 0 . 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "public class test { public int indexOf ( String str , int startIndex ) { startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } if ( strLen > size ) { return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "fixed_code": "public class test { public int indexOf ( String str , int startIndex ) { if ( buffer . length > length ( ) ) { char [ ] old = buffer ; buffer = new char [ length ( ) ] ; System . arraycopy ( old , 0 , buffer , 0 , size ) ; } startIndex = ( startIndex < 0 ? 0 : startIndex ) ; if ( str = = null | | startIndex > = size ) { return - 1 ; if ( strLen = = 0 ) { return startIndex ; } ensureCapacity ( size + 4 ) ; char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer :", "label": 0}
{"buggy_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; cDateTimeInstanceCache . put ( key , format ) ; } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) { Object key = new Integer ( style ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) {", "fixed_code": "locale ) ; String pattern = formatter . toPattern ( ) ; format = getInstance ( pattern , timeZone , locale ) ; if ( pattern = = null ) { throw new IllegalArgumentException ( \" The pattern must not be null \" ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" No date time pattern for locale : \" + locale ) ; return format ; } public static synchronized FastDateFormat getDateInstance ( int style , TimeZone timeZone , Locale locale ) {  Object key = new Integer ( style ) ; if ( locale = = null ) { locale = Locale . getDefault ( ) ; } if ( locale ! = null ) {", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' :", "label": 0}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0}
{"buggy_code": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "if ( masd ! = null ) { result = masd . getMean ( ) ; } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { int nextr = 0 ; minRow = row ; } }", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 0}
{"buggy_code": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { public double density ( final double [ ] vals ) throws DimensionMismatchException { final int dim = getDimension ( ) ; if ( vals . length ! = dim ) { throw new DimensionMismatchException ( vals . length , dim ) ; }  return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double density ( double [ ] list ) { double m = Double . NEGATIVE_INFINITY ; for ( double x : list ) m = Math . max ( m , x ) ; return m ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( str = = \" true \" ) { return true ; } if ( str = = null ) { return false ; } switch ( str . length ( ) ) { case 2 : { char ch0 = str . charAt ( 0 ) ; char ch1 = str . charAt ( 1 ) ; return ( ch0 = = ' o ' | | ch0 = = ' O ' ) & & ( ch1 = = ' n ' | | ch1 = = ' N ' ) ; } case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) { return ( str . charAt ( 1 ) = = ' r ' | | str . charAt ( 1 ) = = ' R ' ) & & ( str . charAt ( 2 ) = = ' u ' | | str . charAt ( 2 ) = = ' U ' ) & & ( str . charAt ( 3 ) = = ' e ' | | str . charAt ( 3 ) = = ' E ' ) ; } if ( ch = = ' T ' ) { return ( str . charAt ( 1 ) = = ' R ' | | str . charAt ( 1 ) = = ' r ' ) & & ( str . charAt ( 2 ) = = ' U ' | | str . charAt ( 2 ) = = ' u ' ) & & ( str . charAt ( 3 ) = = ' E ' | | str . charAt ( 3 ) = = ' e ' ) ; } } } return false ; }", "fixed_code": "if ( str = = \" true \" ) { return true ; } if ( \" true \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" false \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" on \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" off \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } else if ( \" yes \" . equalsIgnoreCase ( str ) ) { return Boolean . TRUE ; } else if ( \" no \" . equalsIgnoreCase ( str ) ) { return Boolean . FALSE ; } if ( str = = null ) { return false ; } if ( StringUtils . isEmpty ( str ) ) { return false ; } return false ; }", "label": 0}
{"buggy_code": "public class test { private void handleBlockComment ( Comment comment ) {", "fixed_code": "public class test { private void handleBlockComment ( Comment comment ) {", "label": 0}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0}
{"buggy_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; - i ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "fixed_code": "for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } setStateInitialized ( false ) ; return eventT ; } ta = forward ? ta + convergence : ta - convergence ; ga = f . value ( ta ) ; } else if ( Double . isNaN ( previousEventTime ) | | ( FastMath . abs ( previousEventTime - root ) > convergence ) & & ! ( ( nextAction = = EventHandler . Action . RESET_STATE ) | | ( nextAction = = EventHandler . Action . RESET_DERIVATIVES ) ) ) { pendingEventTime = root ; pendingEvent = true ; return true ; } else { ta = tb ; ga = gb ; }", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "label": 0}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; } } \\ No newline at end of file", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return 1 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; }", "fixed_code": "if ( node2 = = null ) { throw new IllegalStateException ( ) ; } if ( com . google . javascript . rhino . Node . PROPERTY_FLAG = = com . google . javascript . rhino . Node . this . first . getType ( ) ) { res = n . checkTreeEqualsImpl ( n2 ) ; } if ( res ! = null ) { return res ; }", "label": 0}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "label": 0}
{"buggy_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "fixed_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "label": 0}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "fixed_code": "double xA = x [ signChangeIndex - 1 ] ; double yA = y [ signChangeIndex - 1 ] ; double absYA = FastMath . abs ( yA ) ; signChangeIndex = 2 ; int agingA = 0 ; double xB = x [ signChangeIndex ] ; double yB = y [ signChangeIndex ] ;", "label": 0}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } } j - = 4 ; }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 | | this . foregroundDomainMarkers ! = null ) { return ; }", "label": 0}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( size + 4 ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = Math . PI / 2 . 0 ; + idx ; }", "label": 0}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; - size ; + + count ; return previous ; } } \\ No newline at end of file", "fixed_code": "final double previous = values [ index ] ; values [ index ] = missingEntries ; if ( states [ index ] = = FULL ) { return changeIndexSign ( index ) ; } return previous ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : u = - u ; / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without", "label": 0}
{"buggy_code": "return x ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } } \\ No newline at end of file", "fixed_code": "return x ; } double [ ] res = new double [ x . length ] ; this . valueRange = valueRange ; return res ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "fixed_code": "return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ; parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ;", "label": 0}
{"buggy_code": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "fixed_code": "final double gb = handler . g ( tb , interpolator . getInterpolatedState ( ) ) ; / / check events occurrence if ( ( pendingEvent ) & & ( ( java . lang . Math . abs ( ( t1 - ( pendingEventTime ) ) ) ) < = ( convergence ) ) ) { return false ; } if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step", "label": 0}
{"buggy_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "fixed_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0}
{"buggy_code": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } drawBackground ( g2 , plotArea ) ;", "fixed_code": "info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; } if ( info = = null ) { return ; } drawBackground ( g2 , plotArea ) ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0}
{"buggy_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return 3 ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0}
{"buggy_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0}
{"buggy_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0}
{"buggy_code": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0}
{"buggy_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( tryBlock , exitType , labelName ) ; } }", "label": 0}
{"buggy_code": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , parseOffset ( id ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < 32 ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & info . getLendsName ( ) ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "fixed_code": "case Token . OBJECTLIT : JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & this . sourceName ! = null ) { if ( lentObjectLiterals = = null ) { lentObjectLiterals = Lists . newArrayList ( ) ; }", "label": 0}
{"buggy_code": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "fixed_code": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "label": 0}
{"buggy_code": "public class test { public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "public class test { public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0}
{"buggy_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "fixed_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0}
{"buggy_code": "} else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } } \\ No newline at end of file", "fixed_code": "} else { replacement = Node . newNumber ( value ) ; } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } } \\ No newline at end of file", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { if ( com . google . javascript . rhino . Node . this . type < = com . google . javascript . rhino . Node . LABEL_PROP ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } } return null ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( parent . isDo ( ) & & parent . getLastChild ( ) = = n ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "fixed_code": "try { parser . parseArgument ( processedArgs . toArray ( new String [ ] { } ) ) ; } catch ( CmdLineException e ) { System . err . println ( e . getMessage ( ) ) ; isConfigValid = false ; }", "label": 0}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkMissingReturn = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_STOPPED ) { throw new IllegalStateException ( \" Stopwatch must be reset before being restarted . \" ) ; } return ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "} / / Check whether the extended interfaces have any conflicts if ( functionType . getExtendedInterfacesCount ( ) > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "fixed_code": "} / / Check whether the extended interfaces have any conflicts if ( typedCount > 1 ) { / / Only check when extending more than one interfaces HashMap < String , ObjectType > properties = new HashMap < String , ObjectType > ( ) ;", "label": 0}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( t1 - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "fixed_code": "forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final int n = Math . max ( 1 , ( int ) Math . ceil ( Math . abs ( convergence - t0 ) / maxCheckInterval ) ) ; final double h = ( t1 - t0 ) / n ; double ta = t0 ;", "label": 0}
{"buggy_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 0 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tType = - 5 ; return true ; } return false ;", "label": 0}
{"buggy_code": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over", "fixed_code": "/ / get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit int increase = 0 ; for ( int i = 0 ; i < textIndex ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; } } / / have upper - bound at 20 % increase , then let Java take over", "label": 0}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { pos . setIndex ( pos . getIndex ( ) + 1 ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0}
{"buggy_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "fixed_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { System . out . println ( \" Writing ZoneInfoMap \" ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( p < = 0 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ! an . isExprResult ( ) ) continue ; int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0}
{"buggy_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; }", "fixed_code": "throw new IllegalStateException ( ) ; } res = n . checkTreeEqualsImpl ( n2 ) ; return res ; } return res ; }", "label": 0}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0}
{"buggy_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling :", "fixed_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { } / / 2 . apply Bland ' s rule to prevent cycling :", "label": 0}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "fixed_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) & & id = = null ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence . renameAppend ( \" - Summer \" ) , tailZone . iEndRecurrence ) ; } else { tailZone = new DSTZone ( tailZone . getID ( ) , tailZone . iStandardOffset , tailZone . iStartRecurrence , tailZone . iEndRecurrence . renameAppend ( \" - Summer \" ) ) ; } }", "label": 0}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "public class test { public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "fixed_code": "public class test { public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( p = = 1 . 0 ) { return upper ; } } }", "label": 0}
{"buggy_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . weekyear ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 0}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0}
{"buggy_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0}
{"buggy_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0}
{"buggy_code": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "fixed_code": "FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . toMaybeEnumElementType ( ) ) ; } else { ensureTyped ( t , n ) ; }", "label": 0}
{"buggy_code": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { finallyMap . put ( lastJump , null ) ; } } } \\ No newline at end of file", "fixed_code": "if ( lastJump = = null ) { createEdge ( node , Branch . UNCOND , null ) ; } else { if ( com . google . javascript . jscomp . ControlFlowAnalysis . this . shouldTraverseFunctions ) { finallyMap . put ( lastJump , null ) ; } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "label": 0}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "fixed_code": "boolean tooltips , boolean urls ) { RingPlot plot = new RingPlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ;", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) ,", "label": 0}
{"buggy_code": "/ / check convergence return ; } }", "fixed_code": "/ / check convergence return ; } return ; }", "label": 0}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0}
{"buggy_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( org . jfree . chart . renderer . category . AbstractCategoryItemRenderer . this . plot ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . float sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 0}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0}
{"buggy_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "fixed_code": "LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; h [ 0 ] = size . height ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) {", "label": 0}
{"buggy_code": "public class test { private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { private static int greatestCommonDivisor ( int u , int v ) { if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0}
{"buggy_code": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "fixed_code": "break ; case BOTH : final SubHyperplane . SplitSubHyperplane < S > split = other . split ( inserted ) ; plusList . add ( 0 , split . getPlus ( ) ) ; minusList . add ( split . getMinus ( ) ) ; break ; default :", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; } if ( y = = ( long ) y ) {", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return StrictMath . pow ( x , y ) ; } if ( y = = ( long ) y ) {", "label": 0}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return", "label": 0}
{"buggy_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file", "fixed_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } } } \\ No newline at end of file", "label": 0}
{"buggy_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) { repaired [ i ] = 1 . 0 ; } else { repaired [ i ] = x [ i ] ; }", "fixed_code": "if ( x [ i ] < 0 ) { repaired [ i ] = 0 ; } else if ( x [ i ] > 1 . 0 ) {  } else { repaired [ i ] = x [ i ] ; }", "label": 0}
