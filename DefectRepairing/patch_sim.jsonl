{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "label": 0}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( tmp = = - 1 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 0}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0}
{"buggy_code": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "fixed_code": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "label": 0}
{"buggy_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; yDotOnScale2 + = ratio * ratio ; } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "fixed_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { yDotOnScale2 + = ratio * ratio ; } } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "label": 0}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; }", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; }", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } @ Override", "label": 0}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } protected enum Method {", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } protected enum Method {", "label": 0}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; }", "label": 0}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } }", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } }", "label": 0}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0}
{"buggy_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( x0 = = x2 ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "fixed_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "label": 0}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0}
{"buggy_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { / / cases 7 and 8 . tType = - 7 ;", "fixed_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { / / cases 7 and 8 . tType = - 7 ;", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 0}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "label": 0}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0}
{"buggy_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "fixed_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { newValues [ i ] = value ; } System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "label": 0}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0}
{"buggy_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "label": 0}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } return result ; }", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; }", "label": 0}
{"buggy_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "fixed_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "label": 0}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 0}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "label": 0}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 0}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 0}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 0}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 0}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } }", "label": 0}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { Only in Chart1b_Patch2 / source / org / jfree / chart / renderer / category : AbstractCategoryItemRenderer . java . orig", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) { Only in Chart1b_Patch2 / source / org / jfree / chart / renderer / category : AbstractCategoryItemRenderer . java . orig", "label": 0}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0}
{"buggy_code": "} / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) {  b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 0}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 0}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; }  public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 0}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 0}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 0}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 0}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 0}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { } } }", "label": 0}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) columnsToDrop . add ( i ) ; } }", "label": 0}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { } else { - end ; }  / / we need to do one more attempt nextX = Double . NaN ;", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( true ) { + start ; } else { } / / we need to do one more attempt nextX = Double . NaN ;", "label": 0}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 0}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0}
{"buggy_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) return false ; } }", "label": 0}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "label": 0}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 0}
{"buggy_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "fixed_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; }", "label": 0}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( - 1 < = delta ) delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "label": 0}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "label": 0}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0}
{"buggy_code": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "fixed_code": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "label": 0}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "label": 0}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "label": 0}
{"buggy_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; }", "label": 0}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; }", "label": 0}
{"buggy_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "fixed_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "label": 0}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; }", "label": 0}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "label": 0}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "label": 0}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0}
{"buggy_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "label": 0}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 0}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } }", "label": 0}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "label": 0}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 0}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 0}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 0}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0}
