{"buggy_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; }", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch51", "project_name": "Math_85"}
{"buggy_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_30"}
{"buggy_code": "public class test { public void setShape ( int index , Shape shape ) { set ( index , shape ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_6"}
{"buggy_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Lang_59"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } incrementIterationsCounter ( ) ; } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch32", "project_name": "Math_28"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Math_5"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_61"}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_5"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; } } \\ No newline at end of file", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_28"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch16", "project_name": "Math_63"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_57"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_9"}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Lang_59"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0, "tool_name": "CapGen", "patch_name": "patch52", "project_name": "Lang_59"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "public class test { public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_93"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_70"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + idx ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_56"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch54", "project_name": "Math_85"}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Chart_13"}
{"buggy_code": "public class test { public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "public class test { public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Math_80"}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "fixed_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Math_80"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch4", "project_name": "Math_28"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Math_63"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; }", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Time_12"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Closure_19"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Closure_92"}
{"buggy_code": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_75"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront ( return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront ( return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_110"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_117"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin = dN1 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ;  } }", "label": 0, "tool_name": "Arja", "patch_name": "patch28", "project_name": "Math_28"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; }", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_31"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_97"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch57", "project_name": "Math_85"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Lang_20"}
{"buggy_code": "public class test { public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalMean ( ) { return ( ( double ) ( ( getSampleSize ( ) ) * ( ( getNumberOfSuccesses ( ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ) ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch37", "project_name": "Math_85"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin2 = 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_38"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_18"}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } } \\ No newline at end of file", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_123"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; } } \\ No newline at end of file", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; int iter = 0 ; while ( true ) { + + iter ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( iter , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; int iter = 0 ; for ( boolean converged = false ; ! converged ; ) { + + iter ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( iter , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; while ( true ) { incrementIterationCount ( ) ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( getIterations ( ) , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_15"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_18"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tau = 0 . 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch36", "project_name": "Math_80"}
{"buggy_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } } \\ No newline at end of file", "fixed_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_45"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_43"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_63"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Math_5"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Chart_12"}
{"buggy_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "fixed_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public class test { public int getSize ( ) { return totalSize ; } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getSize ( ) { return 0 ; } public boolean hasNext ( ) { return false ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Math_56"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_86"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch3", "project_name": "Math_22"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch4", "project_name": "Chart_25"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch3", "project_name": "Math_73"}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { / / accept the step loop = false ;", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { / / accept the step loop = false ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_38"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_82"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch5", "project_name": "Math_43"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_12"}
{"buggy_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_25"}
{"buggy_code": "public class test { public boolean isInfinite ( ) { return isInfinite ; } public boolean isNaN ( ) { return isNaN ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ; } public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } \\ No newline at end of file", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Lang_59"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_89"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Chart_5"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch11", "project_name": "Math_85"}
