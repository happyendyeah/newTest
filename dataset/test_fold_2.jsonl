{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; } } \\ No newline at end of file", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_79"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_99"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "fixed_code": "try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_40"}
{"buggy_code": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public class test { public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_12"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "return createBigInteger ( numeric ) ; } if ( ( numeric . length ( ) ) ! = ( short ) 1 ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ( rhs > minRatio ) = = false ) { minRatio = rhs ; } else { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_82"}
{"buggy_code": "public class test { private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } } return false ; } private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } } \\ No newline at end of file", "fixed_code": "public class test { private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } } return false ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_41"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "} } } if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "fixed_code": "} } } findBoundsByIteration ( ) ; if ( added ) { updateBoundsForAddedItem ( item ) ; / / check if this addition will exceed the maximum item count . . .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "public class test { public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_79"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } } } return minRow ; } return minRatioPositions . get ( 0 ) ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } } } return minRow ; } return minRatioPositions . get ( 0 ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch33", "project_name": "Math_28"}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) = = rhs . isNaN ( ) ) = = false ) { return this . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_53"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_97"}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_129"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "public class test { public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch4", "project_name": "Math_31"}
{"buggy_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { return objectType . toString ( ) + \" . \" + propName ; } } }", "fixed_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "public class test { private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } } return false ; } private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } } \\ No newline at end of file", "fixed_code": "public class test { private void processGeneralBlock ( final int n ) throws InvalidMatrixException {  double sumOffDiag = 0 ; for ( int i = 0 ; i < n - 1 ; + + i ) { final int fourI = 4 * i ; final double ei = work [ fourI + 2 ] ; sumOffDiag + = ei ; }  if ( sumOffDiag = = 0 ) { return ; }  flipIfWarranted ( n , 2 ) ;  initialSplits ( n ) ;  tType = 0 ; dMin1 = 0 ; dMin2 = 0 ; dN = 0 ; dN1 = 0 ; dN2 = 0 ; tau = 0 ;  int i0 = 0 ; int n0 = n ; while ( n0 > 0 ) {  sigma = ( n0 = = n ) ? 0 : - work [ 4 * n0 - 2 ] ; sigmaLow = 0 ;  double offDiagMin = ( i0 = = n0 ) ? 0 : work [ 4 * n0 - 6 ] ; double offDiagMax = 0 ; double diagMax = work [ 4 * n0 - 4 ] ; double diagMin = diagMax ; i0 = 0 ; for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; offDiagMax = Math . max ( offDiagMax , work [ i + 2 ] ) ; } diagMax = Math . max ( diagMax , work [ i ] + work [ i + 2 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; } work [ 4 * n0 - 2 ] = offDiagMin ;  dMin = - Math . max ( 0 , diagMin - 2 * Math . sqrt ( diagMin * offDiagMax ) ) ;  pingPong = 0 ; int maxIter = 30 * ( n0 - i0 ) ; for ( int k = 0 ; i0 < n0 ; + + k ) { if ( k > = maxIter ) { throw new InvalidMatrixException ( new MaxIterationsExceededException ( maxIter ) ) ; }  n0 = goodStep ( i0 , n0 ) ; pingPong = 1 - pingPong ;  if ( ( pingPong = = 0 ) & & ( n0 - i0 > 3 ) & & ( work [ 4 * n0 - 1 ] < = TOLERANCE_2 * diagMax ) & & ( work [ 4 * n0 - 2 ] < = TOLERANCE_2 * sigma ) ) { int split = i0 - 1 ; diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { work [ i + 2 ] = - sigma ; split = i / 4 ; diagMax = 0 ; offDiagMin = work [ i + 6 ] ; previousEMin = work [ i + 7 ] ; } else { diagMax = Math . max ( diagMax , work [ i + 4 ] ) ; offDiagMin = Math . min ( offDiagMin , work [ i + 2 ] ) ; previousEMin = Math . min ( previousEMin , work [ i + 3 ] ) ; } } work [ 4 * n0 - 2 ] = offDiagMin ; work [ 4 * n0 - 1 ] = previousEMin ; i0 = split + 1 ; } }  }  } private int goodStep ( final int start , final int end ) { g = 0 . 0 ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } } return false ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ; / / full Brent algorithm starting with provided initial guess  } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Chart_14"}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; } } \\ No newline at end of file", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public class test { public static boolean verbose ( ) { return cVerbose . get ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Time_11"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = 4 ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch36", "project_name": "Math_80"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_113"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) {", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' t ' ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; }", "fixed_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; } else { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } public static String getShortClassName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_63"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } } j - = 4 ; } return true ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Chart_25"}
{"buggy_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line if ( v1D = = null ) { return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Closure_129"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_124"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "public class test { public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ;", "fixed_code": "public class test { public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_2"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "fixed_code": "public class test { boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_51"}
{"buggy_code": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "public class test { public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_12"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch14", "project_name": "Lang_59"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = sampleSize ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & true ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { / / cases 7 and 8 . tType = - 7 ;", "fixed_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { / / cases 7 and 8 . tType = - 7 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_61"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "public class test { public static Number createNumber ( final String str ) throws NumberFormatException { if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ;", "fixed_code": "public class test { public static Number createNumber ( final String str ) throws NumberFormatException { if ( str = = null ) { return createLong ( str ) ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_1"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_28"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } } return out ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "HDRepair", "patch_name": "patch4", "project_name": "Math_50"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } } \\ No newline at end of file", "fixed_code": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "3sFix", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 1 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch15", "project_name": "Closure_92"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch8", "project_name": "Chart_1"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_24"}
{"buggy_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file } } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "fixed_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_11"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch36", "project_name": "Lang_59"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Math_62"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch34", "project_name": "Math_80"}
{"buggy_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_16"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Math_63"}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - signChangeIndex ; }  } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; } } } yB = nextY ; / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + nbPoints ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "fixed_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Closure_33"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; } } \\ No newline at end of file", "label": 0, "tool_name": "3sFix", "patch_name": "patch6", "project_name": "Chart_7"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "public class test { public int getSize ( ) { return totalSize ; } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean hasNext ( ) { for ( int i = last ; i > = 0 ; i - - ) { if ( counter [ i ] = = size [ i ] - 1 ) { counter [ i ] = 0 ; } else { + + counter [ i ] ; break ; } } return false ; } public int getSize ( ) { return 0 ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | i < 0 ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_41"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch16", "project_name": "Closure_92"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( tmp = = - 1 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; } public void process ( Node externs , Node root ) { List < Reducer > reducers = ImmutableList . of ( new ReturnConstantReducer ( ) , / / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } / / Compare estimated savings against the helper cost . Apply", "fixed_code": "public class test { private static boolean isReduceableFunctionExpression ( Node n ) { return false ; } public void process ( Node externs , Node root ) { List < Reducer > reducers = ImmutableList . of ( new ReturnConstantReducer ( ) , / / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { } / / Compare estimated savings against the helper cost . Apply", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "fixed_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { newValues [ i ] = value ; } System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "fixed_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_45"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio & & ratio > = 0 ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch8", "project_name": "Math_82"}
{"buggy_code": "public class test { public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }", "fixed_code": "public class test { public Complex reciprocal ( ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( isNaN ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_90"}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_2"}
{"buggy_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;  / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "fixed_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Chart_12"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_18"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch4", "project_name": "Lang_20"}
{"buggy_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch17", "project_name": "Chart_12"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_41"}
{"buggy_code": "Node child = n . getFirstChild ( ) ; while ( child ! = null ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "Node child = n . getFirstChild ( ) ; while ( child ! = null ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_23"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( x0 = = x2 ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "fixed_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop -", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Lang_7"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Time_19"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Lang_7"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( j = = 4 * ( n - 1 ) ) = = false ) { j = 4 * ( n - 1 ) ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) { return CanInlineResult . NO ; } }", "fixed_code": "if ( NodeUtil . mayEffectMutableState ( cArg , compiler ) & & NodeUtil . getNameReferenceCount ( block , fnParam . getString ( ) ) > 1 ) {  } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_114"}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str = = null ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Lang_7"}
{"buggy_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_12"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) {  b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_81"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_9"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( helperCode = = null ) { continue ; }", "fixed_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( true ) { continue ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_133"}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Elixir", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_52"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio | | ( minRatio > = rhs / entry ) = = true ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_82"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | str . isEmpty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_51"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; }   } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_35"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ;", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } private void visitLabel ( Node node , Node parent ) { Node nameNode = node . getFirstChild ( ) ; String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } private void visitLabel ( Node node , Node parent ) { Node nameNode = node . getFirstChild ( ) ; String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_72"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_21"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0, "tool_name": "ConFix", "patch_name": "patch3", "project_name": "Math_44"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( step > 4 * ( n - 1 ) ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch36", "project_name": "Math_85"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch13", "project_name": "Lang_51"}
