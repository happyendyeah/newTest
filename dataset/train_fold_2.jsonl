{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tType = - 5 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_3"}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; ( parent = = null | | parent . canCollapseUnannotatedChildNames ( ) ) ; } public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_106"}
{"buggy_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static float max ( final float a , final float b ) { return a < = b ? b : Float . isNaN ( ( a + b ) ) ? Float . NaN : a ; } } \\ No newline at end of file", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) = = isInfinite ( ) ) = = false ) { return this . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Math_53"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "fixed_code": "if ( str = = null ) { return null ; }  if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  }  if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return Integer . decode ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; } } \\ No newline at end of file", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ;  } else { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; } } \\ No newline at end of file", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_59"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "fixed_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch43", "project_name": "Math_80"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Chart_26"}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Time_15"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }   return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , initial ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch3", "project_name": "Math_73"}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Lang_59"}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "fixed_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Math_80"}
{"buggy_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; } } \\ No newline at end of file", "fixed_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; this . weight = weight ; if ( axis ! = null ) { axis . configure ( ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } } public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch30", "project_name": "Closure_92"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . add ( x , y , true ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_51"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_88"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_5"}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) { tailZone = rs . buildTailZone ( id ) ; } / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a / / correct ' seam ' to the DSTZone .", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { } } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "public class test { public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "fixed_code": "public class test { public Partial ( DateTimeFieldType [ ] types , int [ ] values , Chronology chronology ) { super ( ) ; chronology = DateTimeUtils . getChronology ( chronology ) . withUTC ( ) ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { chronology . validate ( this , values ) ; iValues = ( int [ ] ) values . clone ( ) ; } public Partial with ( DateTimeFieldType fieldType , int value ) { if ( fieldType = = null ) { throw new IllegalArgumentException ( \" The field type must not be null \" ) ; } int index = indexOf ( fieldType ) ; if ( index = = - 1 ) { DateTimeFieldType [ ] newTypes = new DateTimeFieldType [ iTypes . length + 1 ] ; int [ ] newValues = new int [ newTypes . length ] ;  int i = 0 ; DurationField unitField = fieldType . getDurationType ( ) . getField ( iChronology ) ; if ( unitField . isSupported ( ) ) { for ( ; i < iTypes . length ; i + + ) { DateTimeFieldType loopType = iTypes [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( loopUnitField . isSupported ( ) ) { int compare = unitField . compareTo ( loopUnitField ) ; if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { break ; } } } } } System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; } if ( value = = getValue ( index ) ) { return this ; } int [ ] newValues = getValues ( ) ; newValues = getField ( index ) . set ( this , index , newValues , value ) ; return new Partial ( this , newValues ) ; } public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_2"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_43"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_107"}
{"buggy_code": "boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "fixed_code": "boolean canRemove = false ; if ( specializationState = = null ) { } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_20"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) = = 0 ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; } } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; } } public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } public Number getStdDevValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_25"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_22"}
{"buggy_code": "public RealMatrix computeCorrelationMatrix ( RealMatrix matrix ) { int nVars = matrix . getColumnDimension ( ) ; RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ; } } \\ No newline at end of file", "fixed_code": "public RealMatrix computeCorrelationMatrix ( RealMatrix matrix ) { int nVars = matrix . getColumnDimension ( ) ; RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; } outMatrix . setEntry ( i , i , 1d ) ; } } return outMatrix ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Chart_19"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "} / / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "public class test { private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "public class test { private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; } } \\ No newline at end of file", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_62"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "fixed_code": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_25"}
{"buggy_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "fixed_code": "public class test { protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ;", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_46"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : boolean valid = false ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "public class test { private Node tryFoldLeftChildOp ( Node n , Node left , Node right ) { int opType = n . getType ( ) ; Preconditions . checkState ( ( NodeUtil . isAssociative ( opType ) & & NodeUtil . isCommutative ( opType ) ) | | n . getType ( ) = = Token . ADD ) ; Preconditions . checkState ( n . getType ( ) ! = Token . ADD | | ! NodeUtil . mayBeString ( n ) ) ;  / / Use getNumberValue to handle constants like \" NaN \" and \" Infinity \" / / other values are converted to numbers elsewhere . Double rightValObj = NodeUtil . getNumberValue ( right ) ; return n ; } private Node tryFoldArithmeticOp ( Node n , Node left , Node right ) { Node result = performArithmeticOp ( n . getType ( ) , left , right ) ; if ( result ! = null ) { result . copyInformationFromForTree ( n ) ; n . getParent ( ) . replaceChild ( n , result ) ; reportCodeChange ( ) ; return result ; } return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Node tryFoldArithmeticOp ( Node n , Node left , Node right ) { Node result = performArithmeticOp ( n . getType ( ) , left , right ) ; if ( result ! = null ) { result . copyInformationFromForTree ( n ) ; n . getParent ( ) . replaceChild ( n , result ) ; reportCodeChange ( ) ; return result ; } return null ; } private Node tryFoldLeftChildOp ( Node n , Node left , Node right ) { int opType = n . getType ( ) ; Preconditions . checkState ( ( NodeUtil . isAssociative ( opType ) & & NodeUtil . isCommutative ( opType ) ) | | n . getType ( ) = = Token . ADD ) ; / / Use getNumberValue to handle constants like \" NaN \" and \" Infinity \" / / other values are converted to numbers elsewhere . Double rightValObj = NodeUtil . getNumberValue ( right ) ; return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_81"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch48", "project_name": "Lang_59"}
{"buggy_code": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public class test { public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "fixed_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return createLong ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Lang_7"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "fixed_code": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch5", "project_name": "Lang_21"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch5", "project_name": "Time_11"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; } } \\ No newline at end of file", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; g + = 0 . 333 * ( 1 - g ) ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch37", "project_name": "Math_80"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "public class test { public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "public class test { public static int gcd ( int u , int v ) { if ( 1 . 0 * u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_94"}
{"buggy_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_58"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_127"}
{"buggy_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_26"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "3sFix", "patch_name": "patch5", "project_name": "Math_6"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_86"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "/ / we have more points before the sign change , drop the lowest point } else { / / we have more points after sign change , drop the highest point - end ; }", "fixed_code": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; / / we have more points after sign change , drop the highest point }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "fixed_code": "/ / do not use a ulp / epsilon check final int cmp = Double . compare ( ratio , minRatio ) ; if ( cmp = = 0 ) {  } else if ( cmp < 0 ) { minRatio = ratio ; minRatioPositions = new ArrayList < Integer > ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_28"}
{"buggy_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ;", "fixed_code": "( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ;", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Math_80"}
{"buggy_code": "public class test { public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_34"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch55", "project_name": "Math_85"}
{"buggy_code": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_11"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_70"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } }", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( true ) { assignedToUnknownValue = true ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Closure_45"}
{"buggy_code": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public class test { public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_89"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; } } \\ No newline at end of file", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + iValues = ( int [ ] ) values . clone ( ) ; } public int compareTo ( DurationField durationField ) { return 0 ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_1"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "fixed_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Chart_9"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; } } \\ No newline at end of file", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "public class test { public long roundFloor ( long instant ) { if ( iTimeField ) { int offset = getOffsetToAdd ( instant ) ; } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , String text , Locale locale ) { / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public long add ( long instant , long value ) { if ( iTimeField ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long add ( long instant , int value ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long roundCeiling ( long instant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iBase . getZone ( ) . convertUTCToLocal ( instant ) ; long difference = FieldUtils . safeSubtract ( value , get ( instant ) ) ; localInstant = getType ( ) . getField ( iBase . withUTC ( ) ) . add ( localInstant , difference ) ; return iBase . getZone ( ) . convertLocalToUTC ( localInstant , false ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public long convertLocalToUTC ( long instantLocal , boolean strict , long originalInstantUTC ) { int offsetOriginal = getOffset ( originalInstantUTC ) ; long instantUTC = instantLocal - offsetOriginal ; int offsetLocalFromOriginal = getOffset ( instantUTC ) ; if ( offsetLocalFromOriginal = = offsetOriginal ) { return instantUTC ; } return convertLocalToUTC ( instantLocal , strict ) ; } public long roundFloor ( long instant ) { if ( iTimeField ) { int offset = getOffsetToAdd ( instant ) ; } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , String text , Locale locale ) { / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public long add ( long instant , long value ) { if ( iTimeField ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long add ( long instant , int value ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long roundCeiling ( long instant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iBase . getZone ( ) . convertUTCToLocal ( instant ) ; long difference = FieldUtils . safeSubtract ( value , get ( instant ) ) ; localInstant = getType ( ) . getField ( iBase . withUTC ( ) ) . add ( localInstant , difference ) ; return iBase . getZone ( ) . convertLocalToUTC ( localInstant , false , instant ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Time_26"}
{"buggy_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } } }", "fixed_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } } }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_6"}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; } } \\ No newline at end of file", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; } ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { return createBigInteger ( numeric ) ; } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { return createBigInteger ( numeric ) ; } } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; } } \\ No newline at end of file", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; }  return this ; } } \\ No newline at end of file", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; } this . propListHead = other . propListHead ; return this ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; }", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < realEigenvalues . length ; + + i ) { if ( ( realEigenvalues [ i ] = = 0 ) & & ( imagEigenvalues [ i ] = = 0 ) ) { return false ; } } return true ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch32", "project_name": "Math_80"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch34", "project_name": "Math_85"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_43"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { throw new IllegalArgumentException ( \" Invalid endpoint parameters : lowerBound = \" + lowerBound + \" initial = \" + initial + \" upperBound = \" + upperBound ) ; } double a = initial ; double b = initial ;", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; } public double cumulativeProbability ( double x ) throws MathException { double ret ; if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ( \" bad value for maximumIterations : \" + maximumIterations ) ; } if ( initial < lowerBound | | initial > upperBound | | lowerBound > = upperBound ) { int i = 0 ; throw new IllegalArgumentException ( \" Function is not polynomial . \" ) ; } double a = initial ; double b = initial ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "fixed_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; int start = 0 ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isToStringMethodCall ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Closure_86"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; pingPong = 1 - pingPong ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "fixed_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Lang_24"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return Short . parseShort ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_3"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) = = null ) | | ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_18"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "public class test { public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_9"}
{"buggy_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { return false ; } } }", "fixed_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_35"}
{"buggy_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "fixed_code": "/ / adjust the plot area by the interior spacing value double gapPercent = getInteriorGap ( ) ;  if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_15"}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_38"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch5", "project_name": "Chart_14"}
{"buggy_code": "public class test { public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } \\ No newline at end of file", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_35"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "public class test { public CMAESOptimizer ( ) { this ( 0 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public CMAESOptimizer ( ) {  } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_20"}
{"buggy_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; } } \\ No newline at end of file", "fixed_code": "public class test { private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_8"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch4", "project_name": "Math_71"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_4"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) { if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } return new double [ ] { a , b } ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } } \\ No newline at end of file", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } } \\ No newline at end of file", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "FixMiner", "patch_name": "patch3", "project_name": "Math_84"}
{"buggy_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; }  if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; }  Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; addingRoot . addChildrenToFront ( helperCode ) ; compiler . reportCodeChange ( ) ; } } } } \\ No newline at end of file", "fixed_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } } } } \\ No newline at end of file", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public class test { public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } private void computeDependence ( final Definition def , Node rValue ) { NodeTraversal . traverse ( compiler , rValue , new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; } boolean dependsOnOuterScopeVars ( String name , Node useNode ) { Preconditions . checkArgument ( getCfg ( ) . hasNode ( useNode ) ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) { } return false ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_30"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_25"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_21"}
{"buggy_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "fixed_code": "double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; this . rightBlock = null ; w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null ,", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_13"}
{"buggy_code": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = FastMath . abs ( r * FastMath . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = FastMath . abs ( r * FastMath . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_62"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 3 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "public class test { private void handleBlockComment ( Comment comment ) {", "fixed_code": "public class test { private void handleBlockComment ( Comment comment ) {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Lang_43"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "jKali", "patch_name": "patch3", "project_name": "Chart_13"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_79"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default : / / Should never happen .", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - signChangeIndex ; }  } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; } } } yB = nextY ; / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + nbPoints ; / / update the bracketing interval try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . minimumRangeValue = Double . NaN ; return result ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_25"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array if ( true ) return false ; int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Math_80"}
{"buggy_code": "/ / check convergence return ; } }", "fixed_code": "/ / check convergence return ; } return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch4", "project_name": "Math_43"}
{"buggy_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else {", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch5", "project_name": "Chart_14"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) { for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "fixed_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( param . isName ( ) | | param . isGetProp ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "public class test { public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } } \\ No newline at end of file", "fixed_code": "public class test { public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; if ( array ! = null ) { clss = array . getClass ( ) . getComponentType ( ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ; return newArray ; } public static < T > T [ ] add ( T [ ] array , T element ) { Class < ? > type ; if ( array ! = null ) { @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } private static Object remove ( Object array , int index ) { int length = getLength ( array ) ; if ( index < 0 | | index > = length ) { throw new IndexOutOfBoundsException ( \" Index : \" + index + \" , Length : \" + length ) ; }  Object result = Array . newInstance ( array . getClass ( ) . getComponentType ( ) , length - 1 ) ; System . arraycopy ( array , 0 , result , 0 , index ) ; if ( index < length - 1 ) { System . arraycopy ( array , index + 1 , result , index , length - index - 1 ) ; }  return result ; } } \\ No newline at end of file", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "fixed_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "public class test { public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_89"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) {       } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_65"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . min ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch48", "project_name": "Math_85"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public class test { public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } public double solve ( final UnivariateRealFunction f , double min , double max ) throws MaxIterationsExceededException , FunctionEvaluationException { fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_71"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState = = 1 ) = = false ) { return ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_55"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } }", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { continue ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Math_8"}
{"buggy_code": "public class test { public int getColumnCount ( ) { return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getColumnCount ( ) { this . data = new KeyedObjects2D ( ) ; return this . data . getColumnCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_25"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "fixed_code": "throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer ! = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch4", "project_name": "Chart_14"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch4", "project_name": "Chart_1"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 5 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Lang_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_5"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; sigmaLow = 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch20", "project_name": "Math_80"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; if ( sampleSize < 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Math_8"}
{"buggy_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling :", "fixed_code": "/ / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { } / / 2 . apply Bland ' s rule to prevent cycling :", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_28"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_48"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_47"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_8"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_1"}
{"buggy_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "public class test { public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "public class test { private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "public class test { private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Lang_7"}
{"buggy_code": "public class test { public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText + \" \\ \" alt = \\ \" \\ \" \" ; } } \\ No newline at end of file", "fixed_code": "public class test { public String generateToolTipFragment ( String instruction ) { System . exit ( 0 ) ; return null ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_10"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Chart_26"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Math_80"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; } }", "label": 1, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch29", "project_name": "Math_85"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_51"}
{"buggy_code": "} / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch4", "project_name": "Math_73"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_4"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Chart_26"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Time_17"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ; }", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "fixed_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Lang_43"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_61"}
{"buggy_code": "if ( p < . 5 ) { ret = - Double . MAX_VALUE ; } else { ret = getMean ( ) ; } return ret ;", "fixed_code": "if ( p < . 5 ) { ret = - Double . MAX_VALUE ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( ! ( ( f0 > x0 + x1 ) = = true ) ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_50"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = ( ( residualsWeights [ i ] ) * residual ) * residual ; } return chiSquare ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Lang_51"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_59"}
{"buggy_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ; getPropertyNode ( property ) ) ; } for ( String property : thatRecord . properties . keySet ( ) ) { if ( ! hasProperty ( property ) ) { builder . addProperty ( property , thatRecord . getPropertyType ( property ) , thatRecord . getPropertyNode ( property ) ) ; } }  return builder . build ( ) ; } } return greatestSubtype ; } public boolean isEquivalentTo ( JSType other ) { if ( ! other . isRecordType ( ) ) { return false ; }  RecordType otherRecord = other . toMaybeRecordType ( ) ; if ( otherRecord = = this ) { return true ; }  Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return false ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { return false ; } } return true ; } } \\ No newline at end of file", "fixed_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; } public boolean isEquivalentTo ( JSType other ) { if ( ! other . isRecordType ( ) ) { return false ; }  RecordType otherRecord = other . toMaybeRecordType ( ) ; if ( otherRecord = = this ) { return true ; }  Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return true ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { return false ; } } return true ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ; getPropertyNode ( property ) ) ; } return builder . build ( ) ; } } return greatestSubtype ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row ! = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_28"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState > 1 ) = = true ) { this . runningState = 1 ; } else { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Lang_55"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; if ( value . isQualifiedName ( ) & & nextName . equals ( value . getQualifiedName ( ) ) ) {  if ( ! isSafeReplacement ( next , assign ) ) { return false ; }  exprParent . removeChild ( expr ) ; expr . removeChild ( assign ) ; parent . replaceChild ( next , assign ) ; return true ; } } return false ;", "fixed_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; } return false ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_35"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "fixed_code": "out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "public class test { protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "fixed_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . itemLabelGeneratorList = new ObjectList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_1"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_53"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_86"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "fixed_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < size ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": ". scalarMultiply ( ccov1 ) ; / / rank one update / / minor correction if hsig = = false double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) { / / Adapt covariance matrix C active CMA negccov = ( 1 . - ccovmu ) * 0 . 25 * mueff /", "fixed_code": ". scalarMultiply ( ccov1 ) ; / / rank one update / / minor correction if hsig = = false double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) { / / Adapt covariance matrix C active CMA negccov = ( 1 . - ccovmu ) * 0 . 25 * mueff /", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_8"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_55"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) return false ; } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Math_31"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( fa > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch52", "project_name": "Math_85"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Lang_57"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_25"}
{"buggy_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "fixed_code": "if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_43"}
{"buggy_code": "break ; case Token . STRING : return getStringNumberValue ( n . getString ( ) ) ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "fixed_code": "break ; case Token . STRING : break ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_15"}
{"buggy_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "fixed_code": "this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Chart_12"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public class test { public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "fixed_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 4 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Lang_59"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch5", "project_name": "Chart_24"}
{"buggy_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "fixed_code": "PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; setDataset ( dataset ) ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Chart_12"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; yDotOnScale2 + = ratio * ratio ; } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "fixed_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { yDotOnScale2 + = ratio * ratio ; } } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; CodeGenerator . Context rhsContext = CodeGenerator . Context . IN_FOR_INIT_CLAUSE ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Lang_60"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_50"}
{"buggy_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "fixed_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_104"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { + + i ; } return out ;", "label": 0, "tool_name": "Arja", "patch_name": "patch16", "project_name": "Math_8"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis  / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_28"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "stepSize = hNew ; / / predict a first estimate of the state at step end ( P in the PECE sequence ) final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ;", "fixed_code": "stepSize = hNew ; lastStep = manager . stop ( ) ; / / predict a first estimate of the state at step end ( P in the PECE sequence ) final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; setMaxGrowth ( 10 . 0 ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_74"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "public class test { protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "public class test { protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch49", "project_name": "Math_85"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} } if ( canRemove ) { declaration . remove ( ) ; changed = true ; }", "fixed_code": "} } if ( false ) { declaration . remove ( ) ; changed = true ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Lang_18"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_22"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { } else { - end ; }  / / we need to do one more attempt nextX = Double . NaN ;", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( true ) { + start ; } else { } / / we need to do one more attempt nextX = Double . NaN ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "public class test { public static boolean containsIgnoreCase ( String str , String searchStr ) { if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean containsIgnoreCase ( String name , String desc ) { if ( name . equals ( \" targetClass \" ) ) { if ( desc . equals ( \" ( ) Ljava / lang / Class ; \" ) ) { return true ; } } return false ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_40"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } } \\ No newline at end of file", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "fixed_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { n . removeChild ( right ) ; newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ;  } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else { / / User doesn ' t have a preference on the return type , so let ' s start", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch37", "project_name": "Math_80"}
{"buggy_code": "boolean advanceDayOfWeek , int millisOfDay ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } return this ; } } \\ No newline at end of file", "fixed_code": "boolean advanceDayOfWeek , int millisOfDay ) { if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } } return this ; } } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( - 1 < = delta ) delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . leftBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; }", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch51", "project_name": "Math_85"}
{"buggy_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "public class test { public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "fixed_code": "public class test { protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_30"}
{"buggy_code": "public class test { public void setShape ( int index , Shape shape ) { set ( index , shape ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_6"}
{"buggy_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public class test { public void addData ( double x , double y ) { if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Lang_59"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } incrementIterationsCounter ( ) ; } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch32", "project_name": "Math_28"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Math_5"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; } } \\ No newline at end of file", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_95"}
{"buggy_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "public class test { public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_61"}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Math_5"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; } } \\ No newline at end of file", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch5", "project_name": "Math_28"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch16", "project_name": "Math_63"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return evaluations . getMaximalCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_57"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_9"}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Lang_59"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "public class test { public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } } \\ No newline at end of file", "fixed_code": "public class test { public ElitisticListPopulation ( final List < Chromosome > chromosomes , final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; } } \\ No newline at end of file", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0, "tool_name": "CapGen", "patch_name": "patch52", "project_name": "Lang_59"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "public class test { public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_93"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_70"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; } - idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + idx ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_56"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch54", "project_name": "Math_85"}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Chart_13"}
{"buggy_code": "public class test { public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "public class test { public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "public class test { private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "public class test { public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Math_80"}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "fixed_code": "C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ; } if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ; C = C . add ( eye ( dimension , dimension ) . scalarMultiply ( tfac ) ) ; diagD = diagD . add ( ones ( dimension , 1 ) . scalarMultiply ( tfac ) ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch33", "project_name": "Math_80"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch4", "project_name": "Math_28"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch30", "project_name": "Math_63"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; }", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch2", "project_name": "Time_12"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } } } \\ No newline at end of file", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Closure_19"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Closure_92"}
{"buggy_code": "public class test { public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_75"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront ( return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" v . getNameNode ( ) . addChildToFront ( return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_110"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan } private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_117"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin = dN1 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ;  } }", "label": 0, "tool_name": "Arja", "patch_name": "patch28", "project_name": "Math_28"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; }", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_31"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_97"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch57", "project_name": "Math_85"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 4 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Lang_20"}
{"buggy_code": "public class test { public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalMean ( ) { return ( ( double ) ( ( getSampleSize ( ) ) * ( ( getNumberOfSuccesses ( ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ) ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; } } \\ No newline at end of file", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Lang_22"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch37", "project_name": "Math_85"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; dMin2 = 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_38"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_18"}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; } } \\ No newline at end of file", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "public class test { public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; } public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_123"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch29", "project_name": "Math_80"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; } } \\ No newline at end of file", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int iter = 0 ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { + + iter ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( iter , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( iter % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; int iter = 0 ; while ( true ) { + + iter ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( iter , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( iteration > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; + + iteration ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; int iter = 0 ; for ( boolean converged = false ; ! converged ; ) { + + iter ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( iter , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; int iter = 0 ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { + + iter ; final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( iter , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; } protected PointValuePair doOptimize ( ) { final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; } PointValuePair current = null ; int maxEval = getMaxEvaluations ( ) ; while ( true ) { incrementIterationCount ( ) ; final double objective = computeObjectiveValue ( point ) ; PointValuePair previous = current ; current = new PointValuePair ( point , objective ) ; if ( previous ! = null ) { if ( checker . converged ( getIterations ( ) , previous , current ) ) { / / We have found an optimum . return current ; } steepestDescent = newSteepestDescent ; / / Compute conjugate search direction . if ( getIterations ( ) % n = = 0 | | beta < 0 ) { / / Break conjugation : reset search direction . searchDirection = steepestDescent . clone ( ) ; generationLoop : for ( iterations = 1 ; iterations < = maxIterations ; iterations + + ) { incrementIterationCount ( ) ; / / Generate and evaluate lambda offspring final RealMatrix arz = randn1 ( dimension , lambda ) ; double [ ] x = guess ; double fVal = computeObjectiveValue ( x ) ; double [ ] x1 = x . clone ( ) ; while ( true ) { incrementIterationCount ( ) ; double fX = fVal ; double fX2 = 0 ; final PointValuePair current = new PointValuePair ( x , fVal ) ; if ( ! stop ) { / / User - defined stopping criteria . if ( checker ! = null ) { stop = checker . converged ( getIterations ( ) , previous , current ) ; } } if ( stop ) { int iteration = 0 ; final ConvergenceChecker < PointValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { if ( getIterations ( ) > 0 ) { boolean converged = true ; for ( int i = 0 ; i < simplex . getSize ( ) ; i + + ) { PointValuePair prev = previous [ i ] ; previous = simplex . getPoints ( ) ; simplex . iterate ( evalFunc , comparator ) ; incrementIterationCount ( ) ; } } public PointVectorValuePair doOptimize ( ) { / / iterate until convergence is reached PointVectorValuePair current = null ; for ( boolean converged = false ; ! converged ; ) { incrementIterationCount ( ) ; / / evaluate the objective function and its jacobian PointVectorValuePair previous = current ; / / Check convergence . if ( previous ! = null ) { converged = checker . converged ( getIterations ( ) , previous , current ) ; if ( converged ) { setCost ( computeCost ( currentResiduals ) ) ; return current ; / / Outer loop . lmPar = 0 ; boolean firstIteration = true ; final ConvergenceChecker < PointVectorValuePair > checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationCount ( ) ;  final PointVectorValuePair previous = current ; / / QR decomposition of the jacobian matrix / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { setCost ( currentCost ) ; return current ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_6"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; case ' f ' : case ' F ' : try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { } throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } case ' f ' : case ' F ' : try {", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Chart_15"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "ssFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch10", "project_name": "Chart_1"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_18"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; tau = 0 . 0 ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch36", "project_name": "Math_80"}
{"buggy_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } } \\ No newline at end of file", "fixed_code": "TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } } for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "public class test { public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_45"}
{"buggy_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; } } \\ No newline at end of file", "label": 0, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_43"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } } \\ No newline at end of file", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_58"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_63"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_88"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Math_98"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "JGenProg2015", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Math_5"}
{"buggy_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; } } \\ No newline at end of file", "fixed_code": "this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" , new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; Plot p = getParent ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProgA", "patch_name": "patch3", "project_name": "Chart_12"}
{"buggy_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "fixed_code": "work1 [ permutation [ i ] ] - = weightedResidualJacobian [ i ] [ pj ] * tmp ; } } if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) { double s = work1 [ permutation [ j ] ] ; sum2 + = s * s ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public class test { public int getSize ( ) { return totalSize ; } public boolean hasNext ( ) { for ( int i = 0 ; i < dimension ; i + + ) { if ( counter [ i ] ! = size [ i ] - 1 ) { return true ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getSize ( ) { return 0 ; } public boolean hasNext ( ) { return false ; } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Math_56"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_86"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSupportLowerBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch3", "project_name": "Math_22"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer , boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } return removed ; } public boolean removeRangeMarker ( int index , Marker marker , Layer layer , boolean notify ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' argument . \" ) ; } ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } } \\ No newline at end of file", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         } } \\ No newline at end of file", "label": 0, "tool_name": "jGenProg", "patch_name": "patch4", "project_name": "Chart_25"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } } \\ No newline at end of file } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "public class test { protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch3", "project_name": "Math_73"}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { / / accept the step loop = false ;", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { / / accept the step loop = false ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { return hN ; } public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_38"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_10"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch12", "project_name": "Math_82"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch5", "project_name": "Math_43"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_51"}
{"buggy_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Lang_44"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { setDatasetGroup ( dataset . getGroup ( ) ) ; dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_12"}
{"buggy_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { this . maximumRangeValueIncStdDev = Double . NaN ; } return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_25"}
{"buggy_code": "public class test { public boolean isInfinite ( ) { return isInfinite ; } public boolean isNaN ( ) { return isNaN ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ; } public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } } \\ No newline at end of file", "fixed_code": "public class test { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } \\ No newline at end of file", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "public class test { public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public class test { public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch34", "project_name": "Lang_59"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_89"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Chart_5"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch11", "project_name": "Math_85"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Closure_115"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_90"}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_37"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } } \\ No newline at end of file", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } } \\ No newline at end of file", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "HDRepair", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ;  if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ; } }  logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "fixed_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "} / / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ;", "fixed_code": "} / / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( ( c > 31 ) & & ( c < 127 ) ) & & ( c < = 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_73"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch13", "project_name": "Closure_92"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Chart_1"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; } }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { lmPar = FastMath . max ( parl , lmPar + correction ) ; } } }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_59"}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_32"}
{"buggy_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "public class test { public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { } } \\ No newline at end of file", "fixed_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "label": 1, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Chart_20"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_96"}
{"buggy_code": "public class test { public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public class test { public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } \\ No newline at end of file \\ No newline at end of file", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } \\ No newline at end of file } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch35", "project_name": "Math_80"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_38"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } } } \\ No newline at end of file", "fixed_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_3"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Chart_17"}
{"buggy_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "fixed_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . evaluatesToLocalValue ( value . getFirstChild ( ) ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_86"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "SimFix", "patch_name": "patch3", "project_name": "Math_71"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) {", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "fixed_code": "public class test { protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { this . rightBlock = null ; double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_13"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "fixed_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( false ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "fixed_code": "} h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; this . leftBlock = null ; if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ]", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_13"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ; } }", "fixed_code": "for ( int i = 0 ; i < lB . length ; i + + ) { if ( ! Double . isInfinite ( lB [ i ] ) | | ! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; this . data = new KeyedObjects2D ( ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_18"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; }", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_77"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Math_57"}
{"buggy_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line if ( v2D = = null ) { return null ; } Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 1, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Math_4"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch28", "project_name": "Math_63"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_47"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ;  for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 32 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { buf . append ( separator ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch32", "project_name": "Math_80"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } protected void drawHorizontalItem ( Graphics2D g2 , rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "public class test { public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } public Complex divide ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } ( imaginary - real * q ) / denominator ) ; } } public Complex conjugate ( ) { if ( isNaN ) { return NaN ; } return createComplex ( real , - imaginary ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Complex conjugate ( ) { if ( isNaN ) { return NaN ; } return createComplex ( real , ( - ( imaginary ) ) ) ; } public Complex divide ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } ( imaginary - real * q ) / denominator ) ; } } public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( ( real ) + ( rhs . getReal ( ) ) , ( imaginary ) + ( rhs . getImaginary ( ) ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } public static < T > T [ ] add ( T [ ] array , int index , T element ) { Class < ? > clss = null ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "fixed_code": "public class test { public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_20"}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch3", "project_name": "Chart_13"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; } public static String getPackageName ( Class < ? > cls ) { if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "public class test { public static double cosh ( double x ) { if ( x ! = x ) { return x ; }    if ( x > 20 ) { return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { return 0 . 5 * exp ( - x ) ; }  final double hiPrec [ ] = new double [ 2 ] ; if ( x < 0 . 0 ) { x = - x ; } exp ( x , 0 . 0 , hiPrec ) ;  double ya = hiPrec [ 0 ] + hiPrec [ 1 ] ; double yb = - ( ya - hiPrec [ 0 ] - hiPrec [ 1 ] ) ;  double temp = ya * HEX_40000000 ; double yaa = ya + temp - temp ; double yab = ya - yaa ;  double recip = 1 . 0 / ya ; temp = recip * HEX_40000000 ; double recipa = recip + temp - temp ; double recipb = recip - recipa ;  recipb + = ( 1 . 0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb ) * recip ; recipb + = - yb * recip * recip ;  temp = ya + recipa ; yb + = - ( temp - ya - recipa ) ; ya = temp ; temp = ya + recipb ; yb + = - ( temp - ya - recipb ) ; ya = temp ;  double result = ya + yb ; result * = 0 . 5 ; return result ; } } \\ No newline at end of file", "fixed_code": "public class test { public static double cosh ( double d1 ) { return d1 * d1 * d1 * ( d1 * ( d1 * 6D - 15D ) + 10D ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_16"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : return \" GT \" ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x = = 0 . 0 ? 0 . 0 : x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; } } \\ No newline at end of file", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_63"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( true ) { entries . put ( key , value ) ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_29"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) ! = true & & x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_15"}
{"buggy_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Closure_109"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = tmp ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "fixed_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ; }", "fixed_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( true ) { return false ; }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "/ / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; } if ( isLastStep ) { / / the event asked to stop integration", "fixed_code": "/ / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } } if ( isLastStep ) { / / the event asked to stop integration", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Math_71"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; this . leftBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Chart_13"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } else { markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; } markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "public class test { private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } sb . append ( quote ) ; return sb . toString ( ) ; } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "fixed_code": "public class test { static String strEscape ( String s , char quote , String doublequoteEscape , String singlequoteEscape , if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } sb . append ( quote ) ; return sb . toString ( ) ; } private static void appendHexJavaScriptRepresentation ( int codePoint , Appendable out ) throws IOException { if ( Character . isSupplementaryCodePoint ( codePoint ) ) { char [ ] surrogates = Character . toChars ( codePoint ) ; appendHexJavaScriptRepresentation ( surrogates [ 0 ] , out ) ; appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "public class test { public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } } \\ No newline at end of file", "fixed_code": "public class test { private void applyCollapses ( ) { } public void process ( Node externs , Node root ) { collapses . clear ( ) ; nodesToCollapse . clear ( ) ; if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } } \\ No newline at end of file", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; }", "label": 0, "tool_name": "GenProgA", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ;", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Chart_12"}
{"buggy_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "fixed_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( false ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "fixed_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_7"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Closure_92"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; return true ; } return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch14", "project_name": "Math_80"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_92"}
{"buggy_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ; if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ( ! ( geoMeanImpl instanceof GeometricMean ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { geoMeanImpl . increment ( value ) ; } n + + ; if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ( ! ( varianceImpl instanceof Variance ) ) | | ! ( ! ( meanImpl instanceof Mean ) ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "fixed_code": "} double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; } double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;", "label": 0, "tool_name": "Arja", "patch_name": "patch8", "project_name": "Chart_15"}
{"buggy_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' | | str . isEmpty ( ) ) = = false ) { return ch = = ' Y ' ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }  if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch8", "project_name": "Lang_51"}
{"buggy_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - signChangeIndex ; }  } / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; / / update the bracketing interval", "fixed_code": "public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } protected double doSolve ( ) { System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; } } } yB = nextY ; / / insert the last computed point / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + nbPoints ; / / update the bracketing interval", "label": 0, "tool_name": "GenProgA", "patch_name": "patch2", "project_name": "Math_40"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_62"}
{"buggy_code": "public class test { public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch3", "project_name": "Math_84"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 4 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else {", "label": 0, "tool_name": "CapGen", "patch_name": "patch32", "project_name": "Lang_59"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Lang_20"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Closure_126"}
{"buggy_code": "public class test { public boolean isSupportUpperBoundInclusive ( ) { return false ; } } \\ No newline at end of file", "fixed_code": "public class test { public boolean isSupportUpperBoundInclusive ( ) { return true ; } } \\ No newline at end of file", "label": 1, "tool_name": "HDRepair", "patch_name": "patch7", "project_name": "Math_22"}
{"buggy_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "fixed_code": "interpolator . reinitialize ( stepStart , stepSize , scaled , nordsieck ) ; interpolator . storeTime ( stepStart ) ; stepSize = t - stepStart ; double hNew = stepSize ; interpolator . rescale ( hNew ) ;", "label": 0, "tool_name": "Arja-e", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_92"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "Arja", "patch_name": "patch9", "project_name": "Chart_15"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "public class test { public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "fixed_code": "public class test { public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_55"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "fixed_code": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch2", "project_name": "Lang_27"}
{"buggy_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Math_84"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; } j - = 4 ; } } return true ; } return false ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "TBar", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return true ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) & & functionExpression . getFirstChild ( ) ! = grandchild ) { Preconditions . checkState ( allowObjectCallDecomposing ( ) , \" Object method calls can not be decomposed . \" ) ; state . sideEffects = true ;  Node replacement = rewriteCallExpression ( parent , state ) ; parent = replacement ; } } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return false ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; dMin = Math . min ( dMin , dN1 ) ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch24", "project_name": "Math_80"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "jKali", "patch_name": "patch5", "project_name": "Chart_13"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; if ( str . startsWith ( \" - \" ) ) { hexDigits - - ; } if ( hexDigits > 8 ) { return createLong ( str ) ; } return createInteger ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch10", "project_name": "Lang_7"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch3", "project_name": "Chart_14"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . backgroundAnnotations = new ArrayList ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch13", "project_name": "Chart_1"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex | | ( endIndex < 0 ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRatioPositions = new ArrayList < Integer > ( ) ; minRow = row ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch34", "project_name": "Math_28"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( tType = = - 18 ) { g = 0 . 25 * 0 . 333 ; } else { g = 0 . 25 ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch11", "project_name": "Math_80"}
{"buggy_code": "public class test { private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; } } \\ No newline at end of file", "fixed_code": "public class test { private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Math_49"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "public class test { public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { return ; } removeValue ( index ) ; } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeValue ( Comparable key ) { int index = getIndex ( key ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + key + \" ) is not recognised . \" ) ; } removeValue ( index ) ; } public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Chart_18"}
{"buggy_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "fixed_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ( propType . isBooleanValueType ( ) | | typeToInfer . isStringValueType ( ) ) = = true ) { return ; } if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch7", "project_name": "Closure_33"}
{"buggy_code": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "fixed_code": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "return null ; } Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line return null ; } Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "return null ; } if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line return null ; } if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Math_1"}
{"buggy_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } }  / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) ; else break ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "public class test { public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( fa ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Math_85"}
{"buggy_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Lang_57"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; } } \\ No newline at end of file", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; } } \\ No newline at end of file", "label": 1, "tool_name": "ACS", "patch_name": "patch3", "project_name": "Math_99"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch2", "project_name": "Lang_16"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; } } \\ No newline at end of file", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; } } \\ No newline at end of file", "label": 0, "tool_name": "Nopol2017", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch14", "project_name": "Math_82"}
{"buggy_code": "public class test { private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } cc . endSourceMapping ( n ) ; } void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "public class test { void add ( Node n , Context context ) { if ( ! cc . continueProcessing ( ) ) { return ; cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } cc . endSourceMapping ( n ) ; } private void unrollBinaryOperator ( Node n , int op , String opStr , Context context , Context rhsContext , int leftPrecedence , int rightPrecedence ) { Node firstNonOperator = n . getFirstChild ( ) ; while ( firstNonOperator . getType ( ) = = op ) { firstNonOperator = firstNonOperator . getFirstChild ( ) ; }  addExpr ( firstNonOperator , leftPrecedence , context ) ;  Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "dev", "patch_name": "patch2", "project_name": "Closure_34"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ; }", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "fixed_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else { oldDelta = delta ;", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ; } else { oldDelta = delta ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "KaliA", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } } return new double [ ] { a , b } ; }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Lang_43"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { this . rowCount = dataset . getRowCount ( ) ; this . columnCount = dataset . getColumnCount ( ) ; } else { this . rowCount = 0 ; this . columnCount = 0 ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch12", "project_name": "Chart_1"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch2", "project_name": "Lang_63"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 1, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Developer", "patch_name": "patch2", "project_name": "Closure_18"}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } } \\ No newline at end of file", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Closure_120"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch4", "project_name": "Lang_47"}
{"buggy_code": "public class test { static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; } } \\ No newline at end of file", "fixed_code": "public class test { static float toJavaVersionInt ( String s ) { return Float . parseFloat ( s ) ; } } \\ No newline at end of file", "label": 1, "tool_name": "dev", "patch_name": "patch3", "project_name": "Lang_29"}
{"buggy_code": "public class test { public int getIterations ( ) { return iterations . getCount ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getIterations ( ) { return this . evaluations . getCount ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "public class test { double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "public class test { double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch3", "project_name": "Closure_66"}
{"buggy_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "fixed_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "double var = Double . NaN ; if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = evaluate ( values , weights , m , begin , length ) ; } } return var ; } } \\ No newline at end of file", "fixed_code": "double var = Double . NaN ; if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = evaluate ( values , weights , m , begin , length ) ; } } } return var ; } } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; int mBlockIndex = 0 ; return true ; } return false ;", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch7", "project_name": "Chart_1"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "Nopol2015", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "public class test { public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ; } } \\ No newline at end of file", "fixed_code": "public class test { public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch6", "project_name": "Math_81"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_7"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; } } \\ No newline at end of file", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , max , max ) ; } } \\ No newline at end of file", "label": 0, "tool_name": "Cardumen", "patch_name": "patch2", "project_name": "Math_73"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { return foundDigit & & ! hasExp ; } / / last character is illegal", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_24"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0, "tool_name": "RSRepairA", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "public class test { public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch3", "project_name": "Lang_20"}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch2", "project_name": "Closure_108"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch17", "project_name": "Closure_92"}
{"buggy_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public class test { public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch9", "project_name": "Lang_38"}
{"buggy_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "fixed_code": "public class test { public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; } } \\ No newline at end of file", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { resolvedTemplateType ( resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "fixed_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } findBoundsByIteration ( ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_3"}
