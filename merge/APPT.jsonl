{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Chart_14"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Chart_19"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; }", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { return foundDigit & & ! hasExp ; } / / last character is illegal", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Lang_24"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_25"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_3"}
{"buggy_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_35"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; } if ( isInfinite ) {", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_89"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_90"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_99"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ; case 1 :", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ; case 1 :", "label": 1, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Time_15"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "fixed_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ; } final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch2", "project_name": "Math_98"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleList . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_57"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = ( ( residualsWeights [ i ] ) * residual ) * residual ; } return chiSquare ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + ImageMapUtilities . htmlEscape ( toolTipText ) }", "fixed_code": "* @ return The formatted HTML area tag attribute ( s ) . public String generateToolTipFragment ( String toolTipText ) { return \" title = \\ \" \" + toolTipText \" \\ \" alt = \\ \" \\ \" \" ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_10"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; setDataset ( dataset ) ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , Math . max ( constraint . getWidth ( ) - w [ 2 ] , 0 . 0 ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "fixed_code": "h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { if ( this . dataset = = null ) { return 0 . 0 ; } double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; if ( this . dataset ! = null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; } state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "fixed_code": "* @ return The percent . public double getMaximumExplodePercent ( ) { double result = 0 . 0 ; Iterator iterator = this . dataset . getKeys ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; return state ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} else { this . seriesKeys = new Comparable [ 0 ] ; this . categoryKeys = new Comparable [ 0 ] ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = getCategoryCount ( ) ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "fixed_code": "} else { this . seriesKeys = null ; this . categoryKeys = null ; } } if ( categoryKeys = = null ) { throw new IllegalArgumentException ( \" Null ' categoryKeys ' argument . \" ) ; } if ( categoryKeys . length ! = this . startData [ 0 ] . length ) { throw new IllegalArgumentException ( \" The number of categories does not match the data . \" ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_16"}
{"buggy_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { TimeSeries clone = ( TimeSeries ) super . clone ( ) ; clone . data = ( List ) ObjectUtilities . deepClone ( this . data ) ; return clone ; }", "fixed_code": "* subclasses may differ . public Object clone ( ) throws CloneNotSupportedException { Object clone = createCopy ( 0 , getItemCount ( ) - 1 ) ; return clone ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; rebuildIndex ( ) ; } public void removeColumn ( Comparable columnKey ) { if ( columnKey = = null ) { throw new IllegalArgumentException ( \" Null ' columnKey ' argument . \" ) ; } if ( ! this . columnKeys . contains ( columnKey ) ) { throw new UnknownKeyException ( \" Unknown key : \" + columnKey ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { rowData . removeValue ( columnKey ) ; } } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } } public void removeColumn ( Comparable columnKey ) { Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { DefaultKeyedValues rowData = ( DefaultKeyedValues ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = intervalXYData . getXValue ( series , item ) ; lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double value = ixyd . getYValue ( series , item ) ; double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( value ) ) { minimum = Math . min ( minimum , value ) ; maximum = Math . max ( maximum , value ) ; } if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; maximum = Math . max ( maximum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { minimum = Math . min ( minimum , uvalue ) ; maximum = Math . max ( maximum , uvalue ) ; } }", "fixed_code": "for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { lvalue = intervalXYData . getStartXValue ( series , item ) ; uvalue = intervalXYData . getEndXValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } } for ( int series = 0 ; series < seriesCount ; series + + ) { int itemCount = dataset . getItemCount ( series ) ; for ( int item = 0 ; item < itemCount ; item + + ) { double lvalue = ixyd . getStartYValue ( series , item ) ; double uvalue = ixyd . getEndYValue ( series , item ) ; if ( ! Double . isNaN ( lvalue ) ) { minimum = Math . min ( minimum , lvalue ) ; } if ( ! Double . isNaN ( uvalue ) ) { maximum = Math . max ( maximum , uvalue ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_2"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } else { double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . minimumRangeValueRow = - 1 ; this . minimumRangeValueColumn = - 1 ; this . maximumRangeValue = Double . NaN ; this . maximumRangeValueRow = - 1 ; this . maximumRangeValueColumn = - 1 ; int rowCount = getRowCount ( ) ; int columnCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r + + ) { for ( int c = 0 ; c < columnCount ; c + + ) { BoxAndWhiskerItem item = getItem ( r , c ) ; if ( item ! = null ) { Number min = item . getMinOutlier ( ) ; if ( min ! = null ) { double minv = min . doubleValue ( ) ; if ( ! Double . isNaN ( minv ) ) { if ( minv < this . minimumRangeValue | | Double . isNaN ( this . minimumRangeValue ) ) { this . minimumRangeValue = minv ; this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } } } Number max = item . getMaxOutlier ( ) ; if ( max ! = null ) { double maxv = max . doubleValue ( ) ; if ( ! Double . isNaN ( maxv ) ) { if ( maxv > this . maximumRangeValue | | Double . isNaN ( this . maximumRangeValue ) ) { this . maximumRangeValue = maxv ; this . maximumRangeValueRow = r ; this . maximumRangeValueColumn = c ; } } } } } } }", "fixed_code": "& & this . minimumRangeValueColumn = = c ) ) { updateBounds ( ) ; } double minval = Double . NaN ; if ( item . getMinOutlier ( ) ! = null ) { this . minimumRangeValueRow = r ; this . minimumRangeValueColumn = c ; } this . rangeBounds = new Range ( this . minimumRangeValue , this . maximumRangeValue ) ; private void updateBounds ( ) { this . minimumRangeValue = Double . NaN ; this . maximumRangeValue = Double . NaN ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey } KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; int index = rowData . getIndex ( columnKey ) ; if ( index > = 0 ) { return rowData . getObject ( index ) ; } else { return null ; } / / 2 . check whether the column is now empty . allNull = true ; for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 & & row . getObject ( columnIndex ) ! = null ) { allNull = false ; break ; } } if ( allNull ) { for ( int item = 0 , itemCount = this . rows . size ( ) ; item < itemCount ; item + + ) { row = ( KeyedObjects ) this . rows . get ( item ) ; int columnIndex = row . getIndex ( columnKey ) ; if ( columnIndex > = 0 ) { row . removeValue ( columnIndex ) ; } } this . columnKeys . remove ( columnKey ) ; } } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" Row key ( \" + rowKey + \" ) not recognised . \" ) ; } removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; int i = rowData . getIndex ( columnKey ) ; if ( i > = 0 ) { rowData . removeValue ( i ) ; } } this . columnKeys . remove ( columnKey ) ; }", "fixed_code": "throw new UnknownKeyException ( \" Column key ( \" + columnKey \" ) not recognised . \" ) ; } if ( row > = 0 ) { KeyedObjects rowData = ( KeyedObjects ) this . rows . get ( row ) ; return rowData . getObject ( columnKey ) ; } else { return null ; } / / 2 . check whether the column is now empty . } public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; } Iterator iterator = this . rows . iterator ( ) ; while ( iterator . hasNext ( ) ) { KeyedObjects rowData = ( KeyedObjects ) iterator . next ( ) ; rowData . removeValue ( columnKey ) ; } this . columnKeys . remove ( columnKey ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "* * @ since 1 . 0 . 7 public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( ! ( obj instanceof MinMaxCategoryRenderer ) ) { return false ; } MinMaxCategoryRenderer that = ( MinMaxCategoryRenderer ) obj ; if ( this . plotLines ! = that . plotLines ) { return false ; } if ( ! PaintUtilities . equal ( this . groupPaint , that . groupPaint ) ) { return false ; } if ( ! this . groupStroke . equals ( that . groupStroke ) ) { return false ; } return super . equals ( obj ) ; }", "fixed_code": "* * @ since 1 . 0 . 7", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_23"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; if ( meanValue = = null ) { return ; } double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines Number n = dataset . getStdDevValue ( row , column ) ; if ( n ! = null ) { double valueDelta = n . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; } CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "fixed_code": "/ / BAR X Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( lowVal , rectY + rectHeight * 0 . 25 , lowVal , rectY + rectHeight * 0 . 75 ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ; / / BAR Y Number meanValue = dataset . getMeanValue ( row , column ) ; double value = meanValue . doubleValue ( ) ; double base = 0 . 0 ; } / / standard deviation lines double valueDelta = dataset . getStdDevValue ( row , column ) . doubleValue ( ) ; double highVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) valueDelta , dataArea , yAxisLocation ) ; double lowVal = rangeAxis . valueToJava2D ( meanValue . doubleValue ( ) line = new Line2D . Double ( rectX + rectWidth / 2 . 0d - 5 . 0d , lowVal , rectX + rectWidth / 2 . 0d + 5 . 0d , lowVal ) ; g2 . draw ( line ) ; CategoryItemLabelGenerator generator = getItemLabelGenerator ( row , column ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . minY = Double . NaN ; copy . maxY = Double . NaN ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "fixed_code": "throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) { for ( int index = start ; index < = end ; index + + ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "fixed_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } if ( this . allowDuplicateXValues ) { add ( x , y ) ; return null ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "fixed_code": "if ( x = = null ) { throw new IllegalArgumentException ( \" Null ' x ' argument . \" ) ; } / / if we get to here , we know that duplicate X values are not permitted XYDataItem overwritten = null ; int index = indexOf ( x ) ; if ( index > = 0 & & ! this . allowDuplicateXValues ) { XYDataItem existing = ( XYDataItem ) this . data . get ( index ) ; try { overwritten = ( XYDataItem ) existing . clone ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } ShapeList that = ( ShapeList ) obj ; int listSize = size ( ) ; for ( int i = 0 ; i < listSize ; i + + ) { if ( ! ShapeUtilities . equal ( ( Shape ) get ( i ) , ( Shape ) that . get ( i ) ) ) { return false ; } } return true ; }", "fixed_code": "if ( ! ( obj instanceof ShapeList ) ) { return false ; } return super . equals ( obj ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 if ( ! removeGlobals ) { return ; } Node function = fnScope . getRootNode ( ) ;", "fixed_code": "/ / is removing globals , then it ' s OK to remove unused function args . / / / / See http : / / code . google . com / p / closure - compiler / issues / detail ? id = 253 Node function = fnScope . getRootNode ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return anyResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "fixed_code": "static boolean mayBeString ( Node n , boolean recurse ) { if ( recurse ) { return allResultsMatch ( n , MAY_BE_STRING_PREDICATE ) ; } else { return mayBeStringHelper ( n ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; int pType = parent . getType ( ) ; if ( ! ( pType = = Token . BLOCK | | pType = = Token . SCRIPT | | pType = = Token . NAME | | pType = = Token . ASSIGN ) ) { return false ; } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return parent ! = null & & NodeUtil . isGet ( parent ) ; }", "fixed_code": "/ / var a = function ( ) { } ; / / or / / function a ( ) { } / / or / / a . x = function ( ) { } ; } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) { } / / Also report a THIS with a property access . return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_100"}
{"buggy_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } options . closurePass = flags . process_closure_primitives ; initOptionsFromFlags ( options ) ; return options ; }", "fixed_code": "for ( FormattingOption formattingOption : flags . formatting ) { formattingOption . applyToOptions ( options ) ; } if ( flags . process_closure_primitives ) { options . closurePass = true ; } initOptionsFromFlags ( options ) ; return options ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; removeDuplicateDeclarations ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "fixed_code": "@ Override public void process ( Node externs , Node root ) { NodeTraversal . traverse ( compiler , root , this ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; t . traverseRoots ( externs , root ) ; } removeDuplicateDeclarations ( root ) ; new PropogateConstantAnnotations ( compiler , assertOnChange ) . process ( externs , root ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_102"}
{"buggy_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : case Token . INSTANCEOF : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . if ( foundType = = null ) { ObjectType maybeType = ObjectType . cast ( registry . getGreatestSubtypeWithProperty ( type , field ) ) ; / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . if ( maybeType ! = null & & maybeType . hasOwnProperty ( field ) ) { foundType = maybeType ; } } return foundType ; }", "fixed_code": "case Token . ASSIGN : case Token . INC : case Token . DEC : return true ; case Token . FUNCTION : return false ; } / / If the property does not exist on the referenced type but the original / / type is an object type , see if any subtype has the property . / / getGreatestSubtypeWithProperty does not guarantee that the property / / is defined on the returned type , it just indicates that it might be , / / so we have to double check . return foundType ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_103"}
{"buggy_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( ! result . isNoType ( ) ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "fixed_code": "builder . addAlternate ( that ) ; } JSType result = builder . build ( ) ; if ( result ! = null ) { return result ; } else if ( this . isObject ( ) & & that . isObject ( ) ) { return getNativeType ( JSTypeNative . NO_OBJECT_TYPE ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_104"}
{"buggy_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = null ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } else { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = null ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb ! = null ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "fixed_code": "String joinString = NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ; StringBuilder sb = new StringBuilder ( ) ; int foldedSize = 0 ; Node elem = arrayNode . getFirstChild ( ) ; / / Merges adjacent String nodes . while ( elem ! = null ) { if ( NodeUtil . isImmutableValue ( elem ) ) { if ( sb . length ( ) > 0 ) { sb . append ( joinString ) ; } sb . append ( NodeUtil . getStringValue ( elem ) ) ; } else { if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ; sb = new StringBuilder ( ) ; } foldedSize + = InlineCostEstimator . getCost ( elem ) ; arrayFoldedChildren . add ( elem ) ; elem = elem . getNext ( ) ; } if ( sb . length ( ) > 0 ) { / / + 2 for the quotes . foldedSize + = sb . length ( ) + 2 ; arrayFoldedChildren . add ( Node . newString ( sb . toString ( ) ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_105"}
{"buggy_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . Preconditions . checkNotNull ( declaration ) ; if ( declaration . getTwin ( ) ! = null ) { return false ; } if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { populated = true ; return currentInfo . documentBlock ( description ) ; }", "fixed_code": "/ / Don ' t try to collapse if the one global set is a twin reference . / / We could theoretically handle this case in CollapseProperties , but / / it ' s probably not worth the effort . if ( isClassOrEnum ) { return true ; * @ return { @ code true } if the description was recorded . public boolean recordBlockDescription ( String description ) { if ( parseDocumentation ) { populated = true ; } return currentInfo . documentBlock ( description ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; options . setWarningLevel ( JsMessageVisitor . MSG_CONVENTIONS , CheckLevel . OFF ) ; } return options ;", "fixed_code": "/ / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . private final Set < Node > injectedDecls = Sets . newHashSet ( ) ; / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; injectedDecls . clear ( ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } injectedDecls . add ( newDecl . getFirstChild ( ) ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null & & ! injectedDecls . contains ( n ) ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "fixed_code": "private final Map < String , Var > aliases = Maps . newHashMap ( ) ; / / Also temporary and cleared for each scope . / / Suppose you create an alias . / / var x = goog . x ; if ( t . getScopeDepth ( ) = = 2 ) { renameNamespaceShadows ( t ) ; aliases . clear ( ) ; forbiddenLocals . clear ( ) ; transformation = null ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" / / When we inject declarations , we duplicate jsdoc . Make sure / / we only process that jsdoc once . JSDocInfo info = n . getJSDocInfo ( ) ; if ( info ! = null ) { for ( Node node : info . getTypeNodes ( ) ) { fixTypeNode ( node ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { if ( token = = JsDocToken . QMARK ) { return newNode ( Token . QMARK ) ; } else { return parseBasicTypeExpression ( token ) ; } }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "fixed_code": "if ( childType . isDict ( ) ) { report ( t , property , TypeValidator . ILLEGAL_PROPERTY_ACCESS , \" ' . ' \" , \" dict \" ) ; } else if ( n . getJSType ( ) ! = null & & parent . isAssign ( ) ) { return ; } else if ( validator . expectNotNullOrUndefined ( t , n , childType , \" No properties on this expression \" , getNativeType ( OBJECT_TYPE ) ) ) { checkPropertyAccess ( childType , property . getString ( ) , t , n ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_11"}
{"buggy_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; boolean isFunctionDecl = NodeUtil . isFunctionDeclaration ( parent ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar | | isFunctionDecl ) { boolean isHoisted = NodeUtil . isHoistedFunctionDeclaration ( parent ) ; Node grandparent = parent . getParent ( ) ; Node value = v . getInitialValue ( ) ! = null ? v . getInitialValue ( ) : null ; Node varNode = null ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . if ( isFunctionDecl ) { / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . Node existingName = v . getNameNode ( ) ; / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . Node newName = IR . name ( \" \" ) . useSourceInfoFrom ( existingName ) ; value . replaceChild ( existingName , newName ) ; varNode = IR . var ( existingName ) . useSourceInfoFrom ( existingName ) ; grandparent . replaceChild ( parent , varNode ) ; } else { if ( value ! = null ) { / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . value . detachFromParent ( ) ; } varNode = parent ; } / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; if ( isHoisted ) { grandparent . addChildToFront ( newDecl ) ; } else { grandparent . addChildBefore ( newDecl , varNode ) ; } } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; if ( n = = null ) { throw new RuntimeException ( \" node is not a child \" ) ; } while ( n . next ! = child ) { n = n . next ;", "fixed_code": "Node n = v . getNode ( ) ; Node parent = n . getParent ( ) ; boolean isVar = parent . isVar ( ) ; if ( isVar & & n . getFirstChild ( ) ! = null & & n . getFirstChild ( ) . isQualifiedName ( ) ) { recordAlias ( v ) ; } else if ( v . isBleedingFunction ( ) ) { } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else if ( isVar ) { Node grandparent = parent . getParent ( ) ; Node value = n . hasChildren ( ) ? v . getInitialValue ( ) . detachFromParent ( ) : null ; Node varNode = parent ; String name = n . getString ( ) ; int nameCount = scopedAliasNames . count ( name ) ; / / First , we need to free up the function expression ( EXPR ) / / to be used in another expression . / / Replace \" function NAME ( ) { . . . } \" with \" var NAME ; \" . / / We can ' t keep the local name on the function expression , / / because IE is buggy and will leak the name into the global / / / / This will only cause problems if this is a hoisted , recursive / / function , and the programmer is using the hoisting . / / If this is a VAR , we can just detach the expression and / / the tree will still be valid . / / Add $ jscomp . scope . name = EXPR ; / / Make sure we copy over all the jsdoc and debug info . NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ; grandparent . addChildBefore ( newDecl , varNode ) ; } / / Rewrite \" var name = EXPR ; \" to \" var name = $ jscomp . scope . name ; \" return null ; } Node n = first ; while ( n . next ! = child ) { n = n . next ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_110"}
{"buggy_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType . isAllType ( ) ? getNativeType ( ARRAY_TYPE ) : topType ; } @ Override", "fixed_code": "new RestrictByTrueTypeOfResultVisitor ( ) { @ Override protected JSType caseTopType ( JSType topType ) { return topType ; } @ Override", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_111"}
{"buggy_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = Maps . filterKeys ( inferTemplateTypesFromParameters ( fnType , n ) , new Predicate < TemplateType > ( ) {  @ Override public boolean apply ( TemplateType key ) { return keys . contains ( key ) ; } } ) ; / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "fixed_code": "} / / Try to infer the template types Map < TemplateType , JSType > inferred = inferTemplateTypesFromParameters ( fnType , n ) ;  / / Replace all template types . If we couldn ' t find a replacement , we / / replace it with UNKNOWN .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null | | requiresLevel . isOn ( ) ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "/ / the checks for broken requires turned off . In these cases , we / / allow broken requires to be preserved by the first run to / / let them be caught in the subsequent run . if ( provided ! = null ) { parent . detachFromParent ( ) ; compiler . reportCodeChange ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_113"}
{"buggy_code": "} else { recordDepScope ( nameNode , ns ) ; } } else if ( ! ( parent . isCall ( ) & & parent . getFirstChild ( ) = = n ) ) { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "fixed_code": "} else { recordDepScope ( nameNode , ns ) ; } } else { / / The rhs of the assignment is the caller , so it ' s used by the / / context . Don ' t associate it w / the lhs . / / FYI : this fixes only the specific case where the assignment is the", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node block = fnNode . getLastChild ( ) ; boolean hasSideEffects = false ; / / empty function case if ( block . hasChildren ( ) ) { Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "Node block = fnNode . getLastChild ( ) ; / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ] Node cArg = callNode . getFirstChild ( ) . getNext ( ) ; / / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } / / The best type name is the actual type name . if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "fixed_code": "* to an Object type , if possible . String getReadableJSTypeName ( Node n , boolean dereference ) { / / The best type name is the actual type name . / / If we ' re analyzing a GETPROP , the property may be inherited by the / / prototype chain . So climb the prototype chain and find out where } } JSType type = getJSType ( n ) ; if ( dereference ) { ObjectType dereferenced = type . dereference ( ) ; if ( dereferenced ! = null ) { type = dereferenced ; } } if ( type . isFunctionPrototypeType ( ) | | ( type . toObjectType ( ) ! = null & & type . toObjectType ( ) . getConstructor ( ) ! = null ) ) { return type . toString ( ) ; } String qualifiedName = n . getQualifiedName ( ) ; if ( qualifiedName ! = null ) { return qualifiedName ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET if ( child . isQuotedString ( ) ) { continue ; } / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { / / Maybe STRING , GET , SET / / We should never see a mix of numbers and strings . String name = child . getString ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_118"}
{"buggy_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . CATCH : case Token . INC : case Token . DEC : isSet = true ;", "fixed_code": "isSet = true ; type = Name . Type . FUNCTION ; break ; case Token . INC : case Token . DEC : isSet = true ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { List < DiGraphEdge < Node , Branch > > branchEdges = getCfg ( ) . getOutEdges ( cfgNode ) ; for ( DiGraphEdge < Node , Branch > edge : branchEdges ) { if ( edge . getValue ( ) = = Branch . ON_EX ) { return true ; } } return false ; }", "fixed_code": "} private boolean hasExceptionHandler ( Node cfgNode ) { return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { if ( ref . getSymbol ( ) . getScope ( ) ! = ref . scope ) { return false ; } break ; } else if ( block . isLoop ) { return false ;", "fixed_code": "for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) & & / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . ( isInlineableDeclaredConstant ( v , referenceInfo ) | | referenceInfo . isOnlyAssignmentSameScopeAsDeclaration ( ) ) ) { List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "fixed_code": "if ( ! maybeModifiedArguments & & ! staleVars . contains ( v ) & & referenceInfo . isWellDefined ( ) & & referenceInfo . isAssignedOnceInLifetime ( ) ) { / / Inlining the variable based solely on well - defined and assigned / / once is * NOT * correct . We relax the correctness requirement if / / the variable is declared constant . List < Reference > refs = referenceInfo . references ; Node nameNode = refs . get ( i ) . getNode ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) { Pattern p = Pattern . compile ( \" ( / | ( \\ n [ \\ t ] * ) ) \\ \\ * [ \\ t ] * @ [ a - zA - Z ] \" ) ; if ( p . matcher ( comment . getValue ( ) ) . find ( ) ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = getContextForNoInOperator ( context ) ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; while ( node . isGetProp ( ) ) { node = node . getFirstChild ( ) ; } if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "fixed_code": "} Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null & & fnType . hasInstanceType ( ) ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "fixed_code": "JSType type = getJSType ( constructor ) . restrictByNotNullOrUndefined ( ) ; if ( type . isConstructor ( ) | | type . isEmptyType ( ) | | type . isUnknownType ( ) ) { FunctionType fnType = type . toMaybeFunctionType ( ) ; if ( fnType ! = null ) { visitParameterList ( t , n , fnType ) ; ensureTyped ( t , n , fnType . getInstanceType ( ) ) ; } else {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough & & ! inFinally ( n . getParent ( ) , n ) ) { removeNode ( n ) ; } } } } private boolean inFinally ( Node parent , Node child ) { if ( parent = = null | | parent . isFunction ( ) ) { return false ; } else if ( NodeUtil . isTryFinallyNode ( parent , child ) ) { return true ; } else { return inFinally ( parent . getParent ( ) , parent ) ; } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } } } } private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; if ( len = = 0 ) { return false ; } for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len = = 1 | | s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "static boolean isSimpleNumber ( String s ) { int len = s . length ( ) ; for ( int index = 0 ; index < len ; index + + ) { char c = s . charAt ( index ) ; if ( c < ' 0 ' | | c > ' 9 ' ) { return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_128"}
{"buggy_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . while ( first . isCast ( ) ) { first = first . getFirstChild ( ) ; } if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "fixed_code": "Node first = n . getFirstChild ( ) ; / / ignore cast nodes . if ( ! NodeUtil . isGet ( first ) ) { n . putBooleanProp ( Node . FREE_CALL , true ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { Node next = c . getNext ( ) ; traverse ( c ) ; c = next ; }", "fixed_code": "do { Node c = node . getFirstChild ( ) ; while ( c ! = null ) { traverse ( c ) ; Node next = c . getNext ( ) ; c = next ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_13"}
{"buggy_code": "continue ; } if ( ! name . inExterns & & name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "fixed_code": "continue ; } if ( name . globalSets = = 1 & & name . localSets = = 0 & & name . aliasingGets > 0 ) { / / { @ code name } meets condition ( b ) . Find all of its local aliases / / and try to inline them .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "int length = s . length ( ) ; if ( length = = 0 | | Character . isIdentifierIgnorable ( s . charAt ( 0 ) ) | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( Character . isIdentifierIgnorable ( s . charAt ( i ) ) | | ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "fixed_code": "int length = s . length ( ) ; if ( length = = 0 | | ! Character . isJavaIdentifierStart ( s . charAt ( 0 ) ) ) { return false ; } for ( int i = 1 ; i < length ; i + + ) { if ( ! Character . isJavaIdentifierPart ( s . charAt ( i ) ) ) { return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_131"}
{"buggy_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) & & ( ! mayHaveSideEffects ( cond ) | | ( thenOp . isAssign ( ) & & thenOp . getFirstChild ( ) . isName ( ) ) ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "fixed_code": "/ / evaluates LHS before cond ] / / NOTE - there are some circumstances where we can / / proceed even if there are side effects . . . ! mayEffectMutableState ( lhs ) ) { n . removeChild ( cond ) ; Node assignName = thenOp . removeFirstChild ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; unreadToken = NO_UNREAD_TOKEN ; return result ; }", "fixed_code": "private String getRemainingJSDocLine ( ) { String result = stream . getRemainingJSDocLine ( ) ; return result ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "return true ; } if ( n . isDelProp ( ) ) { return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "fixed_code": "return true ; } for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final Node aliasDefinition ; private final String aliasName ; AliasedTypeNode ( Node typeReference , Node aliasDefinition , String aliasName ) { this . typeReference = typeReference ; this . aliasDefinition = aliasDefinition ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { String typeName = typeReference . getString ( ) ; String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName ( ) ) ; Preconditions . checkState ( typeName . startsWith ( aliasName ) ) ; typeReference . setString ( typeName . replaceFirst ( aliasName , aliasExpanded ) ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode , baseName ) ) ; } }", "fixed_code": "private class AliasedTypeNode implements AliasUsage { private final Node typeReference ; private final String aliasName ; AliasedTypeNode ( Node typeReference , String aliasName ) { this . typeReference = typeReference ; this . aliasName = aliasName ; } @ Override public void applyAlias ( ) { typeReference . setString ( aliasName ) ; } } Var aliasVar = aliases . get ( baseName ) ; if ( aliasVar ! = null ) { Node aliasedNode = aliasVar . getInitialValue ( ) ; aliasUsages . add ( new AliasedTypeNode ( typeNode , aliasedNode . getQualifiedName ( ) + name . substring ( endIndex ) ) ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_16"}
{"buggy_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { JSDocInfo rValueInfo = rValue . getJSDocInfo ( ) ; if ( rValueInfo ! = null & & rValueInfo . hasType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . return rValueInfo . getType ( ) . evaluate ( scope , typeRegistry ) ; } else if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "fixed_code": "if ( info . isConstant ( ) ) { JSType knownType = null ; if ( rValue ! = null ) { if ( rValue . getJSType ( ) ! = null & & ! rValue . getJSType ( ) . isUnknownType ( ) ) { / / If rValue has a type - cast , we use the type in the type - cast . / / If rValue ' s type was already computed during scope creation , / / then we can safely use that . return rValue . getJSType ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_17"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; case Token . THIS : / / \" this \" references aren ' t currently modeled in the CFG . break ; default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "fixed_code": "scope . inferQualifiedSlot ( node , qualifiedName , origType , type ) ; break ; / / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" +", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; if ( implicitProto = = null ) { / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = ImmutableSet . of ( ) ; } else { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; } for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "fixed_code": "ObjectType interfaceType ) { ObjectType implicitProto = interfaceType . getImplicitPrototype ( ) ; Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null & & value . getNext ( ) = = null & & NodeUtil . isImmutableValue ( value ) ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "fixed_code": "/ / slightly different semantics than ' ' + ( a ) . See / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 759 Node value = callTarget . getNext ( ) ; if ( value ! = null ) { Node addition = IR . add ( IR . string ( \" \" ) . srcref ( callTarget ) , value . detachFromParent ( ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_20"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( parent . getType ( ) = = Token . COMMA ) { if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ; } } if ( ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( n . isExprResult ( ) | | n . isBlock ( ) ) { return ; } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "fixed_code": "/ / Do not try to remove a block or an expr result . We already handle / / these cases when we visit the child , and the peephole passes will / / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } } / / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) { } else { return ; } } boolean isResultUsed = NodeUtil . isExpressionResultUsed ( n ) ; boolean isSimpleOp = NodeUtil . isSimpleOperatorType ( n . getType ( ) ) ; if ( ! isResultUsed & & ( isSimpleOp | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { if ( n . isQualifiedName ( ) & & n . getJSDocInfo ( ) ! = null ) { return ; } else if ( n . isExprResult ( ) ) { return ; } String msg = \" This code lacks side - effects . Is there a bug ? \" ; if ( n . isString ( ) ) { msg = \" Is there a missing ' + ' on the previous line ? \" ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null ; i + + ) { if ( i ! = intIndex ) { if ( mayHaveSideEffects ( current ) ) { return n ; } } else { elem = current ; } current = current . getNext ( ) ; }", "fixed_code": "Node current = left . getFirstChild ( ) ; Node elem = null ; for ( int i = 0 ; current ! = null & & i < intIndex ; i + + ) { elem = current ; current = current . getNext ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_23"}
{"buggy_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) & & n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; } else if ( v . isBleedingFunction ( ) ) { / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . } else if ( parent . getType ( ) = = Token . LP ) { / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } }", "fixed_code": "Node n = v . getNode ( ) ; int type = n . getType ( ) ; Node parent = n . getParent ( ) ; if ( parent . isVar ( ) ) { if ( n . hasChildren ( ) & & n . getFirstChild ( ) . isQualifiedName ( ) ) { String name = n . getString ( ) ; Var aliasVar = scope . getVar ( name ) ; aliases . put ( name , aliasVar ) ; String qualifiedName = aliasVar . getInitialValue ( ) . getQualifiedName ( ) ; transformation . addAlias ( name , qualifiedName ) ; / / Bleeding functions already get a BAD_PARAMETERS error , so just / / do nothing . / / Parameters of the scope function also get a BAD_PARAMETERS / / error . } else { / / TODO ( robbyw ) : Support using locals for private variables . report ( t , n , GOOG_SCOPE_NON_ALIAS_LOCAL , n . getString ( ) ) ; } } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_24"}
{"buggy_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { scope = traverseChildren ( n , scope ) ; Node constructor = n . getFirstChild ( ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; backwardsInferenceFromCallSite ( n , ct ) ; } } } n . setJSType ( type ) ; return scope ; }", "fixed_code": "} private FlowScope traverseNew ( Node n , FlowScope scope ) { Node constructor = n . getFirstChild ( ) ; scope = traverse ( constructor , scope ) ; JSType constructorType = constructor . getJSType ( ) ; JSType type = null ; if ( constructorType ! = null ) { } if ( ct ! = null & & ct . isConstructor ( ) ) { type = ct . getInstanceType ( ) ; } } } n . setJSType ( type ) ; for ( Node arg = constructor . getNext ( ) ; arg ! = null ; arg = arg . getNext ( ) ) { scope = traverse ( arg , scope ) ; } return scope ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_25"}
{"buggy_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; private Set < String > modulesWithExports = Sets . newHashSet ( ) ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { if ( ! modulesWithExports . contains ( moduleName ) ) { return ; } Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; modulesWithExports . add ( moduleName ) ; }", "fixed_code": "AbstractPostOrderCallback { private int scriptNodeCount = 0 ; @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { private void emitOptionalModuleExportsOverride ( Node script , String moduleName ) { Node moduleExportsProp = IR . getprop ( IR . name ( moduleName ) , IR . string ( \" module $ exports \" ) ) ; Node exports = prop . getChildAtIndex ( 1 ) ; exports . putProp ( Node . ORIGINALNAME_PROP , \" exports \" ) ; exports . setString ( \" module $ exports \" ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "return block ; } private static Node blockUnchecked ( Node stmt ) { return new Node ( Token . BLOCK , stmt ) ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( finallyBody . isBlock ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = blockUnchecked ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "fixed_code": "return block ; } public static Node script ( Node . . . stmts ) { / / TODO ( johnlenz ) : finish setting up the SCRIPT node } public static Node tryFinally ( Node tryBody , Node finallyBody ) { Preconditions . checkState ( tryBody . isLabelName ( ) ) ; Preconditions . checkState ( finallyBody . isLabelName ( ) ) ; Node catchBody = block ( ) . copyInformationFrom ( tryBody ) ; return new Node ( Token . TRY , tryBody , catchBody , finallyBody ) ; } public static Node tryCatch ( Node tryBody , Node catchNode ) { Preconditions . checkState ( tryBody . isBlock ( ) ) ; Preconditions . checkState ( catchNode . isCatch ( ) ) ; Node catchBody = block ( catchNode ) . copyInformationFrom ( catchNode ) ; return new Node ( Token . TRY , tryBody , catchBody ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_27"}
{"buggy_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . @ Override void addConstant ( String newcode ) { add ( \" 0 \" ) ; } } }", "fixed_code": "* Constants ( true , false , null ) are considered basically free , * because it ' s likely that they will get folded when we ' re done . } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_28"}
{"buggy_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; Set < String > validProperties = Sets . newHashSet ( ) ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . String propName = parent . getLastChild ( ) . getString ( ) ; if ( ! validProperties . contains ( propName ) ) { if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , gramps ) ) { validProperties . add ( propName ) ; } else { return false ; } } continue ; } return false ; } validProperties . add ( child . getString ( ) ) ; Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "fixed_code": "private boolean isInlinableObject ( List < Reference > refs ) { boolean ret = false ; for ( Reference ref : refs ) { Node name = ref . getNode ( ) ; Node parent = ref . getParent ( ) ; / / We short - circuit this problem by bailing out if we see a reference / / to a property that isn ' t defined on the object literal . This / / isn ' t a perfect algorithm , but it should catch most cases . continue ; } return false ; } Node childVal = child . getFirstChild ( ) ; / / Check if childVal is the parent of any of the passed in", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_29"}
{"buggy_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( t . getScope ( ) ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( final Scope scope ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; case Token . NAME : Var var = scope . getOwnSlot ( input . getString ( ) ) ; if ( var ! = null & & var . getParentNode ( ) . isCatch ( ) ) { return true ; } } return false ; }", "fixed_code": "reachingUses = new MaybeReachingVariableUse ( cfg , t . getScope ( ) , compiler ) ; reachingUses . analyze ( ) ; for ( Candidate c : candidates ) { if ( c . canInline ( ) ) { c . inlineVariable ( ) ; / / If definition c has dependencies , then inlining it may have return defMetadata . node ; } private boolean canInline ( ) { / / Cannot inline a parameter . if ( getDefCfgNode ( ) . isFunction ( ) ) { return false ; case Token . REGEXP : case Token . NEW : return true ; } return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverseRoots ( externs , root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; private boolean unknownDependencies = false ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; if ( dep = = null ) { def . unknownDependencies = true ; } else { def . depends . add ( dep ) ; } } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; if ( def . unknownDependencies ) { return true ; } for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "fixed_code": "@ Override public void process ( Node externs , Node root ) { ( new NodeTraversal ( compiler , this ) ) . traverse ( root ) ; } @ Override private static class Definition { final Node node ; final Set < Var > depends = Sets . newHashSet ( ) ; Definition ( Node node ) { this . node = node ; new AbstractCfgNodeTraversalCallback ( ) { @ Override public void visit ( NodeTraversal t , Node n , Node parent ) { if ( n . isName ( ) & & jsScope . isDeclared ( n . getString ( ) , true ) ) { Var dep = jsScope . getVar ( n . getString ( ) ) ; def . depends . add ( dep ) ; } } } ) ; GraphNode < Node , Branch > n = getCfg ( ) . getNode ( useNode ) ; FlowState < MustDef > state = n . getAnnotation ( ) ; Definition def = state . getIn ( ) . reachingDef . get ( jsScope . getVar ( name ) ) ; for ( Var s : def . depends ) { if ( s . scope ! = jsScope ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_30"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . int lineStartChar = - 1 ; do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . lineStartChar = stream . getCharno ( ) + 1 ; } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; lineStartChar = 0 ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; boolean isEOC = token = = JsDocToken . EOC ; if ( ! isEOC ) { if ( lineStartChar ! = - 1 & & option = = WhitespaceOption . PRESERVE ) { int numSpaces = stream . getCharno ( ) - lineStartChar ; for ( int i = 0 ; i < numSpaces ; i + + ) { builder . append ( ' ' ) ; } lineStartChar = - 1 ; } else if ( builder . length ( ) > 0 ) { / / All tokens must be separated by a space . builder . append ( ' ' ) ; } } if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "fixed_code": "/ / Track the start of the line to count whitespace that / / the tokenizer skipped . Because this case is rare , it ' s easier / / to do this here than in the tokenizer . do { switch ( token ) { case STAR : if ( ignoreStar ) { / / Mark the position after the star as the new start of the line . } else { / / The star is part of the comment . if ( builder . length ( ) > 0 ) { } ignoreStar = true ; token = next ( ) ; continue ; ignoreStar = false ; state = State . SEARCHING_ANNOTATION ; / / All tokens must be separated by a space . if ( token = = JsDocToken . EOC | | token = = JsDocToken . EOF | | return new ExtractionInfo ( multilineText , token ) ; } if ( builder . length ( ) > 0 ) { builder . append ( ' ' ) ; } builder . append ( toString ( token ) ) ; line = stream . getRemainingJSDocLine ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_32"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( hasReferenceName ( ) ) { return ; } / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { unrollBinaryOperator ( n , type , opstr , context , rhsContext , p , p + 1 ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . addOp ( opStr , true ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' & & op . charAt ( 0 ) ! = ' , ' ) { append ( \" \" ) ; } append ( op ) ;", "fixed_code": "cc . addOp ( opstr , true ) ; addExpr ( last , p , rhsContext ) ; } else { addExpr ( first , p , context ) ; cc . addOp ( opstr , true ) ; addExpr ( last , p + 1 , rhsContext ) ; } return ; } Node current = firstNonOperator ; do { current = current . getParent ( ) ; cc . listSeparator ( ) ; addExpr ( current . getFirstChild ( ) . getNext ( ) , rightPrecedence , rhsContext ) ; } while ( current ! = n ) ; } @ Override void appendOp ( String op , boolean binOp ) { if ( binOp ) { if ( getLastChar ( ) ! = ' ' ) { append ( \" \" ) ; } append ( op ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_34"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null ) { type . matchConstraint ( constraintObj ) ; } }", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! objType . isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! objType . hasProperty ( prop ) ) { typeToInfer = getNativeType ( VOID_TYPE ) . getLeastSupertype ( propType ) ; } objType . defineInferredProperty ( prop , typeToInfer , null ) ; } } } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . if ( convention . getSingletonGetterClassName ( callNode ) ! = null ) { return false ; } } }", "fixed_code": "/ / issue 668 : Don ' t inline singleton getter methods / / calls as this confused class removing logic . } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_36"}
{"buggy_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) , body ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; if ( ! bodyNode . isBlock ( ) ) { / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . Preconditions . checkState ( config . isIdeMode ) ; bodyNode = IR . block ( ) ; } parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "fixed_code": "/ / Body Preconditions . checkState ( body . getNext ( ) = = null & & body . isBlock ( ) ) ; traverseBranch ( body , n ) ; popScope ( ) ; node . addChildToBack ( lp ) ; Node bodyNode = transform ( functionNode . getBody ( ) ) ; / / When in ideMode Rhino tries to parse some constructs the compiler / / doesn ' t support , repair it here . see Rhino ' s / / Parser # parseFunctionBodyExpr . parseDirectives ( bodyNode ) ; node . addChildToBack ( bodyNode ) ; return node ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_37"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( x < 0 | | negativeZero ) & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ; if ( ! forAnnotations & & i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return forAnnotations ? \" ? \" : \" { . . . } \" ; } }", "fixed_code": "sb . append ( property ) ; sb . append ( \" : \" ) ; sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } prettyPrint = true ; return sb . toString ( ) ; } else { return \" { . . . } \" ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_39"}
{"buggy_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectInheritanceCycle ( ) ) { handleTypeCycle ( t ) ; }", "fixed_code": "/ / makes more sense . Now , resolution via registry is first in order to / / avoid triggering the warnings built into the resolution via properties . boolean resolved = resolveViaRegistry ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; } } resolveViaProperties ( t , enclosing ) ; if ( detectImplicitPrototypeCycle ( ) ) { handleTypeCycle ( t ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_4"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } }", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ; } } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "} / / Clone any remaining params that aren ' t in the function literal . while ( oldParams . hasNext ( ) ) { paramBuilder . newParameterFromNode ( oldParams . next ( ) ) ; } parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( ! isVarArgs ) { while ( oldParameterType ! = null & & ! isVarArgs ) { builder . newParameterFromNode ( oldParameterType ) ; oldParameterType = oldParameterType . getNext ( ) ; } } if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "fixed_code": "} / / Clone any remaining params that aren ' t in the function literal . parametersNode = paramBuilder . build ( ) ; } } / / Copy over any old parameters that aren ' t in the param list . if ( templateTypeName ! = null & & ! foundTemplateType ) { reportError ( TEMPLATE_TYPE_EXPECTED , fnName ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_41"}
{"buggy_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { if ( loopNode . isForEach ( ) ) { errorReporter . error ( \" unsupported language extension : for each \" , sourceName , loopNode . getLineno ( ) , \" \" , 0 ) ; / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . EXPR_RESULT , Node . newNumber ( 0 ) ) ; } return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "fixed_code": "@ Override Node processForInLoop ( ForInLoop loopNode ) { / / Return the bare minimum to put the AST in a valid state . return newNode ( Token . FOR , transform ( loopNode . getIterator ( ) ) ,", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_42"}
{"buggy_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314 private List < Node > lentObjectLiterals = null ;", "fixed_code": "* For more information , see * http : / / code . google . com / p / closure - compiler / issues / detail ? id = 314", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_43"}
{"buggy_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; } else if ( c = = ' / ' & & getLastChar ( ) = = ' / ' ) { / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / append ( \" \" ) ; } append ( newcode ) ;", "fixed_code": "/ / need space to separate . This is not pretty printing . / / For example : \" return foo ; \" append ( \" \" ) ; / / Do not allow a forward slash to appear after a DIV . / / For example , / / REGEXP DIV REGEXP / / is valid and should print like / / / / / / / } append ( newcode ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_44"}
{"buggy_code": "assignedToUnknownValue = true ; } boolean maybeEscaped = false ; for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } if ( assign . maybeAliased ) { maybeEscaped = true ; } } if ( ( assignedToUnknownValue | | maybeEscaped ) & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = NodeUtil . isExpressionResultUsed ( assignNode ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "fixed_code": "assignedToUnknownValue = true ; } for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) { changes = markReferencedVar ( var ) | | changes ; maybeUnreferenced . remove ( current ) ; current - - ; this . nameNode = nameNode ; this . isPropertyAssign = isPropertyAssign ; this . maybeAliased = ! assignNode . getParent ( ) . isExprResult ( ) ; this . mayHaveSecondarySideEffects = maybeAliased | | NodeUtil . mayHaveSideEffects ( assignNode . getFirstChild ( ) ) | |", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) + 1 ) . setColumnPosition ( entry . getSourceColumn ( ) + 1 ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . int lineBaseOffset = 1 ; if ( generator instanceof SourceMapGeneratorV1 | | generator instanceof SourceMapGeneratorV2 ) { lineBaseOffset = 0 ; } generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) - lineBaseOffset , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "fixed_code": "/ / Adjust the line / column here to be start at 1 . Builder x = OriginalMapping . newBuilder ( ) . setOriginalFile ( sources [ entry . getSourceFileId ( ) ] ) . setLineNumber ( entry . getSourceLine ( ) ) . setColumnPosition ( entry . getSourceColumn ( ) ) ; if ( entry . getNameId ( ) ! = UNMAPPED ) { x . setIdentifier ( names [ entry . getNameId ( ) ] ) ; } / / zero based . / / We don ' t change this for the v1 or v2 source maps but for / / v3 we make them both 0 based . generator . addMapping ( sourceFile , originalName , new FilePosition ( node . getLineno ( ) , node . getCharno ( ) ) , outputStartPosition , outputEndPosition ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_47"}
{"buggy_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred & & rhsValue ! = null & & rhsValue . isFunction ( ) ) { / / Determining declaration for # 2 if ( info ! = null ) { inferred = false ; } else if ( ! scope . isDeclared ( qName , false ) & & n . isUnscopedQualifiedName ( ) ) { inferred = false ; } } if ( ! inferred ) {", "fixed_code": "| | FunctionTypeBuilder . isFunctionTypeDeclaration ( info ) ) ; } if ( inferred ) { / / Determining declaration for # 2 inferred = ! ( rhsValue ! = null & & rhsValue . isFunction ( ) & & ( info ! = null | | ! scope . isDeclared ( qName , false ) ) ) ; } if ( ! inferred ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } nameStack . push ( renamer ) ; } break ; case Token . LP : { Renamer renamer = nameStack . peek ( ) . forChildScope ( ) ; / / Add the function parameters for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } / / Add the function body declarations Node functionBody = n . getNext ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope nameStack . pop ( ) ; / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; case Token . LP : / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . break ; case Token . CATCH : / / Remove catch except name from the stack of names .", "fixed_code": "renamer = nameStack . peek ( ) . forChildScope ( ) ; } if ( declarationRoot . getType ( ) = = Token . FUNCTION ) { for ( Node c = declarationRoot . getFirstChild ( ) . getNext ( ) . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { String name = c . getString ( ) ; renamer . addDeclaredName ( name ) ; } Node functionBody = declarationRoot . getLastChild ( ) ; findDeclaredNames ( functionBody , null , renamer ) ; } else if ( declarationRoot . getType ( ) ! = Token . FUNCTION ) { / / Add the block declarations findDeclaredNames ( declarationRoot , null , renamer ) ; renamer . addDeclaredName ( name ) ; } / / Add the function parameters / / Add the function body declarations nameStack . push ( renamer ) ; } case Token . FUNCTION : / / Remove the function body scope / / Remove function recursive name ( if any ) . nameStack . pop ( ) ; break ; / / Note : The parameters and function body variables live in the / / same scope , we introduce the scope when in the \" shouldTraverse \" / / visit of LP , but remove it when when we exit the function above . case Token . CATCH : / / Remove catch except name from the stack of names .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_49"}
{"buggy_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . if ( gramps . isDelProp ( ) ) { return false ; } / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "fixed_code": "/ / Deleting a property has different semantics from deleting / / a variable , so deleted properties should not be inlined . / / NOTE ( nicksantos ) : This pass ' s object - splitting algorithm has / / a blind spot . It assumes that if a property isn ' t defined on an", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_5"}
{"buggy_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( right . getNext ( ) ! = null | | ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } if ( right ! = null & & right . getType ( ) = = Token . STRING & & \" , \" . equals ( right . getString ( ) ) ) { / / \" , \" is the default , it doesn ' t need to be explicit n . removeChild ( right ) ; reportCodeChange ( ) ; } String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "fixed_code": "Node right = callTarget . getNext ( ) ; if ( right ! = null ) { if ( ! NodeUtil . isImmutableValue ( right ) ) { return n ; } } return n ; } / / \" , \" is the default , it doesn ' t need to be explicit String joinString = ( right = = null ) ? \" , \" : NodeUtil . getStringValue ( right ) ; List < Node > arrayFoldedChildren = Lists . newLinkedList ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "add ( \" \" ) ; } if ( ( long ) x = = x & & ! isNegativeZero ( x ) ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "fixed_code": "add ( \" \" ) ; } if ( ( long ) x = = x ) { long value = ( long ) x ; long mantissa = value ; int exp = 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_51"}
{"buggy_code": "return false ; } } return len > 0 & & s . charAt ( 0 ) ! = ' 0 ' ; } static double getSimpleNumber ( String s ) {", "fixed_code": "return false ; } } return len > 0 ; } static double getSimpleNumber ( String s ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_52"}
{"buggy_code": "} Node replacement ; if ( nodes . isEmpty ( ) ) { replacement = new Node ( Token . TRUE ) ; } else { / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; } Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "fixed_code": "} Node replacement ; / / All assignments evaluate to true , so make sure that the / / expr statement evaluates to true in case it matters . nodes . add ( new Node ( Token . TRUE ) ) ; } cur . addChildToFront ( nodes . get ( i ) ) ; cur . addChildToFront ( nodes . get ( i + 1 ) ) ; Node replace = ref . getParent ( ) ; replacement . copyInformationFromForTree ( replace ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_53"}
{"buggy_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . ObjectType qVarType = ObjectType . cast ( qVar . getType ( ) ) ; if ( qVarType ! = null & & rhsValue ! = null & & rhsValue . getType ( ) = = Token . OBJECTLIT ) { typeRegistry . resetImplicitPrototype ( rhsValue . getJSType ( ) , qVarType . getImplicitPrototype ( ) ) ; } else if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } PrototypeObjectType oldPrototype = this . prototype ; boolean replacedPrototype = oldPrototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; if ( oldPrototype ! = null ) { / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . oldPrototype . setOwnerFunction ( null ) ; } if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "fixed_code": "/ / then they are responsible for making sure that the object literal ' s / / implicit prototype is set up appropriately . We just obey / / the @ extends tag . if ( ! qVar . isTypeInferred ( ) ) { / / If the programmer has declared that F inherits from Super , / / and they assign F . prototype to some arbitrary expression , / / there ' s not much we can do . We just ignore the expression , / / / / In the second case , we just use the anonymous object as the prototype . if ( baseType . hasReferenceName ( ) | | baseType . isUnknownType ( ) | | isNativeObjectType ( ) | | baseType . isFunctionPrototypeType ( ) | | ! ( baseType instanceof PrototypeObjectType ) ) { return false ; } boolean replacedPrototype = prototype ! = null ; this . prototype = prototype ; this . prototypeSlot = new SimpleSlot ( \" prototype \" , prototype , true ) ; this . prototype . setOwnerFunction ( this ) ; / / Disassociating the old prototype makes this easier to debug - - / / we don ' t have to worry about two prototypes running around . if ( isConstructor ( ) | | isInterface ( ) ) { FunctionType superClass = getSuperClassConstructor ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_54"}
{"buggy_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) & & ! NodeUtil . isGetOrSetKey ( n . getParent ( ) ) ; }", "fixed_code": "} private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . if ( pos > = js . length ( ) ) { return null ; } else { return js . substring ( pos , js . length ( ) ) ; } } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "fixed_code": "/ / If next new line cannot be found , there are two cases / / 1 . pos already reaches the end of file , then null should be returned / / 2 . otherwise , return the contents between pos and the end of file . return null ; } else { return js . substring ( pos , js . indexOf ( ' \\ n ' , pos ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_56"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } if ( NodeUtil . isName ( lhs ) ) { addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; } else { computeGenKill ( lhs , gen , kill , conditional ) ; } computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "fixed_code": "/ / for ( var x in y ) { . . . } lhs = lhs . getLastChild ( ) ; } addToSetIfLocal ( lhs , kill ) ; addToSetIfLocal ( lhs , gen ) ; computeGenKill ( rhs , gen , kill , conditional ) ; } return ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_58"}
{"buggy_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) & & ! options . disables ( DiagnosticGroups . GLOBAL_THIS ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "fixed_code": "CheckLevel . OFF ) ; } if ( options . checkGlobalThisLevel . isOn ( ) ) { options . setWarningLevel ( DiagnosticGroups . GLOBAL_THIS , options . checkGlobalThisLevel ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { mismatch ( t , n , msg , rightType , leftType ) ; return false ; } return true ;", "fixed_code": "JSType leftType , Node owner , String propName ) { / / The NoType check is a hack to make typedefs work OK . if ( ! leftType . isNoType ( ) & & ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { / / Do not type - check interface methods , because we expect that / / they will have dummy implementations that do not match the type / / annotations . \" assignment to property \" + propName + \" of \" + getReadableJSTypeName ( owner , true ) , rightType , leftType ) ; } return false ; } return true ; boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ( leftType . isConstructor ( ) | | leftType . isEnumType ( ) ) & & ( rightType . isConstructor ( ) | | rightType . isEnumType ( ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "/ / ignoring side - effects return TernaryValue . TRUE ; case Token . VOID : return TernaryValue . FALSE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : if ( ! mayHaveSideEffects ( n . getFirstChild ( ) ) ) { return TernaryValue . FALSE ; } break ; case Token . NAME : String name = n . getString ( ) ;", "fixed_code": "/ / ignoring side - effects return TernaryValue . TRUE ; default : return getPureBooleanValue ( n ) ; return TernaryValue . FALSE ; case Token . VOID : return TernaryValue . FALSE ; case Token . NAME : String name = n . getString ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_60"}
{"buggy_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . NAME ) { String namespaceName = nameNode . getFirstChild ( ) . getString ( ) ; if ( namespaceName . equals ( \" Math \" ) ) { return false ; } } if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "fixed_code": "} / / Functions in the \" Math \" namespace have no side effects . if ( compiler ! = null & & ! compiler . hasRegExpGlobalReferences ( ) ) { if ( nameNode . getFirstChild ( ) . getType ( ) = = Token . REGEXP", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap , inputSeqNum = = 0 ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null , true ) ; } private String toSource ( Node n , SourceMap sourceMap , boolean firstOutput ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( firstOutput & & options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "fixed_code": "/ / if LanguageMode is ECMASCRIPT5_STRICT , only print ' use strict ' / / for the first input file String code = toSource ( root , sourceMap ) ; if ( ! code . isEmpty ( ) ) { cb . append ( code ) ; @ Override String toSource ( Node n ) { initCompilerOptionsIfTesting ( ) ; return toSource ( n , null ) ; } private String toSource ( Node n , SourceMap sourceMap ) { CodePrinter . Builder builder = new CodePrinter . Builder ( n ) ; builder . setPrettyPrint ( options . prettyPrint ) ; builder . setLineBreak ( options . lineBreak ) ; builder . setSourceMap ( sourceMap ) ; builder . setSourceMapDetailLevel ( options . sourceMapDetailLevel ) ; builder . setTagAsStrict ( options . getLanguageOut ( ) = = LanguageMode . ECMASCRIPT5_STRICT ) ; builder . setLineLengthThreshold ( options . lineLengthThreshold ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 000 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_65"}
{"buggy_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; } else { / / Object literal keys are not typeable typeable = false ; } break ;", "fixed_code": "/ / Object literal keys are handled with OBJECTLIT if ( ! NodeUtil . isObjectLitKey ( n , n . getParent ( ) ) ) { ensureTyped ( t , n , STRING_TYPE ) ; / / Object literal keys are not typeable } break ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP & & assign . getParent ( ) . getType ( ) = = Token . EXPR_RESULT ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "fixed_code": "Node n = assign . getFirstChild ( ) ; if ( n ! = null & & NodeUtil . isVarOrSimpleAssignLhs ( n , assign ) & & n . getType ( ) = = Token . GETPROP ) { / / We want to exclude the assignment itself from the usage list boolean isChainedProperty = n . getFirstChild ( ) . getType ( ) = = Token . GETPROP ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "} break ; } } token = eatTokensUntilEOL ( ) ; continue retry ; } } } } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "fixed_code": "} break ; } token = eatTokensUntilEOL ( ) ; } continue retry ; } } } } return reportGenericTypeSyntaxWarning ( ) ; } / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . if ( functionType . isOrdinaryFunction ( ) & & ! functionType . getTypeOfThis ( ) . isUnknownType ( ) & & ! functionType . getTypeOfThis ( ) . isNativeObjectType ( ) & & ! ( child . getType ( ) = = Token . GETELEM | | child . getType ( ) = = Token . GETPROP ) ) { report ( t , n , EXPECTED_THIS_TYPE , functionType . toString ( ) ) ; } visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "fixed_code": "/ / Functions with explcit ' this ' types must be called in a GETPROP / / or GETELEM . visitParameterList ( t , n , functionType ) ; ensureTyped ( t , n , functionType . getReturnType ( ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_69"}
{"buggy_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; if ( resultEqualsValue ) { / / Objects are restricted to \" Function \" , subtypes are left return ctorType . getGreatestSubtype ( type ) ; } else { / / Only filter out subtypes of \" function \" return type . isSubtype ( ctorType ) ? null : type ; } } return matchesExpectation ( \" object \" ) ? type : null ; }", "fixed_code": "public JSType caseObjectType ( ObjectType type ) { if ( value . equals ( \" function \" ) ) { JSType ctorType = getNativeType ( U2U_CONSTRUCTOR_TYPE ) ; return resultEqualsValue & & ctorType . isSubtype ( type ) ? ctorType : null ; / / Objects are restricted to \" Function \" , subtypes are left / / Only filter out subtypes of \" function \" } return matchesExpectation ( \" object \" ) ? type : null ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = parent . getJSDocInfo ( ) ! = null & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "fixed_code": "if ( objectType ! = null ) { / / Is this a normal property access , or are we trying to override / / an existing property ? boolean isOverride = t . inGlobalScope ( ) & & parent . getType ( ) = = Token . ASSIGN & & parent . getFirstChild ( ) = = getprop ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_71"}
{"buggy_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . new RenameLabels ( compiler , new LabelNameSupplier ( idSupplier ) , false ) . process ( null , fnNode ) ; } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced | | ! removeUnused ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "fixed_code": "\" inline_ \" , isCallInLoop ) ) ) ; / / Make label names unique to this instance . } static class LabelNameSupplier implements Supplier < String > { String name = nameNode . getString ( ) ; LabelInfo li = getLabelInfo ( name ) ; / / This is a label . . . if ( li . referenced ) { String newName = getNameForId ( li . id ) ; if ( ! name . equals ( newName ) ) { / / . . . and it is used , give it the short name .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_72"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = getNormalizedNodeType ( left ) ; int rhType = getNormalizedNodeType ( right ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) { private int getNormalizedNodeType ( Node n ) { int type = n . getType ( ) ; if ( type = = Token . NOT ) { TernaryValue value = NodeUtil . getPureBooleanValue ( n ) ; switch ( value ) { case TRUE : return Token . TRUE ; case FALSE : return Token . FALSE ; } } return type ; }", "fixed_code": "& & right . getString ( ) . equals ( \" undefined \" ) ) | | ( Token . VOID = = right . getType ( ) & & NodeUtil . isLiteralValue ( right . getFirstChild ( ) , false ) ) ) ; int lhType = left . getType ( ) ; int rhType = right . getType ( ) ; switch ( lhType ) { case Token . VOID : if ( ! NodeUtil . isLiteralValue ( left . getFirstChild ( ) , false ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_74"}
{"buggy_code": "} static Double getStringNumberValue ( String rawJsString ) { if ( rawJsString . contains ( \" \\ u000b \" ) ) { / / vertical tab is not always whitespace return null ; } String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . UNKNOWN ; / / IE says \" no \" , EcmaScript says \" yes \" case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "fixed_code": "} static Double getStringNumberValue ( String rawJsString ) { / / vertical tab is not always whitespace String s = trimJsWhiteSpace ( rawJsString ) ; / / return ScriptRuntime . toNumber ( s ) ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR >", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . if ( n . getNext ( ) ! = null ) { state = isVariableReadBeforeKill ( n . getNext ( ) , variable ) ; if ( state = = VariableLiveness . KILL ) { state = VariableLiveness . MAYBE_LIVE ; } } break ; case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . if ( n . getNext ( ) ! = null & & n . getNext ( ) . getNext ( ) ! = null ) { state = checkHookBranchReadBeforeKill ( n . getNext ( ) , n . getNext ( ) . getNext ( ) , variable ) ; } break ; default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { break ; } } } / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( ControlFlowGraph . isEnteringNewCfgNode ( n ) ) { / / Not a FUNCTION return VariableLiveness . MAYBE_LIVE ; } if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : VariableLiveness v1 = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; VariableLiveness v2 = isVariableReadBeforeKill ( n . getLastChild ( ) , variable ) ; / / With a AND / OR the first branch always runs , but the second is / / may not . if ( v1 ! = VariableLiveness . MAYBE_LIVE ) { return v1 ; } else if ( v2 = = VariableLiveness . READ ) { return VariableLiveness . READ ; } else { return VariableLiveness . MAYBE_LIVE ; } case Token . HOOK : VariableLiveness first = isVariableReadBeforeKill ( n . getFirstChild ( ) , variable ) ; if ( first ! = VariableLiveness . MAYBE_LIVE ) { return first ; } return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } return VariableLiveness . MAYBE_LIVE ;", "fixed_code": "/ / If the currently node is the first child of / / AND / OR , be conservative only consider the READs / / of the second operand . case Token . HOOK : / / If current node is the condition , check each following / / branch , otherwise it is a conditional branch and the / / other branch can be ignored . default : for ( Node sibling = n . getNext ( ) ; sibling ! = null ; sibling = sibling . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( sibling ) ) { state = isVariableReadBeforeKill ( sibling , variable ) ; / / If we see a READ or KILL there is no need to continue . if ( state = = VariableLiveness . READ ) { return true ; } else if ( state = = VariableLiveness . KILL ) { return false ; } } } } n = n . getParent ( ) ; } private VariableLiveness isVariableReadBeforeKill ( Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / Conditionals case Token . OR : case Token . AND : / / With a AND / OR the first branch always runs , but the second is / / may not . case Token . HOOK : return checkHookBranchReadBeforeKill ( n . getFirstChild ( ) . getNext ( ) , n . getLastChild ( ) , variable ) ; / / Expressions are evaluated left - right , depth first . for ( Node child = n . getFirstChild ( ) ; child ! = null ; child = child . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( child ) ) { / / Not a FUNCTION VariableLiveness state = isVariableReadBeforeKill ( child , variable ) ; if ( state ! = VariableLiveness . MAYBE_LIVE ) { return state ; } } } } return VariableLiveness . MAYBE_LIVE ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ 0 ' : sb . append ( \" \\ \\ 0 \" ) ; break ; case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "fixed_code": "for ( int i = 0 ; i < s . length ( ) ; i + + ) { char c = s . charAt ( i ) ; switch ( c ) { case ' \\ n ' : sb . append ( \" \\ \\ n \" ) ; break ; case ' \\ r ' : sb . append ( \" \\ \\ r \" ) ; break ; case ' \\ t ' : sb . append ( \" \\ \\ t \" ) ; break ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_77"}
{"buggy_code": "break ; case Token . MOD : if ( rval = = 0 ) { return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { return null ; } result = lval / rval ;", "fixed_code": "break ; case Token . MOD : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval % rval ; break ; case Token . DIV : if ( rval = = 0 ) { error ( DiagnosticType . error ( \" JSC_DIVIDE_BY_0_ERROR \" , \" Divide by 0 \" ) , right ) ; return null ; } result = lval / rval ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverseRoots ( externs , root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; compiler . reportCodeChange ( ) ; }", "fixed_code": "public void process ( Node externs , Node root ) { new NodeTraversal ( compiler , new NormalizeStatements ( compiler , assertOnChange ) ) . traverse ( root ) ; if ( MAKE_LOCAL_NAMES_UNIQUE ) { MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique ( ) ; NodeTraversal t = new NodeTraversal ( compiler , renamer ) ; getSynthesizedExternsRoot ( ) . addChildToBack ( new Node ( Token . VAR , nameNode ) ) ; varsToDeclareInExterns . remove ( varName ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_79"}
{"buggy_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! isNamedParameter ( var ) & & ! blacklistedVars . contains ( var ) ; } } private boolean isNamedParameter ( Var v ) { return v . getParentNode ( ) . isParamList ( ) ; } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "fixed_code": "Var var = s . getVar ( lhs . getString ( ) ) ; return var ! = null & & var . getScope ( ) = = s & & ! blacklistedVars . contains ( var ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . case Token . DELPROP : return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . DELPROP : case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "fixed_code": "/ / Inversion case Token . NOT : / / delete operator returns a boolean . return true ; default : return false ; case Token . OBJECTLIT : / / Literals objects with non - literal children are allowed . return true ; case Token . IN : / / TODO ( johnlenz ) : should IN operator be included in # isSimpleOperator ? return true ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_80"}
{"buggy_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { int functionType = functionNode . getFunctionType ( ) ; if ( functionType ! = FunctionNode . FUNCTION_EXPRESSION ) { errorReporter . error ( \" unnamed function statement \" , sourceName , functionNode . getLineno ( ) , \" \" , 0 ) ; } name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "fixed_code": "Name name = functionNode . getFunctionName ( ) ; Boolean isUnnamedFunction = false ; if ( name = = null ) { name = new Name ( ) ; name . setIdentifier ( \" \" ) ; isUnnamedFunction = true ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_81"}
{"buggy_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) | | ( registry . getNativeFunctionType ( JSTypeNative . LEAST_FUNCTION_TYPE ) = = this ) ; } public boolean isNumberObjectType ( ) {", "fixed_code": "} public final boolean isEmptyType ( ) { return isNoType ( ) | | isNoObjectType ( ) | | isNoResolvedType ( ) ; } public boolean isNumberObjectType ( ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_82"}
{"buggy_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = null ; try { param = params . getParameter ( 0 ) ; } catch ( CmdLineException e ) { } if ( param = = null ) { setter . addValue ( true ) ;", "fixed_code": "@ Override public int parseArguments ( Parameters params ) throws CmdLineException { String param = params . getParameter ( 0 ) ; if ( param = = null ) { setter . addValue ( true ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_83"}
{"buggy_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; Node target = assign . getFirstChild ( ) ; if ( ! validAssignmentTarget ( target ) ) { errorReporter . error ( \" invalid assignment target \" , sourceName , target . getLineno ( ) , \" \" , 0 ) ; } return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { if ( type = = Token . INC | | type = = Token . DEC ) { if ( ! validAssignmentTarget ( operand ) ) { String msg = ( type = = Token . INC ) ? \" invalid increment target \" : \" invalid decrement target \" ; errorReporter . error ( msg , sourceName , operand . getLineno ( ) , \" \" , 0 ) ; } } Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } private boolean validAssignmentTarget ( Node target ) { switch ( target . getType ( ) ) { case Token . NAME : case Token . GETPROP : case Token . GETELEM : return true ; } return false ; } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "fixed_code": "@ Override Node processAssignment ( Assignment assignmentNode ) { Node assign = processInfixExpression ( assignmentNode ) ; return assign ; } operand . setDouble ( - operand . getDouble ( ) ) ; return operand ; } else { Node node = newNode ( type , operand ) ; if ( exprNode . isPostfix ( ) ) { } } @ Override Node processVariableDeclaration ( VariableDeclaration declarationNode ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_84"}
{"buggy_code": "return n ; } switch ( n . getType ( ) ) { case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; while ( next ! = null & & next . getType ( ) = = Token . BLOCK ) { if ( next . hasChildren ( ) ) { next = next . getFirstChild ( ) ; } else { next = computeFollowing ( next ) ; } } return next ; }", "fixed_code": "return n ; } if ( n . getParent ( ) = = null ) { List < DiGraphEdge < Node , Branch > > outEdges = gNode . getOutEdges ( ) ; if ( outEdges . size ( ) = = 1 ) { return tryRemoveUnconditionalBranching ( outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ) ; } } switch ( n . getType ( ) ) { case Token . BLOCK : if ( n . hasChildren ( ) ) { Node first = n . getFirstChild ( ) ; return tryRemoveUnconditionalBranching ( first ) ; } else { return tryRemoveUnconditionalBranching ( ControlFlowAnalysis . computeFollowNode ( n ) ) ; } case Token . RETURN : if ( n . hasChildren ( ) ) { break ; ( n . getNext ( ) = = null | | n . getNext ( ) . getType ( ) = = Token . FUNCTION ) ) { Preconditions . checkState ( outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = tryRemoveUnconditionalBranching ( computeFollowing ( n ) ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeDeadExprStatementSafely ( n ) ; private Node computeFollowing ( Node n ) { Node next = ControlFlowAnalysis . computeFollowNode ( n ) ; return next ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_85"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; if ( maybeExpr . getType ( ) = = Token . EXPR_RESULT ) { / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . if ( maybeExpr . getFirstChild ( ) . getType ( ) = = Token . CALL ) { Node calledFn = maybeExpr . getFirstChild ( ) . getFirstChild ( ) ; / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . if ( calledFn . getType ( ) = = Token . GETELEM ) { return false ; } else if ( calledFn . getType ( ) = = Token . GETPROP & & calledFn . getLastChild ( ) . getString ( ) . startsWith ( \" on \" ) ) { return false ; } } return true ; } return false ; } }", "fixed_code": "if ( n . getType ( ) = = Token . BLOCK ) { if ( n . hasOneChild ( ) ) { Node maybeExpr = n . getFirstChild ( ) ; / / IE has a bug where event handlers behave differently when / / their return value is used vs . when their return value is in / / an EXPR_RESULT . It ' s pretty freaking weird . See : / / http : / / code . google . com / p / closure - compiler / issues / detail ? id = 291 / / We try to detect this case , and not fold EXPR_RESULTs / / into other expressions . / / We only have to worry about methods with an implicit ' this ' / / param , or this doesn ' t happen . return NodeUtil . isExpressionNode ( maybeExpr ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_87"}
{"buggy_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { Preconditions . checkState ( n . getParent ( ) . getType ( ) = = Token . ASSIGN ) ; / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . Node rhs = n . getNext ( ) ; VariableLiveness state = isVariableReadBeforeKill ( rhs , variable ) ; if ( state = = VariableLiveness . READ ) { return state ; } return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "fixed_code": "Node n , String variable ) { if ( NodeUtil . isName ( n ) & & variable . equals ( n . getString ( ) ) ) { if ( NodeUtil . isLhs ( n , n . getParent ( ) ) ) { / / The expression to which the assignment is made is evaluated before / / the RHS is evaluated ( normal left to right evaluation ) but the KILL / / occurs after the RHS is evaluated . return VariableLiveness . KILL ; } else { return VariableLiveness . READ ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_88"}
{"buggy_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; if ( rvalue ! = null & & rvalue . getType ( ) = = Token . FUNCTION ) { checkForHosedThisReferences ( rvalue , refName . docInfo , refName ) ; } / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( aliasingGets > 0 ) { return false ; }", "fixed_code": "Node greatGramps = gramps . getParent ( ) ; Node greatGreatGramps = greatGramps . getParent ( ) ; / / Create the new alias node . Node nameNode = NodeUtil . newName ( } / / If this is aliased , then its properties can ' t be collapsed either . if ( type ! = Type . FUNCTION & & aliasingGets > 0 ) { return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_89"}
{"buggy_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . filename = filename . replace ( \" \\ \\ \" , \" / \" ) ; if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( script . getSourceFileName ( ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "fixed_code": "private String normalizeSourceName ( String filename ) { / / The DOS command shell will normalize \" / \" to \" \\ \" , so we have to / / wrestle it back . if ( filename . indexOf ( filenamePrefix ) = = 0 ) { filename = filename . substring ( filenamePrefix . length ( ) ) ; Preconditions . checkArgument ( scriptNodeCount = = 1 , \" ProcessCommonJSModules supports only one invocation per \" + \" CompilerInput / script node \" ) ; String moduleName = guessCJSModuleName ( normalizeSourceName ( script . getSourceFileName ( ) ) ) ; script . addChildToFront ( IR . var ( IR . name ( moduleName ) , IR . objectlit ( ) ) . copyInformationFromForTree ( script ) ) ; if ( reportDependencies ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_9"}
{"buggy_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . restrictByNotNullOrUndefined ( ) . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis ! = null ) { maybeTypeOfThis = maybeTypeOfThis . restrictByNotNullOrUndefined ( ) ; } if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "fixed_code": "/ / create interfaces JSType , ObjectType , FunctionType etc and have / / separate implementation instead of the class hierarchy , so that / / union types can also be object types , etc . if ( ! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) ) ) { reportWarning ( THIS_TYPE_NON_OBJECT , type . toString ( ) ) ; return false ; / / mean \" nullable Foo \" . For certain tags ( like @ extends ) we de - nullify / / the name for them . JSType maybeTypeOfThis = safeResolve ( typeOfThis , t , scope ) ; if ( maybeTypeOfThis instanceof ObjectType ) { typeOfThis = ( ObjectType ) maybeTypeOfThis ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_90"}
{"buggy_code": "} / / Don ' t traverse functions that are getting lent to a prototype . Node gramps = parent . getParent ( ) ; if ( NodeUtil . isObjectLitKey ( parent , gramps ) ) { JSDocInfo maybeLends = gramps . getJSDocInfo ( ) ; if ( maybeLends ! = null & & maybeLends . getLendsName ( ) ! = null & & maybeLends . getLendsName ( ) . endsWith ( \" . prototype \" ) ) { return false ; } } } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "fixed_code": "} / / Don ' t traverse functions that are getting lent to a prototype . } if ( parent ! = null & & parent . getType ( ) = = Token . ASSIGN ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_91"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . lastIndexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_92"}
{"buggy_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . ADD : case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : case Token . DIV : case Token . EQ : case Token . GE : case Token . GT : case Token . LE : case Token . LSH : case Token . LT : case Token . MOD : case Token . MUL : case Token . NE : case Token . RSH : case Token . SHEQ : case Token . SHNE : case Token . SUB : case Token . URSH : return isValidDefineValue ( val . getFirstChild ( ) , defines ) & & isValidDefineValue ( val . getLastChild ( ) , defines ) ; / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : case Token . POS : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "fixed_code": "return true ; / / Binary operators are only valid if both children are valid . case Token . BITAND : case Token . BITNOT : case Token . BITOR : case Token . BITXOR : / / Uniary operators are valid if the child is valid . case Token . NOT : case Token . NEG : return isValidDefineValue ( val . getFirstChild ( ) , defines ) ; / / Names are valid if and only if they are defines themselves .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_94"}
{"buggy_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; if ( n . getType ( ) = = Token . GETPROP & & ! scope . isGlobal ( ) & & isQnameRootedInGlobalScope ( n ) ) { Scope globalScope = scope . getGlobalScope ( ) ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . if ( ! globalScope . isDeclared ( variableName , false ) ) { scopeToDeclareIn = scope . getGlobalScope ( ) ; } } / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "fixed_code": "/ / scope where the root object appears . This helps out people / / who declare \" global \" names in an anonymous namespace . Scope scopeToDeclareIn = scope ; / / don ' t try to declare in the global scope if there ' s / / already a symbol there with this name . / / declared in closest scope ? if ( scopeToDeclareIn . isDeclared ( variableName , false ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_95"}
{"buggy_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & ( parameters . hasNext ( ) | | parameter ! = null & & parameter . isVarArgs ( ) ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . if ( parameters . hasNext ( ) ) { parameter = parameters . next ( ) ; } argument = arguments . next ( ) ; ordinal + + ;", "fixed_code": "Node parameter = null ; Node argument = null ; while ( arguments . hasNext ( ) & & parameters . hasNext ( ) ) { / / If there are no parameters left in the list , then the while loop / / above implies that this must be a var_args function . parameter = parameters . next ( ) ; argument = arguments . next ( ) ; ordinal + + ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_96"}
{"buggy_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . long lvalLong = lvalInt & 0xffffffffL ; result = lvalLong > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "fixed_code": "/ / JavaScript handles zero shifts on signed numbers differently than / / Java as an Java int can not represent the unsigned 32 - bit number / / where JavaScript can so use a long here . result = lvalInt > > > rvalInt ; break ; default : throw new AssertionError ( \" Unknown shift operator : \" +", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_97"}
{"buggy_code": "} / / Make sure this assignment is not in a loop . for ( BasicBlock block = ref . getBasicBlock ( ) ; block ! = null ; block = block . getParent ( ) ) { if ( block . isFunction ) { break ; } else if ( block . isLoop ) { return false ; } } return true ; } private final boolean isFunction ; private final boolean isLoop ;", "fixed_code": "} / / Make sure this assignment is not in a loop . return true ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_98"}
{"buggy_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . isInterface ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( NodeUtil . isGet ( lhs ) ) { if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } Node llhs = lhs . getFirstChild ( ) ; if ( llhs . getType ( ) = = Token . GETPROP & & llhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } } } }", "fixed_code": "JSDocInfo jsDoc = getFunctionJsDocInfo ( n ) ; if ( jsDoc ! = null & & ( jsDoc . isConstructor ( ) | | jsDoc . hasThisType ( ) | | jsDoc . isOverride ( ) ) ) { return false ; } else { / / Only traverse the right side if it ' s not an assignment to a prototype / / property or subproperty . if ( lhs . getType ( ) = = Token . GETPROP & & lhs . getLastChild ( ) . getString ( ) . equals ( \" prototype \" ) ) { return false ; } if ( lhs . getQualifiedName ( ) ! = null & & lhs . getQualifiedName ( ) . contains ( \" . prototype . \" ) ) { return false ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Closure_99"}
{"buggy_code": "} } if ( pfxLen > 0 ) { / / we have a hex number char firstSigDigit = 0 ; / / strip leading zeroes for ( int i = pfxLen ; i < str . length ( ) ; i + + ) { firstSigDigit = str . charAt ( i ) ; if ( firstSigDigit = = ' 0 ' ) { / / count leading zeroes pfxLen + + ; } else { break ; } } final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 | | ( hexDigits = = 16 & & firstSigDigit > ' 7 ' ) ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 | | ( hexDigits = = 8 & & firstSigDigit > ' 7 ' ) ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "fixed_code": "} } if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int return createLong ( str ) ; } return createInteger ( str ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "fixed_code": "* @ return The < code > StringBuilder < / code > private static StringBuilder escapeRegex ( StringBuilder regex , String value , boolean unquote ) { boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' : if ( unquote ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "start = ' ' ; } } } else { if ( end < = start ) { throw new IllegalArgumentException ( \" Parameter end ( \" + end + \" ) must be greater than start ( \" + start + \" ) \" ) ; } } char [ ] buffer = new char [ count ] ;", "fixed_code": "start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_11"}
{"buggy_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars ! = null & & chars . length = = 0 ) { throw new IllegalArgumentException ( \" The chars array must not be empty \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( chars ! = null ) { end = chars . length ; } else { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } } char [ ] buffer = new char [ count ] ;", "fixed_code": "} else if ( count < 0 ) { throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else { end = ' z ' + 1 ; start = ' ' ; } } char [ ] buffer = new char [ count ] ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private static final Map < String , Class < ? > > primitiveTypes = new HashMap < String , Class < ? > > ( ) ; private ClassLoader classLoader ;", "fixed_code": "* class here is a workaround , see the JIRA issue LANG - 626 . < / p > static class ClassLoaderAwareObjectInputStream extends ObjectInputStream { private ClassLoader classLoader ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } if ( cs1 instanceof String & & cs2 instanceof String ) { return cs1 . equals ( cs2 ) ; } return CharSequenceUtils . regionMatches ( cs1 , false , 0 , cs2 , 0 , Math . max ( cs1 . length ( ) , cs2 . length ( ) ) ) ; }", "fixed_code": "if ( cs1 = = null | | cs2 = = null ) { return false ; } return cs1 . equals ( cs2 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_14"}
{"buggy_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( TypeVariable < ? > var : toTypeVarAssigns . keySet ( ) ) { Type toTypeArg = unrollVariableAssignments ( var , toTypeVarAssigns ) ; Type fromTypeArg = unrollVariableAssignments ( var , fromTypeVarAssigns ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( toClass . equals ( cls ) ) { return typeVarAssigns ; }", "fixed_code": "toClass , typeVarAssigns ) ; / / now to check each type argument for ( Map . Entry < TypeVariable < ? > , Type > entry : toTypeVarAssigns . entrySet ( ) ) { Type toTypeArg = entry . getValue ( ) ; Type fromTypeArg = fromTypeVarAssigns . get ( entry . getKey ( ) ) ; / / parameters must either be absent from the subject type , within / / the bounds of the wildcard type , or be an exact match to the : new HashMap < TypeVariable < ? > , Type > ( subtypeVarAssigns ) ; / / has target class been reached ? if ( cls . getTypeParameters ( ) . length > 0 | | toClass . equals ( cls ) ) { return typeVarAssigns ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_15"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "fixed_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; } char lastChar = str . charAt ( str . length ( ) - 1 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "return ; } int pos = 0 ; int len = input . length ( ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; pos + = c . length ; continue ; } / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "return ; } int pos = 0 ; int len = Character . codePointCount ( input , 0 , input . length ( ) ) ; while ( pos < len ) { int consumed = translate ( input , pos , out ) ; if ( consumed = = 0 ) { char [ ] c = Character . toChars ( Character . codePointAt ( input , pos ) ) ; out . write ( c ) ; } else { / / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { if ( pos < len - 2 ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } else { pos + + ; } } pos - - ; } pos + + ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_17"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen = = 2 ) { rule = TwoDigitYearField . INSTANCE ; } else { rule = selectNumberRule ( Calendar . YEAR , tokenLen < 4 ? 4 : tokenLen ) ; } break ; case ' M ' : / / month in year ( text and number )", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ; } break ; case ' M ' : / / month in year ( text and number )", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 2 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # if ( start = = seqEnd ) { return 0 ; } } int end = start ; / / Note that this supports character codes without a ; on the end while ( end < seqEnd & & ( ( input . charAt ( end ) > = ' 0 ' & & input . charAt ( end ) < = ' 9 ' ) | | ( input . charAt ( end ) > = ' a ' & & input . charAt ( end ) < = ' f ' ) | | ( input . charAt ( end ) > = ' A ' & & input . charAt ( end ) < = ' F ' ) ) ) { end + + ; } out . write ( entityValue ) ; } boolean semiNext = ( end ! = seqEnd ) & & ( input . charAt ( end ) = = ' ; ' ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + ( semiNext ? 1 : 0 ) ; } return 0 ; }", "fixed_code": "public int translate ( CharSequence input , int index , Writer out ) throws IOException { int seqEnd = input . length ( ) ; / / Uses - 2 to ensure there is something after the & # if ( input . charAt ( index ) = = ' & ' & & index < seqEnd - 1 & & input . charAt ( index + 1 ) = = ' # ' ) { int start = index + 2 ; boolean isHex = false ; isHex = true ; / / Check there ' s more than just an x after the & # } int end = start ; / / Note that this supports character codes without a ; on the end while ( input . charAt ( end ) ! = ' ; ' ) { end + + ; } out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_19"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . contains ( \" # \" ) ) { / / LANG - 879 - Cannot handle Java 7 script & extensions throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "if ( str = = null ) { return null ; } final int len = str . length ( ) ; if ( len < 2 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_2"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems * 16 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR_OF_DAY ) = = cal2 . get ( Calendar . HOUR_OF_DAY ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw new ArithmeticException ( \" overflow : gcd is 2 ^ 31 \" ) ; } return Math . abs ( u ) + Math . abs ( v ) ; } / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) = = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final int HASH_SEED = 31 ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false @ Override public boolean equals ( Object obj ) { if ( obj = = this ) { return true ; } if ( obj = = null ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; } if ( ObjectUtils . notEqual ( getClass ( ) , obj . getClass ( ) ) ) { return false ; } ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ; if ( ObjectUtils . notEqual ( toPattern , rhs . toPattern ) ) { return false ; } if ( ObjectUtils . notEqual ( registry , rhs . registry ) ) { return false ; } return true ; } @ Override public int hashCode ( ) { int result = super . hashCode ( ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( registry ) ; result = HASH_SEED * result + ObjectUtils . hashCode ( toPattern ) ; return result ; }", "fixed_code": "public class ExtendedMessageFormat extends MessageFormat { private static final long serialVersionUID = - 2362048321261811743L ; private static final String DUMMY_PATTERN = \" \" ; private static final String ESCAPED_QUOTE = \" ' ' \" ; * @ param obj the object to compare to * @ return true if this object equals the other , otherwise false", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_23"}
{"buggy_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp & & ! hasDecPoint ; } / / last character is illegal return false ;", "fixed_code": "if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal return false ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos | | expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "if ( decPos > - 1 ) { if ( expPos > - 1 ) { if ( expPos < decPos ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } dec = str . substring ( decPos + 1 , expPos ) ; mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "return 0 ; } if ( entityValue > 0xFFFF ) { char [ ] chrs = Character . toChars ( entityValue ) ; out . write ( chrs [ 0 ] ) ; out . write ( chrs [ 1 ] ) ; } else { out . write ( entityValue ) ; } return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "fixed_code": "return 0 ; } out . write ( entityValue ) ; return 2 + ( end - start ) + ( isHex ? 1 : 0 ) + 1 ; } return 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_28"}
{"buggy_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static int toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "fixed_code": "* * @ return the version , for example 131 for Java 1 . 3 . 1 static float toJavaVersionInt ( String version ) { return toVersionInt ( toJavaVersionIntArray ( version , JAVA_VERSION_TRIM_SIZE ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_29"}
{"buggy_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { if ( numDecimals < = 7 ) { / / If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { if ( numDecimals < = 16 ) { / / If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "fixed_code": "/ / Must be a Float , Double , BigDecimal final boolean allZeros = isAllZeros ( mant ) & & isAllZeros ( exp ) ; try { final Float f = createFloat ( str ) ; if ( ! ( f . isInfinite ( ) | | ( f . floatValue ( ) = = 0 . 0F & & ! allZeros ) ) ) { return f ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number } try { final Double d = createDouble ( str ) ; if ( ! ( d . isInfinite ( ) | | ( d . doubleValue ( ) = = 0 . 0D & & ! allZeros ) ) ) { return d ; } } catch ( final NumberFormatException nfe ) { / / NOPMD / / ignore the bad number }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_3"}
{"buggy_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return i ; } } else { return i ; } } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return true ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( String cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & Character . isHighSurrogate ( ch ) ) { if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { continue outer ; } } else { continue outer ; } } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; boolean chFound = searchChars . indexOf ( ch ) > = 0 ; if ( i + 1 < strLen & & Character . isHighSurrogate ( ch ) ) { char ch2 = str . charAt ( i + 1 ) ; if ( chFound & & searchChars . indexOf ( ch2 ) < 0 ) { return i ; } } else { if ( ! chFound ) { return i ; } } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int csLast = csLen - 1 ; int searchLen = searchChars . length ; int searchLast = searchLen - 1 ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j = = searchLast ) { / / missing low surrogate , fine , like String . indexOf ( String ) return false ; } if ( i < csLast & & searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return false ; } } else { / / ch is in the Basic Multilingual Plane return false ; } } } }", "fixed_code": "return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character return i ; } } } * < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) | | ArrayUtils . isEmpty ( searchChars ) ) { return false ; } char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLast & & j < searchLast & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / missing low surrogate , fine , like String . indexOf ( String ) if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { * @ return the < code > true < / code > if any of the chars are found , < code > false < / code > if no match or null input * @ since 2 . 4 public static boolean containsAny ( CharSequence cs , String searchChars ) { if ( searchChars = = null ) { return false ; } return INDEX_NOT_FOUND ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; outer : for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { continue outer ; } } return i ; int strLen = str . length ( ) ; for ( int i = 0 ; i < strLen ; i + + ) { char ch = str . charAt ( i ) ; if ( searchChars . indexOf ( ch ) < 0 ) { return i ; } } return INDEX_NOT_FOUND ; return true ; } int csLen = cs . length ( ) ; int searchLen = searchChars . length ; for ( int i = 0 ; i < csLen ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLen ; j + + ) { if ( searchChars [ j ] = = ch ) { / / missing low surrogate , fine , like String . indexOf ( String ) / / ch is in the Basic Multilingual Plane return false ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_30"}
{"buggy_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLastIndex = csLength - 1 ; int searchLastIndex = searchLength - 1 ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { if ( i < csLastIndex & & j < searchLastIndex & & ch > = Character . MIN_HIGH_SURROGATE & & ch < = Character . MAX_HIGH_SURROGATE ) { / / ch is a supplementary character if ( searchChars [ j + 1 ] = = cs . charAt ( i + 1 ) ) { return true ; } } else { / / ch is in the Basic Multilingual Plane return true ; } } } }", "fixed_code": "} int csLength = cs . length ( ) ; int searchLength = searchChars . length ; for ( int i = 0 ; i < csLength ; i + + ) { char ch = cs . charAt ( i ) ; for ( int j = 0 ; j < searchLength ; j + + ) { if ( searchChars [ j ] = = ch ) { / / ch is a supplementary character / / ch is in the Basic Multilingual Plane return true ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_31"}
{"buggy_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) ; static boolean isRegistered ( Object value ) { Set < IDKey > registry = getRegistry ( ) ; return registry ! = null & & registry . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { synchronized ( HashCodeBuilder . class ) { if ( getRegistry ( ) = = null ) { REGISTRY . set ( new HashSet < IDKey > ( ) ) ; } } getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { Set < IDKey > s = getRegistry ( ) ; if ( s ! = null ) { s . remove ( new IDKey ( value ) ) ; synchronized ( HashCodeBuilder . class ) { if ( s . isEmpty ( ) ) { REGISTRY . remove ( ) ; } } } }", "fixed_code": "* * @ since 2 . 3 private static final ThreadLocal < Set < IDKey > > REGISTRY = new ThreadLocal < Set < IDKey > > ( ) { @ Override protected Set < IDKey > initialValue ( ) { return new HashSet < IDKey > ( ) ; } } ; static boolean isRegistered ( Object value ) { return getRegistry ( ) . contains ( new IDKey ( value ) ) ; } static void register ( Object value ) { getRegistry ( ) . add ( new IDKey ( value ) ) ; } * @ since 2 . 3 static void unregister ( Object value ) { getRegistry ( ) . remove ( new IDKey ( value ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_32"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m ! = null & & m . containsKey ( value ) ; }", "fixed_code": "* @ return Set the registry of objects being traversed static Map < Object , Object > getRegistry ( ) { return REGISTRY . get ( ) ! = null ? REGISTRY . get ( ) : Collections . < Object , Object > emptyMap ( ) ; } static boolean isRegistered ( Object value ) { Map < Object , Object > m = getRegistry ( ) ; return m . containsKey ( value ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_34"}
{"buggy_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Arguments cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { throw new IllegalArgumentException ( \" Array and element cannot both be null \" ) ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "fixed_code": "} else if ( element ! = null ) { type = element . getClass ( ) ; } else { type = Object . class ; } @ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T final T [ ] newArray = ( T [ ] ) add ( array , index , element , clss ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { return false ; } return foundDigit ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "fixed_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else { / / can ' t have an E at the last byte return false ; } if ( ! allowSigns & & ( chars [ i ] = = ' d ' | | chars [ i ] = = ' D '", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_36"}
{"buggy_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; try { System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; } catch ( ArrayStoreException ase ) { / / Check if problem is incompatible types final Class < ? > type2 = array2 . getClass ( ) . getComponentType ( ) ; if ( ! type1 . isAssignableFrom ( type2 ) ) { throw new IllegalArgumentException ( \" Cannot store \" + type2 . getName ( ) + \" in an array of \" + type1 . getName ( ) ) ; } throw ase ; / / No , so rethrow original } return joinedArray ; }", "fixed_code": "final Class < ? > type1 = array1 . getClass ( ) . getComponentType ( ) ; T [ ] joinedArray = ( T [ ] ) Array . newInstance ( type1 , array1 . length + array2 . length ) ; System . arraycopy ( array1 , 0 , joinedArray , 0 , array1 . length ) ; System . arraycopy ( array2 , 0 , joinedArray , array1 . length , array2 . length ) ; / / Check if problem is incompatible types return joinedArray ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_37"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; / / / LANG - 538 calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < String , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < String , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] . toString ( ) , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq . toString ( ) ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "fixed_code": "public class LookupTranslator extends CharSequenceTranslator { private final HashMap < CharSequence , CharSequence > lookupMap ; private final int shortest ; private final int longest ; * @ param lookup CharSequence [ ] [ ] table of size [ * ] [ 2 ] public LookupTranslator ( final CharSequence [ ] . . . lookup ) { lookupMap = new HashMap < CharSequence , CharSequence > ( ) ; int _shortest = Integer . MAX_VALUE ; int _longest = 0 ; if ( lookup ! = null ) { for ( final CharSequence [ ] seq : lookup ) { this . lookupMap . put ( seq [ 0 ] , seq [ 1 ] ) ; final int sz = seq [ 0 ] . length ( ) ; if ( sz < _shortest ) { _shortest = sz ; / / descend so as to get a greedy algorithm for ( int i = max ; i > = shortest ; i - - ) { final CharSequence subSeq = input . subSequence ( index , index + i ) ; final CharSequence result = lookupMap . get ( subSeq ) ; if ( result ! = null ) { out . write ( result . toString ( ) ) ; return i ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_4"}
{"buggy_code": "if ( str = = null | | searchStr = = null ) { return false ; } int len = searchStr . length ( ) ; int max = str . length ( ) - len ; for ( int i = 0 ; i < = max ; i + + ) { if ( str . regionMatches ( true , i , searchStr , 0 , len ) ) { return true ; } } return false ; } / / IndexOfAny chars", "fixed_code": "if ( str = = null | | searchStr = = null ) { return false ; } return contains ( str . toUpperCase ( ) , searchStr . toUpperCase ( ) ) ; } / / IndexOfAny chars", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_40"}
{"buggy_code": "return StringUtils . EMPTY ; } StringBuffer arrayPrefix = new StringBuffer ( ) ; / / Handle array encoding if ( className . startsWith ( \" [ \" ) ) { while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; arrayPrefix . append ( \" [ ] \" ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 , className . length ( ) - 1 ) ; } } if ( reverseAbbreviationMap . containsKey ( className ) ) { className = reverseAbbreviationMap . get ( className ) ; } int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out + arrayPrefix ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null | | className . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / Strip array encoding while ( className . charAt ( 0 ) = = ' [ ' ) { className = className . substring ( 1 ) ; } / / Strip Object type encoding if ( className . charAt ( 0 ) = = ' L ' & & className . charAt ( className . length ( ) - 1 ) = = ' ; ' ) { className = className . substring ( 1 ) ; } int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "fixed_code": "return StringUtils . EMPTY ; } / / Handle array encoding / / Strip Object type encoding int lastDotIdx = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; int innerIdx = className . indexOf ( if ( innerIdx ! = - 1 ) { out = out . replace ( INNER_CLASS_SEPARATOR_CHAR , PACKAGE_SEPARATOR_CHAR ) ; } return out ; } / / Package name * @ return the package name or an empty string public static String getPackageName ( String className ) { if ( className = = null ) { return StringUtils . EMPTY ; } / / Strip array encoding / / Strip Object type encoding int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ; if ( i = = - 1 ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { int c = Character . codePointAt ( str , i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > = 0x010000 & & i < len - 1 ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ; i + + ; } else if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "fixed_code": "public void escape ( Writer writer , String str ) throws IOException { int len = str . length ( ) ; for ( int i = 0 ; i < len ; i + + ) { char c = str . charAt ( i ) ; String entityName = this . entityName ( c ) ; if ( entityName = = null ) { if ( c > 0x7F ) { writer . write ( \" & # \" ) ; writer . write ( Integer . toString ( c , 10 ) ) ; writer . write ( ' ; ' ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_42"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . length ( ) = = 1 & & ! Character . isDigit ( val . charAt ( 0 ) ) ) { throw new NumberFormatException ( val + \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "fixed_code": "if ( val . length ( ) = = 0 ) { throw new NumberFormatException ( \" \\ \" \\ \" is not a valid number . \" ) ; } if ( val . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string if ( lower > str . length ( ) ) { lower = str . length ( ) ; } / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "fixed_code": "/ / if the lower value is greater than the length of the string , / / set to the length of the string / / if the upper value is - 1 ( i . e . no limit ) or is greater / / than the length of the string , set to the length of the string if ( upper = = - 1 | | upper > str . length ( ) ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes , boolean escapeForwardSlash ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes , escapeForwardSlash ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote , boolean escapeForwardSlash ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : if ( escapeForwardSlash ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ; break ; default :", "fixed_code": "* @ return String with escaped values , < code > null < / code > if null string input public static String escapeJava ( String str ) { return escapeJavaStyleString ( str , false ) ; } public static void escapeJava ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , false ) ; } public static String escapeJavaScript ( String str ) { return escapeJavaStyleString ( str , true ) ; } public static void escapeJavaScript ( Writer out , String str ) throws IOException { escapeJavaStyleString ( out , str , true ) ; } private static String escapeJavaStyleString ( String str , boolean escapeSingleQuotes ) { if ( str = = null ) { return null ; } try { StringWriter writer = new StringWriter ( str . length ( ) * 2 ) ; escapeJavaStyleString ( writer , str , escapeSingleQuotes ) ; return writer . toString ( ) ; } catch ( IOException ioe ) { / / this should never ever happen while writing to a StringWriter * @ param escapeForwardSlash TODO * @ throws IOException if an IOException occurs private static void escapeJavaStyleString ( Writer out , String str , boolean escapeSingleQuote ) throws IOException { if ( out = = null ) { throw new IllegalArgumentException ( \" The Writer must not be null \" ) ; } out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default :", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) { str = \" \" ; } int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { if ( lhs instanceof java . math . BigDecimal ) { isEquals = ( ( ( java . math . BigDecimal ) lhs ) . compareTo ( rhs ) = = 0 ) ; } else { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "fixed_code": "} Class lhsClass = lhs . getClass ( ) ; if ( ! lhsClass . isArray ( ) ) { / / The simple case , not an array , just test the element isEquals = lhs . equals ( rhs ) ; } else if ( lhs . getClass ( ) ! = rhs . getClass ( ) ) { / / Here when we compare different dimensions , for example : a boolean [ ] [ ] to a boolean [ ] this . setEquals ( false ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_48"}
{"buggy_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { if ( numerator = = 0 ) { return equals ( ZERO ) ? this : ZERO ; } int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "fixed_code": "* @ return a new reduced fraction instance , or this if no simplification possible public Fraction reduce ( ) { int gcd = greatestCommonDivisor ( Math . abs ( numerator ) , denominator ) ; if ( gcd = = 1 ) { return this ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_49"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; if ( ch0 = = ' _ ' ) { if ( len < 3 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch1 = str . charAt ( 1 ) ; final char ch2 = str . charAt ( 2 ) ; if ( ! Character . isUpperCase ( ch1 ) | | ! Character . isUpperCase ( ch2 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( len = = 3 ) { return new Locale ( \" \" , str . substring ( 1 , 3 ) ) ; } if ( len < 5 ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } if ( str . charAt ( 3 ) ! = ' _ ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( \" \" , str . substring ( 1 , 3 ) , str . substring ( 4 ) ) ; } else { final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } final char ch0 = str . charAt ( 0 ) ; final char ch1 = str . charAt ( 1 ) ; if ( ! Character . isLowerCase ( ch0 ) | | ! Character . isLowerCase ( ch1 ) ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } return new Locale ( str . substring ( 0 , 2 ) , str . substring ( 3 , 5 ) , str . substring ( 6 ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_5"}
{"buggy_code": "key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale = = null ) { locale = Locale . getDefault ( ) ; } key = new Pair ( key , locale ) ; FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "fixed_code": "key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateInstance ( style , locale ) ; String pattern = formatter . toPattern ( ) ; if ( timeZone ! = null ) { key = new Pair ( key , timeZone ) ; } if ( locale ! = null ) { key = new Pair ( key , locale ) ; } FastDateFormat format = ( FastDateFormat ) cDateTimeInstanceCache . get ( key ) ; if ( format = = null ) { if ( locale = = null ) { locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ; break ; default : out . write ( ch ) ; break ;", "fixed_code": "out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; default : out . write ( ch ) ; break ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_52"}
{"buggy_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; } if ( field = = Calendar . SECOND ) { done = true ; } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; } if ( field = = Calendar . MINUTE ) { done = true ; } / / truncate minutes", "fixed_code": "int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; if ( ch3 = = ' _ ' ) { return new Locale ( str . substring ( 0 , 2 ) , \" \" , str . substring ( 4 ) ) ; } char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ; } char ch3 = str . charAt ( 3 ) ; char ch4 = str . charAt ( 4 ) ; if ( ch3 < ' A ' | | ch3 > ' Z ' | | ch4 < ' A ' | | ch4 > ' Z ' ) { throw new IllegalArgumentException ( \" Invalid locale format : \" + str ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_54"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( this . runningState = = STATE_RUNNING ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "private transient Rule [ ] mRules ; private transient int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "private Rule [ ] mRules ; private int mMaxLengthEstimate ; / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_56"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < this . size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } return - 1 ; } char [ ] thisBuf = buffer ; for ( int i = startIndex ; i < thisBuf . length ; i + + ) { if ( thisBuf [ i ] = = ch ) { return i ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = size - strLen + 1 ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "fixed_code": "return - 1 ; } char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; break ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } if ( entityValue > 0xFFFF ) { entityValue = - 1 ; } } catch ( NumberFormatException e ) { entityValue = - 1 ; } } } else { / / escaped value content is an entity name", "fixed_code": "} else { entityValue = Integer . parseInt ( entityName . substring ( 1 ) ) ; } } catch ( NumberFormatException ex ) { entityValue = - 1 ; } case ' X ' : case ' x ' : { entityValue = Integer . parseInt ( entityContent . substring ( 2 ) , 16 ) ; } default : { entityValue = Integer . parseInt ( entityContent . substring ( 1 ) , 10 ) ; } } } catch ( NumberFormatException e ) { } } } else { / / escaped value content is an entity name", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_62"}
{"buggy_code": "days - = 1 ; } while ( days < 0 ) { end . add ( Calendar . MONTH , - 1 ) ; days + = end . getActualMaximum ( Calendar . DAY_OF_MONTH ) ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; end . add ( Calendar . MONTH , 1 ) ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static final Object y = \" y \" ; static final Object M = \" M \" ;", "fixed_code": "days - = 1 ; } while ( days < 0 ) { days + = 31 ; / / days + = 31 ; / / TODO : Need tests to show this is bad and the new code is good . / / HEN : It ' s a tricky subject . Jan 15th to March 10th . If I count days - first it is / / 1 month and 26 days , but if I count month - first then it is 1 month and 23 days . / / Also it ' s contextual - if asked for no M in the format then I should probably / / be doing no calculating here . months - = 1 ; } while ( months < 0 ) { months + = 12 ; years - = 1 ; } milliseconds - = reduceAndCorrect ( start , end , Calendar . MILLISECOND , milliseconds ) ; seconds - = reduceAndCorrect ( start , end , Calendar . SECOND , seconds ) ; minutes - = reduceAndCorrect ( start , end , Calendar . MINUTE , minutes ) ; hours - = reduceAndCorrect ( start , end , Calendar . HOUR_OF_DAY , hours ) ; days - = reduceAndCorrect ( start , end , Calendar . DAY_OF_MONTH , days ) ; months - = reduceAndCorrect ( start , end , Calendar . MONTH , months ) ; years - = reduceAndCorrect ( start , end , Calendar . YEAR , years ) ; / / This next block of code adds in values that / / aren ' t requested . This allows the user to ask for the } return buffer . toString ( ) ; } static int reduceAndCorrect ( Calendar start , Calendar end , int field , int difference ) { end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ; } } static final Object y = \" y \" ; static final Object M = \" M \" ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { if ( other = = this ) { return 0 ; } if ( other . getClass ( ) ! = this . getClass ( ) ) { if ( other . getClass ( ) . getName ( ) . equals ( this . getClass ( ) . getName ( ) ) ) { return iValue - getValueInOtherClassLoader ( other ) ; } throw new ClassCastException ( \" Different enum class ' \" + ClassUtils . getShortClassName ( other . getClass ( ) ) + \" ' \" ) ; } return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value private int getValueInOtherClassLoader ( Object other ) { try { Method mth = other . getClass ( ) . getMethod ( \" getValue \" , null ) ; Integer value = ( Integer ) mth . invoke ( other , null ) ; return value . intValue ( ) ; } catch ( NoSuchMethodException e ) { / / ignore - should never happen } catch ( IllegalAccessException e ) { / / ignore - should never happen } catch ( InvocationTargetException e ) { / / ignore - should never happen } throw new IllegalStateException ( \" This should not happen \" ) ; }", "fixed_code": "* @ throws NullPointerException if other is < code > null < / code > public int compareTo ( Object other ) { return iValue - ( ( ValuedEnum ) other ) . iValue ; } * @ param other the object to determine the value for * @ return the value / / ignore - should never happen / / ignore - should never happen / / ignore - should never happen", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_64"}
{"buggy_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } if ( field = = Calendar . MILLISECOND ) { return ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . Date date = val . getTime ( ) ; long time = date . getTime ( ) ; boolean done = false ; / / truncate milliseconds int millisecs = val . get ( Calendar . MILLISECOND ) ; if ( ! round | | millisecs < 500 ) { time = time - millisecs ; if ( field = = Calendar . SECOND ) { done = true ; } } / / truncate seconds int seconds = val . get ( Calendar . SECOND ) ; if ( ! done & & ( ! round | | seconds < 30 ) ) { time = time - ( seconds * 1000L ) ; if ( field = = Calendar . MINUTE ) { done = true ; } } / / truncate minutes int minutes = val . get ( Calendar . MINUTE ) ; if ( ! done & & ( ! round | | minutes < 30 ) ) { time = time - ( minutes * 60000L ) ; } / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field if ( offset ! = 0 ) { val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "fixed_code": "throw new ArithmeticException ( \" Calendar value too large for accurate calculations \" ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - START - - - - - - - - - - - - - - - / / see http : / / issues . apache . org / jira / browse / LANG - 59 / / Manually truncate milliseconds , seconds and minutes , rather than using / / Calendar methods . / / truncate milliseconds / / truncate seconds / / truncate minutes / / reset time / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ; roundUp = offset > ( ( max - min ) / 2 ) ; } / / We need to remove this field val . set ( fields [ i ] [ 0 ] , val . get ( fields [ i ] [ 0 ] ) - offset ) ; } throw new IllegalArgumentException ( \" The field \" + field + \" is not supported \" ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_65"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { TimeZone zone = calendar . getTimeZone ( ) ; if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "fixed_code": "private static class TimeZoneNameRule implements Rule { private final Locale mLocale ; private final int mStyle ; private final TimeZone zone ; private final String mStandard ; private final String mDaylight ; TimeZoneNameRule ( TimeZone timeZone , Locale locale , int style ) { mLocale = locale ; mStyle = style ; zone = timeZone ; mStandard = getTimeZoneDisplay ( timeZone , false , style , locale ) ; mDaylight = getTimeZoneDisplay ( timeZone , true , style , locale ) ; @ Override public void appendTo ( StringBuffer buffer , Calendar calendar ) { if ( zone . useDaylightTime ( ) & & calendar . get ( Calendar . DST_OFFSET ) ! = 0 ) { buffer . append ( getTimeZoneDisplay ( zone , true , mStyle , mLocale ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_8"}
{"buggy_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( patternMatcher . regionStart ( ) ! = patternMatcher . regionEnd ( ) ) { throw new IllegalArgumentException ( \" Failed to parse \\ \" \" + pattern + \" \\ \" ; gave up at index \" + patternMatcher . regionStart ( ) ) ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "fixed_code": "currentFormatField = nextFormatField ; currentStrategy = nextStrategy ; } if ( currentStrategy . addRegex ( this , regex ) ) { collector . add ( currentStrategy ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Lang_9"}
{"buggy_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . if ( epsilon = = 0 . 0 & & FastMath . abs ( q1 ) < maxDenominator ) { break ; } throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; } if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { / / in maxDenominator mode , if the last fraction was very close to the actual value / / q2 may overflow in the next iteration ; in this case return the last one . throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly result [ resultOffset ] = FastMath . atan2 ( y [ yOffset ] , x [ xOffset ] ) ; }", "fixed_code": "} / / fix value to take special cases ( + 0 / + 0 , + 0 / - 0 , - 0 / + 0 , - 0 / - 0 , + / - infinity ) correctly }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_10"}
{"buggy_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getUnboundParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getUnboundParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getUnboundParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "fixed_code": "/ / compute transpose ( J ) . J , avoiding building big intermediate matrices final int rows = problem . getMeasurements ( ) . length ; final int cols = problem . getAllParameters ( ) . length ; final int max = cols * rows ; double [ ] [ ] jTj = new double [ cols ] [ cols ] ; for ( int i = 0 ; i < cols ; + + i ) { public double [ ] guessParametersErrors ( EstimationProblem problem ) throws EstimationException { int m = problem . getMeasurements ( ) . length ; int p = problem . getAllParameters ( ) . length ; if ( m < = p ) { throw new EstimationException ( \" no degrees of freedom ( { 0 } measurements , { 1 } parameters ) \" , new Object [ ] { new Integer ( m ) , new Integer ( p ) } ) ; } double [ ] errors = new double [ problem . getAllParameters ( ) . length ] ; final double c = Math . sqrt ( getChiSquare ( problem ) / ( m - p ) ) ; double [ ] [ ] covar = getCovariances ( problem ) ; for ( int i = 0 ; i < errors . length ; + + i ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_100"}
{"buggy_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( ( startIndex > = source . length ( ) ) | | ( endIndex > source . length ( ) ) | | source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "fixed_code": "int n = getImaginaryCharacter ( ) . length ( ) ; startIndex = pos . getIndex ( ) ; int endIndex = startIndex + n ; if ( source . substring ( startIndex , endIndex ) . compareTo ( getImaginaryCharacter ( ) ) ! = 0 ) { / / set index back to initial , error index should be the start index", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_101"}
{"buggy_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumExpected = 0d ; double sumObserved = 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { sumExpected + = expected [ i ] ; sumObserved + = observed [ i ] ; } double ratio = 1 . 0d ; boolean rescale = false ; if ( Math . abs ( sumExpected - sumObserved ) > 10E - 6 ) { ratio = sumObserved / sumExpected ; rescale = true ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { if ( rescale ) { dev = ( ( double ) observed [ i ] - ratio * expected [ i ] ) ; sumSq + = dev * dev / ( ratio * expected [ i ] ) ; } else { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } } return sumSq ; }", "fixed_code": "throw new IllegalArgumentException ( \" observed counts must be non - negative and expected counts must be postive \" ) ; } double sumSq = 0 . 0d ; double dev = 0 . 0d ; for ( int i = 0 ; i < observed . length ; i + + ) { dev = ( ( double ) observed [ i ] - expected [ i ] ) ; sumSq + = dev * dev / expected [ i ] ; } return sumSq ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_102"}
{"buggy_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 . 0d ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 . 0d ; } else { throw ex ; } } }", "fixed_code": "* convergence exception is caught and 0 or 1 is returned . public double cumulativeProbability ( double x ) throws MathException { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( 2 . 0 ) ) ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 15 ; private static double [ ] lanczos =", "fixed_code": "private static final long serialVersionUID = - 6587513359895466954L ; private static final double DEFAULT_EPSILON = 10e - 9 ; private static double [ ] lanczos =", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return Math . max ( 0d , sumYY - sumXY * sumXY / sumXX ) ; }", "fixed_code": "* @ return sum of squared errors associated with the regression model public double getSumSquaredErrors ( ) { return sumYY - sumXY * sumXY / sumXX ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "return null ; } if ( num . intValue ( ) < 0 ) { / / minus signs should be leading , invalid expression pos . setIndex ( initialIndex ) ; return null ; } / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } if ( den . intValue ( ) < 0 ) { / / minus signs must be leading , invalid pos . setIndex ( initialIndex ) ; return null ; } int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "fixed_code": "return null ; } / / minus signs should be leading , invalid expression / / parse ' / ' int startIndex = pos . getIndex ( ) ; return null ; } / / minus signs must be leading , invalid int w = whole . intValue ( ) ; int n = num . intValue ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_106"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - 0 . 5 * dim ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "package org . apache . commons . math3 . random ; import java . io . Serializable ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator , Serializable { private static final long serialVersionUID = 20130104L ; private double nextGaussian ;", "fixed_code": "package org . apache . commons . math3 . random ; import org . apache . commons . math3 . exception . NotStrictlyPositiveException ; import org . apache . commons . math3 . util . FastMath ; * @ since 2 . 0 public abstract class BitsStreamGenerator implements RandomGenerator { private double nextGaussian ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_12"}
{"buggy_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "fixed_code": "* @ return the square - root of the weight matrix . private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_13"}
{"buggy_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = new DiagonalMatrix ( weight ) ; } private RealMatrix squareRoot ( RealMatrix m ) { if ( m instanceof DiagonalMatrix ) { final int dim = m . getRowDimension ( ) ; final RealMatrix sqrtM = new DiagonalMatrix ( dim ) ; for ( int i = 0 ; i < dim ; i + + ) { sqrtM . setEntry ( i , i , FastMath . sqrt ( m . getEntry ( i , i ) ) ) ; } return sqrtM ; } else { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } } }", "fixed_code": "public Weight ( double [ ] weight ) { final int dim = weight . length ; weightMatrix = org . apache . commons . math3 . linear . MatrixUtils . createRealMatrix ( dim , dim ) ; for ( int i = 0 ; i < dim ; i + + ) { weightMatrix . setEntry ( i , i , weight [ i ] ) ; } } private RealMatrix squareRoot ( RealMatrix m ) { final EigenDecomposition dec = new EigenDecomposition ( m ) ; return dec . getSquareRoot ( ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_14"}
{"buggy_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double TWO_POWER_53 = 2 * TWO_POWER_52 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_53 | | y < = - TWO_POWER_53 ) { return pow ( - x , y ) ; }", "fixed_code": "private static final double TWO_POWER_52 = 4503599627370496 . 0 ; private static final double F_1_3 = 1d / 3d ; if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "public class FastMath { private static final double LOG_MAX_VALUE = StrictMath . log ( Double . MAX_VALUE ) ; public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( - x ) ; } } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { if ( x > = LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( 0 . 5 * x ) ; return ( 0 . 5 * t ) * t ; } else { return 0 . 5 * exp ( x ) ; } } else if ( x < - 20 ) { if ( x < = - LOG_MAX_VALUE ) { / / Avoid overflow ( MATH - 905 ) . final double t = exp ( - 0 . 5 * x ) ; return ( - 0 . 5 * t ) * t ; } else { return - 0 . 5 * exp ( - x ) ; } } if ( x = = 0 ) {", "fixed_code": "public class FastMath { public static final double PI = 105414357 . 0 / 33554432 . 0 + 1 . 984187159361080883e - 9 ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( - x ) ; } final double hiPrec [ ] = new double [ 2 ] ; / / exp ( - z ) can be ignored in comparison with exp ( z ) if ( x > 20 ) { / / Avoid overflow ( MATH - 905 ) . return 0 . 5 * exp ( x ) ; } if ( x < - 20 ) { / / Avoid overflow ( MATH - 905 ) . return - 0 . 5 * exp ( - x ) ; } if ( x = = 0 ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_16"}
{"buggy_code": "* @ return product of this and x public Dfp multiply ( final int x ) { if ( x > = 0 & & x < RADIX ) { return multiplyFast ( x ) ; } else { return multiply ( newInstance ( x ) ) ; } }", "fixed_code": "* @ return product of this and x public Dfp multiply ( final int x ) { return multiplyFast ( x ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_17"}
{"buggy_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = x [ i ] / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] ; } return res ; } return true ; } final double [ ] bLoEnc = encode ( boundaries [ 0 ] ) ; final double [ ] bHiEnc = encode ( boundaries [ 1 ] ) ; for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < bLoEnc [ i ] ) { return false ; } if ( x [ i ] > bHiEnc [ i ] ) { return false ; } }", "fixed_code": "double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = ( x [ i ] - boundaries [ 0 ] [ i ] ) / diff ; } return res ; } double [ ] res = new double [ x . length ] ; for ( int i = 0 ; i < x . length ; i + + ) { double diff = boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ; res [ i ] = diff * x [ i ] + boundaries [ 0 ] [ i ] ; } return res ; } return true ; } for ( int i = 0 ; i < x . length ; i + + ) { if ( x [ i ] < 0 ) { return false ; } if ( x [ i ] > 1 . 0 ) { return false ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . for ( int i = 0 ; i < lB . length ; i + + ) { if ( Double . isInfinite ( boundaries [ 1 ] [ i ] - boundaries [ 0 ] [ i ] ) ) { final double max = Double . MAX_VALUE + boundaries [ 0 ] [ i ] ; final NumberIsTooLargeException e = new NumberIsTooLargeException ( boundaries [ 1 ] [ i ] , max , true ) ; e . getContext ( ) . addMessage ( LocalizedFormats . OVERFLOW ) ; e . getContext ( ) . addMessage ( LocalizedFormats . INDEX , i ) ;  throw e ; } } } } else { / / Convert API to internal handling of boundaries .", "fixed_code": "boundaries [ 1 ] = uB ; / / Abort early if the normalization will overflow ( cf . \" encode \" method ) . } } else { / / Convert API to internal handling of boundaries .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_19"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return getSampleSize ( ) * ( getNumberOfSuccesses ( ) / ( double ) getPopulationSize ( ) ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return boundaries ! = null & & isRepairMode ? decode ( repair ( x ) ) : decode ( x ) ; }", "fixed_code": "* @ return the original objective variables , possibly repaired . public double [ ] repairAndDecode ( final double [ ] x ) { return decode ( x ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element int swapR = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isr = index [ swapR ] ; if ( c [ ii ] [ ii ] > c [ isr ] [ isr ] ) { swapR = i ; } } / / swap elements if ( swapR ! = r ) { final int tmpIndex = index [ r ] ; index [ r ] = index [ swapR ] ; index [ swapR ] = tmpIndex ; final double [ ] tmpRow = b [ r ] ; b [ r ] = b [ swapR ] ; b [ swapR ] = tmpRow ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; final double inverse2 = 1 / c [ ir ] [ ir ] ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = c [ ii ] [ ir ] * c [ ii ] [ ir ] * inverse2 ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "fixed_code": "final double [ ] [ ] c = matrix . getData ( ) ; final double [ ] [ ] b = new double [ order ] [ order ] ; int [ ] swap = new int [ order ] ; int [ ] index = new int [ order ] ; for ( int i = 0 ; i < order ; + + i ) { for ( boolean loop = true ; loop ; ) { / / find maximal diagonal element swap [ r ] = r ; for ( int i = r + 1 ; i < order ; + + i ) { int ii = index [ i ] ; int isi = index [ swap [ i ] ] ; if ( c [ ii ] [ ii ] > c [ isi ] [ isi ] ) { swap [ r ] = i ; } } / / swap elements if ( swap [ r ] ! = r ) { int tmp = index [ r ] ; index [ r ] = index [ swap [ r ] ] ; index [ swap [ r ] ] = tmp ; } / / check diagonal element final double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ; b [ r ] [ r ] = sqrt ; final double inverse = 1 / sqrt ; for ( int i = r + 1 ; i < order ; + + i ) { final int ii = index [ i ] ; final double e = inverse * c [ ii ] [ ir ] ; b [ i ] [ r ] = e ; c [ ii ] [ ii ] - = e * e ; for ( int j = r + 1 ; j < i ; + + j ) { final int ij = index [ j ] ; final double f = c [ ii ] [ ij ] - e * b [ j ] [ r ] ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_21"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; } public boolean isSupportUpperBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; } public boolean isSupportUpperBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . UnivariatePointValuePair best = current ; int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; best = best ( best , best ( current , previous , isMinim ) , isMinim ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( best , best ( current , previous , isMinim ) , isMinim ) ; }", "fixed_code": "UnivariatePointValuePair current = new UnivariatePointValuePair ( x , isMinim ? fx : - fx ) ; / / Best point encountered so far ( which is the initial guess ) . int iter = 0 ; while ( true ) { / / User - defined convergence checker . previous = current ; current = new UnivariatePointValuePair ( u , isMinim ? fu : - fu ) ; if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } + iter ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_23"}
{"buggy_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return best ( current , previous , isMinim ) ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return best ( current , previous , isMinim ) ; } }", "fixed_code": "if ( checker ! = null ) { if ( checker . converged ( iter , previous , current ) ) { return current ; } } } } } else { / / Default termination ( Brent ' s criterion ) . return current ; } + iter ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { if ( c2 = = 0 ) { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . throw new MathIllegalStateException ( LocalizedFormats . ZERO_DENOMINATOR ) ; } a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "fixed_code": "} a = 0 . 5 * ( yMax - yMin ) ; } else { / / In some ill - conditioned cases ( cf . MATH - 844 ) , the guesser / / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) | | ( FastMath . abs ( q2 ) > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; } long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_26"}
{"buggy_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return 100 * doubleValue ( ) ; }", "fixed_code": "* @ return the fraction percentage as a < tt > double < / tt > . public double percentageValue ( ) { return multiply ( 100 ) . doubleValue ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_27"}
{"buggy_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis if ( tableau . getNumArtificialVariables ( ) > 0 ) { for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . if ( getIterations ( ) < getMaxIterations ( ) / 2 ) { Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "/ / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis for ( Integer row : minRatioPositions ) { for ( int i = 0 ; i < tableau . getNumArtificialVariables ( ) ; i + + ) { int column = i + tableau . getArtificialVariableOffset ( ) ; } } } / / 2 . apply Bland ' s rule to prevent cycling : / / take the row for which the corresponding basic variable has the smallest index / / Additional heuristic : if we did not get a solution after half of maxIterations / / revert to the simple case of just returning the top - most row / / This heuristic is based on empirical data gathered while investigating MATH - 828 . Integer minRow = null ; int minIndex = tableau . getWidth ( ) ; for ( Integer row : minRatioPositions ) { } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { res . setEntry ( i , this . getEntry ( i ) / v . getEntry ( i ) ) ; } return res ; } * * These special cases are handled below . if ( v . isNaN ( ) | | v . isInfinite ( ) ) { final int n = getDimension ( ) ; for ( int i = 0 ; i < n ; i + + ) { final double y = v . getEntry ( i ) ; if ( Double . isNaN ( y ) ) { res . setEntry ( i , Double . NaN ) ; } else if ( Double . isInfinite ( y ) ) { final double x = this . getEntry ( i ) ; res . setEntry ( i , x * y ) ; } } } return res ; }", "fixed_code": "* this only . Indeed , if this [ i ] = 0d and v [ i ] = 0d , then * this [ i ] / v [ i ] = NaN , and not 0d . Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; } return res ; } * * These special cases are handled below . return res ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "throw new DimensionMismatchException ( len , b . length ) ; } if ( len = = 1 ) { / / Revert to scalar multiplication . return a [ 0 ] * b [ 0 ] ; } final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "fixed_code": "throw new DimensionMismatchException ( len , b . length ) ; } / / Revert to scalar multiplication . final double [ ] prodHigh = new double [ len ] ; double prodLowSum = 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "int n = 1 ; double dPrev = 0 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double dN = a + b * dPrev ; if ( Precision . equals ( dN , 0 . 0 , small ) ) { dN = small ; } double cN = a + b / cPrev ; if ( Precision . equals ( cN , 0 . 0 , small ) ) { cN = small ; } dN = 1 / dN ; final double deltaN = cN * dN ; hN = hPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = dN ; cPrev = cN ; hPrev = hN ; n + + ; }", "fixed_code": "int n = 1 ; double dPrev = 0 . 0 ; double p0 = 1 . 0 ; double q1 = 1 . 0 ; double cPrev = hPrev ; double hN = hPrev ; final double a = getA ( n , x ) ; final double b = getB ( n , x ) ; double cN = a * hPrev + b * p0 ; double q2 = a * q1 + b * dPrev ; if ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) { double scaleFactor = 1d ; double lastScaleFactor = 1d ; final int maxPower = 5 ; final double scale = FastMath . max ( a , b ) ; if ( scale < = 0 ) { / / Can ' t scale throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , x ) ; } for ( int i = 0 ; i < maxPower ; i + + ) { lastScaleFactor = scaleFactor ; scaleFactor * = scale ; if ( a ! = 0 . 0 & & a > b ) { cN = hPrev / lastScaleFactor + ( b / scaleFactor * p0 ) ; q2 = q1 / lastScaleFactor + ( b / scaleFactor * dPrev ) ; } else if ( b ! = 0 ) { cN = ( a / scaleFactor * hPrev ) + p0 / lastScaleFactor ; q2 = ( a / scaleFactor * q1 ) + dPrev / lastScaleFactor ; } if ( ! ( Double . isInfinite ( cN ) | | Double . isInfinite ( q2 ) ) ) { break ; } } } final double deltaN = cN / q2 / cPrev ; hN = cPrev * deltaN ; if ( Double . isInfinite ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_INFINITY_DIVERGENCE , break ; } dPrev = q1 ; cPrev = cN / q2 ; p0 = hPrev ; hPrev = cN ; q1 = q2 ; n + + ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( tree . getCut ( ) = = null & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; setElitismRate ( elitismRate ) ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; setElitismRate ( elitismRate ) ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Double . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . doubleValue ( ) / denominator . shiftRight ( shift ) . doubleValue ( ) ; } return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; if ( Double . isNaN ( result ) ) { / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . int shift = Math . max ( numerator . bitLength ( ) , denominator . bitLength ( ) ) - Float . MAX_EXPONENT ; result = numerator . shiftRight ( shift ) . floatValue ( ) / denominator . shiftRight ( shift ) . floatValue ( ) ; } return result ; }", "fixed_code": "@ Override public double doubleValue ( ) { double result = numerator . doubleValue ( ) / denominator . doubleValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; } @ Override public float floatValue ( ) { float result = numerator . floatValue ( ) / denominator . floatValue ( ) ; / / Numerator and / or denominator must be out of range : / / Calculate how far to shift them to put them in range . return result ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_36"}
{"buggy_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN | | Double . isInfinite ( real ) ) { return NaN ; } if ( imaginary > 20 . 0 ) { return createComplex ( 0 . 0 , 1 . 0 ) ; } if ( imaginary < - 20 . 0 ) { return createComplex ( 0 . 0 , - 1 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN | | Double . isInfinite ( imaginary ) ) { return NaN ; } if ( real > 20 . 0 ) { return createComplex ( 1 . 0 , 0 . 0 ) ; } if ( real < - 20 . 0 ) { return createComplex ( - 1 . 0 , 0 . 0 ) ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "fixed_code": "* @ since 1 . 2 public Complex tan ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; * @ since 1 . 2 public Complex tanh ( ) { if ( isNaN ) { return NaN ; } double real2 = 2 . 0 * real ; double imaginary2 = 2 . 0 * imaginary ; double d = FastMath . cosh ( real2 ) + FastMath . cos ( imaginary2 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_37"}
{"buggy_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; } final int iptMinus1 = ipt - 1 ; final int jptMinus1 = jpt - 1 ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "fixed_code": "final int tmp2 = jpt ; jpt = ipt - n ; ipt = tmp2 ; throw new PathIsExploredException ( ) ; / / XXX } final int iptMinus1 = ipt ; final int jptMinus1 = jpt ; interpolationPoints . setEntry ( nfm , iptMinus1 , interpolationPoints . getEntry ( ipt , iptMinus1 ) ) ; interpolationPoints . setEntry ( nfm , jptMinus1 , interpolationPoints . getEntry ( jpt , jptMinus1 ) ) ; } final int ih = ipt * ( ipt - 1 ) / 2 + jpt - 1 ; final double tmp = interpolationPoints . getEntry ( nfm , ipt - 1 ) * interpolationPoints . getEntry ( nfm , jpt - 1 ) ; modelSecondDerivativesValues . setEntry ( ih , ( fbeg - fAtInterpolationPoints . getEntry ( ipt ) - fAtInterpolationPoints . getEntry ( jpt ) + f ) / tmp ) ; throw new PathIsExploredException ( ) ; / / XXX } } while ( getEvaluations ( ) < npt ) ; } / / prelim", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_38"}
{"buggy_code": "} stepSize = hNew ; if ( forward ) { if ( stepStart + stepSize > = t ) { stepSize = t - stepStart ; } } else { if ( stepStart + stepSize < = t ) { stepSize = t - stepStart ; } } / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "fixed_code": "} stepSize = hNew ; / / next stages for ( int k = 1 ; k < stages ; + + k ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this final int p = agingA - MAXIMAL_AGING ; final double weightA = ( 1 < < p ) - 1 ; final double weightB = p + 1 ; targetY = ( weightA * yA - weightB * REDUCTION_FACTOR * yB ) / ( weightA + weightB ) ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this final int p = agingB - MAXIMAL_AGING ; final double weightA = p + 1 ; final double weightB = ( 1 < < p ) - 1 ; targetY = ( weightB * yB - weightA * REDUCTION_FACTOR * yA ) / ( weightA + weightB ) ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this targetY = - REDUCTION_FACTOR * yA ; } else { / / bracketing is balanced , try to find the root itself targetY = 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; if ( basicRow ! = null & & basicRow = = 0 ) { / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function coefficients [ i ] = 0 ; } else if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "fixed_code": "continue ; } Integer basicRow = getBasicRow ( colIndex ) ; / / if the basic row is found to be the objective function row / / set the coefficient to 0 - > this case handles unconstrained / / variables that are still part of the objective function if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 - ( restrictToNonNegative ? 0 : mostNegative ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( meanImpl ! = mean ) { meanImpl . increment ( value ) ; } if ( varianceImpl ! = variance ) { varianceImpl . increment ( value ) ; } if ( geoMeanImpl ! = geoMean ) { geoMeanImpl . increment ( value ) ; } n + + ;", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) { varianceImpl . increment ( value ) ; } if ( ! ( geoMeanImpl instanceof GeometricMean ) ) { geoMeanImpl . increment ( value ) ; } n + + ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "fixed_code": "double previousT = interpolator . getGlobalPreviousTime ( ) ; final double currentT = interpolator . getGlobalCurrentTime ( ) ; resetOccurred = false ; / / initialize the events states if needed if ( ! statesInitialized ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; long lRow = ( long ) rowDimension ; long lCol = ( long ) columnDimension ; if ( lRow * lCol > = ( long ) Integer . MAX_VALUE ) { throw new NumberIsTooLargeException ( lRow * lCol , Integer . MAX_VALUE , false ) ; } this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "fixed_code": "public OpenMapRealMatrix ( int rowDimension , int columnDimension ) { super ( rowDimension , columnDimension ) ; this . rows = rowDimension ; this . columns = columnDimension ; this . entries = new OpenIntToDoubleHashMap ( 0 . 0 ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_45"}
{"buggy_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return NaN ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "fixed_code": "if ( divisor . isZero ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( divisor . isInfinite ( ) & & ! isInfinite ( ) ) { } if ( divisor = = 0d ) { / / return isZero ? NaN : INF ; / / See MATH - 657 return isZero ? NaN : INF ; } if ( Double . isInfinite ( divisor ) ) { return ! isInfinite ( ) ? ZERO : NaN ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_46"}
{"buggy_code": "private final transient boolean isInfinite ; private final transient boolean isZero ;", "fixed_code": "private final transient boolean isInfinite ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_47"}
{"buggy_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . if ( x = = x1 ) { throw new ConvergenceException ( ) ; } break ; default : / / Should never happen .", "fixed_code": "case REGULA_FALSI : / / Detect early that algorithm is stuck , instead of waiting / / for the maximum number of iterations to be exceeded . break ; default : / / Should never happen .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_48"}
{"buggy_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "fixed_code": "public OpenMapRealVector ebeDivide ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeDivide ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) / v [ iter . key ( ) ] ) ; public OpenMapRealVector ebeMultiply ( RealVector v ) { checkVectorDimensions ( v . getDimension ( ) ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v . getEntry ( iter . key ( ) ) ) ; public OpenMapRealVector ebeMultiply ( double [ ] v ) { checkVectorDimensions ( v . length ) ; OpenMapRealVector res = new OpenMapRealVector ( this ) ; Iterator iter = res . entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; res . setEntry ( iter . key ( ) , iter . value ( ) * v [ iter . key ( ) ] ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { final double delta = FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ; / / Update formula cannot make any progress : Update the / / search interval . x0 = 0 . 5 * ( x0 + x1 - delta ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . throw new MathInternalError ( ) ; } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "fixed_code": "case PEGASUS : f0 * = f1 / ( f1 + fx ) ; break ; / / Update formula cannot make any progress : Update the / / search interval . default : / / Should never happen . } } / / Update from [ x0 , x1 ] to [ x0 , x ] .", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_51"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; final double inPlaneThreshold = 0 . 001 ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u3 . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c < = inPlaneThreshold * k . getNorm ( ) * u2Prime . getNorm ( ) ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ; Vector3D u2Prime = u1 . crossProduct ( u3 ) ; c = k . dotProduct ( u2Prime ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is also close to the ( u1 , u3 ) plane , / / it is almost aligned with u1 : we try ( u2 , u3 ) and ( v2 , v3 ) k = v2Su2 . crossProduct ( v3Su3 ) ; ; c = k . dotProduct ( u2 . crossProduct ( u3 ) ) ; ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is aligned with everything / / this is really the identity rotation q0 = 1 . 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign if ( ( bits & 0x8000000000000000L ) ! = 0 ) { sign = - 1 ; } return ; } Dfp y = this ; boolean negate = false ; int cmp0 = compare ( this , getZero ( ) ) ; if ( cmp0 = = 0 ) { return sign < 0 ? - 0 . 0 : + 0 . 0 ; } else if ( cmp0 < 0 ) { y = negate ( ) ; negate = true ; }", "fixed_code": "/ / Zero or sub - normal if ( x = = 0 ) { / / make sure 0 has the right sign return ; } Dfp y = this ; boolean negate = false ; if ( lessThan ( getZero ( ) ) ) { y = negate ( ) ; negate = true ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_54"}
{"buggy_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { final double n1 = v1 . getNormSq ( ) ; final double n2 = v2 . getNormSq ( ) ; if ( ( n1 * n2 ) < MathUtils . SAFE_MIN ) { return ZERO ; } / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude final int deltaExp = ( FastMath . getExponent ( n1 ) - FastMath . getExponent ( n2 ) ) / 4 ; final double x1 = FastMath . scalb ( v1 . x , - deltaExp ) ; final double y1 = FastMath . scalb ( v1 . y , - deltaExp ) ; final double z1 = FastMath . scalb ( v1 . z , - deltaExp ) ; final double x2 = FastMath . scalb ( v2 . x , deltaExp ) ; final double y2 = FastMath . scalb ( v2 . y , deltaExp ) ; final double z2 = FastMath . scalb ( v2 . z , deltaExp ) ; / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 final double ratio = ( x1 * x2 + y1 * y2 + z1 * z2 ) / FastMath . scalb ( n2 , 2 * deltaExp ) ; final double rho = FastMath . rint ( 256 * ratio ) / 256 ; final double x3 = x1 - rho * x2 ; final double y3 = y1 - rho * y2 ; final double z3 = z1 - rho * z2 ; / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( y3 * z2 - z3 * y2 , z3 * x2 - x3 * z2 , x3 * y2 - y3 * x2 ) ; }", "fixed_code": "public static Vector3D crossProduct ( final Vector3D v1 , final Vector3D v2 ) { / / rescale both vectors without losing precision , / / to ensure their norm are the same order of magnitude / / we reduce cancellation errors by preconditioning , / / we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute / / available at http : / / www . cs . berkeley . edu / ~ wkahan / MathH110 / Cross . pdf / / compute rho as an 8 bits approximation of v1 . v2 / v2 . v2 / / compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D ( v1 . y * v2 . z - v1 . z * v2 . y , v1 . z * v2 . x - v1 . x * v2 . z , v1 . x * v2 . y - v1 . y * v2 . x ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_55"}
{"buggy_code": "indices [ i ] = idx ; } indices [ last ] = index - count ; return indices ; }", "fixed_code": "indices [ i ] = idx ; } int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - - idx ; indices [ last ] = idx ; return indices ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( Integer . MAX_VALUE , new MaxIterCallback ( ) ) ; }", "fixed_code": "this . checker = checker ; evaluations = new Incrementor ( 0 , new MaxEvalCallback ( ) ) ; iterations = new Incrementor ( 0 , new MaxIterCallback ( ) ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; if ( FastMath . abs ( dev ) > 40 * standardDeviation ) { return dev < 0 ? 0 . 0d : 1 . 0d ; } return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; }", "fixed_code": "public double cumulativeProbability ( double x ) throws MathException { final double dev = x - mean ; try { return 0 . 5 * ( 1 . 0 + Erf . erf ( ( dev ) / ( standardDeviation * FastMath . sqrt ( 2 . 0 ) ) ) ) ; } catch ( MaxIterationsExceededException ex ) { if ( x < ( mean - 20 * standardDeviation ) ) { / / JDK 1 . 5 blows at 38 return 0 ; } else if ( x > ( mean + 20 * standardDeviation ) ) { return 1 ; } else { throw ex ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "import java . io . Serializable ; import org . apache . commons . math . MathException ; import org . apache . commons . math . MathRuntimeException ; import org . apache . commons . math . exception . util . LocalizedFormats ; import org . apache . commons . math . special . Gamma ; import org . apache . commons . math . util . MathUtils ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , min + 0 . 5 * ( max - min ) ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double s = ( i = = 0 ) ? startValue : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , max , s ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "final GoalType goal , final double min , final double max ) throws FunctionEvaluationException { return optimize ( f , goal , min , max , 0 ) ; } / / Multi - start loop . for ( int i = 0 ; i < starts ; + + i ) { try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] oldObj = new double [ rows ] ; double [ ] qtf = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { for ( int i = 0 ; i < rows ; i + + ) { qtf [ i ] = residuals [ i ] ; } incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( qtf ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * qtf [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( qtf , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; current = new VectorialPointValuePair ( point , objective ) ; / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; tmpVec = objective ; objective = oldObj ; oldObj = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "double [ ] diag = new double [ cols ] ; double [ ] oldX = new double [ cols ] ; double [ ] oldRes = new double [ rows ] ; double [ ] work1 = new double [ cols ] ; double [ ] work2 = new double [ cols ] ; double [ ] work3 = new double [ cols ] ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix qrDecomposition ( ) ; / / compute Qt . res qTy ( residuals ) ; / / now we don ' t need Q anymore , / / so let jacobian contain the R matrix with its diagonal elements for ( int k = 0 ; k < solvedCols ; + + k ) { if ( s ! = 0 ) { double sum = 0 ; for ( int i = 0 ; i < = j ; + + i ) { sum + = jacobian [ i ] [ pj ] * residuals [ i ] ; } maxCosine = Math . max ( maxCosine , Math . abs ( sum ) / ( s * cost ) ) ; } } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } double [ ] tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; / / determine the Levenberg - Marquardt parameter determineLMParameter ( oldRes , delta , diag , work1 , work2 , work3 ) ; / / compute the new point and the norm of the evolution direction double lmNorm = 0 ; / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; xNorm + = xK * xK ; } xNorm = Math . sqrt ( xNorm ) ; / / tests for convergence . / / we use the vectorial convergence checker } else { / / failed iteration , reset the previous values cost = previousCost ; tmpVec = residuals ; residuals = oldRes ; oldRes = tmpVec ; } if ( checker = = null ) { if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } else { if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_64"}
{"buggy_code": "* @ return RMS value public double getRMS ( ) { return Math . sqrt ( getChiSquare ( ) / rows ) ; }", "fixed_code": "* @ return RMS value public double getRMS ( ) { double criterion = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; criterion + = residual * residual * residualsWeights [ i ] ; } return Math . sqrt ( criterion / rows ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( 1000 ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1e - 11 ) ; setRelativeAccuracy ( 1e - 9 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , getMin ( ) , getStartValue ( ) , getMax ( ) , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } private double localMin ( boolean isMinim , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( x ) ; if ( ! isMinim ) { fx = - fx ; } double fv = fx ; double fw = fx ; while ( true ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( u ) ; if ( ! isMinim ) { fu = - fu ; } } } } else { / / termination setFunctionValue ( isMinim ? fx : - fx ) ; return x ; } incrementIterationsCounter ( ) ; } } }", "fixed_code": "* Construct a solver . public BrentOptimizer ( ) { setMaxEvaluations ( Integer . MAX_VALUE ) ; setMaximalIterationCount ( 100 ) ; setAbsoluteAccuracy ( 1E - 10 ) ; setRelativeAccuracy ( 1 . 0e - 14 ) ; } protected double doOptimize ( ) throws MaxIterationsExceededException , FunctionEvaluationException { throw new UnsupportedOperationException ( ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max , final double startValue ) throws MaxIterationsExceededException , FunctionEvaluationException { clearResult ( ) ; return localMin ( getGoalType ( ) = = GoalType . MINIMIZE , f , goalType , min , startValue , max , getRelativeAccuracy ( ) , getAbsoluteAccuracy ( ) ) ; } public double optimize ( final UnivariateRealFunction f , final GoalType goalType , final double min , final double max ) throws MaxIterationsExceededException , FunctionEvaluationException { return optimize ( f , goalType , min , max , min + GOLDEN_SECTION * ( max - min ) ) ; } private double localMin ( boolean isMinim , UnivariateRealFunction f , GoalType goalType , double lo , double mid , double hi , double eps , double t ) throws MaxIterationsExceededException , FunctionEvaluationException { double w = x ; double d = 0 ; double e = 0 ; double fx = computeObjectiveValue ( f , x ) ; if ( goalType = = GoalType . MAXIMIZE ) { fx = - fx ; } double fv = fx ; double fw = fx ; int count = 0 ; while ( count < maximalIterationCount ) { double m = 0 . 5 * ( a + b ) ; final double tol1 = eps * Math . abs ( x ) + t ; final double tol2 = 2 * tol1 ; u = x + d ; } double fu = computeObjectiveValue ( f , u ) ; if ( goalType = = GoalType . MAXIMIZE ) { fu = - fu ; } } } } else { / / termination setResult ( x , ( goalType = = GoalType . MAXIMIZE ) ? - fx : fx , count ) ; return x ; } + + count ; } throw new MaxIterationsExceededException ( maximalIterationCount ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_66"}
{"buggy_code": "public double getFunctionValue ( ) { return optimaValues [ 0 ] ; } public double getResult ( ) { return optima [ 0 ] ; }", "fixed_code": "public double getFunctionValue ( ) { return optimizer . getFunctionValue ( ) ; } public double getResult ( ) { return optimizer . getResult ( ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_67"}
{"buggy_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setConvergenceChecker ( null ) ; setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; VectorialPointValuePair current = new VectorialPointValuePair ( point , objective ) ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix VectorialPointValuePair previous = current ; updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return current ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; current = new VectorialPointValuePair ( point , objective ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . if ( checker ! = null ) { / / we use the vectorial convergence checker if ( checker . converged ( getIterations ( ) , previous , current ) ) { return current ; } } else { / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return current ; } } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "fixed_code": "setMaxIterations ( 1000 ) ; / / default values for the tuning parameters setInitialStepBoundFactor ( 100 . 0 ) ; setCostRelativeTolerance ( 1 . 0e - 10 ) ; setParRelativeTolerance ( 1 . 0e - 10 ) ; / / outer loop lmPar = 0 ; boolean firstIteration = true ; while ( true ) { incrementIterationsCounter ( ) ; / / compute the Q . R . decomposition of the jacobian matrix updateJacobian ( ) ; qrDecomposition ( ) ; } if ( maxCosine < = orthoTolerance ) { / / convergence has been reached return new VectorialPointValuePair ( point , objective ) ; } / / rescale if necessary / / evaluate the function at x + p and calculate its norm updateResidualsAndCost ( ) ; / / compute the scaled actual reduction double actRed = - 1 . 0 ; } / / tests for convergence . / / we use the vectorial convergence checker / / we use the Levenberg - Marquardt specific convergence parameters if ( ( ( Math . abs ( actRed ) < = costRelativeTolerance ) & & ( preRed < = costRelativeTolerance ) & & ( ratio < = 2 . 0 ) ) | | ( delta < = parRelativeTolerance * xNorm ) ) { return new VectorialPointValuePair ( point , objective ) ; } / / tests for termination and stringent tolerances / / ( 2 . 2204e - 16 is the machine epsilon for IEEE754 )", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_68"}
{"buggy_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * tDistribution . cumulativeProbability ( - t ) ; } } }", "fixed_code": "} else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ; out [ i ] [ j ] = 2 * ( 1 - tDistribution . cumulativeProbability ( t ) ) ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time for ( final EventState state : eventsStates ) { state . stepAccepted ( eventT , eventY ) ; isLastStep = isLastStep | | state . stop ( ) ; } / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; return eventT ; } boolean needReset = false ; for ( final EventState state : eventsStates ) { needReset = needReset | | state . reset ( eventT , eventY ) ; } if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; return eventT ; }", "fixed_code": "final double [ ] eventY = interpolator . getInterpolatedState ( ) . clone ( ) ; / / advance all event states to current time currentEvent . stepAccepted ( eventT , eventY ) ; isLastStep = currentEvent . stop ( ) ; / / handle the first part of the step , up to the event for ( final StepHandler handler : stepHandlers ) { if ( isLastStep ) { / / the event asked to stop integration System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; } boolean needReset = currentEvent . reset ( eventT , eventY ) ; if ( needReset ) { / / some event handler has triggered changes that / / invalidate the derivatives , we need to recompute them System . arraycopy ( eventY , 0 , y , 0 , y . length ) ; computeDerivatives ( eventT , y , yDot ) ; resetOccurred = true ; for ( final EventState remaining : occuringEvents ) { remaining . stepAccepted ( eventT , eventY ) ; } return eventT ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; hNew = 0 ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states interpolator . storeTime ( stepStart ) ; System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { / / reject the step to match exactly the next switch time", "fixed_code": "/ / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time / / it is so small ( much probably exactly 0 due to limited accuracy ) / / that the code above would fail handling it . / / So we set up an artificial 0 size step by copying states loop = false ; } else { / / reject the step to match exactly the next switch time", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; return result ; }", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( yMin , 0 ) ; return result ; } / / return the second endpoint if it is good enough double yMax = f . value ( max ) ; if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( yMax , 0 ) ; return result ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } if ( yMin * yMax > 0 ) { throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "fixed_code": "return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "} if ( firstTime ) { final double [ ] scale = new double [ y0 . length ] ; if ( vecAbsoluteTolerance = = null ) { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = scalAbsoluteTolerance + scalRelativeTolerance * Math . abs ( y [ i ] ) ; } } else { for ( int i = 0 ; i < scale . length ; + + i ) { scale [ i ] = vecAbsoluteTolerance [ i ] + vecRelativeTolerance [ i ] * Math . abs ( y [ i ] ) ; } } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "fixed_code": "} if ( firstTime ) { final double [ ] scale ; if ( vecAbsoluteTolerance = = null ) { scale = new double [ y0 . length ] ; java . util . Arrays . fill ( scale , scalAbsoluteTolerance ) ; } else { scale = vecAbsoluteTolerance ; } hNew = initializeStep ( equations , forward , getOrder ( ) , scale , stepStart , y , yDotK [ 0 ] , yTmp , yDotK [ 1 ] ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , n - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < n - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , m - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; if ( i < m - 1 ) { ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } else { for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = mi * ei0 [ j ] / singularValues [ j ] ; } } } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "fixed_code": "if ( m > = n ) { / / the tridiagonal matrix is Bt . B , where B is upper bidiagonal final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ m ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { / / compute W = B . E . S ^ ( - 1 ) where E is the eigenvectors matrix final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < m ; + + i ) { wData [ i ] = new double [ p ] ; / / the tridiagonal matrix is B . Bt , where B is lower bidiagonal / / compute W = Bt . E . S ^ ( - 1 ) where E is the eigenvectors matrix final RealMatrix e = eigenDecomposition . getV ( ) . getSubMatrix ( 0 , p - 1 , 0 , p - 1 ) ; final double [ ] [ ] eData = e . getData ( ) ; final double [ ] [ ] wData = new double [ n ] [ p ] ; double [ ] ei1 = eData [ 0 ] ; for ( int i = 0 ; i < p - 1 ; + + i ) { final double mi = mainBidiagonal [ i ] ; final double [ ] ei0 = ei1 ; final double [ ] wi = wData [ i ] ; ei1 = eData [ i + 1 ] ; final double si = secondaryBidiagonal [ i ] ; for ( int j = 0 ; j < p ; + + j ) { wi [ j ] = ( mi * ei0 [ j ] + si * ei1 [ j ] ) / singularValues [ j ] ; } } for ( int j = 0 ; j < p ; + + j ) { wData [ p - 1 ] [ j ] = ei1 [ j ] * mainBidiagonal [ p - 1 ] / singularValues [ j ] ; } for ( int i = p ; i < n ; + + i ) { wData [ i ] = new double [ p ] ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_76"}
{"buggy_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; }", "fixed_code": "public double getLInfNorm ( ) { double max = 0 ; for ( double a : data ) { max + = Math . max ( max , Math . abs ( a ) ) ; } return max ; } return max ; } public double getLInfNorm ( ) { double max = 0 ; Iterator iter = entries . iterator ( ) ; while ( iter . hasNext ( ) ) { iter . advance ( ) ; max + = iter . value ( ) ; } return max ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_77"}
{"buggy_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step if ( ga * gb > 0 ) { / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing final double epsilon = ( forward ? 0 . 25 : - 0 . 25 ) * convergence ; for ( int k = 0 ; ( k < 4 ) & & ( ga * gb > 0 ) ; + + k ) { ta + = epsilon ; interpolator . setInterpolatedTime ( ta ) ; ga = handler . g ( ta , interpolator . getInterpolatedState ( ) ) ; } if ( ga * gb > 0 ) { / / this should never happen throw MathRuntimeException . createInternalError ( null ) ; } } / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "fixed_code": "if ( g0Positive ^ ( gb > = 0 ) ) { / / there is a sign change : an event is expected during this step / / this is a corner case : / / - there was an event near ta , / / - there is another event between ta and tb / / this implies that the real sign of ga is the same as gb , so we need to slightly / / shift ta to make sure ga and gb get opposite signs and the solver won ' t complain / / about bracketing / / this should never happen / / variation direction , with respect to the integration direction increasing = gb > = ga ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public Object [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final Object [ ] out = new Object [ sampleSize ] ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "* @ throws NotStrictlyPositiveException if { @ code sampleSize } is not * positive . public T [ ] sample ( int sampleSize ) throws NotStrictlyPositiveException { if ( sampleSize < = 0 ) { throw new NotStrictlyPositiveException ( LocalizedFormats . NUMBER_OF_SAMPLES , sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; upperSpectra = Math . max ( upperSpectra , upper ) ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 16 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) | | ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 3 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "lowerSpectra = Math . min ( lowerSpectra , lower ) ; final double upper = dCurrent + eCurrent ; work [ upperStart + m - 1 ] = upper ; minPivot = MathUtils . SAFE_MIN * Math . max ( 1 . 0 , eMax * eMax ) ; } diagMax = work [ 4 * i0 ] ; offDiagMin = work [ 4 * i0 + 2 ] ; double previousEMin = work [ 4 * i0 + 3 ] ; for ( int i = 4 * i0 ; i < 4 * n0 - 11 ; i + = 4 ) { if ( ( work [ i + 3 ] < = TOLERANCE_2 * work [ i ] ) & & ( work [ i + 2 ] < = TOLERANCE_2 * sigma ) ) { / / insert a split work [ i + 2 ] = - sigma ; double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = ignoreObjectiveRows ? getNumObjectiveFunctions ( ) : 0 ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRowForSolution ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRowForSolution ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "fixed_code": "private Integer getBasicRow ( final int col , boolean ignoreObjectiveRows ) { Integer row = null ; int start = getNumObjectiveFunctions ( ) ; for ( int i = start ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; protected RealPointValuePair getSolution ( ) { double [ ] coefficients = new double [ getOriginalNumDecisionVariables ( ) ] ; Integer negativeVarBasicRow = getBasicRow ( getNegativeDecisionVariableOffset ( ) ) ; double mostNegative = negativeVarBasicRow = = null ? 0 : getEntry ( negativeVarBasicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_83"}
{"buggy_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { final RealConvergenceChecker checker = getConvergenceChecker ( ) ; while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex return ; } / / check convergence final int iter = getIterations ( ) ; boolean converged = true ; for ( int i = 0 ; i < simplex . length ; + + i ) { converged & = checker . converged ( iter , original [ i ] , simplex [ i ] ) ; } if ( converged ) { return ; }", "fixed_code": "protected void iterateSimplex ( final Comparator < RealPointValuePair > comparator ) throws FunctionEvaluationException , OptimizationException , IllegalArgumentException { while ( true ) { incrementIterationsCounter ( ) ; final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence return ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "final double [ ] lI = lTData [ i ] ; / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "fixed_code": "final double [ ] lI = lTData [ i ] ; if ( lTData [ i ] [ i ] < absolutePositivityThreshold ) { throw new NotPositiveDefiniteMatrixException ( ) ; } / / check off - diagonal elements ( and reset them to 0 ) for ( int j = i + 1 ; j < order ; + + j ) { final double [ ] lJ = lTData [ j ] ; final double [ ] ltI = lTData [ i ] ; / / check diagonal element ltI [ i ] = Math . sqrt ( ltI [ i ] ) ; final double inverse = 1 . 0 / ltI [ i ] ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_86"}
{"buggy_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( MathUtils . equals ( getEntry ( i , col ) , 1 . 0 , epsilon ) & & ( row = = null ) ) { row = i ; } else if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { return null ; } } return row ;", "fixed_code": "private Integer getBasicRow ( final int col ) { Integer row = null ; for ( int i = getNumObjectiveFunctions ( ) ; i < getHeight ( ) ; i + + ) { if ( ! MathUtils . equals ( getEntry ( i , col ) , 0 . 0 , epsilon ) ) { if ( row = = null ) { row = i ; } else { return null ; } } } return row ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; Set < Integer > basicRows = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; if ( basicRows . contains ( basicRow ) ) { / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "fixed_code": "Integer basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + getOriginalNumDecisionVariables ( ) ) ; double mostNegative = basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ; for ( int i = 0 ; i < coefficients . length ; i + + ) { basicRow = getBasicRow ( getNumObjectiveFunctions ( ) + i ) ; / / if multiple variables can take a given value / / then we choose the first and set the rest equal to 0 coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( this ) ; reverted . direction = reverted . direction . negate ( ) ; return reverted ; }", "fixed_code": "* @ return a new instance , with reversed direction public Line revert ( ) { final Line reverted = new Line ( zero , zero . subtract ( direction ) ) ; return reverted ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_9"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; } public void addValue ( Comparable < ? > v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "fixed_code": "@ Deprecated public void addValue ( Object v ) { Object obj = v ; if ( v instanceof Integer ) { obj = Long . valueOf ( ( ( Integer ) v ) . longValue ( ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { long nOd = ( ( long ) numerator ) * object . denominator ; long dOn = ( ( long ) denominator ) * object . numerator ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "fixed_code": "* than < tt > object < / tt > , 0 if they are equal . public int compareTo ( Fraction object ) { double nOd = doubleValue ( ) ; double dOn = object . doubleValue ( ) ; return ( nOd < dOn ) ? - 1 : ( ( nOd > dOn ) ? + 1 : 0 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_91"}
{"buggy_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } / / Use symmetry for large k if ( k > n / 2 ) return binomialCoefficient ( n , n - k ) ; / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k long result = 1 ; if ( n < = 61 ) { / / For n < = 61 , the naive implementation cannot overflow . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { result = result * i / j ; } } else if ( n < = 66 ) { / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . long d = gcd ( i , j ) ; result = ( result / ( j / d ) ) * ( i / d ) ; } } else { / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . for ( int j = 1 , i = n - k + 1 ; j < = k ; i + + , j + + ) { long d = gcd ( i , j ) ; result = mulAndCheck ( ( result / ( j / d ) ) , ( i / d ) ) ; } } return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { if ( n < k ) { throw new IllegalArgumentException ( \" must have n > = k for binomial coefficient ( n , k ) \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for binomial coefficient ( n , k ) \" ) ; } if ( ( n = = k ) | | ( k = = 0 ) ) { return 1d ; } if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } if ( k > n / 2 ) { return binomialCoefficientDouble ( n , n - k ) ; } if ( n < 67 ) { return binomialCoefficient ( n , k ) ; } double result = 1d ; for ( int i = 1 ; i < = k ; i + + ) { result * = ( double ) ( n - k + i ) / ( double ) i ; } return Math . floor ( result + 0 . 5 ) ; } if ( n < 67 ) { return Math . log ( binomialCoefficient ( n , k ) ) ; } if ( n < 1030 ) { return Math . log ( binomialCoefficientDouble ( n , k ) ) ; }", "fixed_code": "if ( ( k = = 1 ) | | ( k = = n - 1 ) ) { return n ; } long result = Math . round ( binomialCoefficientDouble ( n , k ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" result too large to represent in a long integer \" ) ; } / / Use symmetry for large k / / We use the formula / / ( n choose k ) = n ! / ( n - k ) ! / k ! / / ( n choose k ) = = ( ( n - k + 1 ) * . . . * n ) / ( 1 * . . . * k ) / / which could be written / / ( n choose k ) = = ( n - 1 choose k - 1 ) * n / k / / For n < = 61 , the naive implementation cannot overflow . / / For n > 61 but n < = 66 , the result cannot overflow , / / but we must take care not to overflow intermediate values . / / We know that ( result * i ) is divisible by j , / / but ( result * i ) may overflow , so we split j : / / Filter out the gcd , d , so j / d and i / d are integer . / / result is divisible by ( j / d ) because ( j / d ) / / is relative prime to ( i / d ) and is a divisor of / / result * ( i / d ) . / / For n > 66 , a result overflow might occur , so we check / / the multiplication , taking care to not overflow / / unnecessary . return result ; } * @ throws IllegalArgumentException if preconditions are not met . public static double binomialCoefficientDouble ( final int n , final int k ) { return Math . floor ( Math . exp ( binomialCoefficientLog ( n , k ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_92"}
{"buggy_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < 21 ) { return factorial ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } if ( n < 21 ) { return Math . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "fixed_code": "* @ throws IllegalArgumentException if n < 0 public static long factorial ( final int n ) { long result = Math . round ( factorialDouble ( n ) ) ; if ( result = = Long . MAX_VALUE ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > 0 for n ! \" ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = Math . log ( ( double ) i ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "* @ since 1 . 1 public static int gcd ( int u , int v ) { if ( u * v = = 0 ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_94"}
{"buggy_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret = 1 . 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; if ( d > 2 . 0 ) { / / use mean ret = d / ( d - 2 . 0 ) ; } return ret ; }", "fixed_code": "* @ return initial domain value protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( real = = rhs . real ) & & ( imaginary = = rhs . imaginary ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_96"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > 0 ) { / / check if either value is close to a zero if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; ret = min ; } else if ( Math . abs ( yMax ) < = functionValueAccuracy ) { setResult ( max , 0 ) ; ret = max ; } else { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } } else if ( sign < 0 ) { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; } else { / / either min or max is a root if ( yMin = = 0 . 0 ) { ret = min ; } else { ret = max ; } } return ret ;", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" + \" Values : [ \" + yMin + \" , \" + yMax + \" ] \" ) ; } else { / / solve using only the first endpoint as initial guess ret = solve ( min , yMin , max , yMax , min , yMin ) ; / / either min or max is a root } return ret ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) { if ( v . length ! = nCols ) { throw new IllegalArgumentException ( \" vector has wrong length \" ) ; } final double [ ] out = new double [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { final double [ ] dataRow = data [ row ] ; double sum = 0 ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( \" overflow : gcd ( { 0 } , { 1 } ) is 2 ^ 31 \" , new Object [ ] { p , q } ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( \" overflow : lcm is 2 ^ 31 \" ) ; } return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { if ( loopUnitField . isSupported ( ) = = false ) { if ( lastUnitField . isSupported ( ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else { throw new IllegalArgumentException ( \" Types array must not contain duplicate unsupported : \" + types [ i - 1 ] . getName ( ) + \" and \" + loopType . getName ( ) ) ; } } int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 & & lastUnitField . equals ( loopUnitField ) ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "fixed_code": "DateTimeFieldType loopType = types [ i ] ; DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( types [ i - 1 ] . getRangeDurationType ( ) = = null ) { if ( loopType . getRangeDurationType ( ) = = null ) { throw new IllegalArgumentException ( \" Types array must not contain duplicate : \" + * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_1"}
{"buggy_code": "private static final long serialVersionUID = 9386874258972L ; private static final long START_1972 = 2L * 365L * 86400L * 1000L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , START_1972 ) , chrono . set ( end , START_1972 ) ) ; return values [ 0 ] ; }", "fixed_code": "private static final long serialVersionUID = 9386874258972L ; private volatile int iPeriod ; throw new IllegalArgumentException ( \" ReadablePartial objects must be contiguous \" ) ; } Chronology chrono = DateTimeUtils . getChronology ( start . getChronology ( ) ) . withUTC ( ) ; int [ ] values = chrono . get ( zeroInstance , chrono . set ( start , 0L ) , chrono . set ( end , 0L ) ) ; return values [ 0 ] ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_10"}
{"buggy_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) { protected Boolean initialValue ( ) { return Boolean . FALSE ; } } ;", "fixed_code": "static Chronology cLenientISO ; static ThreadLocal < Boolean > cVerbose = new ThreadLocal < Boolean > ( ) ; static { cVerbose . set ( Boolean . FALSE ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int era = calendar . get ( Calendar . ERA ) ; int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( ( era = = GregorianCalendar . AD ? yearOfEra : 1 - yearOfEra ) , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } if ( date . getTime ( ) < 0 ) { / / handle years in era BC GregorianCalendar cal = new GregorianCalendar ( ) ; cal . setTime ( date ) ; return fromCalendarFields ( cal ) ; } return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "fixed_code": "if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDate ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) ) ; if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDate ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 , if ( calendar = = null ) { throw new IllegalArgumentException ( \" The calendar must not be null \" ) ; } int yearOfEra = calendar . get ( Calendar . YEAR ) ; return new LocalDateTime ( yearOfEra , calendar . get ( Calendar . MONTH ) + 1 , calendar . get ( Calendar . DAY_OF_MONTH ) , calendar . get ( Calendar . HOUR_OF_DAY ) , if ( date = = null ) { throw new IllegalArgumentException ( \" The date must not be null \" ) ; } / / handle years in era BC return new LocalDateTime ( date . getYear ( ) + 1900 , date . getMonth ( ) + 1 ,", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = ( valueLong < 0 ? Math . max ( sum , 5 ) : Math . max ( sum , 4 ) ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int bufLen = buf . length ( ) ; int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { if ( valueLong < 0 & & valueLong > - DateTimeConstants . MILLIS_PER_SECOND ) { buf . insert ( bufLen , ' - ' ) ; } buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "fixed_code": "if ( iFieldType > = SECONDS_MILLIS ) { / / valueLong contains the seconds and millis fields / / the minimum output is 0 . 000 , which is 4 or 5 digits with a negative sum = Math . max ( sum , 4 ) ; / / plus one for the decimal point sum + + ; if ( iFieldType = = SECONDS_OPTIONAL_MILLIS & & if ( iPrefix ! = null ) { iPrefix . printTo ( buf , value ) ; } int minDigits = iMinPrintedDigits ; if ( minDigits < = 1 ) { FormatUtils . appendUnpaddedInteger ( buf , value ) ; if ( iFieldType > = SECONDS_MILLIS ) { int dp = ( int ) ( Math . abs ( valueLong ) % DateTimeConstants . MILLIS_PER_SECOND ) ; if ( iFieldType = = SECONDS_MILLIS | | dp > 0 ) { buf . append ( ' . ' ) ; FormatUtils . appendPaddedInteger ( buf , dp , 3 ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_13"}
{"buggy_code": "if ( valueToAdd = = 0 ) { return values ; } if ( partial . size ( ) > 0 & & partial . getFieldType ( 0 ) . equals ( DateTimeFieldType . monthOfYear ( ) ) & & fieldIndex = = 0 ) { / / month is largest field and being added to , such as month - day int curMonth0 = partial . getValue ( 0 ) - 1 ; int newMonth = ( ( curMonth0 + ( valueToAdd % 12 ) + 12 ) % 12 ) + 1 ; return set ( partial , 0 , values , newMonth ) ; } if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "fixed_code": "if ( valueToAdd = = 0 ) { return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( \" Multiplication overflows a long : \" + val1 + \" * \" + val2 ) ; } return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , chrono . year ( ) . get ( instantLocal ) ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "fixed_code": "chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , iDefaultYear ) ; int newPos = parser . parseInto ( bucket , text , position ) ; instant . setMillis ( bucket . computeMillis ( false , text ) ) ; if ( iOffsetParsed & & bucket . getOffsetInteger ( ) ! = null ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_16"}
{"buggy_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ; long instantAfter = instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ; long offsetBefore = getOffset ( instantBefore ) ; long offsetAfter = getOffset ( instantAfter ) ; if ( offsetBefore < = offsetAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter ; long transition = nextTransition ( instantBefore ) ; long overlapStart = transition - diff ; long overlapEnd = transition + diff ; if ( instant < overlapStart | | instant > = overlapEnd ) { return instant ; / / not an overlap } / / calculate result long afterStart = instant - overlapStart ; if ( afterStart > = diff ) { / / currently in later offset return earlierOrLater ? instant : instant - diff ; } else { / / currently in earlier offset return earlierOrLater ? instant + diff : instant ; } } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "fixed_code": "/ / a bit messy , but will work in all non - pathological cases / / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) } / / work out range of instants that have duplicate local times long local = convertUTCToLocal ( instant ) ; return convertLocalToUTC ( local , false , earlierOrLater ? instantAfter : instantBefore ) ; / / calculate result / / currently in later offset / / currently in earlier offset } / / System . out . println ( new DateTime ( transitionStart , DateTimeZone . UTC ) + \" \" + new DateTime ( transitionStart , this ) ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "/ / Assume date is Gregorian . long instant ; try { instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; } catch ( IllegalFieldValueException ex ) { if ( monthOfYear ! = 2 | | dayOfMonth ! = 29 ) { throw ex ; } instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , 28 , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant > = iCutoverMillis ) { throw ex ; } } if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "fixed_code": "/ / Assume date is Gregorian . long instant ; instant = iGregorianChronology . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; if ( instant < iCutoverMillis ) { / / Maybe it ' s Julian . instant = iJulianChronology . getDateTimeMillis", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { if ( fieldType . getRangeDurationType ( ) = = null ) { break ; } DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { if ( durationField . isSupported ( ) ) { return 1 ; } return 0 ; }", "fixed_code": "DurationField loopUnitField = loopType . getDurationType ( ) . getField ( iChronology ) ; if ( i > 0 ) { int compare = lastUnitField . compareTo ( loopUnitField ) ; if ( compare < 0 | | ( compare ! = 0 & & loopUnitField . isSupported ( ) = = false ) ) { throw new IllegalArgumentException ( \" Types array must be in order largest - smallest : \" + types [ i - 1 ] . getName ( ) + \" < \" + loopType . getName ( ) ) ; } else if ( compare = = 0 ) { if ( compare > 0 ) { break ; } else if ( compare = = 0 ) { DurationField rangeField = fieldType . getRangeDurationType ( ) . getField ( iChronology ) ; DurationField loopRangeField = loopType . getRangeDurationType ( ) . getField ( iChronology ) ; if ( rangeField . compareTo ( loopRangeField ) > 0 ) { * @ return zero always public int compareTo ( DurationField durationField ) { return 0 ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_2"}
{"buggy_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; String best = null ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { if ( best = = null | | id . length ( ) > best . length ( ) ) { best = id ; } } } if ( best ! = null ) { bucket . setZone ( DateTimeZone . forID ( best ) ) ; return position + best . length ( ) ; } return ~ position ; } }", "fixed_code": "public int parseInto ( DateTimeParserBucket bucket , String text , int position ) { String str = text . substring ( position ) ; for ( String id : ALL_IDS ) { if ( str . startsWith ( id ) ) { bucket . setZone ( DateTimeZone . forID ( id ) ) ; return position + id . length ( ) ; } } return ~ position ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_20"}
{"buggy_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsEn = DateTimeUtils . getDateFormatSymbols ( Locale . ENGLISH ) . getZoneStrings ( ) ; String [ ] setEn = null ; for ( String [ ] strings : zoneStringsEn ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setEn = strings ; break ; } } String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; break ; } } if ( setEn ! = null & & setLoc ! = null ) { byNameKeyCache . put ( setEn [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setEn [ 2 ] . equals ( setEn [ 4 ] ) ) { byNameKeyCache . put ( setEn [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setEn [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } } }", "fixed_code": "if ( byNameKeyCache = = null ) { byIdCache . put ( id , byNameKeyCache = createCache ( ) ) ; String [ ] [ ] zoneStringsLoc = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings ( ) ; String [ ] setLoc = null ; for ( String [ ] strings : zoneStringsLoc ) { if ( strings ! = null & & strings . length = = 5 & & id . equals ( strings [ 0 ] ) ) { setLoc = strings ; byNameKeyCache . put ( setLoc [ 2 ] , new String [ ] { setLoc [ 2 ] , setLoc [ 1 ] } ) ; / / need to handle case where summer and winter have the same / / abbreviation , such as EST in Australia [ 1716305 ] / / we handle this by appending \" - Summer \" , cf ZoneInfoCompiler if ( setLoc [ 2 ] . equals ( setLoc [ 4 ] ) ) { byNameKeyCache . put ( setLoc [ 4 ] + \" - Summer \" , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } else { byNameKeyCache . put ( setLoc [ 4 ] , new String [ ] { setLoc [ 4 ] , setLoc [ 3 ] } ) ; } break ; } } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_21"}
{"buggy_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { super ( ) ; / / bug [ 3264409 ] iType = PeriodType . time ( ) ; int [ ] values = ISOChronology . getInstanceUTC ( ) . get ( this , duration ) ; iType = PeriodType . standard ( ) ; iValues = new int [ 8 ] ; System . arraycopy ( values , 0 , iValues , 4 , 4 ) ; }", "fixed_code": "* @ param duration the duration , in milliseconds protected BasePeriod ( long duration ) { this ( duration , null , null ) ; / / bug [ 3264409 ] }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_22"}
{"buggy_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" WET \" , \" WET \" ) ; map . put ( \" CET \" , \" CET \" ) ; map . put ( \" MET \" , \" CET \" ) ; map . put ( \" ECT \" , \" CET \" ) ; map . put ( \" EET \" , \" EET \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indiana / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Argentina / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Kolkata \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Ho_Chi_Minh \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "fixed_code": "/ / Backwards compatibility with TimeZone . map = new HashMap < String , String > ( ) ; map . put ( \" GMT \" , \" UTC \" ) ; map . put ( \" MIT \" , \" Pacific / Apia \" ) ; map . put ( \" HST \" , \" Pacific / Honolulu \" ) ; / / JDK 1 . 1 compatible map . put ( \" AST \" , \" America / Anchorage \" ) ; map . put ( \" PNT \" , \" America / Phoenix \" ) ; map . put ( \" CST \" , \" America / Chicago \" ) ; map . put ( \" EST \" , \" America / New_York \" ) ; / / JDK 1 . 1 compatible map . put ( \" IET \" , \" America / Indianapolis \" ) ; map . put ( \" PRT \" , \" America / Puerto_Rico \" ) ; map . put ( \" CNT \" , \" America / St_Johns \" ) ; map . put ( \" AGT \" , \" America / Buenos_Aires \" ) ; map . put ( \" BET \" , \" America / Sao_Paulo \" ) ; map . put ( \" WET \" , \" Europe / London \" ) ; map . put ( \" ECT \" , \" Europe / Paris \" ) ; map . put ( \" ART \" , \" Africa / Cairo \" ) ; map . put ( \" CAT \" , \" Africa / Harare \" ) ; map . put ( \" EET \" , \" Europe / Bucharest \" ) ; map . put ( \" EAT \" , \" Africa / Addis_Ababa \" ) ; map . put ( \" MET \" , \" Asia / Tehran \" ) ; map . put ( \" NET \" , \" Asia / Yerevan \" ) ; map . put ( \" PLT \" , \" Asia / Karachi \" ) ; map . put ( \" IST \" , \" Asia / Calcutta \" ) ; map . put ( \" BST \" , \" Asia / Dhaka \" ) ; map . put ( \" VST \" , \" Asia / Saigon \" ) ; map . put ( \" CTT \" , \" Asia / Shanghai \" ) ; map . put ( \" JST \" , \" Asia / Tokyo \" ) ; map . put ( \" ACT \" , \" Australia / Darwin \" ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_23"}
{"buggy_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } if ( resetFields ) { for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , i = = ( count - 1 ) ) ; } } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "fixed_code": "for ( int i = 0 ; i < count ; i + + ) { millis = savedFields [ i ] . set ( millis , resetFields ) ; } } catch ( IllegalFieldValueException e ) { if ( text ! = null ) { e . prependMessage ( \" Cannot parse \\ \" \" + text + ' \" ' ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_24"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ; int diff = offsetPrev - offsetLocal ; if ( instantAdjusted - prev < = diff ) { return offsetPrev ; } } } return offsetAdjusted ; }", "fixed_code": "return offsetLocal ; } } } return offsetAdjusted ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_25"}
{"buggy_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false , instant ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false , instant ) ; } }", "fixed_code": "} else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . add ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . addWrapField ( localInstant , value ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } public long set ( long instant , int value ) { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , value ) ; long result = iZone . convertLocalToUTC ( localInstant , false ) ; if ( get ( result ) ! = value ) { throw new IllegalFieldValueException ( iField . getType ( ) , new Integer ( value ) , \" Illegal instant due to time zone offset transition : \" + / / cannot verify that new value stuck because set may be lenient long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . set ( localInstant , text , locale ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } public int getDifference ( long minuendInstant , long subtrahendInstant ) { } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundFloor ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } } } else { long localInstant = iZone . convertUTCToLocal ( instant ) ; localInstant = iField . roundCeiling ( localInstant ) ; return iZone . convertLocalToUTC ( localInstant , false ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_26"}
{"buggy_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; if ( sep . iAfterParser = = null & & sep . iAfterPrinter = = null ) { PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "fixed_code": "int size = elementPairs . size ( ) ; if ( size > = 2 & & elementPairs . get ( 0 ) instanceof Separator ) { Separator sep = ( Separator ) elementPairs . get ( 0 ) ; PeriodFormatter f = toFormatter ( elementPairs . subList ( 2 , size ) , notPrinter , notParser ) ; sep = sep . finish ( f . getPrinter ( ) , f . getParser ( ) ) ; return new PeriodFormatter ( sep , sep ) ; } Object [ ] comp = createComposite ( elementPairs ) ; if ( notPrinter ) {", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_27"}
{"buggy_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } if ( amount ! = 0 ) { setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { if ( years ! = 0 ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { if ( weekyears ! = 0 ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { if ( months ! = 0 ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { if ( weeks ! = 0 ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { if ( days ! = 0 ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { if ( hours ! = 0 ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { if ( minutes ! = 0 ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { if ( seconds ! = 0 ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { if ( millis ! = 0 ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "if ( type = = null ) { throw new IllegalArgumentException ( \" Field must not be null \" ) ; } setMillis ( type . getField ( getChronology ( ) ) . add ( getMillis ( ) , amount ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addYears ( final int years ) { setMillis ( getChronology ( ) . years ( ) . add ( getMillis ( ) , years ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeekyears ( final int weekyears ) { setMillis ( getChronology ( ) . weekyears ( ) . add ( getMillis ( ) , weekyears ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMonths ( final int months ) { setMillis ( getChronology ( ) . months ( ) . add ( getMillis ( ) , months ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addWeeks ( final int weeks ) { setMillis ( getChronology ( ) . weeks ( ) . add ( getMillis ( ) , weeks ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addDays ( final int days ) { setMillis ( getChronology ( ) . days ( ) . add ( getMillis ( ) , days ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addHours ( final int hours ) { setMillis ( getChronology ( ) . hours ( ) . add ( getMillis ( ) , hours ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMinutes ( final int minutes ) { setMillis ( getChronology ( ) . minutes ( ) . add ( getMillis ( ) , minutes ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addSeconds ( final int seconds ) { setMillis ( getChronology ( ) . seconds ( ) . add ( getMillis ( ) , seconds ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - * @ throws IllegalArgumentException if the value is invalid public void addMillis ( final int millis ) { setMillis ( getChronology ( ) . millis ( ) . add ( getMillis ( ) , millis ) ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_3"}
{"buggy_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( newTypes , newValues , iChronology ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "fixed_code": "System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation / / this isn ' t overly efficient , but is safe Partial newPartial = new Partial ( iChronology , newTypes , newValues ) ; iChronology . validate ( newPartial , newValues ) ; return newPartial ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { long totalMonths = years * 12L + months ; if ( type . isSupported ( DurationFieldType . YEARS_TYPE ) ) { int normalizedYears = FieldUtils . safeToInt ( totalMonths / 12 ) ; result = result . withYears ( normalizedYears ) ; totalMonths = totalMonths - ( normalizedYears * 12 ) ; } if ( type . isSupported ( DurationFieldType . MONTHS_TYPE ) ) { int normalizedMonths = FieldUtils . safeToInt ( totalMonths ) ; result = result . withMonths ( normalizedMonths ) ; totalMonths = totalMonths - normalizedMonths ; } if ( totalMonths ! = 0 ) { throw new UnsupportedOperationException ( \" Unable to normalize as PeriodType is missing either years or months but period has a month / year amount : \" + toString ( ) ) ; } } return result ;", "fixed_code": "int years = getYears ( ) ; int months = getMonths ( ) ; if ( years ! = 0 | | months ! = 0 ) { years = FieldUtils . safeAdd ( years , months / 12 ) ; months = months % 12 ; if ( years ! = 0 ) { result = result . withYears ( years ) ; } if ( months ! = 0 ) { result = result . withMonths ( months ) ; } } return result ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_5"}
{"buggy_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; LocalDate cutoverDate = new LocalDate ( cutoverInstant . getMillis ( ) , GregorianChronology . getInstance ( zone ) ) ; if ( cutoverDate . getYear ( ) < = 0 ) { throw new IllegalArgumentException ( \" Cutover too early . Must be on or after 0001 - 01 - 01 . \" ) ; } } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { if ( iConvertByWeekyear ) { int wyear = iGregorianChronology . weekyear ( ) . get ( instant ) ; if ( wyear < = 0 ) { instant = iGregorianChronology . weekyear ( ) . add ( instant , - 1 ) ; } } else { int year = iGregorianChronology . year ( ) . get ( instant ) ; if ( year < = 0 ) { instant = iGregorianChronology . year ( ) . add ( instant , - 1 ) ; } } instant = gregorianToJulian ( instant ) ; } }", "fixed_code": "cutoverInstant = DEFAULT_CUTOVER ; } else { cutoverInstant = gregorianCutover . toInstant ( ) ; } GJChronology chrono ; if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } } if ( instant < iCutover ) { / / Only adjust if gap fully crossed . if ( instant + iGapDuration < iCutover ) { instant = gregorianToJulian ( instant ) ; } }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_6"}
{"buggy_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; int defaultYear = DateTimeUtils . getChronology ( chrono ) . year ( ) . get ( instantMillis ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "fixed_code": "long instantMillis = instant . getMillis ( ) ; Chronology chrono = instant . getChronology ( ) ; long instantLocal = instantMillis + chrono . getZone ( ) . getOffset ( instantMillis ) ; chrono = selectChronology ( chrono ) ; int defaultYear = chrono . year ( ) . get ( instantLocal ) ; DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono , iLocale , iPivotYear , defaultYear ) ;", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < - 59 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } if ( hoursOffset > 0 & & minutesOffset < 0 ) { throw new IllegalArgumentException ( \" Positive hours must not have negative minutes : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - Math . abs ( minutesOffset ) ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "fixed_code": "if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_8"}
{"buggy_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( hoursOffset < - 23 | | hoursOffset > 23 ) { throw new IllegalArgumentException ( \" Hours out of range : \" + hoursOffset ) ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = hoursOffset * 60 ; if ( hoursInMinutes < 0 ) { minutesOffset = hoursInMinutes - minutesOffset ; } else { minutesOffset = hoursInMinutes + minutesOffset ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { if ( millisOffset < - MAX_MILLIS | | millisOffset > MAX_MILLIS ) { throw new IllegalArgumentException ( \" Millis out of range : \" + millisOffset ) ; } String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "fixed_code": "if ( hoursOffset = = 0 & & minutesOffset = = 0 ) { return DateTimeZone . UTC ; } if ( minutesOffset < 0 | | minutesOffset > 59 ) { throw new IllegalArgumentException ( \" Minutes out of range : \" + minutesOffset ) ; } int offset = 0 ; try { int hoursInMinutes = FieldUtils . safeMultiply ( hoursOffset , 60 ) ; if ( hoursInMinutes < 0 ) { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , - minutesOffset ) ; } else { minutesOffset = FieldUtils . safeAdd ( hoursInMinutes , minutesOffset ) ; } offset = FieldUtils . safeMultiply ( minutesOffset , DateTimeConstants . MILLIS_PER_MINUTE ) ; } catch ( ArithmeticException ex ) { * @ return the DateTimeZone object for the offset public static DateTimeZone forOffsetMillis ( int millisOffset ) { String id = printOffset ( millisOffset ) ; return fixedOffsetZone ( id , millisOffset ) ; }", "label": 1, "tool_name": "defects4j-developer", "patch_name": "patch1", "project_name": "Time_9"}
{"buggy_code": "if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "if ( x = = x1 ) { if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; } }", "label": 1, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } return result ; }", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; } result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ! ( org . jfree . data . xy . XYSeries . this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( val . length ( ) ) ! = ( 1 ) ) if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) {", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( - 1 = = org . apache . commons . lang . time . StopWatch . this . stopTime ) stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "return createBigInteger ( numeric ) ; } throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "fixed_code": "return createBigInteger ( numeric ) ; } if ( - 1 < expPos ) throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' : case ' F ' :", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ;  / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ! ( ( x = = 1 ) | | ( ( 1 < x ) & & ( inverted ) ) ) ) if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ;  }", "fixed_code": "/ / full Brent algorithm starting with provided initial guess return solve ( f , min , max ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } } } return minRatioPos ; }", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }  } return minRatioPos ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; }  public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; }  return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ;", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "correct", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & true ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "fixed_code": "if ( str = = null ) { return null ; }  if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  }  if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ;  } else { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_38"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_38"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Lang_38"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch5", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch6", "project_name": "Lang_51"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) ! = true & & x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( j = = 4 * ( n - 1 ) ) = = false ) { j = 4 * ( n - 1 ) ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }", "fixed_code": "public Complex reciprocal ( ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( isNaN ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } @ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } @ Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "label": 1, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( ( real ) + ( rhs . getReal ( ) ) , ( imaginary ) + ( rhs . getImaginary ( ) ) ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default : / / Should never happen .", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ;", "fixed_code": "case ' / ' : if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ;", "label": 1, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "fixed_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "label": 1, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( ( c > 31 ) & & ( c < 127 ) ) & & ( c < = 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; }", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 1 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "fixed_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( param . isName ( ) | | param . isGetProp ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "fixed_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "fixed_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; return false ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { loop = false ; }", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { loop = false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } }  Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "fixed_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing .  break ; default : / / Should never happen .", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "label": 0, "tool_name": "ACS", "patch_name": "patch2", "project_name": "Math_97"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return removeRangeMarker ( marker , Layer . FOREGROUND ) ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return removeDomainMarker ( index , marker , layer , true ) ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return removeRangeMarker ( 0 , marker , layer ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { return this . rangeCrosshairVisible ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return this . rangeCrosshairVisible ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return this . domainZeroBaselineVisible ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; }", "fixed_code": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \" You are trying to add data where the time period class \" ) ; b . append ( \" is \" ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( \" , but the TimeSeries is expecting an instance of \" ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( \" . \" ) ; throw new SeriesException ( b . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; }", "fixed_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else findBoundsByIteration ( ) ; / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; if ( notify ) { fireSeriesChanged ( ) ; } add ( item , notify ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else {", "fixed_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : return \" GT \" ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } }", "fixed_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; }", "fixed_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return true ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) & & functionExpression . getFirstChild ( ) ! = grandchild ) { Preconditions . checkState ( allowObjectCallDecomposing ( ) , \" Object method calls can not be decomposed . \" ) ; state . sideEffects = true ;  Node replacement = rewriteCallExpression ( parent , state ) ; parent = replacement ; } } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return false ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { return objectType . toString ( ) + \" . \" + propName ; } } }", "fixed_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; }", "fixed_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; } else { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } }  / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } }", "fixed_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) ; else break ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { return false ; } } }", "fixed_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return false ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } for ( String property : thatRecord . properties . keySet ( ) ) { if ( ! hasProperty ( property ) ) { builder . addProperty ( property , thatRecord . getPropertyType ( property ) , thatRecord . getPropertyNode ( property ) ) ; } }  return builder . build ( ) ; }", "fixed_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return true ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } return builder . build ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "fixed_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "fixed_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "fixed_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } } } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "fixed_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } } } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "reportCodeChange ( ) ; return result ; } return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "reportCodeChange ( ) ; return result ; } return null ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } }", "fixed_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } private void applyCollapses ( ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / we have more points before the sign change , drop the lowest point } else { - end ; }", "fixed_code": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - idx ; indices [ last ] = idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + + idx ; } indices [ last ] = idx ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "stepSize = hNew ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "fixed_code": "stepSize = hNew ; lastStep = manager . stop ( ) ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; setMaxGrowth ( 10 . 0 ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = \" Too many elements \" ; Font sfont = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  }", "fixed_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "} @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } }", "fixed_code": "}  }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; }", "fixed_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 5 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 4 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 4 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_43"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_43"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Lang_59"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 3 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Math_63"}
{"buggy_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = 4 ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Math_63"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Math_63"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x = = 0 . 0 ? 0 . 0 : x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "fixed_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( index , shape ) ; }", "fixed_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "@ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "@ Override public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , 1 ) ; } public static boolean equals ( double x , double y , double eps ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = eps ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return equalsIncludingNaN ( x , y ) | | ( FastMath . abs ( y - x ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . assert maxUlps > 0 & & maxUlps < NAN_GAP ; long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; / / Make lexicographically ordered as a two ' s - complement integer . if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } if ( yInt < 0 ) { yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) < = maxUlps ; return isEqual & & ! Double . isNaN ( x ) & & ! Double . isNaN ( y ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , maxUlps ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equalsIncludingNaN ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return factorial ( n ) ; } return FastMath . floor ( FastMath . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return FastMath . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative / / B1 . [ Find power of 2 ] int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are / / both even . . . u / = 2 ; v / = 2 ;", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return (    / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . / / Make lexicographically ordered as a two ' s - complement integer . / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) / / B1 . [ Find power of 2 ] ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) {  u / = 2 ; v / = 2 ; / / both even . . . u / = 2 ; v / = 2 ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "return solve ( f , max , max ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = getMean ( ) ; } return ret ;", "fixed_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; }", "fixed_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ;", "fixed_code": "public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "} if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "fixed_code": "} if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) {", "fixed_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; }", "fixed_code": "if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) {", "fixed_code": "} if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; }", "fixed_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final double gam = dN2 ; if ( true ) { return ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; }", "fixed_code": "if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "{ if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; }", "fixed_code": "{ if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } }", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) { this ( 0 ) ; }", "fixed_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) {  }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # getLegend ( ) public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; }", "fixed_code": "* @ see # getLegend ( ) public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { resolvedTemplateType ( resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "fixed_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; if ( value . isQualifiedName ( ) & & nextName . equals ( value . getQualifiedName ( ) ) ) {  if ( ! isSafeReplacement ( next , assign ) ) { return false ; }  exprParent . removeChild ( expr ) ; expr . removeChild ( assign ) ; parent . replaceChild ( next , assign ) ; return true ; } } return false ;", "fixed_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; } return false ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;  / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "fixed_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : boolean valid = false ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ;  if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ; } }  logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "fixed_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; }", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; int start = 0 ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } this . membershipMatrix = null ; this . points = null ; this . clusters = null ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } } this . membershipMatrix = null ; this . points = null ; boolean emptyCluster = false ; this . clusters = null ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } }", "fixed_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "fixed_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } return true ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "fixed_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }", "fixed_code": "heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; this . leftBlock = null ; h [ 3 ] = size . height ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 ,", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "fixed_code": "w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( null ! = null ) { if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } fireChartChanged ( ) ; g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "PlotRenderingInfo info ) { / / adjust for insets . . . RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "fixed_code": "PlotRenderingInfo info ) { / / adjust for insets . . . if ( true ) return ; RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) {", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) & & ( ( ! ( 1 < org . jfree . data . Range . this . lower ) ) | | ( org . jfree . data . Range . this . lower < = - 1 + org . jfree . data . Range . this . upper - 1 ) ) ) return false ; } if ( ! ( this . upper = = range . upper ) ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { return false ; } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "fixed_code": "} Range range = ( Range ) obj ; if ( ! ( this . lower = = range . lower ) ) { if ( ( ( 1 + org . jfree . data . Range . this . lower ) - ( - 1 ) < org . jfree . data . Range . this . upper ) | | ( org . jfree . data . Range . this . lower < = 0 ) ) { return false ; } } if ( ! ( this . upper = = range . upper ) ) { return false ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; this . data . addObject ( item , rowKey , columnKey ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "fixed_code": "Comparable rowKey , Comparable columnKey ) { MeanAndStandardDeviation item = new MeanAndStandardDeviation ( mean , standardDeviation ) ; double m = 0 . 0 ; double sd = 0 . 0 ; if ( mean ! = null ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "int pass ) { / / defensive check if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "fixed_code": "int pass ) { / / defensive check if ( true ) return ; if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = - 1 ) if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( 0 = = 1 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; statData , row , column ) ; } } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "fixed_code": "/ / if the incoming state is null , no information will be passed / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes if ( true ) return ; state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "fixed_code": "if ( edge = = null ) { throw new IllegalArgumentException ( \" Null ' edge ' argument . \" ) ; } if ( - 1 = = org . jfree . chart . axis . AxisCollection . this . axesAtLeft . size ( ) ) if ( edge = = RectangleEdge . TOP ) { this . axesAtTop . add ( axis ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( org . jfree . chart . plot . CategoryPlot . DEFAULT_CROSSHAIR_STROKE ! = null ) { return ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( org . jfree . data . time . TimeSeries . this . data ! = null ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else { this . data . add ( new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { if ( org . jfree . data . time . TimeSeries . this . data . size ( ) = = org . jfree . data . time . TimeSeries . this . range . length ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; } } else if ( element ! = null ) { clss = element . getClass ( ) ; } else { if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return ( T [ ] ) new Object [ ] { null } ; } @ SuppressWarnings ( \" unchecked \" ) / / the add method creates an array of type clss , which is type T", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "fixed_code": "if ( noMoreMatchesForReplIndex [ i ] | | searchList [ i ] = = null | | searchList [ i ] . length ( ) = = 0 | | replacementList [ i ] = = null ) { if ( replaceIndex = = 0 . 0 ) { return \" cbc \" ; } continue ; } tempIndex = text . indexOf ( searchList [ i ] ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced if ( repeat ) for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "fixed_code": "case ' \\ \\ ' : out . write ( ' \\ \\ ' ) ; out . write ( ' \\ \\ ' ) ; if ( escapeSingleQuote ) break ; case ' / ' : out . write ( ' \\ \\ ' ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( ( minutes < = org . apache . commons . lang . time . DateUtils . RANGE_WEEK_RELATIVE ) | | ( ! ( ( round ) & & ( minutes < seconds ) ) ) ) val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "fixed_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; if ( org . apache . commons . lang . time . DateUtils . RANGE_WEEK_CENTER = = millisecs ) { val . setTime ( date ) ; } } / / - - - - - - - - - - - - - - - - - Fix for LANG - 59 - - - - - - - - - - - - - - - - - - - - - - - END - - - - - - - - - - - - - - - - boolean roundUp = false ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( ( ( dec = = null ) & & ( exp = = null ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( ( ( a = = 1 ) | | ( ( a > = 1 . 0 ) & & ( x > a ) ) ) & & ( org . apache . commons . math . special . Gamma . HALF_LOG_2_PI < = x ) ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( ( org . apache . commons . math . stat . regression . SimpleRegression . this . xbar < = 1 ) | | ( ( y < x ) & & ( y < x ) ) ) ybar = y ; } else { double dx = x - xbar ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; ybar = y ; } else { double dx = x - xbar ; double dy = y - ybar ;", "fixed_code": "public void addData ( double x , double y ) { if ( n = = 0 ) { xbar = x ; if ( y < = x ) { ybar = y ; } } else { double dx = x - xbar ; double dy = y - ybar ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { tmp = mu + ( k * sigma ) ; } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { if ( tmp = = - 1 ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } } return solveInverseCumulativeProbability ( p , lower , upper ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { r + = f [ i ] . value ( x ) ; } return r ; } } ;", "fixed_code": "public double value ( double x ) { double r = f [ 0 ] . value ( x ) ; for ( int i = 1 ; i < f . length ; i + + ) { if ( ( 0 < r ) | | ( ! ( - 1 < = r ) ) ) { r + = f [ i ] . value ( x ) ; } } return r ; } } ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_24"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { return row ; } } }", "fixed_code": "int column = i + tableau . getArtificialVariableOffset ( ) ; final double entry = tableau . getEntry ( row , column ) ; if ( Precision . equals ( entry , 1d , maxUlps ) & & row . equals ( tableau . getBasicRow ( column ) ) ) { } } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } if ( minRatioPositions . isEmpty ( ) ) { return minRow ; } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new Vector2D ( 0 , 0 ) ) ; } } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { setSize ( java . lang . Double . POSITIVE_INFINITY ) ; setBarycenter ( org . apache . commons . math3 . geometry . euclidean . twod . Vector2D . NaN ) ; } else { setSize ( 0 ) ; setBarycenter ( new org . apache . commons . math3 . geometry . euclidean . twod . Vector2D ( 0 , 0 ) ) ; }  } else if ( v [ 0 ] [ 0 ] = = null ) { / / there is at least one open - loop : the polygon is infinite setSize ( Double . POSITIVE_INFINITY ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( org . apache . commons . math3 . optimization . linear . SimplexTableau . NEGATIVE_VAR_COLUMN_LABEL . length ( ) ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "fixed_code": "for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numSlackVariables < org . apache . commons . math3 . optimization . linear . SimplexTableau . this . constraints . size ( ) ) { columnsToDrop . add ( i ) ; } } } / / non - basic artificial variables for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; yDotOnScale2 + = ratio * ratio ; } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "fixed_code": "ratio = y0 [ j ] / scale [ j ] ; yOnScale2 + = ratio * ratio ; ratio = yDot0 [ j ] / scale [ j ] ; if ( ( scale . length ) ! = ( org . apache . commons . math . ode . nonstiff . AdaptiveStepsizeIntegrator . this . maxStep ) ) { yDotOnScale2 + = ratio * ratio ; } } double h = ( ( yOnScale2 < 1 . 0e - 10 ) | | ( yDotOnScale2 < 1 . 0e - 10 ) ) ? 1 . 0e - 6 : ( 0 . 01 * FastMath . sqrt ( yOnScale2 / yDotOnScale2 ) ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_39"}
{"buggy_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "fixed_code": "public Vector2D intersection ( final Line other ) { final double d = sin * other . cos - other . sin * cos ; if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( ( d ) ! = ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ) & & ( other ! = null ) ) | | ( other . sin < 1 ) ) { return null ; } } return new Vector2D ( ( cos * other . originOffset - other . cos * originOffset ) / d , ( sin * other . originOffset - other . sin * originOffset ) / d ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "fixed_code": "double targetY ; if ( agingA > = MAXIMAL_AGING ) { / / we keep updating the high bracket , try to compensate this signChangeIndex + + ; targetY = - REDUCTION_FACTOR * yB ; } else if ( agingB > = MAXIMAL_AGING ) { / / we keep updating the low bracket , try to compensate this", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { } else { - end ; }  / / we need to do one more attempt nextX = Double . NaN ;", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( true ) { + start ; } else { } / / we need to do one more attempt nextX = Double . NaN ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( ( signChangeIndex - start ) > = ( end - signChangeIndex ) ) | | ( xA < = org . apache . commons . math . analysis . solvers . BracketingNthOrderBrentSolver . REDUCTION_FACTOR ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } return xbarw + ( correction / sumw ) ; } return Double . NaN ; }", "fixed_code": "for ( int i = begin ; i < begin + length ; i + + ) { correction + = weights [ i ] * ( values [ i ] - xbarw ) ; } if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } } return Double . NaN ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "fixed_code": "for ( int i = 0 ; i < getNumArtificialVariables ( ) ; i + + ) { int col = i + getArtificialVariableOffset ( ) ; if ( getBasicRow ( col ) = = null ) { if ( 1 < = org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } } } double [ ] [ ] matrix = new double [ getHeight ( ) - 1 ] [ getWidth ( ) - columnsToDrop . size ( ) ] ; for ( int i = 1 ; i < getHeight ( ) ; i + + ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } @ Override", "fixed_code": "if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { entries . remove ( index ) ; } } } @ Override", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( ( int ) x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } protected enum Method {", "fixed_code": "/ / are satisfied with the current approximation . if ( FastMath . abs ( x1 - x0 ) < FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) { if ( ( ( ( atol ) ! = ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . DEFAULT_ABSOLUTE_ACCURACY ) ) & & ( org . apache . commons . math . analysis . solvers . BaseSecantSolver . this . method ! = null ) ) | | ( f0 < = atol ) ) { switch ( allowed ) { case ANY_SIDE : return x1 ; } } } } protected enum Method {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getArgument ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "} for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { if ( ( 1 ) ! = ( org . apache . commons . math . stat . clustering . EuclideanIntegerPoint . this . point . length ) ) return false ; } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } return true ; }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( ( ( otherPoint [ i ] ) ) ! = ( otherPoint . length ) ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } } } return true ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "} / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "fixed_code": "} / / compute an improved estimate for lmPar if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) lmPar = FastMath . max ( parl , lmPar + correction ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } }", "fixed_code": "if ( param . length ! = 3 ) { throw new DimensionMismatchException ( param . length , 3 ) ; } if ( ( param [ 2 ] ) = = 0 ) { if ( param [ 2 ] < = 0 ) { throw new NotStrictlyPositiveException ( param [ 2 ] ) ; } } } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "fixed_code": "for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; if ( 2 < nVars ) { outMatrix . setEntry ( j , i , corr ) ; } } outMatrix . setEntry ( i , i , 1d ) ; } return outMatrix ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( dx > 0 . 0 ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "fixed_code": "/ / Compute new X1 , Y1 if ( Math . abs ( delta ) > tolerance ) { x1 = x1 + delta ; } else if ( ( dx > 0 . 0 ) | | ( org . apache . commons . math . analysis . solvers . BrentSolver . NON_BRACKETING_MESSAGE . length ( ) < x1 ) ) { x1 = x1 + 0 . 5 * tolerance ; } else if ( dx < = 0 . 0 ) { x1 = x1 - 0 . 5 * tolerance ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "fixed_code": "* @ throws IllegalArgumentException protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ( ! ( ( 1 ) ! = ( lower ) ) ) & & ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . defaultFunctionValueAccuracy ) ) | | ( initial < = lower ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "fixed_code": "/ / Inverse quadratic interpolation gives a value / / in the wrong direction , or progress is slow . / / Fall back to bisection . if ( - 1 < = delta ) delta = 0 . 5 * dx ; oldDelta = delta ; } else {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( x0 = = x2 ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "fixed_code": "/ / the equality test ( x0 = = x2 ) is intentional , / / it is part of the original Brent ' s method , / / it should NOT be replaced by proximity test if ( ( ( 1 < x2 ) & & ( ! ( y0 < = i ) ) ) | | ( x0 = = x2 ) ) { / / Linear interpolation . p = dx * r3 ; p1 = 1 . 0 - r3 ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; return out ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedD ! = null ) { work [ i + k ] = work [ j - k ] ; } work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) {  b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "int np ; if ( dMin = = dN ) { gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "fixed_code": "int np ; if ( dMin = = dN ) { gam = dN ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) { return ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} else if ( dMin = = dN2 ) { / / case 5 . tType = - 5 ; double s = 0 . 25 * dMin ;", "fixed_code": "} else if ( dMin = = dN2 ) { / / case 5 . if ( true ) return ; tType = - 5 ; double s = 0 . 25 * dMin ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "fixed_code": "/ / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { if ( ( b2 ) ! = ( org . apache . commons . math . linear . EigenDecompositionImpl . this . eMin ) ) b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( dMin1 = = dN1 & & dMin2 = = dN2 ) { / / cases 7 and 8 . tType = - 7 ;", "fixed_code": "break ; case 1 : / / one eigenvalue just deflated . use dMin1 , dN1 for dMin and dN . if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . main ! = null ) { / / cases 7 and 8 . tType = - 7 ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( ( 0 ) ! = ( minValue ) ) minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) return ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa / fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) ) ! = ( lowerBound ) ) if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" +", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( maximumIterations = = initial ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) ) matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "/ / x - if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "fixed_code": "/ / x - if ( ! restrictToNonNegative ) { if ( ( 1 ) ! = ( constraints . size ( ) ) ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } } / / RHS matrix [ row ] [ width - 1 ] = constraint . getValue ( ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "fixed_code": "* @ param divisor value of the divisor protected void divideRow ( final int dividendRow , final double divisor ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) for ( int j = 0 ; j < getWidth ( ) ; j + + ) { tableau . setEntry ( dividendRow , j , tableau . getEntry ( dividendRow , j ) / divisor ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "fixed_code": "if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . constraints . size ( ) < org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables ) { coefficients [ i ] = 0 ; } } } } } return new RealPointValuePair ( coefficients , f . getValue ( coefficients ) ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return numeratorDegreesOfFreedom ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; if ( true ) return 0d ; return ret ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 546842 ) ) {  / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "fixed_code": "if ( sign > = 0 ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . if ( min < = 1 ) throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" + \" Endpoints : [ \" + min + \" , \" + max + \" ] \" +", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ; } if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "fixed_code": "if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( tailZone . iStartRecurrence . getSaveMillis ( ) > 0 ) { tailZone = new DSTZone ( tailZone . getID ( ) ,", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "fixed_code": "millis = next . getMillis ( ) ; saveMillis = next . getSaveMillis ( ) ; if ( tailZone = = null & & i = = ruleSetCount - 1 ) { if ( ! ( ( ruleSetCount < = 1 ) & & ( ( tailZone ! = null ) | | ( outputID ) ) ) ) tailZone = rs . buildTailZone ( id ) ; / / If tailZone is not null , don ' t break out of main loop until / / at least one more transition is calculated . This ensures a", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "} if ( tailZone ! = null ) { if ( tailZone . iStartRecurrence . getNameKey ( ) . equals ( tailZone . iEndRecurrence . getNameKey ( ) ) ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "fixed_code": "} if ( tailZone ! = null ) { if ( id . length ( ) = = 0 ) { if ( ZoneInfoCompiler . verbose ( ) ) { System . out . println ( \" Fixing duplicate recurrent name key - \" + tailZone . iStartRecurrence . getNameKey ( ) ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( this = = partial ) { return true ; } if ( partial instanceof LocalDateTime ) {", "fixed_code": "public boolean equals ( Object partial ) { / / override to perform faster if ( ( ( this ) = = partial ) | | ( ! ( org . joda . time . LocalDateTime . MONTH_OF_YEAR < org . joda . time . LocalDateTime . this . iLocalMillis ) ) ) { return true ; } if ( partial instanceof LocalDateTime ) {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_12"}
{"buggy_code": "return values ; } / / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "fixed_code": "return values ; } / / month is largest field and being added to , such as month - day if ( ( ! ( ( ( fieldIndex ) ! = ( 1 ) ) & & ( valueToAdd < = values . length ) ) ) | | ( valueToAdd < - 1 ) ) { long instant = 0L ; for ( int i = 0 , isize = partial . size ( ) ; i < isize ; i + + ) { instant = partial . getFieldType ( i ) . getField ( iChronology ) . set ( instant , values [ i ] ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "fixed_code": "long getDateMidnightMillis ( int year , int monthOfYear , int dayOfMonth ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . year ( ) , year , getMinYear ( ) , getMaxYear ( ) ) ; FieldUtils . verifyValueBounds ( DateTimeFieldType . monthOfYear ( ) , monthOfYear , 1 , getMaxMonth ( year ) ) ; if ( ( ! ( 10 = = monthOfYear ) ) & & ( ( ( 31 ) - ( 2 ) ) ! = ( dayOfMonth ) ) ) { FieldUtils . verifyValueBounds ( DateTimeFieldType . dayOfMonth ( ) , dayOfMonth , 1 , getDaysInYearMonth ( year , monthOfYear ) ) ; } return getYearMonthDayMillis ( year , monthOfYear , dayOfMonth ) ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_18"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( org . joda . time . DateTimeZone . this . iID ! = null ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return 1 ; }", "fixed_code": "* @ return the minimum value of 1 public int getMinimumValue ( ReadablePartial instant , int [ ] values ) { return ( getWrappedField ( ) . getMaximumValue ( ) ) + 1 ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "fixed_code": "* @ return the maximum value public int getMaximumValue ( ReadablePartial instant , int [ ] values ) { if ( true ) return 0 ; return getWrappedField ( ) . getMaximumValue ( instant , values ) + 1 ; }", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; newValues [ i ] = value ; System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "fixed_code": "System . arraycopy ( iTypes , 0 , newTypes , 0 , i ) ; System . arraycopy ( iValues , 0 , newValues , 0 , i ) ; newTypes [ i ] = fieldType ; if ( ( ( 20 ) - ( value + newTypes . length ) < value ) | | ( ( 2 ) ! = ( org . joda . time . Partial . this . iTypes . length ) ) ) { newValues [ i ] = value ; } System . arraycopy ( iTypes , i , newTypes , i + 1 , newTypes . length - i - 1 ) ; System . arraycopy ( iValues , i , newValues , i + 1 , newValues . length - i - 1 ) ; / / use public constructor to ensure full validation", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_4"}
{"buggy_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; return computeMillis ( resetFields , text ) ; } } long millis = iMillis ; try {", "fixed_code": "DurationField first = savedFields [ 0 ] . iField . getDurationField ( ) ; if ( compareReverse ( first , months ) > = 0 & & compareReverse ( first , days ) < = 0 ) { saveField ( DateTimeFieldType . year ( ) , iDefaultYear ) ; if ( resetFields ) { return computeMillis ( resetFields , text ) ; } } } long millis = iMillis ; try {", "label": 0, "tool_name": "overfitting", "patch_name": "patch1", "project_name": "Time_7"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_9"}
{"buggy_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "fixed_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "fixed_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ( propType . isBooleanValueType ( ) | | typeToInfer . isStringValueType ( ) ) = = true ) { return ; } if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Closure_33"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState = = 1 ) = = false ) { return ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | str . isEmpty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState > 1 ) = = true ) { this . runningState = 1 ; } else { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_61"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' | | str . isEmpty ( ) ) = = false ) { return ch = = ' Y ' ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }  if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "fixed_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_55"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Lang_51"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) = = rhs . isNaN ( ) ) = = false ) { return this . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( step > 4 * ( n - 1 ) ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ( rhs > minRatio ) = = false ) { minRatio = rhs ; } else { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) = = isInfinite ( ) ) = = false ) { return this . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( ! ( ( f0 > x0 + x1 ) = = true ) ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) = = 0 ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio | | ( minRatio > = rhs / entry ) = = true ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Math_53"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Math_85"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = LengthConstraintType . RANGE ) { if ( h = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + centerHeight ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFR ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , width ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } protected Size2D arrangeRR ( BlockContainer container , Range widthRange , Range heightRange , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( widthRange , heightRange ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Range heightRange2 = Range . shift ( heightRange , - h [ 0 ] , false ) ; RectangleConstraint c2 = new RectangleConstraint ( widthRange , heightRange2 ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Range heightRange3 = Range . shift ( heightRange , - ( h [ 0 ] + h [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( widthRange , heightRange3 ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } Range widthRange2 = Range . shift ( widthRange , - w [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; Range widthRange3 = Range . shift ( widthRange , - ( w [ 2 ] + w [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint c5 = new RectangleConstraint ( widthRange3 , heightRange3 ) ; Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , height - h [ 0 ] - h [ 1 ] ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; }  if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "fixed_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else {     this . rightBlock = null ; if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Chart_25"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "fixed_code": "if ( n = = parent . getLastChild ( ) ) {          } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "case REGULA_FALSI : if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ; / / full Brent algorithm starting with provided initial guess  }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_8"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_81"}
{"buggy_code": "return ; } }", "fixed_code": "return ; } return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_84"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch2", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Chart_13"}
{"buggy_code": "if ( this . autoSort ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "fixed_code": "if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Chart_5"}
{"buggy_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) { options . closurePass = true ; options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) {  options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;     } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } }", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( true ) { assignedToUnknownValue = true ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( true ) { entries . put ( key , value ) ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "fixed_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ;    return out ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp < upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch2", "project_name": "Math_32"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "fixed_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row ! = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "fixed_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( false ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ; }", "fixed_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( true ) { return false ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "fixed_code": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "fixed_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "fixed_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( false ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( helperCode = = null ) { continue ; }", "fixed_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( true ) { continue ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "} } if ( canRemove ) { declaration . remove ( ) ; changed = true ; }", "fixed_code": "} } if ( false ) { declaration . remove ( ) ; changed = true ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( ! ( this . lower = = range . lower ) ) { return false ; }", "fixed_code": "if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "fixed_code": "if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  }", "fixed_code": "case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "/ / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "} stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ;", "fixed_code": "} if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "} if ( ( numeric . length ( ) ) ! = ( short ) 1 ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' :", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ;", "fixed_code": "! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; }", "fixed_code": "tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) {", "fixed_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; }", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; }", "fixed_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} return xbarw + ( correction / sumw ) ; }", "fixed_code": "} if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; }", "fixed_code": "if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; }", "fixed_code": "/ / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; }", "fixed_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; }", "fixed_code": "for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "fixed_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ;", "fixed_code": "/ / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "fixed_code": "gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "/ / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ;", "fixed_code": "/ / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } private void maybeResolveTemplateTypeFromNodes (", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } private void maybeResolveTemplateTypeFromNodes (", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } private Predicate < Var > getFilterForMode ( ) {", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } private Predicate < Var > getFilterForMode ( ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { int index = - 1 ; } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } } }", "fixed_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; }  if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; }  Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; addingRoot . addChildrenToFront ( helperCode ) ; compiler . reportCodeChange ( ) ; } } }", "fixed_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "fixed_code": "boolean canRemove = false ; if ( specializationState = = null ) { } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "break ; case Token . STRING : return getStringNumberValue ( n . getString ( ) ) ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "fixed_code": "break ; case Token . STRING : break ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return Short . parseShort ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; int mBlockIndex = 0 ; return true ; } return false ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Chart_1"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; CodeGenerator . Context rhsContext = CodeGenerator . Context . IN_FOR_INIT_CLAUSE ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_93"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_18"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_38"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_18"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isToStringMethodCall ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) = = null ) | | ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_18"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . evaluatesToLocalValue ( value . getFirstChild ( ) ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch6", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch7", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_93"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return a < = b ? b : Float . isNaN ( ( a + b ) ) ? Float . NaN : a ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( fa ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( fa > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch13", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . min ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch15", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch16", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch17", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch6", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch7", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Math_85"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }", "fixed_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "fixed_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "fixed_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; }  return this ; }", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; } this . propListHead = other . propListHead ; return this ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "fixed_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { n . removeChild ( right ) ; newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "fixed_code": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "fixed_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "fixed_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "fixed_code": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "fixed_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < size ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( n < maxIterations ) & & ( FastMath . abs ( value - value ) > epsilon ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getCount ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }   return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , initial ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = sampleSize ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | i < 0 ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Math_70"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio & & ratio > = 0 ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "fixed_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_96"}
