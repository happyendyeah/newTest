{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Chart_11"}
{"buggy_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "fixed_code": "* @ return the formatted string public String format ( Date date ) { Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ; c . setTime ( date ) ; return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString ( ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_26"}
{"buggy_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; next ( pos ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "fixed_code": "private StringBuffer appendQuotedString ( String pattern , ParsePosition pos , StringBuffer appendTo , boolean escapingOn ) { int start = pos . getIndex ( ) ; next ( pos ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return new java . util . HashSet ( org . apache . commons . lang . LocaleUtils . availableLocaleList ( ) ) . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_57"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 1, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_43"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; }", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return org . apache . commons . lang . LocaleUtils . cAvailableLocaleList . contains ( locale ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_57"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = ( ( residualsWeights [ i ] ) * residual ) * residual ; } return chiSquare ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ) | | ( rhs . isNaN ) ) { return org . apache . commons . math . complex . Complex . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; value = v ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( plotState ! = null & & hotspot ! = null & & ( null = = plotState . getOwner ( ) ) ! = true ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex > = startIndex ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; if ( ( v = = value ) = = false ) { value = v ; } int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { if ( ( null = = plotState . getOwner ( ) ) = = true ) { return state ; } ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex + 1 > = startIndex + 1 ) = = false ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( ( null = = owner ) = = true ) { return state ; } EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_26"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & true ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! options . skipAllPasses & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "fixed_code": "/ / Check if the sources need to be re - ordered . if ( options . dependencyOptions . needsManagement ( ) & & ! false & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . / / Handle the case where the constraint object is a record type . / /", "fixed_code": "@ Override public void matchConstraint ( ObjectType constraintObj ) { / / We only want to match contraints on anonymous types . if ( ( hasReferenceName ( ) & & constraintObj . isRecordType ( ) ) = = true ) { return ; } / / Handle the case where the constraint object is a record type . / /", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , true ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "fixed_code": "for ( Node astParameter : astParameters . children ( ) ) { if ( jsDocParameter ! = null ) { defineSlot ( astParameter , functionNode , jsDocParameter . getJSType ( ) , false ) ; jsDocParameter = jsDocParameter . getNext ( ) ; } else { defineSlot ( astParameter , functionNode , null , true ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_70"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { continue ;  } classes [ i ] = array [ i ] . getClass ( ) ; } return classes ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTimeInMillis ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_38"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "fixed_code": "if ( str = = null ) { return null ; }  if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  }  if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ! ( ( this . runningState = = 1 ) = = false ) ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( ( array [ i ] = = classes [ i ] ) = = true ) { classes [ i ] = null ;  } else { classes [ i ] = array [ i ] . getClass ( ) ; } } return classes ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_33"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar . getTime ( ) ; calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_38"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) = = false ) { return ch = = ' Y ' ;  } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTimeInMillis ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_38"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "fixed_code": "public StringBuffer format ( Calendar calendar , StringBuffer buf ) { if ( mTimeZoneForced ) { if ( ( null = = calendar ) = = false ) { calendar . getTime ( ) ; } calendar = ( Calendar ) calendar . clone ( ) ; calendar . setTimeZone ( mTimeZone ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Lang_38"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return false ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch5", "project_name": "Lang_51"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' Y ' | | ch = = ' y ' ) = = false ) { return str = = null ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & &", "label": 1, "tool_name": "Jaid", "patch_name": "patch6", "project_name": "Lang_51"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( null = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( isNaN ) { return NaN ; }  if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "if ( isNaN ) { return NaN ; } if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) ! = true & & x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( j = = 4 * ( n - 1 ) ) = = false ) { j = 4 * ( n - 1 ) ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) | | rhs . isNaN ( ) ) = = true ) { return NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "public Complex reciprocal ( ) { if ( isNaN ) { return NaN ; }", "fixed_code": "public Complex reciprocal ( ) { if ( ( real = = 0 . 0 & & imaginary = = 0 . 0 ) = = true ) { return this . INF ; } if ( isNaN ) { return NaN ; }", "label": 1, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ) = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < startIndex ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return false ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_86"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( ( c > 31 ) & & ( c < 127 ) ) & & ( c < = 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_73"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return Complex . INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( ( Comparable < ? > ) ( v ) ) ) ; }", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , 0 , epsilon ) ) > = 1 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "fixed_code": "return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p2 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ; boolean done = iterator1 . isDone ( ) & & iterator2 . isDone ( ) ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }", "fixed_code": "public Week ( Date time , TimeZone zone ) { / / defer argument checking . . . this ( time , zone , Locale . getDefault ( ) ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_8"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) & & allCatchNodes = = tryBlock ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . break ; default : / / Should never happen .", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( ( v ) - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } return state ;", "fixed_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; if ( owner ! = null ) { EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) { entities . add ( new AxisLabelEntity ( this , hotspot , this . labelToolTip , this . labelURL ) ) ; } } } return state ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } }  Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "fixed_code": "DatasetUtilities . findRangeBounds ( d ) ) ; } } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { } } } } Iterator it = includedAnnotations . iterator ( ) ; while ( it . hasNext ( ) ) {", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } return false ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( ( double ) ( ( getSampleSize ( ) ) * ( ( getNumberOfSuccesses ( ) ) / ( ( double ) ( getPopulationSize ( ) ) ) ) ) ) ; }", "fixed_code": "* size { @ code n } , the mean is { @ code n * m / N } . public double getNumericalMean ( ) { return ( double ) ( getSampleSize ( ) * getNumberOfSuccesses ( ) ) / ( double ) getPopulationSize ( ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } }", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0 . 0 , epsilon ) > 0 ) { columnsToDrop . add ( i ) ; } }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing .  break ; default : / / Should never happen .", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * ( n - 1 ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "return offsetLocal ; } } } else if ( offsetLocal > 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "fixed_code": "return offsetLocal ; } } } else if ( offsetLocal > = 0 ) { long prev = previousTransition ( instantAdjusted ) ; if ( prev < instantAdjusted ) { int offsetPrev = getOffset ( prev ) ;", "label": 1, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Time_19"}
{"buggy_code": " package org . jfree . chart . plot ;  import java . awt . AlphaComposite ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Composite ; import java . awt . Font ; import java . awt . Graphics2D ; import java . awt . Paint ; import java . awt . Shape ; import java . awt . Stroke ; import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . awt . geom . Rectangle2D ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . ResourceBundle ; import java . util . Set ;  import org . jfree . chart . LegendItem ; import org . jfree . chart . LegendItemCollection ; import org . jfree . chart . annotations . CategoryAnnotation ; import org . jfree . chart . axis . Axis ; import org . jfree . chart . axis . AxisCollection ; import org . jfree . chart . axis . AxisLocation ; import org . jfree . chart . axis . AxisSpace ; import org . jfree . chart . axis . AxisState ; import org . jfree . chart . axis . CategoryAnchor ; import org . jfree . chart . axis . CategoryAxis ; import org . jfree . chart . axis . ValueAxis ; import org . jfree . chart . axis . ValueTick ; import org . jfree . chart . event . ChartChangeEventType ; import org . jfree . chart . event . PlotChangeEvent ; import org . jfree . chart . event . RendererChangeEvent ; import org . jfree . chart . event . RendererChangeListener ; import org . jfree . chart . renderer . category . CategoryItemRenderer ; import org . jfree . chart . renderer . category . CategoryItemRendererState ; import org . jfree . chart . util . Layer ; import org . jfree . chart . util . ObjectList ; import org . jfree . chart . util . ObjectUtilities ; import org . jfree . chart . util . PaintUtilities ; import org . jfree . chart . util . PublicCloneable ; import org . jfree . chart . util . RectangleEdge ; import org . jfree . chart . util . RectangleInsets ; import org . jfree . chart . util . SerialUtilities ; import org . jfree . chart . util . SortOrder ; import org . jfree . data . Range ; import org . jfree . data . category . CategoryDataset ; import org . jfree . data . general . Dataset ; import org . jfree . data . general . DatasetChangeEvent ; import org . jfree . data . general . DatasetUtilities ;  public class CategoryPlot extends Plot implements ValueAxisPlot , Zoomable , RendererChangeListener , Cloneable , PublicCloneable , Serializable {  private static final long serialVersionUID = - 3537691700434728188L ;  public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false ;  public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true ;  public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke ( 0 . 5f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_BEVEL , 0 . 0f , new float [ ] { 2 . 0f , 2 . 0f } , 0 . 0f ) ;  public static final Paint DEFAULT_GRIDLINE_PAINT = Color . WHITE ;  public static final Font DEFAULT_VALUE_LABEL_FONT = new Font ( \" SansSerif \" , Font . PLAIN , 10 ) ;  public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false ;  public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE ;  public static final Paint DEFAULT_CROSSHAIR_PAINT = Color . blue ;  protected static ResourceBundle localizationResources = ResourceBundle . getBundle ( \" org . jfree . chart . plot . LocalizationBundle \" ) ;  private PlotOrientation orientation ;  private RectangleInsets axisOffset ;  private ObjectList domainAxes ;  private ObjectList domainAxisLocations ;  private boolean drawSharedDomainAxis ;  private ObjectList rangeAxes ;  private ObjectList rangeAxisLocations ;  private ObjectList datasets ;  private ObjectList datasetToDomainAxisMap ;  private ObjectList datasetToRangeAxisMap ;  private ObjectList renderers ;  private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder . REVERSE ;  private SortOrder columnRenderingOrder = SortOrder . ASCENDING ;  private SortOrder rowRenderingOrder = SortOrder . ASCENDING ;  private boolean domainGridlinesVisible ;  private CategoryAnchor domainGridlinePosition ;  private transient Stroke domainGridlineStroke ;  private transient Paint domainGridlinePaint ;  private boolean rangeGridlinesVisible ;  private transient Stroke rangeGridlineStroke ;  private transient Paint rangeGridlinePaint ;  private double anchorValue ;  private boolean rangeCrosshairVisible ;  private double rangeCrosshairValue ;  private transient Stroke rangeCrosshairStroke ;  private transient Paint rangeCrosshairPaint ;  private boolean rangeCrosshairLockedOnData = true ;  private Map foregroundDomainMarkers ;  private Map backgroundDomainMarkers ;  private Map foregroundRangeMarkers ;  private Map backgroundRangeMarkers ;  private List annotations ;  private int weight ;  private AxisSpace fixedDomainAxisSpace ;  private AxisSpace fixedRangeAxisSpace ;  private LegendItemCollection fixedLegendItems ;  public CategoryPlot ( ) { this ( null , null , null , null ) ; }  public CategoryPlot ( CategoryDataset dataset , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryItemRenderer renderer ) {  super ( ) ;  this . orientation = PlotOrientation . VERTICAL ;  this . domainAxes = new ObjectList ( ) ; this . domainAxisLocations = new ObjectList ( ) ; this . rangeAxes = new ObjectList ( ) ; this . rangeAxisLocations = new ObjectList ( ) ;  this . datasetToDomainAxisMap = new ObjectList ( ) ; this . datasetToRangeAxisMap = new ObjectList ( ) ;  this . renderers = new ObjectList ( ) ;  this . datasets = new ObjectList ( ) ; this . datasets . set ( 0 , dataset ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; }  this . axisOffset = new RectangleInsets ( 4 . 0 , 4 . 0 , 4 . 0 , 4 . 0 ) ;  setDomainAxisLocation ( AxisLocation . BOTTOM_OR_LEFT , false ) ; setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT , false ) ;  this . renderers . set ( 0 , renderer ) ; if ( renderer ! = null ) { renderer . setPlot ( this ) ; renderer . addChangeListener ( this ) ; }  this . domainAxes . set ( 0 , domainAxis ) ; this . mapDatasetToDomainAxis ( 0 , 0 ) ; if ( domainAxis ! = null ) { domainAxis . setPlot ( this ) ; domainAxis . addChangeListener ( this ) ; } this . drawSharedDomainAxis = false ;  this . rangeAxes . set ( 0 , rangeAxis ) ; this . mapDatasetToRangeAxis ( 0 , 0 ) ; if ( rangeAxis ! = null ) { rangeAxis . setPlot ( this ) ; rangeAxis . addChangeListener ( this ) ; }  configureDomainAxes ( ) ; configureRangeAxes ( ) ;  this . domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE ; this . domainGridlinePosition = CategoryAnchor . MIDDLE ; this . domainGridlineStroke = DEFAULT_GRIDLINE_STROKE ; this . domainGridlinePaint = DEFAULT_GRIDLINE_PAINT ;  this . rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE ; this . rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE ; this . rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT ;  this . foregroundDomainMarkers = new HashMap ( ) ; this . backgroundDomainMarkers = new HashMap ( ) ; this . foregroundRangeMarkers = new HashMap ( ) ; this . backgroundRangeMarkers = new HashMap ( ) ;  Marker baseline = new ValueMarker ( 0 . 0 , new Color ( 0 . 8f , 0 . 8f , 0 . 8f , 0 . 5f ) , new BasicStroke ( 1 . 0f ) , new Color ( 0 . 85f , 0 . 85f , 0 . 95f , 0 . 5f ) , new BasicStroke ( 1 . 0f ) , 0 . 6f ) ; addRangeMarker ( baseline , Layer . BACKGROUND ) ;  this . anchorValue = 0 . 0 ;  this . rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE ; this . rangeCrosshairValue = 0 . 0 ; this . rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE ; this . rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT ;  this . annotations = new java . util . ArrayList ( ) ;  }  public String getPlotType ( ) { return localizationResources . getString ( \" Category_Plot \" ) ; }  public PlotOrientation getOrientation ( ) { return this . orientation ; }  public void setOrientation ( PlotOrientation orientation ) { if ( orientation = = null ) { throw new IllegalArgumentException ( \" Null ' orientation ' argument . \" ) ; } this . orientation = orientation ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public RectangleInsets getAxisOffset ( ) { return this . axisOffset ; }  public void setAxisOffset ( RectangleInsets offset ) { if ( offset = = null ) { throw new IllegalArgumentException ( \" Null ' offset ' argument . \" ) ; } this . axisOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public CategoryAxis getDomainAxis ( ) { return getDomainAxis ( 0 ) ; }  public CategoryAxis getDomainAxis ( int index ) { CategoryAxis result = null ; if ( index < this . domainAxes . size ( ) ) { result = ( CategoryAxis ) this . domainAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getDomainAxis ( index ) ; } } return result ; }  public void setDomainAxis ( CategoryAxis axis ) { setDomainAxis ( 0 , axis ) ; }  public void setDomainAxis ( int index , CategoryAxis axis ) { setDomainAxis ( index , axis , true ) ; }  public void setDomainAxis ( int index , CategoryAxis axis , boolean notify ) { CategoryAxis existing = ( CategoryAxis ) this . domainAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setDomainAxes ( CategoryAxis [ ] axes ) { for ( int i = 0 ; i < axes . length ; i + + ) { setDomainAxis ( i , axes [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; }  public AxisLocation getDomainAxisLocation ( ) { return getDomainAxisLocation ( 0 ) ; }  public AxisLocation getDomainAxisLocation ( int index ) { AxisLocation result = null ; if ( index < this . domainAxisLocations . size ( ) ) { result = ( AxisLocation ) this . domainAxisLocations . get ( index ) ; } if ( result = = null ) { result = AxisLocation . getOpposite ( getDomainAxisLocation ( 0 ) ) ; } return result ; }  public void setDomainAxisLocation ( AxisLocation location ) { setDomainAxisLocation ( 0 , location , true ) ; }  public void setDomainAxisLocation ( AxisLocation location , boolean notify ) { setDomainAxisLocation ( 0 , location , notify ) ; }  public void setDomainAxisLocation ( int index , AxisLocation location ) { setDomainAxisLocation ( index , location , true ) ; }  public void setDomainAxisLocation ( int index , AxisLocation location , boolean notify ) { if ( index = = 0 & & location = = null ) { throw new IllegalArgumentException ( \" Null ' location ' for index 0 not permitted . \" ) ; } this . domainAxisLocations . set ( index , location ) ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public RectangleEdge getDomainAxisEdge ( ) { return getDomainAxisEdge ( 0 ) ; }  public RectangleEdge getDomainAxisEdge ( int index ) { RectangleEdge result = null ; AxisLocation location = getDomainAxisLocation ( index ) ; if ( location ! = null ) { result = Plot . resolveDomainAxisLocation ( location , this . orientation ) ; } else { result = RectangleEdge . opposite ( getDomainAxisEdge ( 0 ) ) ; } return result ; }  public int getDomainAxisCount ( ) { return this . domainAxes . size ( ) ; }  public void clearDomainAxes ( ) { for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis axis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( axis ! = null ) { axis . removeChangeListener ( this ) ; } } this . domainAxes . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void configureDomainAxes ( ) { for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis axis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( axis ! = null ) { axis . configure ( ) ; } } }  public ValueAxis getRangeAxis ( ) { return getRangeAxis ( 0 ) ; }  public ValueAxis getRangeAxis ( int index ) { ValueAxis result = null ; if ( index < this . rangeAxes . size ( ) ) { result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; } } return result ; }  public void setRangeAxis ( ValueAxis axis ) { setRangeAxis ( 0 , axis ) ; }  public void setRangeAxis ( int index , ValueAxis axis ) { setRangeAxis ( index , axis , true ) ; }  public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setRangeAxes ( ValueAxis [ ] axes ) { for ( int i = 0 ; i < axes . length ; i + + ) { setRangeAxis ( i , axes [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }   public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } return result ; }  public AxisLocation getRangeAxisLocation ( ) { return getRangeAxisLocation ( 0 ) ; }  public AxisLocation getRangeAxisLocation ( int index ) { AxisLocation result = null ; if ( index < this . rangeAxisLocations . size ( ) ) { result = ( AxisLocation ) this . rangeAxisLocations . get ( index ) ; } if ( result = = null ) { result = AxisLocation . getOpposite ( getRangeAxisLocation ( 0 ) ) ; } return result ; }  public void setRangeAxisLocation ( AxisLocation location ) { setRangeAxisLocation ( location , true ) ; }  public void setRangeAxisLocation ( AxisLocation location , boolean notify ) { setRangeAxisLocation ( 0 , location , notify ) ; }  public void setRangeAxisLocation ( int index , AxisLocation location ) { setRangeAxisLocation ( index , location , true ) ; }  public void setRangeAxisLocation ( int index , AxisLocation location , boolean notify ) { if ( index = = 0 & & location = = null ) { throw new IllegalArgumentException ( \" Null ' location ' for index 0 not permitted . \" ) ; } this . rangeAxisLocations . set ( index , location ) ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public RectangleEdge getRangeAxisEdge ( ) { return getRangeAxisEdge ( 0 ) ; }  public RectangleEdge getRangeAxisEdge ( int index ) { AxisLocation location = getRangeAxisLocation ( index ) ; RectangleEdge result = Plot . resolveRangeAxisLocation ( location , this . orientation ) ; if ( result = = null ) { result = RectangleEdge . opposite ( getRangeAxisEdge ( 0 ) ) ; } return result ; }  public int getRangeAxisCount ( ) { return this . rangeAxes . size ( ) ; }  public void clearRangeAxes ( ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis axis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( axis ! = null ) { axis . removeChangeListener ( this ) ; } } this . rangeAxes . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void configureRangeAxes ( ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis axis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( axis ! = null ) { axis . configure ( ) ; } } }  public CategoryDataset getDataset ( ) { return getDataset ( 0 ) ; }  public CategoryDataset getDataset ( int index ) { CategoryDataset result = null ; if ( this . datasets . size ( ) > index ) { result = ( CategoryDataset ) this . datasets . get ( index ) ; } return result ; }  public void setDataset ( CategoryDataset dataset ) { setDataset ( 0 , dataset ) ; }  public void setDataset ( int index , CategoryDataset dataset ) {  CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } this . datasets . set ( index , dataset ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; }  DatasetChangeEvent event = new DatasetChangeEvent ( this , dataset ) ; datasetChanged ( event ) ;  }  public int getDatasetCount ( ) { return this . datasets . size ( ) ; }  public void mapDatasetToDomainAxis ( int index , int axisIndex ) { this . datasetToDomainAxisMap . set ( index , new Integer ( axisIndex ) ) ; datasetChanged ( new DatasetChangeEvent ( this , getDataset ( index ) ) ) ; }  public CategoryAxis getDomainAxisForDataset ( int index ) { CategoryAxis result = getDomainAxis ( ) ; Integer axisIndex = ( Integer ) this . datasetToDomainAxisMap . get ( index ) ; if ( axisIndex ! = null ) { result = getDomainAxis ( axisIndex . intValue ( ) ) ; } return result ; }  public void mapDatasetToRangeAxis ( int index , int axisIndex ) { this . datasetToRangeAxisMap . set ( index , new Integer ( axisIndex ) ) ; datasetChanged ( new DatasetChangeEvent ( this , getDataset ( index ) ) ) ; }  public ValueAxis getRangeAxisForDataset ( int index ) { ValueAxis result = getRangeAxis ( ) ; Integer axisIndex = ( Integer ) this . datasetToRangeAxisMap . get ( index ) ; if ( axisIndex ! = null ) { result = getRangeAxis ( axisIndex . intValue ( ) ) ; } return result ; }  public CategoryItemRenderer getRenderer ( ) { return getRenderer ( 0 ) ; }  public CategoryItemRenderer getRenderer ( int index ) { CategoryItemRenderer result = null ; if ( this . renderers . size ( ) > index ) { result = ( CategoryItemRenderer ) this . renderers . get ( index ) ; } return result ; }  public void setRenderer ( CategoryItemRenderer renderer ) { setRenderer ( 0 , renderer , true ) ; }  public void setRenderer ( CategoryItemRenderer renderer , boolean notify ) { setRenderer ( 0 , renderer , notify ) ; }  public void setRenderer ( int index , CategoryItemRenderer renderer ) { setRenderer ( index , renderer , true ) ; }  public void setRenderer ( int index , CategoryItemRenderer renderer , boolean notify ) {  CategoryItemRenderer existing = ( CategoryItemRenderer ) this . renderers . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; }  this . renderers . set ( index , renderer ) ; if ( renderer ! = null ) { renderer . setPlot ( this ) ; renderer . addChangeListener ( this ) ; }  configureDomainAxes ( ) ; configureRangeAxes ( ) ;  if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setRenderers ( CategoryItemRenderer [ ] renderers ) { for ( int i = 0 ; i < renderers . length ; i + + ) { setRenderer ( i , renderers [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public CategoryItemRenderer getRendererForDataset ( CategoryDataset dataset ) { CategoryItemRenderer result = null ; for ( int i = 0 ; i < this . datasets . size ( ) ; i + + ) { if ( this . datasets . get ( i ) = = dataset ) { result = ( CategoryItemRenderer ) this . renderers . get ( i ) ; break ; } } return result ; }  public int getIndexOf ( CategoryItemRenderer renderer ) { return this . renderers . indexOf ( renderer ) ; }  public DatasetRenderingOrder getDatasetRenderingOrder ( ) { return this . renderingOrder ; }  public void setDatasetRenderingOrder ( DatasetRenderingOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . renderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public SortOrder getColumnRenderingOrder ( ) { return this . columnRenderingOrder ; }  public void setColumnRenderingOrder ( SortOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . columnRenderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public SortOrder getRowRenderingOrder ( ) { return this . rowRenderingOrder ; }  public void setRowRenderingOrder ( SortOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . rowRenderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isDomainGridlinesVisible ( ) { return this . domainGridlinesVisible ; }  public void setDomainGridlinesVisible ( boolean visible ) { if ( this . domainGridlinesVisible ! = visible ) { this . domainGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public CategoryAnchor getDomainGridlinePosition ( ) { return this . domainGridlinePosition ; }  public void setDomainGridlinePosition ( CategoryAnchor position ) { if ( position = = null ) { throw new IllegalArgumentException ( \" Null ' position ' argument . \" ) ; } this . domainGridlinePosition = position ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Stroke getDomainGridlineStroke ( ) { return this . domainGridlineStroke ; }  public void setDomainGridlineStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' not permitted . \" ) ; } this . domainGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getDomainGridlinePaint ( ) { return this . domainGridlinePaint ; }  public void setDomainGridlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . domainGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isRangeGridlinesVisible ( ) { return this . rangeGridlinesVisible ; }  public void setRangeGridlinesVisible ( boolean visible ) { if ( this . rangeGridlinesVisible ! = visible ) { this . rangeGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public Stroke getRangeGridlineStroke ( ) { return this . rangeGridlineStroke ; }  public void setRangeGridlineStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' argument . \" ) ; } this . rangeGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getRangeGridlinePaint ( ) { return this . rangeGridlinePaint ; }  public void setRangeGridlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . rangeGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public LegendItemCollection getFixedLegendItems ( ) { return this . fixedLegendItems ; }  public void setFixedLegendItems ( LegendItemCollection items ) { this . fixedLegendItems = items ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public LegendItemCollection getLegendItems ( ) { LegendItemCollection result = this . fixedLegendItems ; if ( result = = null ) { result = new LegendItemCollection ( ) ; int count = this . datasets . size ( ) ; for ( int datasetIndex = 0 ; datasetIndex < count ; datasetIndex + + ) { CategoryDataset dataset = getDataset ( datasetIndex ) ; if ( dataset ! = null ) { CategoryItemRenderer renderer = getRenderer ( datasetIndex ) ; if ( renderer ! = null ) { int seriesCount = dataset . getRowCount ( ) ; for ( int i = 0 ; i < seriesCount ; i + + ) { LegendItem item = renderer . getLegendItem ( datasetIndex , i ) ; if ( item ! = null ) { result . add ( item ) ; } } } } } } return result ; }  public void handleClick ( int x , int y , PlotRenderingInfo info ) {  Rectangle2D dataArea = info . getDataArea ( ) ; if ( dataArea . contains ( x , y ) ) { double java2D = 0 . 0 ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { java2D = x ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { java2D = y ; } RectangleEdge edge = Plot . resolveRangeAxisLocation ( getRangeAxisLocation ( ) , this . orientation ) ; double value = getRangeAxis ( ) . java2DToValue ( java2D , info . getDataArea ( ) , edge ) ; setAnchorValue ( value ) ; setRangeCrosshairValue ( value ) ; }  }  public void zoom ( double percent ) {  if ( percent > 0 . 0 ) { double range = getRangeAxis ( ) . getRange ( ) . getLength ( ) ; double scaledRange = range * percent ; getRangeAxis ( ) . setRange ( this . anchorValue - scaledRange / 2 . 0 , this . anchorValue + scaledRange / 2 . 0 ) ; } else { getRangeAxis ( ) . setAutoRange ( true ) ; }  }  public void datasetChanged ( DatasetChangeEvent event ) {  int count = this . rangeAxes . size ( ) ; for ( int axisIndex = 0 ; axisIndex < count ; axisIndex + + ) { ValueAxis yAxis = getRangeAxis ( axisIndex ) ; if ( yAxis ! = null ) { yAxis . configure ( ) ; } } if ( getParent ( ) ! = null ) { getParent ( ) . datasetChanged ( event ) ; } else { PlotChangeEvent e = new PlotChangeEvent ( this ) ; e . setType ( ChartChangeEventType . DATASET_UPDATED ) ; notifyListeners ( e ) ; }  }  public void rendererChanged ( RendererChangeEvent event ) { Plot parent = getParent ( ) ; if ( parent ! = null ) { if ( parent instanceof RendererChangeListener ) { RendererChangeListener rcl = ( RendererChangeListener ) parent ; rcl . rendererChanged ( event ) ; } else { throw new RuntimeException ( \" The renderer has changed and I don ' t know what to do ! \" ) ; } } else { configureRangeAxes ( ) ; PlotChangeEvent e = new PlotChangeEvent ( this ) ; notifyListeners ( e ) ; } }  public void addDomainMarker ( CategoryMarker marker ) { addDomainMarker ( marker , Layer . FOREGROUND ) ; }  public void addDomainMarker ( CategoryMarker marker , Layer layer ) { addDomainMarker ( 0 , marker , layer ) ; }  public void addDomainMarker ( int index , CategoryMarker marker , Layer layer ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' not permitted . \" ) ; } if ( layer = = null ) { throw new IllegalArgumentException ( \" Null ' layer ' not permitted . \" ) ; } Collection markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( Collection ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . foregroundDomainMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } else if ( layer = = Layer . BACKGROUND ) { markers = ( Collection ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . backgroundDomainMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } marker . addChangeListener ( this ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void clearDomainMarkers ( ) { if ( this . backgroundDomainMarkers ! = null ) { Set keys = this . backgroundDomainMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearDomainMarkers ( key . intValue ( ) ) ; } this . backgroundDomainMarkers . clear ( ) ; } if ( this . foregroundDomainMarkers ! = null ) { Set keys = this . foregroundDomainMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearDomainMarkers ( key . intValue ( ) ) ; } this . foregroundDomainMarkers . clear ( ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Collection getDomainMarkers ( Layer layer ) { return getDomainMarkers ( 0 , layer ) ; }  public Collection getDomainMarkers ( int index , Layer layer ) { Collection result = null ; Integer key = new Integer ( index ) ; if ( layer = = Layer . FOREGROUND ) { result = ( Collection ) this . foregroundDomainMarkers . get ( key ) ; } else if ( layer = = Layer . BACKGROUND ) { result = ( Collection ) this . backgroundDomainMarkers . get ( key ) ; } if ( result ! = null ) { result = Collections . unmodifiableCollection ( result ) ; } return result ; }  public void clearDomainMarkers ( int index ) { Integer key = new Integer ( index ) ; if ( this . backgroundDomainMarkers ! = null ) { Collection markers = ( Collection ) this . backgroundDomainMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } if ( this . foregroundDomainMarkers ! = null ) { Collection markers = ( Collection ) this . foregroundDomainMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void addRangeMarker ( Marker marker ) { addRangeMarker ( marker , Layer . FOREGROUND ) ; }  public void addRangeMarker ( Marker marker , Layer layer ) { addRangeMarker ( 0 , marker , layer ) ; }  public void addRangeMarker ( int index , Marker marker , Layer layer ) { Collection markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( Collection ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . foregroundRangeMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } else if ( layer = = Layer . BACKGROUND ) { markers = ( Collection ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . backgroundRangeMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } marker . addChangeListener ( this ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void clearRangeMarkers ( ) { if ( this . backgroundRangeMarkers ! = null ) { Set keys = this . backgroundRangeMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearRangeMarkers ( key . intValue ( ) ) ; } this . backgroundRangeMarkers . clear ( ) ; } if ( this . foregroundRangeMarkers ! = null ) { Set keys = this . foregroundRangeMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearRangeMarkers ( key . intValue ( ) ) ; } this . foregroundRangeMarkers . clear ( ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Collection getRangeMarkers ( Layer layer ) { return getRangeMarkers ( 0 , layer ) ; }  public Collection getRangeMarkers ( int index , Layer layer ) { Collection result = null ; Integer key = new Integer ( index ) ; if ( layer = = Layer . FOREGROUND ) { result = ( Collection ) this . foregroundRangeMarkers . get ( key ) ; } else if ( layer = = Layer . BACKGROUND ) { result = ( Collection ) this . backgroundRangeMarkers . get ( key ) ; } if ( result ! = null ) { result = Collections . unmodifiableCollection ( result ) ; } return result ; }  public void clearRangeMarkers ( int index ) { Integer key = new Integer ( index ) ; if ( this . backgroundRangeMarkers ! = null ) { Collection markers = ( Collection ) this . backgroundRangeMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } if ( this . foregroundRangeMarkers ! = null ) { Collection markers = ( Collection ) this . foregroundRangeMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isRangeCrosshairVisible ( ) { return this . rangeCrosshairVisible ; }  public void setRangeCrosshairVisible ( boolean flag ) { if ( this . rangeCrosshairVisible ! = flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public boolean isRangeCrosshairLockedOnData ( ) { return this . rangeCrosshairLockedOnData ; }  public void setRangeCrosshairLockedOnData ( boolean flag ) {  if ( this . rangeCrosshairLockedOnData ! = flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  }  public double getRangeCrosshairValue ( ) { return this . rangeCrosshairValue ; }  public void setRangeCrosshairValue ( double value ) { setRangeCrosshairValue ( value , true ) ; }  public void setRangeCrosshairValue ( double value , boolean notify ) { this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible ( ) & & notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public Stroke getRangeCrosshairStroke ( ) { return this . rangeCrosshairStroke ; }  public void setRangeCrosshairStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' argument . \" ) ; } this . rangeCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getRangeCrosshairPaint ( ) { return this . rangeCrosshairPaint ; }  public void setRangeCrosshairPaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . rangeCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public List getAnnotations ( ) { return this . annotations ; }  public void addAnnotation ( CategoryAnnotation annotation ) { if ( annotation = = null ) { throw new IllegalArgumentException ( \" Null ' annotation ' argument . \" ) ; } this . annotations . add ( annotation ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean removeAnnotation ( CategoryAnnotation annotation ) { if ( annotation = = null ) { throw new IllegalArgumentException ( \" Null ' annotation ' argument . \" ) ; } boolean removed = this . annotations . remove ( annotation ) ; if ( removed ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } return removed ; }  public void clearAnnotations ( ) { this . annotations . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  protected AxisSpace calculateDomainAxisSpace ( Graphics2D g2 , Rectangle2D plotArea , AxisSpace space ) {  if ( space = = null ) { space = new AxisSpace ( ) ; }  if ( this . fixedDomainAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } } else { RectangleEdge domainEdge = Plot . resolveDomainAxisLocation ( getDomainAxisLocation ( ) , this . orientation ) ; if ( this . drawSharedDomainAxis ) { space = getDomainAxis ( ) . reserveSpace ( g2 , this , plotArea , domainEdge , space ) ; }  for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { Axis xAxis = ( Axis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { RectangleEdge edge = getDomainAxisEdge ( i ) ; space = xAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } }  return space ;  }  protected AxisSpace calculateRangeAxisSpace ( Graphics2D g2 , Rectangle2D plotArea , AxisSpace space ) {  if ( space = = null ) { space = new AxisSpace ( ) ; }  if ( this . fixedRangeAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; space . ensureAtLeast ( this . fixedRangeAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; space . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { Axis yAxis = ( Axis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { RectangleEdge edge = getRangeAxisEdge ( i ) ; space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;  }  protected AxisSpace calculateAxisSpace ( Graphics2D g2 , Rectangle2D plotArea ) { AxisSpace space = new AxisSpace ( ) ; space = calculateRangeAxisSpace ( g2 , plotArea , space ) ; space = calculateDomainAxisSpace ( g2 , plotArea , space ) ; return space ; }  public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) {  boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }  if ( state = = null ) { state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;  RectangleInsets insets = getInsets ( ) ; insets . trim ( area ) ;  AxisSpace space = calculateAxisSpace ( g2 , area ) ; Rectangle2D dataArea = space . shrink ( area , null ) ; this . axisOffset . trim ( dataArea ) ;  state . setDataArea ( dataArea ) ;  if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( g2 , this , dataArea ) ; } else { drawBackground ( g2 , dataArea ) ; }  Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( dataArea ) ;  drawDomainGridlines ( g2 , dataArea ) ;  AxisState rangeAxisState = ( AxisState ) axisStateMap . get ( getRangeAxis ( ) ) ; if ( rangeAxisState = = null ) { if ( parentState ! = null ) { rangeAxisState = ( AxisState ) parentState . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( rangeAxisState ! = null ) { drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; }  for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawDomainMarkers ( g2 , dataArea , i , Layer . BACKGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( g2 , dataArea , i , Layer . BACKGROUND ) ; }  boolean foundData = false ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } }  for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawDomainMarkers ( g2 , dataArea , i , Layer . FOREGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( g2 , dataArea , i , Layer . FOREGROUND ) ; }  drawAnnotations ( g2 , dataArea , state ) ;  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ;  if ( ! foundData ) { drawNoDataMessage ( g2 , dataArea ) ; }  if ( isRangeCrosshairVisible ( ) ) { drawRangeCrosshair ( g2 , dataArea , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; }  if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( g2 , this , dataArea ) ; } else { drawOutline ( g2 , dataArea ) ; }  }  public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }  protected Map drawAxes ( Graphics2D g2 , Rectangle2D plotArea , Rectangle2D dataArea , PlotRenderingInfo plotState ) {  AxisCollection axisCollection = new AxisCollection ( ) ;  for ( int index = 0 ; index < this . domainAxes . size ( ) ; index + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; if ( xAxis ! = null ) { axisCollection . add ( xAxis , getDomainAxisEdge ( index ) ) ; } }  for ( int index = 0 ; index < this . rangeAxes . size ( ) ; index + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( yAxis ! = null ) { axisCollection . add ( yAxis , getRangeAxisEdge ( index ) ) ; } }  Map axisStateMap = new HashMap ( ) ;  double cursor = dataArea . getMinY ( ) - this . axisOffset . calculateTopOutset ( dataArea . getHeight ( ) ) ; Iterator iterator = axisCollection . getAxesAtTop ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . TOP , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMaxY ( ) + this . axisOffset . calculateBottomOutset ( dataArea . getHeight ( ) ) ; iterator = axisCollection . getAxesAtBottom ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . BOTTOM , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMinX ( ) - this . axisOffset . calculateLeftOutset ( dataArea . getWidth ( ) ) ; iterator = axisCollection . getAxesAtLeft ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . LEFT , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMaxX ( ) + this . axisOffset . calculateRightOutset ( dataArea . getWidth ( ) ) ; iterator = axisCollection . getAxesAtRight ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . RIGHT , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  return axisStateMap ;  }  public boolean render ( Graphics2D g2 , Rectangle2D dataArea , int index , PlotRenderingInfo info ) {  boolean foundData = false ; CategoryDataset currentDataset = getDataset ( index ) ; CategoryItemRenderer renderer = getRenderer ( index ) ; CategoryAxis domainAxis = getDomainAxisForDataset ( index ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( index ) ; boolean hasData = ! DatasetUtilities . isEmptyOrNull ( currentDataset ) ; if ( hasData & & renderer ! = null ) {  foundData = true ; CategoryItemRendererState state = renderer . initialise ( g2 , dataArea , this , index , info ) ; int columnCount = currentDataset . getColumnCount ( ) ; int rowCount = currentDataset . getRowCount ( ) ; int passCount = renderer . getPassCount ( ) ; for ( int pass = 0 ; pass < passCount ; pass + + ) { if ( this . columnRenderingOrder = = SortOrder . ASCENDING ) { for ( int column = 0 ; column < columnCount ; column + + ) { if ( this . rowRenderingOrder = = SortOrder . ASCENDING ) { for ( int row = 0 ; row < rowCount ; row + + ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } else { for ( int row = rowCount - 1 ; row > = 0 ; row - - ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } } } else { for ( int column = columnCount - 1 ; column > = 0 ; column - - ) { if ( this . rowRenderingOrder = = SortOrder . ASCENDING ) { for ( int row = 0 ; row < rowCount ; row + + ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } else { for ( int row = rowCount - 1 ; row > = 0 ; row - - ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } } } } } return foundData ;  }  protected void drawDomainGridlines ( Graphics2D g2 , Rectangle2D dataArea ) {  if ( isDomainGridlinesVisible ( ) ) { CategoryAnchor anchor = getDomainGridlinePosition ( ) ; RectangleEdge domainAxisEdge = getDomainAxisEdge ( ) ; Stroke gridStroke = getDomainGridlineStroke ( ) ; Paint gridPaint = getDomainGridlinePaint ( ) ; if ( ( gridStroke ! = null ) & & ( gridPaint ! = null ) ) { CategoryDataset data = getDataset ( ) ; if ( data ! = null ) { CategoryAxis axis = getDomainAxis ( ) ; if ( axis ! = null ) { int columnCount = data . getColumnCount ( ) ; for ( int c = 0 ; c < columnCount ; c + + ) { double xx = axis . getCategoryJava2DCoordinate ( anchor , c , columnCount , dataArea , domainAxisEdge ) ; CategoryItemRenderer renderer1 = getRenderer ( ) ; if ( renderer1 ! = null ) { renderer1 . drawDomainGridline ( g2 , this , dataArea , xx ) ; } } } } } } }  protected void drawRangeGridlines ( Graphics2D g2 , Rectangle2D dataArea , List ticks ) { if ( isRangeGridlinesVisible ( ) ) { Stroke gridStroke = getRangeGridlineStroke ( ) ; Paint gridPaint = getRangeGridlinePaint ( ) ; if ( ( gridStroke ! = null ) & & ( gridPaint ! = null ) ) { ValueAxis axis = getRangeAxis ( ) ; if ( axis ! = null ) { Iterator iterator = ticks . iterator ( ) ; while ( iterator . hasNext ( ) ) { ValueTick tick = ( ValueTick ) iterator . next ( ) ; CategoryItemRenderer renderer1 = getRenderer ( ) ; if ( renderer1 ! = null ) { renderer1 . drawRangeGridline ( g2 , this , getRangeAxis ( ) , dataArea , tick . getValue ( ) ) ; } } } } } }  protected void drawAnnotations ( Graphics2D g2 , Rectangle2D dataArea , PlotRenderingInfo info ) {  Iterator iterator = getAnnotations ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryAnnotation annotation = ( CategoryAnnotation ) iterator . next ( ) ; annotation . draw ( g2 , this , dataArea , getDomainAxis ( ) , getRangeAxis ( ) , 0 , info ) ; }  }  protected void drawDomainMarkers ( Graphics2D g2 , Rectangle2D dataArea , int index , Layer layer ) {  CategoryItemRenderer r = getRenderer ( index ) ; if ( r = = null ) { return ; }  Collection markers = getDomainMarkers ( index , layer ) ; CategoryAxis axis = getDomainAxisForDataset ( index ) ; if ( markers ! = null & & axis ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryMarker marker = ( CategoryMarker ) iterator . next ( ) ; r . drawDomainMarker ( g2 , this , axis , marker , dataArea ) ; } }  }  protected void drawRangeMarkers ( Graphics2D g2 , Rectangle2D dataArea , int index , Layer layer ) {  CategoryItemRenderer r = getRenderer ( index ) ; if ( r = = null ) { return ; }  Collection markers = getRangeMarkers ( index , layer ) ; ValueAxis axis = getRangeAxisForDataset ( index ) ; if ( markers ! = null & & axis ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . drawRangeMarker ( g2 , this , axis , marker , dataArea ) ; } }  }  protected void drawRangeLine ( Graphics2D g2 , Rectangle2D dataArea , double value , Stroke stroke , Paint paint ) {  double java2D = getRangeAxis ( ) . valueToJava2D ( value , dataArea , getRangeAxisEdge ( ) ) ; Line2D line = null ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( java2D , dataArea . getMinY ( ) , java2D , dataArea . getMaxY ( ) ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , java2D , dataArea . getMaxX ( ) , java2D ) ; } g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ;  }  protected void drawRangeCrosshair ( Graphics2D g2 , Rectangle2D dataArea , PlotOrientation orientation , double value , ValueAxis axis , Stroke stroke , Paint paint ) {  if ( ! axis . getRange ( ) . contains ( value ) ) { return ; } Line2D line = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { double xx = axis . valueToJava2D ( value , dataArea , RectangleEdge . BOTTOM ) ; line = new Line2D . Double ( xx , dataArea . getMinY ( ) , xx , dataArea . getMaxY ( ) ) ; } else { double yy = axis . valueToJava2D ( value , dataArea , RectangleEdge . LEFT ) ; line = new Line2D . Double ( dataArea . getMinX ( ) , yy , dataArea . getMaxX ( ) , yy ) ; } g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ;  }  public Range getDataRange ( ValueAxis axis ) {  Range result = null ; List mappedDatasets = new ArrayList ( ) ;  int rangeIndex = this . rangeAxes . indexOf ( axis ) ; if ( rangeIndex > = 0 ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( rangeIndex ) ) ; } else if ( axis = = getRangeAxis ( ) ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( 0 ) ) ; }  Iterator iterator = mappedDatasets . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryDataset d = ( CategoryDataset ) iterator . next ( ) ; CategoryItemRenderer r = getRendererForDataset ( d ) ; if ( r ! = null ) { result = Range . combine ( result , r . findRangeBounds ( d ) ) ; } } return result ;  }  private List datasetsMappedToDomainAxis ( int axisIndex ) { List result = new ArrayList ( ) ; for ( int datasetIndex = 0 ; datasetIndex < this . datasets . size ( ) ; datasetIndex + + ) { Object dataset = this . datasets . get ( datasetIndex ) ; if ( dataset ! = null ) { Integer m = ( Integer ) this . datasetToDomainAxisMap . get ( datasetIndex ) ; if ( m = = null ) { / / a dataset with no mapping is assigned to if ( axisIndex = = 0 ) { result . add ( dataset ) ; } } else { if ( m . intValue ( ) = = axisIndex ) { result . add ( dataset ) ; } } } } return result ; }  private List datasetsMappedToRangeAxis ( int index ) { List result = new ArrayList ( ) ; for ( int i = 0 ; i < this . datasets . size ( ) ; i + + ) { Object dataset = this . datasets . get ( i ) ; if ( dataset ! = null ) { Integer m = ( Integer ) this . datasetToRangeAxisMap . get ( i ) ; if ( m = = null ) { / / a dataset with no mapping is assigned to if ( index = = 0 ) { result . add ( dataset ) ; } } else { if ( m . intValue ( ) = = index ) { result . add ( dataset ) ; } } } } return result ; }  public int getWeight ( ) { return this . weight ; }  public void setWeight ( int weight ) { this . weight = weight ; }  public AxisSpace getFixedDomainAxisSpace ( ) { return this . fixedDomainAxisSpace ; }  public void setFixedDomainAxisSpace ( AxisSpace space ) { this . fixedDomainAxisSpace = space ; }  public AxisSpace getFixedRangeAxisSpace ( ) { return this . fixedRangeAxisSpace ; }  public void setFixedRangeAxisSpace ( AxisSpace space ) { this . fixedRangeAxisSpace = space ; }  public List getCategories ( ) { List result = null ; if ( getDataset ( ) ! = null ) { result = Collections . unmodifiableList ( getDataset ( ) . getColumnKeys ( ) ) ; } return result ; }  public List getCategoriesForAxis ( CategoryAxis axis ) { List result = new ArrayList ( ) ; int axisIndex = this . domainAxes . indexOf ( axis ) ; List datasets = datasetsMappedToDomainAxis ( axisIndex ) ; Iterator iterator = datasets . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryDataset dataset = ( CategoryDataset ) iterator . next ( ) ; for ( int i = 0 ; i < dataset . getColumnCount ( ) ; i + + ) { Comparable category = dataset . getColumnKey ( i ) ; if ( ! result . contains ( category ) ) { result . add ( category ) ; } } } return result ; }  public boolean getDrawSharedDomainAxis ( ) { return this . drawSharedDomainAxis ; }  public void setDrawSharedDomainAxis ( boolean draw ) { this . drawSharedDomainAxis = draw ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isDomainZoomable ( ) { return false ; }  public boolean isRangeZoomable ( ) { return true ; }  public void zoomDomainAxes ( double factor , PlotRenderingInfo state , Point2D source ) { }  public void zoomDomainAxes ( double lowerPercent , double upperPercent , PlotRenderingInfo state , Point2D source ) { }  public void zoomDomainAxes ( double factor , PlotRenderingInfo info , Point2D source , boolean useAnchor ) { }  public void zoomRangeAxes ( double factor , PlotRenderingInfo state , Point2D source ) { zoomRangeAxes ( factor , state , source , false ) ; }  public void zoomRangeAxes ( double factor , PlotRenderingInfo info , Point2D source , boolean useAnchor ) {  for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis rangeAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( rangeAxis ! = null ) { if ( useAnchor ) { double sourceY = source . getY ( ) ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { sourceY = source . getX ( ) ; } double anchorY = rangeAxis . java2DToValue ( sourceY , info . getDataArea ( ) , getRangeAxisEdge ( ) ) ; rangeAxis . resizeRange ( factor , anchorY ) ; } else { rangeAxis . resizeRange ( factor ) ; } } } }  public void zoomRangeAxes ( double lowerPercent , double upperPercent , PlotRenderingInfo state , Point2D source ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis rangeAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( rangeAxis ! = null ) { rangeAxis . zoomRange ( lowerPercent , upperPercent ) ; } } }  public double getAnchorValue ( ) { return this . anchorValue ; }  public void setAnchorValue ( double value ) { setAnchorValue ( value , true ) ; }  public void setAnchorValue ( double value , boolean notify ) { this . anchorValue = value ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public boolean equals ( Object obj ) {  if ( obj = = this ) { return true ; } if ( ! ( obj instanceof CategoryPlot ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; }  CategoryPlot that = ( CategoryPlot ) obj ;  if ( this . orientation ! = that . orientation ) { return false ; } if ( ! ObjectUtilities . equal ( this . axisOffset , that . axisOffset ) ) { return false ; } if ( ! this . domainAxes . equals ( that . domainAxes ) ) { return false ; } if ( ! this . domainAxisLocations . equals ( that . domainAxisLocations ) ) { return false ; } if ( this . drawSharedDomainAxis ! = that . drawSharedDomainAxis ) { return false ; } if ( ! this . rangeAxes . equals ( that . rangeAxes ) ) { return false ; } if ( ! this . rangeAxisLocations . equals ( that . rangeAxisLocations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToDomainAxisMap , that . datasetToDomainAxisMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToRangeAxisMap , that . datasetToRangeAxisMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . renderingOrder ! = that . renderingOrder ) { return false ; } if ( this . columnRenderingOrder ! = that . columnRenderingOrder ) { return false ; } if ( this . rowRenderingOrder ! = that . rowRenderingOrder ) { return false ; } if ( this . domainGridlinesVisible ! = that . domainGridlinesVisible ) { return false ; } if ( this . domainGridlinePosition ! = that . domainGridlinePosition ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainGridlineStroke , that . domainGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainGridlinePaint , that . domainGridlinePaint ) ) { return false ; } if ( this . rangeGridlinesVisible ! = that . rangeGridlinesVisible ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeGridlineStroke , that . rangeGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeGridlinePaint , that . rangeGridlinePaint ) ) { return false ; } if ( this . anchorValue ! = that . anchorValue ) { return false ; } if ( this . rangeCrosshairVisible ! = that . rangeCrosshairVisible ) { return false ; } if ( this . rangeCrosshairValue ! = that . rangeCrosshairValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeCrosshairStroke , that . rangeCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeCrosshairPaint , that . rangeCrosshairPaint ) ) { return false ; } if ( this . rangeCrosshairLockedOnData ! = that . rangeCrosshairLockedOnData ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight ! = that . weight ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedDomainAxisSpace , that . fixedDomainAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedRangeAxisSpace , that . fixedRangeAxisSpace ) ) { return false ; }  return true ;  }  public Object clone ( ) throws CloneNotSupportedException {  CategoryPlot clone = ( CategoryPlot ) super . clone ( ) ;  clone . domainAxes = new ObjectList ( ) ; for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { CategoryAxis clonedAxis = ( CategoryAxis ) xAxis . clone ( ) ; clone . setDomainAxis ( i , clonedAxis ) ; } } clone . domainAxisLocations = ( ObjectList ) this . domainAxisLocations . clone ( ) ;  clone . rangeAxes = new ObjectList ( ) ; for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { ValueAxis clonedAxis = ( ValueAxis ) yAxis . clone ( ) ; clone . setRangeAxis ( i , clonedAxis ) ; } } clone . rangeAxisLocations = ( ObjectList ) this . rangeAxisLocations . clone ( ) ;  clone . datasets = ( ObjectList ) this . datasets . clone ( ) ; for ( int i = 0 ; i < clone . datasets . size ( ) ; i + + ) { CategoryDataset dataset = clone . getDataset ( i ) ; if ( dataset ! = null ) { dataset . addChangeListener ( clone ) ; } } clone . datasetToDomainAxisMap = ( ObjectList ) this . datasetToDomainAxisMap . clone ( ) ; clone . datasetToRangeAxisMap = ( ObjectList ) this . datasetToRangeAxisMap . clone ( ) ; clone . renderers = ( ObjectList ) this . renderers . clone ( ) ; if ( this . fixedDomainAxisSpace ! = null ) { clone . fixedDomainAxisSpace = ( AxisSpace ) ObjectUtilities . clone ( this . fixedDomainAxisSpace ) ; } if ( this . fixedRangeAxisSpace ! = null ) { clone . fixedRangeAxisSpace = ( AxisSpace ) ObjectUtilities . clone ( this . fixedRangeAxisSpace ) ; }  return clone ;  }  private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; SerialUtilities . writeStroke ( this . domainGridlineStroke , stream ) ; SerialUtilities . writePaint ( this . domainGridlinePaint , stream ) ; SerialUtilities . writeStroke ( this . rangeGridlineStroke , stream ) ; SerialUtilities . writePaint ( this . rangeGridlinePaint , stream ) ; SerialUtilities . writeStroke ( this . rangeCrosshairStroke , stream ) ; SerialUtilities . writePaint ( this . rangeCrosshairPaint , stream ) ; }  private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException {  stream . defaultReadObject ( ) ; this . domainGridlineStroke = SerialUtilities . readStroke ( stream ) ; this . domainGridlinePaint = SerialUtilities . readPaint ( stream ) ; this . rangeGridlineStroke = SerialUtilities . readStroke ( stream ) ; this . rangeGridlinePaint = SerialUtilities . readPaint ( stream ) ; this . rangeCrosshairStroke = SerialUtilities . readStroke ( stream ) ; this . rangeCrosshairPaint = SerialUtilities . readPaint ( stream ) ;  for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { xAxis . setPlot ( this ) ; xAxis . addChangeListener ( this ) ; } } for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { yAxis . setPlot ( this ) ; yAxis . addChangeListener ( this ) ; } } int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { Dataset dataset = ( Dataset ) this . datasets . get ( i ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } } int rendererCount = this . renderers . size ( ) ; for ( int i = 0 ; i < rendererCount ; i + + ) { CategoryItemRenderer renderer = ( CategoryItemRenderer ) this . renderers . get ( i ) ; if ( renderer ! = null ) { renderer . addChangeListener ( this ) ; } }  }  }", "fixed_code": " package org . jfree . chart . plot ;  import java . awt . AlphaComposite ; import java . awt . BasicStroke ; import java . awt . Color ; import java . awt . Composite ; import java . awt . Font ; import java . awt . Graphics2D ; import java . awt . Paint ; import java . awt . Shape ; import java . awt . Stroke ; import java . awt . geom . Line2D ; import java . awt . geom . Point2D ; import java . awt . geom . Rectangle2D ; import java . io . IOException ; import java . io . ObjectInputStream ; import java . io . ObjectOutputStream ; import java . io . Serializable ; import java . util . ArrayList ; import java . util . Collection ; import java . util . Collections ; import java . util . HashMap ; import java . util . Iterator ; import java . util . List ; import java . util . Map ; import java . util . ResourceBundle ; import java . util . Set ;  import org . jfree . chart . LegendItem ; import org . jfree . chart . LegendItemCollection ; import org . jfree . chart . annotations . CategoryAnnotation ; import org . jfree . chart . axis . Axis ; import org . jfree . chart . axis . AxisCollection ; import org . jfree . chart . axis . AxisLocation ; import org . jfree . chart . axis . AxisSpace ; import org . jfree . chart . axis . AxisState ; import org . jfree . chart . axis . CategoryAnchor ; import org . jfree . chart . axis . CategoryAxis ; import org . jfree . chart . axis . ValueAxis ; import org . jfree . chart . axis . ValueTick ; import org . jfree . chart . event . ChartChangeEventType ; import org . jfree . chart . event . PlotChangeEvent ; import org . jfree . chart . event . RendererChangeEvent ; import org . jfree . chart . event . RendererChangeListener ; import org . jfree . chart . renderer . category . CategoryItemRenderer ; import org . jfree . chart . renderer . category . CategoryItemRendererState ; import org . jfree . chart . util . Layer ; import org . jfree . chart . util . ObjectList ; import org . jfree . chart . util . ObjectUtilities ; import org . jfree . chart . util . PaintUtilities ; import org . jfree . chart . util . PublicCloneable ; import org . jfree . chart . util . RectangleEdge ; import org . jfree . chart . util . RectangleInsets ; import org . jfree . chart . util . SerialUtilities ; import org . jfree . chart . util . SortOrder ; import org . jfree . data . Range ; import org . jfree . data . category . CategoryDataset ; import org . jfree . data . general . Dataset ; import org . jfree . data . general . DatasetChangeEvent ; import org . jfree . data . general . DatasetUtilities ;  public class CategoryPlot extends Plot implements ValueAxisPlot , Zoomable , RendererChangeListener , Cloneable , PublicCloneable , Serializable {  private static final long serialVersionUID = - 3537691700434728188L ;  public static final boolean DEFAULT_DOMAIN_GRIDLINES_VISIBLE = false ;  public static final boolean DEFAULT_RANGE_GRIDLINES_VISIBLE = true ;  public static final Stroke DEFAULT_GRIDLINE_STROKE = new BasicStroke ( 0 . 5f , BasicStroke . CAP_BUTT , BasicStroke . JOIN_BEVEL , 0 . 0f , new float [ ] { 2 . 0f , 2 . 0f } , 0 . 0f ) ;  public static final Paint DEFAULT_GRIDLINE_PAINT = Color . WHITE ;  public static final Font DEFAULT_VALUE_LABEL_FONT = new Font ( \" SansSerif \" , Font . PLAIN , 10 ) ;  public static final boolean DEFAULT_CROSSHAIR_VISIBLE = false ;  public static final Stroke DEFAULT_CROSSHAIR_STROKE = DEFAULT_GRIDLINE_STROKE ;  public static final Paint DEFAULT_CROSSHAIR_PAINT = Color . blue ;  protected static ResourceBundle localizationResources = ResourceBundle . getBundle ( \" org . jfree . chart . plot . LocalizationBundle \" ) ;  private PlotOrientation orientation ;  private RectangleInsets axisOffset ;  private ObjectList domainAxes ;  private ObjectList domainAxisLocations ;  private boolean drawSharedDomainAxis ;  private ObjectList rangeAxes ;  private ObjectList rangeAxisLocations ;  private ObjectList datasets ;  private ObjectList datasetToDomainAxisMap ;  private ObjectList datasetToRangeAxisMap ;  private ObjectList renderers ;  private DatasetRenderingOrder renderingOrder = DatasetRenderingOrder . REVERSE ;  private SortOrder columnRenderingOrder = SortOrder . ASCENDING ;  private SortOrder rowRenderingOrder = SortOrder . ASCENDING ;  private boolean domainGridlinesVisible ;  private CategoryAnchor domainGridlinePosition ;  private transient Stroke domainGridlineStroke ;  private transient Paint domainGridlinePaint ;  private boolean rangeGridlinesVisible ;  private transient Stroke rangeGridlineStroke ;  private transient Paint rangeGridlinePaint ;  private double anchorValue ;  private boolean rangeCrosshairVisible ;  private double rangeCrosshairValue ;  private transient Stroke rangeCrosshairStroke ;  private transient Paint rangeCrosshairPaint ;  private boolean rangeCrosshairLockedOnData = true ;  private Map foregroundDomainMarkers ;  private Map backgroundDomainMarkers ;  private Map foregroundRangeMarkers ;  private Map backgroundRangeMarkers ;  private List annotations ;  private int weight ;  private AxisSpace fixedDomainAxisSpace ;  private AxisSpace fixedRangeAxisSpace ;  private LegendItemCollection fixedLegendItems ;  public CategoryPlot ( ) { this ( null , null , null , null ) ; }  public CategoryPlot ( CategoryDataset dataset , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryItemRenderer renderer ) {  super ( ) ;  this . orientation = PlotOrientation . VERTICAL ;  this . domainAxes = new ObjectList ( ) ; this . domainAxisLocations = new ObjectList ( ) ; this . rangeAxes = new ObjectList ( ) ; this . rangeAxisLocations = new ObjectList ( ) ;  this . datasetToDomainAxisMap = new ObjectList ( ) ; this . datasetToRangeAxisMap = new ObjectList ( ) ;  this . renderers = new ObjectList ( ) ;  this . datasets = new ObjectList ( ) ; this . datasets . set ( 0 , dataset ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; }  this . axisOffset = new RectangleInsets ( 4 . 0 , 4 . 0 , 4 . 0 , 4 . 0 ) ;  setDomainAxisLocation ( AxisLocation . BOTTOM_OR_LEFT , false ) ; setRangeAxisLocation ( AxisLocation . TOP_OR_LEFT , false ) ;  this . renderers . set ( 0 , renderer ) ; if ( renderer ! = null ) { renderer . setPlot ( this ) ; renderer . addChangeListener ( this ) ; }  this . domainAxes . set ( 0 , domainAxis ) ; this . mapDatasetToDomainAxis ( 0 , 0 ) ; if ( domainAxis ! = null ) { domainAxis . setPlot ( this ) ; domainAxis . addChangeListener ( this ) ; } this . drawSharedDomainAxis = false ;  this . rangeAxes . set ( 0 , rangeAxis ) ; this . mapDatasetToRangeAxis ( 0 , 0 ) ; if ( rangeAxis ! = null ) { rangeAxis . setPlot ( this ) ; rangeAxis . addChangeListener ( this ) ; }  configureDomainAxes ( ) ; configureRangeAxes ( ) ;  this . domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE ; this . domainGridlinePosition = CategoryAnchor . MIDDLE ; this . domainGridlineStroke = DEFAULT_GRIDLINE_STROKE ; this . domainGridlinePaint = DEFAULT_GRIDLINE_PAINT ;  this . rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE ; this . rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE ; this . rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT ;  this . foregroundDomainMarkers = new HashMap ( ) ; this . backgroundDomainMarkers = new HashMap ( ) ; this . foregroundRangeMarkers = new HashMap ( ) ; this . backgroundRangeMarkers = new HashMap ( ) ;  Marker baseline = new ValueMarker ( 0 . 0 , new Color ( 0 . 8f , 0 . 8f , 0 . 8f , 0 . 5f ) , new BasicStroke ( 1 . 0f ) , new Color ( 0 . 85f , 0 . 85f , 0 . 95f , 0 . 5f ) , new BasicStroke ( 1 . 0f ) , 0 . 6f ) ; addRangeMarker ( baseline , Layer . BACKGROUND ) ;  this . anchorValue = 0 . 0 ;  this . rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE ; this . rangeCrosshairValue = 0 . 0 ; this . rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE ; this . rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT ;  this . annotations = new java . util . ArrayList ( ) ;  }  public String getPlotType ( ) { return localizationResources . getString ( \" Category_Plot \" ) ; }  public PlotOrientation getOrientation ( ) { return this . orientation ; }  public void setOrientation ( PlotOrientation orientation ) { if ( orientation = = null ) { throw new IllegalArgumentException ( \" Null ' orientation ' argument . \" ) ; } this . orientation = orientation ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public RectangleInsets getAxisOffset ( ) { return this . axisOffset ; }  public void setAxisOffset ( RectangleInsets offset ) { if ( offset = = null ) { throw new IllegalArgumentException ( \" Null ' offset ' argument . \" ) ; } this . axisOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public CategoryAxis getDomainAxis ( ) { return getDomainAxis ( 0 ) ; }  public CategoryAxis getDomainAxis ( int index ) { CategoryAxis result = null ; if ( index < this . domainAxes . size ( ) ) { result = ( CategoryAxis ) this . domainAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getDomainAxis ( index ) ; } } return result ; }  public void setDomainAxis ( CategoryAxis axis ) { setDomainAxis ( 0 , axis ) ; }  public void setDomainAxis ( int index , CategoryAxis axis ) { setDomainAxis ( index , axis , true ) ; }  public void setDomainAxis ( int index , CategoryAxis axis , boolean notify ) { CategoryAxis existing = ( CategoryAxis ) this . domainAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . domainAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setDomainAxes ( CategoryAxis [ ] axes ) { for ( int i = 0 ; i < axes . length ; i + + ) { setDomainAxis ( i , axes [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return this . domainAxes . indexOf ( axis ) ; }  public AxisLocation getDomainAxisLocation ( ) { return getDomainAxisLocation ( 0 ) ; }  public AxisLocation getDomainAxisLocation ( int index ) { AxisLocation result = null ; if ( index < this . domainAxisLocations . size ( ) ) { result = ( AxisLocation ) this . domainAxisLocations . get ( index ) ; } if ( result = = null ) { result = AxisLocation . getOpposite ( getDomainAxisLocation ( 0 ) ) ; } return result ; }  public void setDomainAxisLocation ( AxisLocation location ) { setDomainAxisLocation ( 0 , location , true ) ; }  public void setDomainAxisLocation ( AxisLocation location , boolean notify ) { setDomainAxisLocation ( 0 , location , notify ) ; }  public void setDomainAxisLocation ( int index , AxisLocation location ) { setDomainAxisLocation ( index , location , true ) ; }  public void setDomainAxisLocation ( int index , AxisLocation location , boolean notify ) { if ( index = = 0 & & location = = null ) { throw new IllegalArgumentException ( \" Null ' location ' for index 0 not permitted . \" ) ; } this . domainAxisLocations . set ( index , location ) ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public RectangleEdge getDomainAxisEdge ( ) { return getDomainAxisEdge ( 0 ) ; }  public RectangleEdge getDomainAxisEdge ( int index ) { RectangleEdge result = null ; AxisLocation location = getDomainAxisLocation ( index ) ; if ( location ! = null ) { result = Plot . resolveDomainAxisLocation ( location , this . orientation ) ; } else { result = RectangleEdge . opposite ( getDomainAxisEdge ( 0 ) ) ; } return result ; }  public int getDomainAxisCount ( ) { return this . domainAxes . size ( ) ; }  public void clearDomainAxes ( ) { for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis axis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( axis ! = null ) { axis . removeChangeListener ( this ) ; } } this . domainAxes . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void configureDomainAxes ( ) { for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis axis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( axis ! = null ) { axis . configure ( ) ; } } }  public ValueAxis getRangeAxis ( ) { return getRangeAxis ( 0 ) ; }  public ValueAxis getRangeAxis ( int index ) { ValueAxis result = null ; if ( index < this . rangeAxes . size ( ) ) { result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; } } return result ; }  public void setRangeAxis ( ValueAxis axis ) { setRangeAxis ( 0 , axis ) ; }  public void setRangeAxis ( int index , ValueAxis axis ) { setRangeAxis ( index , axis , true ) ; }  public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { axis . configure ( ) ; axis . addChangeListener ( this ) ; } if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setRangeAxes ( ValueAxis [ ] axes ) { for ( int i = 0 ; i < axes . length ; i + + ) { setRangeAxis ( i , axes [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }   public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot p = ( CategoryPlot ) parent ; result = p . getRangeAxisIndex ( axis ) ; } } if ( axis = = null ) { throw new IllegalArgumentException ( ) ; } return result ; }  public AxisLocation getRangeAxisLocation ( ) { return getRangeAxisLocation ( 0 ) ; }  public AxisLocation getRangeAxisLocation ( int index ) { AxisLocation result = null ; if ( index < this . rangeAxisLocations . size ( ) ) { result = ( AxisLocation ) this . rangeAxisLocations . get ( index ) ; } if ( result = = null ) { result = AxisLocation . getOpposite ( getRangeAxisLocation ( 0 ) ) ; } return result ; }  public void setRangeAxisLocation ( AxisLocation location ) { setRangeAxisLocation ( location , true ) ; }  public void setRangeAxisLocation ( AxisLocation location , boolean notify ) { setRangeAxisLocation ( 0 , location , notify ) ; }  public void setRangeAxisLocation ( int index , AxisLocation location ) { setRangeAxisLocation ( index , location , true ) ; }  public void setRangeAxisLocation ( int index , AxisLocation location , boolean notify ) { if ( index = = 0 & & location = = null ) { throw new IllegalArgumentException ( \" Null ' location ' for index 0 not permitted . \" ) ; } this . rangeAxisLocations . set ( index , location ) ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public RectangleEdge getRangeAxisEdge ( ) { return getRangeAxisEdge ( 0 ) ; }  public RectangleEdge getRangeAxisEdge ( int index ) { AxisLocation location = getRangeAxisLocation ( index ) ; RectangleEdge result = Plot . resolveRangeAxisLocation ( location , this . orientation ) ; if ( result = = null ) { result = RectangleEdge . opposite ( getRangeAxisEdge ( 0 ) ) ; } return result ; }  public int getRangeAxisCount ( ) { return this . rangeAxes . size ( ) ; }  public void clearRangeAxes ( ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis axis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( axis ! = null ) { axis . removeChangeListener ( this ) ; } } this . rangeAxes . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void configureRangeAxes ( ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis axis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( axis ! = null ) { axis . configure ( ) ; } } }  public CategoryDataset getDataset ( ) { return getDataset ( 0 ) ; }  public CategoryDataset getDataset ( int index ) { CategoryDataset result = null ; if ( this . datasets . size ( ) > index ) { result = ( CategoryDataset ) this . datasets . get ( index ) ; } return result ; }  public void setDataset ( CategoryDataset dataset ) { setDataset ( 0 , dataset ) ; }  public void setDataset ( int index , CategoryDataset dataset ) {  CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } this . datasets . set ( index , dataset ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; }  DatasetChangeEvent event = new DatasetChangeEvent ( this , dataset ) ; datasetChanged ( event ) ;  }  public int getDatasetCount ( ) { return this . datasets . size ( ) ; }  public void mapDatasetToDomainAxis ( int index , int axisIndex ) { this . datasetToDomainAxisMap . set ( index , new Integer ( axisIndex ) ) ; datasetChanged ( new DatasetChangeEvent ( this , getDataset ( index ) ) ) ; }  public CategoryAxis getDomainAxisForDataset ( int index ) { CategoryAxis result = getDomainAxis ( ) ; Integer axisIndex = ( Integer ) this . datasetToDomainAxisMap . get ( index ) ; if ( axisIndex ! = null ) { result = getDomainAxis ( axisIndex . intValue ( ) ) ; } return result ; }  public void mapDatasetToRangeAxis ( int index , int axisIndex ) { this . datasetToRangeAxisMap . set ( index , new Integer ( axisIndex ) ) ; datasetChanged ( new DatasetChangeEvent ( this , getDataset ( index ) ) ) ; }  public ValueAxis getRangeAxisForDataset ( int index ) { ValueAxis result = getRangeAxis ( ) ; Integer axisIndex = ( Integer ) this . datasetToRangeAxisMap . get ( index ) ; if ( axisIndex ! = null ) { result = getRangeAxis ( axisIndex . intValue ( ) ) ; } return result ; }  public CategoryItemRenderer getRenderer ( ) { return getRenderer ( 0 ) ; }  public CategoryItemRenderer getRenderer ( int index ) { CategoryItemRenderer result = null ; if ( this . renderers . size ( ) > index ) { result = ( CategoryItemRenderer ) this . renderers . get ( index ) ; } return result ; }  public void setRenderer ( CategoryItemRenderer renderer ) { setRenderer ( 0 , renderer , true ) ; }  public void setRenderer ( CategoryItemRenderer renderer , boolean notify ) { setRenderer ( 0 , renderer , notify ) ; }  public void setRenderer ( int index , CategoryItemRenderer renderer ) { setRenderer ( index , renderer , true ) ; }  public void setRenderer ( int index , CategoryItemRenderer renderer , boolean notify ) {  CategoryItemRenderer existing = ( CategoryItemRenderer ) this . renderers . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; }  this . renderers . set ( index , renderer ) ; if ( renderer ! = null ) { renderer . setPlot ( this ) ; renderer . addChangeListener ( this ) ; }  configureDomainAxes ( ) ; configureRangeAxes ( ) ;  if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public void setRenderers ( CategoryItemRenderer [ ] renderers ) { for ( int i = 0 ; i < renderers . length ; i + + ) { setRenderer ( i , renderers [ i ] , false ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public CategoryItemRenderer getRendererForDataset ( CategoryDataset dataset ) { CategoryItemRenderer result = null ; for ( int i = 0 ; i < this . datasets . size ( ) ; i + + ) { if ( this . datasets . get ( i ) = = dataset ) { result = ( CategoryItemRenderer ) this . renderers . get ( i ) ; break ; } } return result ; }  public int getIndexOf ( CategoryItemRenderer renderer ) { return this . renderers . indexOf ( renderer ) ; }  public DatasetRenderingOrder getDatasetRenderingOrder ( ) { return this . renderingOrder ; }  public void setDatasetRenderingOrder ( DatasetRenderingOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . renderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public SortOrder getColumnRenderingOrder ( ) { return this . columnRenderingOrder ; }  public void setColumnRenderingOrder ( SortOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . columnRenderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public SortOrder getRowRenderingOrder ( ) { return this . rowRenderingOrder ; }  public void setRowRenderingOrder ( SortOrder order ) { if ( order = = null ) { throw new IllegalArgumentException ( \" Null ' order ' argument . \" ) ; } this . rowRenderingOrder = order ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isDomainGridlinesVisible ( ) { return this . domainGridlinesVisible ; }  public void setDomainGridlinesVisible ( boolean visible ) { if ( this . domainGridlinesVisible ! = visible ) { this . domainGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public CategoryAnchor getDomainGridlinePosition ( ) { return this . domainGridlinePosition ; }  public void setDomainGridlinePosition ( CategoryAnchor position ) { if ( position = = null ) { throw new IllegalArgumentException ( \" Null ' position ' argument . \" ) ; } this . domainGridlinePosition = position ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Stroke getDomainGridlineStroke ( ) { return this . domainGridlineStroke ; }  public void setDomainGridlineStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' not permitted . \" ) ; } this . domainGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getDomainGridlinePaint ( ) { return this . domainGridlinePaint ; }  public void setDomainGridlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . domainGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isRangeGridlinesVisible ( ) { return this . rangeGridlinesVisible ; }  public void setRangeGridlinesVisible ( boolean visible ) { if ( this . rangeGridlinesVisible ! = visible ) { this . rangeGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public Stroke getRangeGridlineStroke ( ) { return this . rangeGridlineStroke ; }  public void setRangeGridlineStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' argument . \" ) ; } this . rangeGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getRangeGridlinePaint ( ) { return this . rangeGridlinePaint ; }  public void setRangeGridlinePaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . rangeGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public LegendItemCollection getFixedLegendItems ( ) { return this . fixedLegendItems ; }  public void setFixedLegendItems ( LegendItemCollection items ) { this . fixedLegendItems = items ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public LegendItemCollection getLegendItems ( ) { LegendItemCollection result = this . fixedLegendItems ; if ( result = = null ) { result = new LegendItemCollection ( ) ; int count = this . datasets . size ( ) ; for ( int datasetIndex = 0 ; datasetIndex < count ; datasetIndex + + ) { CategoryDataset dataset = getDataset ( datasetIndex ) ; if ( dataset ! = null ) { CategoryItemRenderer renderer = getRenderer ( datasetIndex ) ; if ( renderer ! = null ) { int seriesCount = dataset . getRowCount ( ) ; for ( int i = 0 ; i < seriesCount ; i + + ) { LegendItem item = renderer . getLegendItem ( datasetIndex , i ) ; if ( item ! = null ) { result . add ( item ) ; } } } } } } return result ; }  public void handleClick ( int x , int y , PlotRenderingInfo info ) {  Rectangle2D dataArea = info . getDataArea ( ) ; if ( dataArea . contains ( x , y ) ) { double java2D = 0 . 0 ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { java2D = x ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { java2D = y ; } RectangleEdge edge = Plot . resolveRangeAxisLocation ( getRangeAxisLocation ( ) , this . orientation ) ; double value = getRangeAxis ( ) . java2DToValue ( java2D , info . getDataArea ( ) , edge ) ; setAnchorValue ( value ) ; setRangeCrosshairValue ( value ) ; }  }  public void zoom ( double percent ) {  if ( percent > 0 . 0 ) { double range = getRangeAxis ( ) . getRange ( ) . getLength ( ) ; double scaledRange = range * percent ; getRangeAxis ( ) . setRange ( this . anchorValue - scaledRange / 2 . 0 , this . anchorValue + scaledRange / 2 . 0 ) ; } else { getRangeAxis ( ) . setAutoRange ( true ) ; }  }  public void datasetChanged ( DatasetChangeEvent event ) {  int count = this . rangeAxes . size ( ) ; for ( int axisIndex = 0 ; axisIndex < count ; axisIndex + + ) { ValueAxis yAxis = getRangeAxis ( axisIndex ) ; if ( yAxis ! = null ) { yAxis . configure ( ) ; } } if ( getParent ( ) ! = null ) { getParent ( ) . datasetChanged ( event ) ; } else { PlotChangeEvent e = new PlotChangeEvent ( this ) ; e . setType ( ChartChangeEventType . DATASET_UPDATED ) ; notifyListeners ( e ) ; }  }  public void rendererChanged ( RendererChangeEvent event ) { Plot parent = getParent ( ) ; if ( parent ! = null ) { if ( parent instanceof RendererChangeListener ) { RendererChangeListener rcl = ( RendererChangeListener ) parent ; rcl . rendererChanged ( event ) ; } else { throw new RuntimeException ( \" The renderer has changed and I don ' t know what to do ! \" ) ; } } else { configureRangeAxes ( ) ; PlotChangeEvent e = new PlotChangeEvent ( this ) ; notifyListeners ( e ) ; } }  public void addDomainMarker ( CategoryMarker marker ) { addDomainMarker ( marker , Layer . FOREGROUND ) ; }  public void addDomainMarker ( CategoryMarker marker , Layer layer ) { addDomainMarker ( 0 , marker , layer ) ; }  public void addDomainMarker ( int index , CategoryMarker marker , Layer layer ) { if ( marker = = null ) { throw new IllegalArgumentException ( \" Null ' marker ' not permitted . \" ) ; } if ( layer = = null ) { throw new IllegalArgumentException ( \" Null ' layer ' not permitted . \" ) ; } Collection markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( Collection ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . foregroundDomainMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } else if ( layer = = Layer . BACKGROUND ) { markers = ( Collection ) this . backgroundDomainMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . backgroundDomainMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } marker . addChangeListener ( this ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void clearDomainMarkers ( ) { if ( this . backgroundDomainMarkers ! = null ) { Set keys = this . backgroundDomainMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearDomainMarkers ( key . intValue ( ) ) ; } this . backgroundDomainMarkers . clear ( ) ; } if ( this . foregroundDomainMarkers ! = null ) { Set keys = this . foregroundDomainMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearDomainMarkers ( key . intValue ( ) ) ; } this . foregroundDomainMarkers . clear ( ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Collection getDomainMarkers ( Layer layer ) { return getDomainMarkers ( 0 , layer ) ; }  public Collection getDomainMarkers ( int index , Layer layer ) { Collection result = null ; Integer key = new Integer ( index ) ; if ( layer = = Layer . FOREGROUND ) { result = ( Collection ) this . foregroundDomainMarkers . get ( key ) ; } else if ( layer = = Layer . BACKGROUND ) { result = ( Collection ) this . backgroundDomainMarkers . get ( key ) ; } if ( result ! = null ) { result = Collections . unmodifiableCollection ( result ) ; } return result ; }  public void clearDomainMarkers ( int index ) { Integer key = new Integer ( index ) ; if ( this . backgroundDomainMarkers ! = null ) { Collection markers = ( Collection ) this . backgroundDomainMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } if ( this . foregroundDomainMarkers ! = null ) { Collection markers = ( Collection ) this . foregroundDomainMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void addRangeMarker ( Marker marker ) { addRangeMarker ( marker , Layer . FOREGROUND ) ; }  public void addRangeMarker ( Marker marker , Layer layer ) { addRangeMarker ( 0 , marker , layer ) ; }  public void addRangeMarker ( int index , Marker marker , Layer layer ) { Collection markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( Collection ) this . foregroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . foregroundRangeMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } else if ( layer = = Layer . BACKGROUND ) { markers = ( Collection ) this . backgroundRangeMarkers . get ( new Integer ( index ) ) ; if ( markers = = null ) { markers = new java . util . ArrayList ( ) ; this . backgroundRangeMarkers . put ( new Integer ( index ) , markers ) ; } markers . add ( marker ) ; } marker . addChangeListener ( this ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public void clearRangeMarkers ( ) { if ( this . backgroundRangeMarkers ! = null ) { Set keys = this . backgroundRangeMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearRangeMarkers ( key . intValue ( ) ) ; } this . backgroundRangeMarkers . clear ( ) ; } if ( this . foregroundRangeMarkers ! = null ) { Set keys = this . foregroundRangeMarkers . keySet ( ) ; Iterator iterator = keys . iterator ( ) ; while ( iterator . hasNext ( ) ) { Integer key = ( Integer ) iterator . next ( ) ; clearRangeMarkers ( key . intValue ( ) ) ; } this . foregroundRangeMarkers . clear ( ) ; } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Collection getRangeMarkers ( Layer layer ) { return getRangeMarkers ( 0 , layer ) ; }  public Collection getRangeMarkers ( int index , Layer layer ) { Collection result = null ; Integer key = new Integer ( index ) ; if ( layer = = Layer . FOREGROUND ) { result = ( Collection ) this . foregroundRangeMarkers . get ( key ) ; } else if ( layer = = Layer . BACKGROUND ) { result = ( Collection ) this . backgroundRangeMarkers . get ( key ) ; } if ( result ! = null ) { result = Collections . unmodifiableCollection ( result ) ; } return result ; }  public void clearRangeMarkers ( int index ) { Integer key = new Integer ( index ) ; if ( this . backgroundRangeMarkers ! = null ) { Collection markers = ( Collection ) this . backgroundRangeMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } if ( this . foregroundRangeMarkers ! = null ) { Collection markers = ( Collection ) this . foregroundRangeMarkers . get ( key ) ; if ( markers ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker m = ( Marker ) iterator . next ( ) ; m . removeChangeListener ( this ) ; } markers . clear ( ) ; } } notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isRangeCrosshairVisible ( ) { return this . rangeCrosshairVisible ; }  public void setRangeCrosshairVisible ( boolean flag ) { if ( this . rangeCrosshairVisible ! = flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public boolean isRangeCrosshairLockedOnData ( ) { return this . rangeCrosshairLockedOnData ; }  public void setRangeCrosshairLockedOnData ( boolean flag ) {  if ( this . rangeCrosshairLockedOnData ! = flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  }  public double getRangeCrosshairValue ( ) { return this . rangeCrosshairValue ; }  public void setRangeCrosshairValue ( double value ) { setRangeCrosshairValue ( value , true ) ; }  public void setRangeCrosshairValue ( double value , boolean notify ) { this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible ( ) & & notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public Stroke getRangeCrosshairStroke ( ) { return this . rangeCrosshairStroke ; }  public void setRangeCrosshairStroke ( Stroke stroke ) { if ( stroke = = null ) { throw new IllegalArgumentException ( \" Null ' stroke ' argument . \" ) ; } this . rangeCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public Paint getRangeCrosshairPaint ( ) { return this . rangeCrosshairPaint ; }  public void setRangeCrosshairPaint ( Paint paint ) { if ( paint = = null ) { throw new IllegalArgumentException ( \" Null ' paint ' argument . \" ) ; } this . rangeCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public List getAnnotations ( ) { return this . annotations ; }  public void addAnnotation ( CategoryAnnotation annotation ) { if ( annotation = = null ) { throw new IllegalArgumentException ( \" Null ' annotation ' argument . \" ) ; } this . annotations . add ( annotation ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean removeAnnotation ( CategoryAnnotation annotation ) { if ( annotation = = null ) { throw new IllegalArgumentException ( \" Null ' annotation ' argument . \" ) ; } boolean removed = this . annotations . remove ( annotation ) ; if ( removed ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } return removed ; }  public void clearAnnotations ( ) { this . annotations . clear ( ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  protected AxisSpace calculateDomainAxisSpace ( Graphics2D g2 , Rectangle2D plotArea , AxisSpace space ) {  if ( space = = null ) { space = new AxisSpace ( ) ; }  if ( this . fixedDomainAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { space . ensureAtLeast ( this . fixedDomainAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; space . ensureAtLeast ( this . fixedDomainAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } } else { RectangleEdge domainEdge = Plot . resolveDomainAxisLocation ( getDomainAxisLocation ( ) , this . orientation ) ; if ( this . drawSharedDomainAxis ) { space = getDomainAxis ( ) . reserveSpace ( g2 , this , plotArea , domainEdge , space ) ; }  for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { Axis xAxis = ( Axis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { RectangleEdge edge = getDomainAxisEdge ( i ) ; space = xAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } }  return space ;  }  protected AxisSpace calculateRangeAxisSpace ( Graphics2D g2 , Rectangle2D plotArea , AxisSpace space ) {  if ( space = = null ) { space = new AxisSpace ( ) ; }  if ( this . fixedRangeAxisSpace ! = null ) { if ( this . orientation = = PlotOrientation . HORIZONTAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getTop ( ) , RectangleEdge . TOP ) ; space . ensureAtLeast ( this . fixedRangeAxisSpace . getBottom ( ) , RectangleEdge . BOTTOM ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { space . ensureAtLeast ( this . fixedRangeAxisSpace . getLeft ( ) , RectangleEdge . LEFT ) ; space . ensureAtLeast ( this . fixedRangeAxisSpace . getRight ( ) , RectangleEdge . RIGHT ) ; } } else { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { Axis yAxis = ( Axis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { RectangleEdge edge = getRangeAxisEdge ( i ) ; space = yAxis . reserveSpace ( g2 , this , plotArea , edge , space ) ; } } } return space ;  }  protected AxisSpace calculateAxisSpace ( Graphics2D g2 , Rectangle2D plotArea ) { AxisSpace space = new AxisSpace ( ) ; space = calculateRangeAxisSpace ( g2 , plotArea , space ) ; space = calculateDomainAxisSpace ( g2 , plotArea , space ) ; return space ; }  public void draw ( Graphics2D g2 , Rectangle2D area , Point2D anchor , PlotState parentState , PlotRenderingInfo state ) {  boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }  if ( state = = null ) { state = new PlotRenderingInfo ( null ) ; } state . setPlotArea ( area ) ;  RectangleInsets insets = getInsets ( ) ; insets . trim ( area ) ;  AxisSpace space = calculateAxisSpace ( g2 , area ) ; Rectangle2D dataArea = space . shrink ( area , null ) ; this . axisOffset . trim ( dataArea ) ;  state . setDataArea ( dataArea ) ;  if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawBackground ( g2 , this , dataArea ) ; } else { drawBackground ( g2 , dataArea ) ; }  Map axisStateMap = drawAxes ( g2 , area , dataArea , state ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( dataArea ) ;  drawDomainGridlines ( g2 , dataArea ) ;  AxisState rangeAxisState = ( AxisState ) axisStateMap . get ( getRangeAxis ( ) ) ; if ( rangeAxisState = = null ) { if ( parentState ! = null ) { rangeAxisState = ( AxisState ) parentState . getSharedAxisStates ( ) . get ( getRangeAxis ( ) ) ; } } if ( rangeAxisState ! = null ) { drawRangeGridlines ( g2 , dataArea , rangeAxisState . getTicks ( ) ) ; }  for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawDomainMarkers ( g2 , dataArea , i , Layer . BACKGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( g2 , dataArea , i , Layer . BACKGROUND ) ; }  boolean foundData = false ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  DatasetRenderingOrder order = getDatasetRenderingOrder ( ) ; if ( order = = DatasetRenderingOrder . FORWARD ) {  int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = 0 ; i < datasetCount ; i + + ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = 0 ; i < datasetCount ; i + + ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } } else { / / DatasetRenderingOrder . REVERSE  int datasetCount = this . datasets . size ( ) ; for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . BACKGROUND , state ) ; } }  for ( int i = this . datasets . size ( ) - 1 ; i > = 0 ; i - - ) { foundData = render ( g2 , dataArea , i , state ) | | foundData ; }  for ( int i = datasetCount - 1 ; i > = 0 ; i - - ) { CategoryItemRenderer r = getRenderer ( i ) ; if ( r ! = null ) { CategoryAxis domainAxis = getDomainAxisForDataset ( i ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( i ) ; r . drawAnnotations ( g2 , dataArea , domainAxis , rangeAxis , Layer . FOREGROUND , state ) ; } } }  for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawDomainMarkers ( g2 , dataArea , i , Layer . FOREGROUND ) ; } for ( int i = 0 ; i < this . renderers . size ( ) ; i + + ) { drawRangeMarkers ( g2 , dataArea , i , Layer . FOREGROUND ) ; }  drawAnnotations ( g2 , dataArea , state ) ;  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ;  if ( ! foundData ) { drawNoDataMessage ( g2 , dataArea ) ; }  if ( isRangeCrosshairVisible ( ) ) { drawRangeCrosshair ( g2 , dataArea , getOrientation ( ) , getRangeCrosshairValue ( ) , getRangeAxis ( ) , getRangeCrosshairStroke ( ) , getRangeCrosshairPaint ( ) ) ; }  if ( getRenderer ( ) ! = null ) { getRenderer ( ) . drawOutline ( g2 , this , dataArea ) ; } else { drawOutline ( g2 , dataArea ) ; }  }  public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }  protected Map drawAxes ( Graphics2D g2 , Rectangle2D plotArea , Rectangle2D dataArea , PlotRenderingInfo plotState ) {  AxisCollection axisCollection = new AxisCollection ( ) ;  for ( int index = 0 ; index < this . domainAxes . size ( ) ; index + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; if ( xAxis ! = null ) { axisCollection . add ( xAxis , getDomainAxisEdge ( index ) ) ; } }  for ( int index = 0 ; index < this . rangeAxes . size ( ) ; index + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( yAxis ! = null ) { axisCollection . add ( yAxis , getRangeAxisEdge ( index ) ) ; } }  Map axisStateMap = new HashMap ( ) ;  double cursor = dataArea . getMinY ( ) - this . axisOffset . calculateTopOutset ( dataArea . getHeight ( ) ) ; Iterator iterator = axisCollection . getAxesAtTop ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . TOP , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMaxY ( ) + this . axisOffset . calculateBottomOutset ( dataArea . getHeight ( ) ) ; iterator = axisCollection . getAxesAtBottom ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . BOTTOM , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMinX ( ) - this . axisOffset . calculateLeftOutset ( dataArea . getWidth ( ) ) ; iterator = axisCollection . getAxesAtLeft ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . LEFT , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  cursor = dataArea . getMaxX ( ) + this . axisOffset . calculateRightOutset ( dataArea . getWidth ( ) ) ; iterator = axisCollection . getAxesAtRight ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Axis axis = ( Axis ) iterator . next ( ) ; if ( axis ! = null ) { AxisState axisState = axis . draw ( g2 , cursor , plotArea , dataArea , RectangleEdge . RIGHT , plotState ) ; cursor = axisState . getCursor ( ) ; axisStateMap . put ( axis , axisState ) ; } }  return axisStateMap ;  }  public boolean render ( Graphics2D g2 , Rectangle2D dataArea , int index , PlotRenderingInfo info ) {  boolean foundData = false ; CategoryDataset currentDataset = getDataset ( index ) ; CategoryItemRenderer renderer = getRenderer ( index ) ; CategoryAxis domainAxis = getDomainAxisForDataset ( index ) ; ValueAxis rangeAxis = getRangeAxisForDataset ( index ) ; boolean hasData = ! DatasetUtilities . isEmptyOrNull ( currentDataset ) ; if ( hasData & & renderer ! = null ) {  foundData = true ; CategoryItemRendererState state = renderer . initialise ( g2 , dataArea , this , index , info ) ; int columnCount = currentDataset . getColumnCount ( ) ; int rowCount = currentDataset . getRowCount ( ) ; int passCount = renderer . getPassCount ( ) ; for ( int pass = 0 ; pass < passCount ; pass + + ) { if ( this . columnRenderingOrder = = SortOrder . ASCENDING ) { for ( int column = 0 ; column < columnCount ; column + + ) { if ( this . rowRenderingOrder = = SortOrder . ASCENDING ) { for ( int row = 0 ; row < rowCount ; row + + ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } else { for ( int row = rowCount - 1 ; row > = 0 ; row - - ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } } } else { for ( int column = columnCount - 1 ; column > = 0 ; column - - ) { if ( this . rowRenderingOrder = = SortOrder . ASCENDING ) { for ( int row = 0 ; row < rowCount ; row + + ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } else { for ( int row = rowCount - 1 ; row > = 0 ; row - - ) { renderer . drawItem ( g2 , state , dataArea , this , domainAxis , rangeAxis , currentDataset , row , column , pass ) ; } } } } } } return foundData ;  }  protected void drawDomainGridlines ( Graphics2D g2 , Rectangle2D dataArea ) {  if ( isDomainGridlinesVisible ( ) ) { CategoryAnchor anchor = getDomainGridlinePosition ( ) ; RectangleEdge domainAxisEdge = getDomainAxisEdge ( ) ; Stroke gridStroke = getDomainGridlineStroke ( ) ; Paint gridPaint = getDomainGridlinePaint ( ) ; if ( ( gridStroke ! = null ) & & ( gridPaint ! = null ) ) { CategoryDataset data = getDataset ( ) ; if ( data ! = null ) { CategoryAxis axis = getDomainAxis ( ) ; if ( axis ! = null ) { int columnCount = data . getColumnCount ( ) ; for ( int c = 0 ; c < columnCount ; c + + ) { double xx = axis . getCategoryJava2DCoordinate ( anchor , c , columnCount , dataArea , domainAxisEdge ) ; CategoryItemRenderer renderer1 = getRenderer ( ) ; if ( renderer1 ! = null ) { renderer1 . drawDomainGridline ( g2 , this , dataArea , xx ) ; } } } } } } }  protected void drawRangeGridlines ( Graphics2D g2 , Rectangle2D dataArea , List ticks ) { if ( isRangeGridlinesVisible ( ) ) { Stroke gridStroke = getRangeGridlineStroke ( ) ; Paint gridPaint = getRangeGridlinePaint ( ) ; if ( ( gridStroke ! = null ) & & ( gridPaint ! = null ) ) { ValueAxis axis = getRangeAxis ( ) ; if ( axis ! = null ) { Iterator iterator = ticks . iterator ( ) ; while ( iterator . hasNext ( ) ) { ValueTick tick = ( ValueTick ) iterator . next ( ) ; CategoryItemRenderer renderer1 = getRenderer ( ) ; if ( renderer1 ! = null ) { renderer1 . drawRangeGridline ( g2 , this , getRangeAxis ( ) , dataArea , tick . getValue ( ) ) ; } } } } } }  protected void drawAnnotations ( Graphics2D g2 , Rectangle2D dataArea , PlotRenderingInfo info ) {  Iterator iterator = getAnnotations ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryAnnotation annotation = ( CategoryAnnotation ) iterator . next ( ) ; annotation . draw ( g2 , this , dataArea , getDomainAxis ( ) , getRangeAxis ( ) , 0 , info ) ; }  }  protected void drawDomainMarkers ( Graphics2D g2 , Rectangle2D dataArea , int index , Layer layer ) {  CategoryItemRenderer r = getRenderer ( index ) ; if ( r = = null ) { return ; }  Collection markers = getDomainMarkers ( index , layer ) ; CategoryAxis axis = getDomainAxisForDataset ( index ) ; if ( markers ! = null & & axis ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryMarker marker = ( CategoryMarker ) iterator . next ( ) ; r . drawDomainMarker ( g2 , this , axis , marker , dataArea ) ; } }  }  protected void drawRangeMarkers ( Graphics2D g2 , Rectangle2D dataArea , int index , Layer layer ) {  CategoryItemRenderer r = getRenderer ( index ) ; if ( r = = null ) { return ; }  Collection markers = getRangeMarkers ( index , layer ) ; ValueAxis axis = getRangeAxisForDataset ( index ) ; if ( markers ! = null & & axis ! = null ) { Iterator iterator = markers . iterator ( ) ; while ( iterator . hasNext ( ) ) { Marker marker = ( Marker ) iterator . next ( ) ; r . drawRangeMarker ( g2 , this , axis , marker , dataArea ) ; } }  }  protected void drawRangeLine ( Graphics2D g2 , Rectangle2D dataArea , double value , Stroke stroke , Paint paint ) {  double java2D = getRangeAxis ( ) . valueToJava2D ( value , dataArea , getRangeAxisEdge ( ) ) ; Line2D line = null ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( java2D , dataArea . getMinY ( ) , java2D , dataArea . getMaxY ( ) ) ; } else if ( this . orientation = = PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , java2D , dataArea . getMaxX ( ) , java2D ) ; } g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ;  }  protected void drawRangeCrosshair ( Graphics2D g2 , Rectangle2D dataArea , PlotOrientation orientation , double value , ValueAxis axis , Stroke stroke , Paint paint ) {  if ( ! axis . getRange ( ) . contains ( value ) ) { return ; } Line2D line = null ; if ( orientation = = PlotOrientation . HORIZONTAL ) { double xx = axis . valueToJava2D ( value , dataArea , RectangleEdge . BOTTOM ) ; line = new Line2D . Double ( xx , dataArea . getMinY ( ) , xx , dataArea . getMaxY ( ) ) ; } else { double yy = axis . valueToJava2D ( value , dataArea , RectangleEdge . LEFT ) ; line = new Line2D . Double ( dataArea . getMinX ( ) , yy , dataArea . getMaxX ( ) , yy ) ; } g2 . setStroke ( stroke ) ; g2 . setPaint ( paint ) ; g2 . draw ( line ) ;  }  public Range getDataRange ( ValueAxis axis ) {  Range result = null ; List mappedDatasets = new ArrayList ( ) ;  int rangeIndex = this . rangeAxes . indexOf ( axis ) ; if ( rangeIndex > = 0 ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( rangeIndex ) ) ; } else if ( axis = = getRangeAxis ( ) ) { mappedDatasets . addAll ( datasetsMappedToRangeAxis ( 0 ) ) ; }  Iterator iterator = mappedDatasets . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryDataset d = ( CategoryDataset ) iterator . next ( ) ; CategoryItemRenderer r = getRendererForDataset ( d ) ; if ( r ! = null ) { result = Range . combine ( result , r . findRangeBounds ( d ) ) ; } } return result ;  }  private List datasetsMappedToDomainAxis ( int axisIndex ) { List result = new ArrayList ( ) ; for ( int datasetIndex = 0 ; datasetIndex < this . datasets . size ( ) ; datasetIndex + + ) { Object dataset = this . datasets . get ( datasetIndex ) ; if ( dataset ! = null ) { Integer m = ( Integer ) this . datasetToDomainAxisMap . get ( datasetIndex ) ; if ( m = = null ) { / / a dataset with no mapping is assigned to if ( axisIndex = = 0 ) { result . add ( dataset ) ; } } else { if ( m . intValue ( ) = = axisIndex ) { result . add ( dataset ) ; } } } } return result ; }  private List datasetsMappedToRangeAxis ( int index ) { List result = new ArrayList ( ) ; for ( int i = 0 ; i < this . datasets . size ( ) ; i + + ) { Object dataset = this . datasets . get ( i ) ; if ( dataset ! = null ) { Integer m = ( Integer ) this . datasetToRangeAxisMap . get ( i ) ; if ( m = = null ) { / / a dataset with no mapping is assigned to if ( index = = 0 ) { result . add ( dataset ) ; } } else { if ( m . intValue ( ) = = index ) { result . add ( dataset ) ; } } } } return result ; }  public int getWeight ( ) { return this . weight ; }  public void setWeight ( int weight ) { this . weight = weight ; }  public AxisSpace getFixedDomainAxisSpace ( ) { return this . fixedDomainAxisSpace ; }  public void setFixedDomainAxisSpace ( AxisSpace space ) { this . fixedDomainAxisSpace = space ; }  public AxisSpace getFixedRangeAxisSpace ( ) { return this . fixedRangeAxisSpace ; }  public void setFixedRangeAxisSpace ( AxisSpace space ) { this . fixedRangeAxisSpace = space ; }  public List getCategories ( ) { List result = null ; if ( getDataset ( ) ! = null ) { result = Collections . unmodifiableList ( getDataset ( ) . getColumnKeys ( ) ) ; } return result ; }  public List getCategoriesForAxis ( CategoryAxis axis ) { List result = new ArrayList ( ) ; int axisIndex = this . domainAxes . indexOf ( axis ) ; List datasets = datasetsMappedToDomainAxis ( axisIndex ) ; Iterator iterator = datasets . iterator ( ) ; while ( iterator . hasNext ( ) ) { CategoryDataset dataset = ( CategoryDataset ) iterator . next ( ) ; for ( int i = 0 ; i < dataset . getColumnCount ( ) ; i + + ) { Comparable category = dataset . getColumnKey ( i ) ; if ( ! result . contains ( category ) ) { result . add ( category ) ; } } } return result ; }  public boolean getDrawSharedDomainAxis ( ) { return this . drawSharedDomainAxis ; }  public void setDrawSharedDomainAxis ( boolean draw ) { this . drawSharedDomainAxis = draw ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }  public boolean isDomainZoomable ( ) { return false ; }  public boolean isRangeZoomable ( ) { return true ; }  public void zoomDomainAxes ( double factor , PlotRenderingInfo state , Point2D source ) { }  public void zoomDomainAxes ( double lowerPercent , double upperPercent , PlotRenderingInfo state , Point2D source ) { }  public void zoomDomainAxes ( double factor , PlotRenderingInfo info , Point2D source , boolean useAnchor ) { }  public void zoomRangeAxes ( double factor , PlotRenderingInfo state , Point2D source ) { zoomRangeAxes ( factor , state , source , false ) ; }  public void zoomRangeAxes ( double factor , PlotRenderingInfo info , Point2D source , boolean useAnchor ) {  for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis rangeAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( rangeAxis ! = null ) { if ( useAnchor ) { double sourceY = source . getY ( ) ; if ( this . orientation = = PlotOrientation . HORIZONTAL ) { sourceY = source . getX ( ) ; } double anchorY = rangeAxis . java2DToValue ( sourceY , info . getDataArea ( ) , getRangeAxisEdge ( ) ) ; rangeAxis . resizeRange ( factor , anchorY ) ; } else { rangeAxis . resizeRange ( factor ) ; } } } }  public void zoomRangeAxes ( double lowerPercent , double upperPercent , PlotRenderingInfo state , Point2D source ) { for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis rangeAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( rangeAxis ! = null ) { rangeAxis . zoomRange ( lowerPercent , upperPercent ) ; } } }  public double getAnchorValue ( ) { return this . anchorValue ; }  public void setAnchorValue ( double value ) { setAnchorValue ( value , true ) ; }  public void setAnchorValue ( double value , boolean notify ) { this . anchorValue = value ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }  public boolean equals ( Object obj ) {  if ( obj = = this ) { return true ; } if ( ! ( obj instanceof CategoryPlot ) ) { return false ; } if ( ! super . equals ( obj ) ) { return false ; }  CategoryPlot that = ( CategoryPlot ) obj ;  if ( this . orientation ! = that . orientation ) { return false ; } if ( ! ObjectUtilities . equal ( this . axisOffset , that . axisOffset ) ) { return false ; } if ( ! this . domainAxes . equals ( that . domainAxes ) ) { return false ; } if ( ! this . domainAxisLocations . equals ( that . domainAxisLocations ) ) { return false ; } if ( this . drawSharedDomainAxis ! = that . drawSharedDomainAxis ) { return false ; } if ( ! this . rangeAxes . equals ( that . rangeAxes ) ) { return false ; } if ( ! this . rangeAxisLocations . equals ( that . rangeAxisLocations ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToDomainAxisMap , that . datasetToDomainAxisMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . datasetToRangeAxisMap , that . datasetToRangeAxisMap ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . renderers , that . renderers ) ) { return false ; } if ( this . renderingOrder ! = that . renderingOrder ) { return false ; } if ( this . columnRenderingOrder ! = that . columnRenderingOrder ) { return false ; } if ( this . rowRenderingOrder ! = that . rowRenderingOrder ) { return false ; } if ( this . domainGridlinesVisible ! = that . domainGridlinesVisible ) { return false ; } if ( this . domainGridlinePosition ! = that . domainGridlinePosition ) { return false ; } if ( ! ObjectUtilities . equal ( this . domainGridlineStroke , that . domainGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . domainGridlinePaint , that . domainGridlinePaint ) ) { return false ; } if ( this . rangeGridlinesVisible ! = that . rangeGridlinesVisible ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeGridlineStroke , that . rangeGridlineStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeGridlinePaint , that . rangeGridlinePaint ) ) { return false ; } if ( this . anchorValue ! = that . anchorValue ) { return false ; } if ( this . rangeCrosshairVisible ! = that . rangeCrosshairVisible ) { return false ; } if ( this . rangeCrosshairValue ! = that . rangeCrosshairValue ) { return false ; } if ( ! ObjectUtilities . equal ( this . rangeCrosshairStroke , that . rangeCrosshairStroke ) ) { return false ; } if ( ! PaintUtilities . equal ( this . rangeCrosshairPaint , that . rangeCrosshairPaint ) ) { return false ; } if ( this . rangeCrosshairLockedOnData ! = that . rangeCrosshairLockedOnData ) { return false ; } if ( ! ObjectUtilities . equal ( this . foregroundRangeMarkers , that . foregroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . backgroundRangeMarkers , that . backgroundRangeMarkers ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . annotations , that . annotations ) ) { return false ; } if ( this . weight ! = that . weight ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedDomainAxisSpace , that . fixedDomainAxisSpace ) ) { return false ; } if ( ! ObjectUtilities . equal ( this . fixedRangeAxisSpace , that . fixedRangeAxisSpace ) ) { return false ; }  return true ;  }  public Object clone ( ) throws CloneNotSupportedException {  CategoryPlot clone = ( CategoryPlot ) super . clone ( ) ;  clone . domainAxes = new ObjectList ( ) ; for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { CategoryAxis clonedAxis = ( CategoryAxis ) xAxis . clone ( ) ; clone . setDomainAxis ( i , clonedAxis ) ; } } clone . domainAxisLocations = ( ObjectList ) this . domainAxisLocations . clone ( ) ;  clone . rangeAxes = new ObjectList ( ) ; for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { ValueAxis clonedAxis = ( ValueAxis ) yAxis . clone ( ) ; clone . setRangeAxis ( i , clonedAxis ) ; } } clone . rangeAxisLocations = ( ObjectList ) this . rangeAxisLocations . clone ( ) ;  clone . datasets = ( ObjectList ) this . datasets . clone ( ) ; for ( int i = 0 ; i < clone . datasets . size ( ) ; i + + ) { CategoryDataset dataset = clone . getDataset ( i ) ; if ( dataset ! = null ) { dataset . addChangeListener ( clone ) ; } } clone . datasetToDomainAxisMap = ( ObjectList ) this . datasetToDomainAxisMap . clone ( ) ; clone . datasetToRangeAxisMap = ( ObjectList ) this . datasetToRangeAxisMap . clone ( ) ; clone . renderers = ( ObjectList ) this . renderers . clone ( ) ; if ( this . fixedDomainAxisSpace ! = null ) { clone . fixedDomainAxisSpace = ( AxisSpace ) ObjectUtilities . clone ( this . fixedDomainAxisSpace ) ; } if ( this . fixedRangeAxisSpace ! = null ) { clone . fixedRangeAxisSpace = ( AxisSpace ) ObjectUtilities . clone ( this . fixedRangeAxisSpace ) ; }  return clone ;  }  private void writeObject ( ObjectOutputStream stream ) throws IOException { stream . defaultWriteObject ( ) ; SerialUtilities . writeStroke ( this . domainGridlineStroke , stream ) ; SerialUtilities . writePaint ( this . domainGridlinePaint , stream ) ; SerialUtilities . writeStroke ( this . rangeGridlineStroke , stream ) ; SerialUtilities . writePaint ( this . rangeGridlinePaint , stream ) ; SerialUtilities . writeStroke ( this . rangeCrosshairStroke , stream ) ; SerialUtilities . writePaint ( this . rangeCrosshairPaint , stream ) ; }  private void readObject ( ObjectInputStream stream ) throws IOException , ClassNotFoundException {  stream . defaultReadObject ( ) ; this . domainGridlineStroke = SerialUtilities . readStroke ( stream ) ; this . domainGridlinePaint = SerialUtilities . readPaint ( stream ) ; this . rangeGridlineStroke = SerialUtilities . readStroke ( stream ) ; this . rangeGridlinePaint = SerialUtilities . readPaint ( stream ) ; this . rangeCrosshairStroke = SerialUtilities . readStroke ( stream ) ; this . rangeCrosshairPaint = SerialUtilities . readPaint ( stream ) ;  for ( int i = 0 ; i < this . domainAxes . size ( ) ; i + + ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( i ) ; if ( xAxis ! = null ) { xAxis . setPlot ( this ) ; xAxis . addChangeListener ( this ) ; } } for ( int i = 0 ; i < this . rangeAxes . size ( ) ; i + + ) { ValueAxis yAxis = ( ValueAxis ) this . rangeAxes . get ( i ) ; if ( yAxis ! = null ) { yAxis . setPlot ( this ) ; yAxis . addChangeListener ( this ) ; } } int datasetCount = this . datasets . size ( ) ; for ( int i = 0 ; i < datasetCount ; i + + ) { Dataset dataset = ( Dataset ) this . datasets . get ( i ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } } int rendererCount = this . renderers . size ( ) ; for ( int i = 0 ; i < rendererCount ; i + + ) { CategoryItemRenderer renderer = ( CategoryItemRenderer ) this . renderers . get ( i ) ; if ( renderer ! = null ) { renderer . addChangeListener ( this ) ; } }  }  }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { return foundDigit & & ! hasExp ; } / / last character is illegal", "fixed_code": "} if ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) { if ( hasDecPoint = = true ) { return false ; } / / not allowing L with an exponent or decimal point return foundDigit & & ! hasExp ; } / / last character is illegal", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; return newArray ; }", "fixed_code": "@ SuppressWarnings ( \" unchecked \" ) / / type must be T T [ ] newArray = ( T [ ] ) copyArrayGrow1 ( array , type ) ; newArray [ newArray . length - 1 ] = element ; if ( element = = null ) { throw new IllegalArgumentException ( ) ; } return newArray ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_35"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { if ( str . startsWith ( \" - - \" ) = = true ) { throw new NumberFormatException ( ) ; } return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0xS", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; omega = FastMath . sqrt ( c2 / c3 ) ; } }", "fixed_code": "/ / procedure cannot produce sensible results . a = FastMath . sqrt ( c1 / c2 ) ; if ( c2 = = 0 . 0 ) { throw new MathIllegalStateException ( ) ; } omega = FastMath . sqrt ( c2 / c3 ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_25"}
{"buggy_code": "final double prodHighCur = prodHigh [ 0 ] ; double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "fixed_code": "final double prodHighCur = prodHigh [ 0 ] ; if ( len = = 1 . 0 ) { return a [ 0 ] * b [ 0 ] ; } double prodHighNext = prodHigh [ 1 ] ; double sHighPrev = prodHighCur + prodHighNext ; double sPrime = sHighPrev - prodHighNext ; double sLowSum = ( prodHighNext - ( sHighPrev - sPrime ) ) + ( prodHighCur - sPrime ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_3"}
{"buggy_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "* limitations under the License . package org . apache . commons . math3 . genetics ; import org . apache . commons . math3 . exception . OutOfRangeException ; import java . util . Collections ; import java . util . List ; final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate > ( double ) 1 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } if ( elitismRate < ( double ) 0 . 0 ) { throw new OutOfRangeException ( null , null , null ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { if ( this . equals ( new Complex ( 0 , 0 ) ) ) { return INF ; } return NaN ; } if ( isInfinite ) {", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "fixed_code": "* See the License for the specific language governing permissions and * limitations under the License . package org . apache . commons . math . distribution ; import org . apache . commons . math . exception . NotStrictlyPositiveException ; import java . io . Serializable ; public PoissonDistributionImpl ( double p , double epsilon , int maxIterations ) { if ( p < = 0 ) { if ( p < = 0 ) { throw new NotStrictlyPositiveException ( null ) ; } throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . NOT_POSITIVE_POISSON_MEAN , p ) ; } mean = p ; normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_61"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 & & ! ( MathUtils . compareTo ( entry , 0 , epsilon ) = = 0 . 0 ) ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ! ( fa * fb = = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" ,", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new IllegalArgumentException ( ) ; } addValue ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "fixed_code": "freqTable . put ( obj , Long . valueOf ( count . longValue ( ) + 1 ) ) ; } } catch ( ClassCastException ex ) { if ( ! ( v instanceof Comparable < ? > ) ) { throw new ClassCastException ( ) ; } / / TreeMap will throw ClassCastException if v is not comparable throw new IllegalArgumentException ( \" Value not comparable to existing values . \" ) ; } }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_90"}
{"buggy_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; return lcm ; }", "fixed_code": "int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( u = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } if ( v = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return ( Math . abs ( u ) + Math . abs ( v ) ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 return 0 ; } int lcm = Math . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ; if ( lcm = = Integer . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return lcm ; }", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_99"}
{"buggy_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "fixed_code": "this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ; setDataset ( dataset ) ; this . pieChart . removeLegend ( ) ; this . dataExtractOrder = TableOrder . BY_COLUMN ; this . pieChart . setBackgroundPaint ( null ) ; TextTitle seriesTitle = new TextTitle ( \" Series Title \" ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "Node catchCodeBlock = catchNode . getLastChild ( ) ; tryMinimizeExits ( catchCodeBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; this . elitismRate = elitismRate ; } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; this . elitismRate = elitismRate ; }", "fixed_code": "final int populationLimit , final double elitismRate ) { super ( chromosomes , populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } } public ElitisticListPopulation ( final int populationLimit , final double elitismRate ) { super ( populationLimit ) ; if ( elitismRate < 0 | | elitismRate > 1 ) { throw new OutOfRangeException ( LocalizedFormats . ELITISM_RATE , elitismRate , 0 , 1 ) ; } this . elitismRate = elitismRate ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_35"}
{"buggy_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { if ( function = = null ) { throw new NullArgumentException ( LocalizedFormats . FUNCTION ) ; } verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "fixed_code": "f0 * = f1 / ( f1 + fx ) ; break ; case REGULA_FALSI : break ; default : / / Should never happen . public static void verifyBracketing ( UnivariateRealFunction function , final double lower , final double upper ) { verifyInterval ( lower , upper ) ; if ( ! isBracketing ( function , lower , upper ) ) { throw new NoBracketingException ( lower , upper ,", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) {  / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "fixed_code": "Set < String > currentPropertyNames ; / / This can be the case if interfaceType is proxy to a non - existent / / object ( which is a bad type annotation , but shouldn ' t crash ) . if ( implicitProto ! = null ) { currentPropertyNames = implicitProto . getOwnPropertyNames ( ) ; for ( String name : currentPropertyNames ) { ObjectType oType = properties . get ( name ) ; if ( oType ! = null ) { } currentProperties . put ( name , interfaceType ) ; } }  for ( ObjectType iType : interfaceType . getCtorExtendedInterfaces ( ) ) { checkInterfaceConflictProperties ( t , n , functionName , properties , currentProperties , iType ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_2"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < = 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleList . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ;", "fixed_code": "if ( x = = x1 ) { if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ;", "label": 1, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ;", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; value = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "fixed_code": "if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a", "label": 1, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; } }", "label": 1, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; }  if ( isInfinite ) { return ZERO ; }  if ( FastMath . abs ( real ) < FastMath . abs ( imaginary ) ) { double q = real / imaginary ; double scale = 1 . / ( real * q + imaginary ) ; return createComplex ( scale * q , - scale ) ; } else { double q = imaginary / real ; double scale = 1 . / ( imaginary * q + real ) ; return createComplex ( scale , - scale * q ) ; } } @ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ; } } return false ; } @ Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( 17 * MathUtils . hash ( imaginary ) + MathUtils . hash ( real ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public Complex multiply ( Complex factor ) throws NullArgumentException { MathUtils . checkNotNull ( factor ) ; if ( isNaN | | factor . isNaN ) { return NaN ; } if ( Double . isInfinite ( real ) | | Double . isInfinite ( imaginary ) | | Double . isInfinite ( factor . real ) | | Double . isInfinite ( factor . imaginary ) ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { / / we don ' t use isInfinite ( ) to avoid testing for NaN again return org . apache . commons . math3 . complex . Complex . INF ; } if ( isInfinite ) { return org . apache . commons . math3 . complex . Complex . ZERO ; } if ( ( org . apache . commons . math3 . util . FastMath . abs ( real ) ) < ( org . apache . commons . math3 . util . FastMath . abs ( imaginary ) ) ) { double q = ( real ) / ( imaginary ) ; double scale = 1 . 0 / ( ( ( real ) * q ) + ( imaginary ) ) ; return createComplex ( ( scale * q ) , ( - scale ) ) ; } else { double q = ( imaginary ) / ( real ) ; double scale = 1 . 0 / ( ( ( imaginary ) * q ) + ( real ) ) ; return createComplex ( scale , ( ( - scale ) * q ) ) ; } } @ java . lang . Override public boolean equals ( java . lang . Object other ) { if ( ( this ) = = other ) { return true ; } if ( other instanceof org . apache . commons . math3 . complex . Complex ) { org . apache . commons . math3 . complex . Complex c = ( ( org . apache . commons . math3 . complex . Complex ) ( other ) ) ; if ( c . isNaN ) { return isNaN ; } else { return ( ( real ) = = ( c . real ) ) & & ( ( imaginary ) = = ( c . imaginary ) ) ; } } return false ; } @ java . lang . Override public int hashCode ( ) { if ( isNaN ) { return 7 ; } return 37 * ( ( 17 * ( org . apache . commons . math3 . util . MathUtils . hash ( imaginary ) ) ) + ( org . apache . commons . math3 . util . MathUtils . hash ( real ) ) ) ; } public double getImaginary ( ) { return imaginary ; } public double getReal ( ) { return real ; } public boolean isNaN ( ) { return isNaN ; } public boolean isInfinite ( ) { return isInfinite ; } public org . apache . commons . math3 . complex . Complex multiply ( org . apache . commons . math3 . complex . Complex factor ) throws org . apache . commons . math3 . exception . NullArgumentException { org . apache . commons . math3 . util . MathUtils . checkNotNull ( factor ) ; if ( ( isNaN ) | | ( factor . isNaN ) ) { return org . apache . commons . math3 . complex . Complex . NaN ; } if ( ( ( ( java . lang . Double . isInfinite ( real ) ) | | ( java . lang . Double . isInfinite ( imaginary ) ) ) | | ( java . lang . Double . isInfinite ( factor . real ) ) ) | | ( java . lang . Double . isInfinite ( factor . imaginary ) ) ) { return org . apache . commons . math3 . complex . Complex . INF ; } return createComplex ( real * factor . real - imaginary * factor . imaginary , real * factor . imaginary + imaginary * factor . real ) ;", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( isNaN ) | | ( rhs . isNaN ) ) { return NaN ; } return createComplex ( ( real ) + ( rhs . getReal ( ) ) , ( imaginary ) + ( rhs . getImaginary ( ) ) ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( false ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {  } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 )  f0 = computeObjectiveValue ( x0 ) ;  break ; default : / / Should never happen .", "label": 1, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( false ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 1, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( false ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 1, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( false ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 1, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , false ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "fixed_code": "Node nameNode = n . getFirstChild ( ) ; NameInformation ns = createNameInformation ( t , nameNode , n ) ; if ( ns ! = null & & ns . onlyAffectsClassDef ) { JsName name = getName ( ns . name , true ) ; if ( name ! = null ) { refNodes . add ( new ClassDefiningFunctionNode ( name , n , parent , parent . getParent ( ) ) ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_40"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "case ' / ' : out . write ( ' \\ \\ ' ) ; out . write ( ' / ' ) ;", "fixed_code": "case ' / ' : if ( escapeSingleQuote ) { out . write ( ' \\ \\ ' ) ; } out . write ( ' / ' ) ;", "label": 1, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_46"}
{"buggy_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { hasSideEffects = NodeUtil . mayHaveSideEffects ( stmt . getFirstChild ( ) , compiler ) ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "fixed_code": "Preconditions . checkState ( block . hasOneChild ( ) ) ; Node stmt = block . getFirstChild ( ) ; if ( stmt . isReturn ( ) ) { int start = 0 ; } } / / CALL NODE : [ NAME , ARG1 , ARG2 , . . . ]", "label": 1, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , stroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( cArg = = null & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once . / / Note : Unlike block inlining , there it is not possible that a / / parameter reference will be in a loop .", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( callee . isGetProp ( ) & & param . isQualifiedName ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "fixed_code": "if ( condition . isCall ( ) & & condition . getChildCount ( ) = = 2 ) { Node callee = condition . getFirstChild ( ) ; Node param = condition . getLastChild ( ) ; if ( param . isName ( ) | | param . isGetProp ( ) ) { JSType paramType = getTypeIfRefinable ( param , blindScope ) ; Node left = callee . getFirstChild ( ) ; Node right = callee . getLastChild ( ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { return false ; } return true ;", "fixed_code": "boolean expectCanAssignTo ( NodeTraversal t , Node n , JSType rightType , JSType leftType , String msg ) { if ( ! rightType . canAssignTo ( leftType ) ) { if ( ! shouldReport & & ( shouldReport | | ! NodeUtil . mayHaveSideEffects ( n , t . getCompiler ( ) ) ) ) { registerMismatch ( rightType , leftType , null ) ; } else { mismatch ( t , n , msg , rightType , leftType ) ; } return false ; } return true ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_6"}
{"buggy_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "fixed_code": "private Node parseFunctionType ( JsDocToken token ) { / / NOTE ( nicksantos ) : We ' re not implementing generics at the moment , so / / just throw out TypeParameters . if ( token ! = JsDocToken . LP ) { restoreLookAhead ( token ) ; return reportTypeSyntaxWarning ( \" msg . jsdoc . missing . lp \" ) ; } Node functionType = newNode ( Token . FUNCTION ) ; Node parameters = null ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; return false ; }", "fixed_code": "public boolean contains ( char ch ) { char [ ] thisBuf = buffer ; for ( int i = 0 ; i < size ; i + + ) { if ( thisBuf [ i ] = = ch ) { return true ; } } return false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; } else { loop = false ; }", "fixed_code": "interpolator . storeTime ( stepStart + stepSize ) ; if ( manager . evaluateStep ( interpolator ) ) { final double dt = manager . getEventTime ( ) - stepStart ; if ( Math . abs ( dt ) < = Math . ulp ( stepStart ) ) { System . arraycopy ( y , 0 , yTmp , 0 , y0 . length ) ; stepSize = 0 ; loop = false ; } else { stepSize = dt ; } } else { loop = false ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "fixed_code": "/ / return the first endpoint if it is good enough double yMin = f . value ( min ) ; if ( Math . abs ( yMin ) < = functionValueAccuracy ) { setResult ( min , 0 ) ; return result ; } / / reduce interval if min and initial bracket the root if ( yInitial * yMin < 0 ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_72"}
{"buggy_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p1 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "fixed_code": "if ( p1 . getWindingRule ( ) ! = p2 . getWindingRule ( ) ) { return false ; } PathIterator iterator1 = p2 . getPathIterator ( null ) ; PathIterator iterator2 = p1 . getPathIterator ( null ) ; double [ ] d1 = new double [ 6 ] ; double [ ] d2 = new double [ 6 ] ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_11"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ; } continue ; } wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ;  wasWhite = false ; switch ( c ) { case ' \\ ' ' :", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { if ( classes = = null ) continue ; if ( array [ i ] = = null ) continue ; classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "fixed_code": "if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; if ( str = = null ) str = new String ( ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( strLen - width , strLen , buffer , size ) ; } else {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_47"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "fixed_code": "if ( str = = null ) { return null ; } if ( ( StringUtils . isBlank ( str ) ) | | ( str . startsWith ( \" - - \" ) ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2 ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "fixed_code": "throw new DimensionMismatchException ( vals . length , dim ) ; } return FastMath . pow ( 2 * FastMath . PI , - dim / 2d ) * FastMath . pow ( covarianceMatrixDeterminant , - 0 . 5 ) * getExponentTerm ( vals ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_11"}
{"buggy_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual / residualsWeights [ i ] ; } return chiSquare ; }", "fixed_code": "double chiSquare = 0 ; for ( int i = 0 ; i < rows ; + + i ) { final double residual = residuals [ i ] ; chiSquare + = residual * residual * residualsWeights [ i ] ; } return chiSquare ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_65"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; markers = ( ArrayList ) this . backgroundRangeMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ;", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : return - val1 ; case 0 : return 0L ; case 1 :", "fixed_code": "public static long safeMultiply ( long val1 , int val2 ) { switch ( val2 ) { case - 1 : if ( val1 = = Long . MIN_VALUE ) { throw new ArithmeticException ( ) ; } return - val1 ; case 0 : return 0L ; case 1 :", "label": 1, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Time_15"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ v . length ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "fixed_code": "} final int nRows = this . getRowDimension ( ) ; final int nCols = this . getColumnDimension ( ) ; final BigDecimal [ ] out = new BigDecimal [ nRows ] ; for ( int row = 0 ; row < nRows ; row + + ) { BigDecimal sum = ZERO ; for ( int i = 0 ; i < nCols ; i + + ) {", "label": 1, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_98"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "propertyNode ) ; } @ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ; for ( String property : properties . keySet ( ) ) { if ( that . toMaybeRecordType ( ) . hasProperty ( property ) & & that . toMaybeRecordType ( ) . getPropertyType ( property ) . isEquivalentTo ( getPropertyType ( property ) ) ) { builder . addProperty ( property , getPropertyType ( property ) , getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "fixed_code": "propertyNode ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) { RecordType thatRecord = that . toMaybeRecordType ( ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / contract with translators is that they have to understand codepoints / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pt ) ) ; } } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . return new BigDecimal ( str ) ; }", "fixed_code": "if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x if ( str . startsWith ( \" - \" ) ) { / / drop - if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . trim ( ) . startsWith ( \" - - \" ) ) { / / this is protection for poorness in java . lang . BigDecimal . / / it accepts this as a legal value , but it does not appear / / to be in specification of class . OS X Java parses it to / / a wrong value . throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } return new BigDecimal ( str ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ;", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "public boolean isSupportLowerBoundInclusive ( ) { return true ; }", "fixed_code": "public boolean isSupportLowerBoundInclusive ( ) { return false ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_22"}
{"buggy_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final int n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "fixed_code": "final int n2 ) throws ConvergenceException , MaxCountExceededException { final double n1n2prod = n1 * n2 ; / / http : / / en . wikipedia . org / wiki / Mann % E2 % 80 % 93Whitney_U # Normal_approximation final double EU = n1n2prod / 2 . 0 ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_30"}
{"buggy_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return chromosomes . iterator ( ) ; } }", "fixed_code": "* @ return chromosome iterator public Iterator < Chromosome > iterator ( ) { return getChromosomes ( ) . iterator ( ) ; } }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_34"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 1, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( new Gaussian . Parametric ( ) , guess ) ; }", "fixed_code": "public double [ ] fit ( ) { final double [ ] guess = ( new ParameterGuesser ( getObservations ( ) ) ) . guess ( ) ; return fit ( guess ) ; }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } } / / Just a ' label ' .", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 } / / Just a ' label ' .", "label": 1, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "fixed_code": "} if ( this . maxMiddleIndex > = 0 ) { long s = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long maxMiddle = s + ( e - s ) / 2 ; if ( middle > maxMiddle ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] . getClass ( ) ; } return classes ; }", "fixed_code": "} Class < ? > [ ] classes = new Class [ array . length ] ; for ( int i = 0 ; i < array . length ; i + + ) { classes [ i ] = array [ i ] = = null ? null : array [ i ] . getClass ( ) ; } return classes ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_33"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { if ( searchList [ i ] = = null | | replacementList [ i ] = = null ) { continue ; } int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { next ( pos ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "} double sumWts = 0 ; for ( int i = 0 ; i < weights . length ; i + + ) { sumWts + = weights [ i ] ; }", "fixed_code": "} double sumWts = 0 ; for ( int i = begin ; i < begin + length ; i + + ) { sumWts + = weights [ i ] ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( isNaN | | rhs . isNaN ) { return NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : a ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset = = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "fixed_code": "* @ since 1 . 0 . 3 public int getDomainAxisIndex ( CategoryAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } return this . domainAxes . indexOf ( axis ) ; } * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { if ( axis = = null ) { throw new IllegalArgumentException ( \" Null ' axis ' argument . \" ) ; } int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }", "fixed_code": "public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { super ( paint , stroke , outlinePaint , outlineStroke , alpha ) ; this . value = value ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_20"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( v - this . lowerBound ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "} } Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } }", "fixed_code": "} } if ( r ! = null ) { Collection c = r . getAnnotations ( ) ; Iterator i = c . iterator ( ) ; while ( i . hasNext ( ) ) { includedAnnotations . add ( a ) ; } } } } }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_4"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) {", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( endIndex < 0 ) | | ( endIndex < startIndex ) ) { emptyRange = true ; } if ( emptyRange ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < = sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return availableLocaleList ( ) . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , width , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return NaN ; } if ( isInfinite ) {", "fixed_code": "} if ( real = = 0 . 0 & & imaginary = = 0 . 0 ) { return INF ; } if ( isInfinite ) {", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . int sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "fixed_code": "while ( resultSet . size ( ) < k ) { / / For each data point x , compute D ( x ) , the distance between x and / / the nearest center that has already been chosen . double sum = 0 ; for ( int i = 0 ; i < pointSet . size ( ) ; i + + ) { final T p = pointSet . get ( i ) ; final Cluster < T > nearest = getNearestCluster ( resultSet , p ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; }", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "@ Deprecated public double getPct ( Object v ) { return getCumPct ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public double getPct ( Object v ) { return getPct ( ( Comparable < ? > ) v ) ; }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_75"}
{"buggy_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { int sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final int dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "fixed_code": "* @ return the L < sub > 2 < / sub > distance between the two points public static double distance ( int [ ] p1 , int [ ] p2 ) { double sum = 0 ; for ( int i = 0 ; i < p1 . length ; i + + ) { final double dp = p1 [ i ] - p2 [ i ] ; sum + = dp * dp ; } return Math . sqrt ( sum ) ;", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_79"}
{"buggy_code": "@ Deprecated public void addValue ( Object v ) { addValue ( ( Comparable < ? > ) v ) ; }", "fixed_code": "@ Deprecated public void addValue ( Object v ) { if ( v instanceof Comparable < ? > ) { addValue ( ( Comparable < ? > ) v ) ; } else { throw new IllegalArgumentException ( \" Object must implement Comparable \" ) ; } }", "label": 1, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_89"}
{"buggy_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "fixed_code": "if ( minRatioPositions . size ( ) = = 0 ) { return null ; } else if ( minRatioPositions . size ( ) > 1 & & ! ( minRatioPositions . size ( ) > ( double ) 0 . 0 ) ) { / / there ' s a degeneracy as indicated by a tie in the minimum ratio test / / 1 . check if there ' s an artificial variable that can be forced out of the basis", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "fixed_code": "/ / compute the intersection on infinite line Vector3D v1D = line . intersection ( subLine . line ) ; if ( v1D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = remainingRegion . checkPoint ( line . toSubSpace ( v1D ) ) ; / / check location of point with respect to second sub - line / / compute the intersection on infinite line Vector2D v2D = line1 . intersection ( line2 ) ; if ( v2D = = null ) { return null ; } / / check location of point with respect to first sub - line Location loc1 = getRemainingRegion ( ) . checkPoint ( line1 . toSubSpace ( v2D ) ) ; / / check location of point with respect to second sub - line", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "} if ( initial > ( double ) 0 . 0 ) { throw new IllegalArgumentException ( ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 & & ! ( end - start > = ( double ) 0 . 0 ) ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "fixed_code": "* @ version $ Revision $ $ Date $ public final class MathUtils { private static long patch_method ( int n ) { long result = 1 ; for ( int i = 2 ; i < = n ; i + + ) { result * = i ; } return result ; } public static final double EPSILON = 0x1 . 0p - 53 ; if ( n < 0 ) { throw new IllegalArgumentException ( \" must have n > = 0 for n ! \" ) ; } if ( n < ( int ) 20 . 0 ) { return patch_method ( n ) ; } return Math . floor ( Math . exp ( factorialLog ( n ) ) + 0 . 5 ) ; }", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_93"}
{"buggy_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 ) { / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "fixed_code": "/ / Verify bracketing double sign = yMin * yMax ; if ( sign > = 0 & & ! ( sign < = ( double ) 0 . 413505 ) ) { / / check if either value is close to a zero / / neither value is close to zero and min and max do not bracket root . throw new IllegalArgumentException ( \" Function values at endpoints do not have different signs . \" +", "label": 0, "tool_name": "ACS", "patch_name": "patch1", "project_name": "Math_97"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; setPlot ( plot ) ; int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "fixed_code": "w [ 4 ] = size . width ; h [ 4 ] = size . height ; } this . rightBlock = null ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { markers = ( ArrayList ) this . foregroundDomainMarkers . get ( new Integer ( index ) ) ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return removeRangeMarker ( marker , Layer . FOREGROUND ) ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return removeDomainMarker ( index , marker , layer , true ) ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return removeRangeMarker ( 0 , marker , layer ) ; }", "fixed_code": "boolean notify ) { ArrayList markers ; if ( layer = = Layer . FOREGROUND ) { return this . rangeCrosshairVisible ; } else { markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( * @ see # addRangeMarker ( Marker ) public boolean removeRangeMarker ( Marker marker ) { return this . rangeCrosshairVisible ; } public boolean removeDomainMarker ( int index , Marker marker , Layer layer ) { return this . domainZeroBaselineVisible ; } public boolean removeRangeMarker ( Marker marker , Layer layer ) { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "boolean tooltips , boolean urls ) { PiePlot3D plot = new PiePlot3D ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; state . setPassesRequired ( 2 ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return result ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "fixed_code": "boolean tooltips , boolean urls ) { PiePlot plot = new PiePlot ( dataset ) ; plot . setInsets ( new RectangleInsets ( 0 . 0 , 5 . 0 , 5 . 0 , 5 . 0 ) ) ; if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( ) ) ; PiePlot plot , Integer index , PlotRenderingInfo info ) { PiePlotState state = new PiePlotState ( info ) ; g2 . setPaint ( Color . gray ) ; state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset ( ) ) ) ; state . setLatestAngle ( plot . getStartAngle ( ) ) ; LegendItemCollection result = new LegendItemCollection ( ) ; if ( this . dataset = = null ) { return null ; } List keys = this . dataset . getKeys ( ) ; int section = 0 ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "return ( index ) ; } } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "fixed_code": "return ( index ) ; } } if ( object = = null ) { throw new IllegalArgumentException ( \" Null ' object ' argument . \" ) ; } return - 1 ; } public void setRangeAxis ( int index , ValueAxis axis , boolean notify ) { ValueAxis existing = ( ValueAxis ) this . rangeAxes . get ( index ) ; this . orientation = PlotOrientation . VERTICAL ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } if ( axis ! = null ) { if ( axis ! = null ) { axis . setPlot ( this ) ; axis . addChangeListener ( this ) ; } axis . setPlot ( this ) ; } this . rangeAxes . set ( index , axis ) ; if ( axis ! = null ) { * @ since 1 . 0 . 7 public int getRangeAxisIndex ( ValueAxis axis ) { this . rangeGridlinesVisible = true ; int result = this . rangeAxes . indexOf ( axis ) ; if ( result < 0 ) { / / try the parent plot Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_19"}
{"buggy_code": "int row , int column ) { RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else if ( lclip < = 0 . 0 ) { / / cases 5 , 6 , 7 and 8 if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { / / cases 9 , 10 , 11 and 12 if ( value < = lclip ) { return ; / / bar is not visible } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getStandardDeviation ( ) ; } return result ; }", "fixed_code": "int row , int column ) { if ( this . errorIndicatorPaint ! = null ) { g2 . setPaint ( this . errorIndicatorPaint ) ; } else { g2 . setPaint ( getItemPaint ( row , column ) ) ; } RectangleEdge xAxisLocation = plot . getDomainAxisEdge ( ) ; / / BAR Y double rectY = domainAxis . getCategoryStart ( column , getColumnCount ( ) , if ( value < = lclip ) { value = lclip ; } } else { rectY = rectY + row * state . getBarWidth ( ) ; if ( lclip < = 0 . 0 ) { if ( value > = uclip ) { value = uclip ; } else { if ( value < = lclip ) { value = lclip ; } } } else { if ( value < = lclip ) { return ; } base = getLowerClip ( ) ; if ( value > = uclip ) { value = uclip ; } } } RectangleEdge yAxisLocation = plot . getRangeAxisEdge ( ) ; double transY1 = rangeAxis . valueToJava2D ( base , dataArea , yAxisLocation ) ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { } return result ; } Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; result = masd . getStandardDeviation ( ) ; return result ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else if ( ! this . timePeriodClass . equals ( c ) ) { StringBuffer b = new StringBuffer ( ) ; b . append ( \" You are trying to add data where the time period class \" ) ; b . append ( \" is \" ) ; b . append ( item . getPeriod ( ) . getClass ( ) . getName ( ) ) ; b . append ( \" , but the TimeSeries is expecting an instance of \" ) ; b . append ( this . timePeriodClass . getName ( ) ) ; b . append ( \" . \" ) ; throw new SeriesException ( b . toString ( ) ) ; } / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; add ( item , notify ) ; }", "fixed_code": "Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) { this . timePeriodClass = c ; } else findBoundsByIteration ( ) ; / / make the change ( if it ' s not a duplicate time period ) . . . boolean added = false ; public void add ( RegularTimePeriod period , double value , boolean notify ) { / / defer argument checking . . . TimeSeriesDataItem item = new TimeSeriesDataItem ( period , value ) ; if ( notify ) { fireSeriesChanged ( ) ; } add ( item , notify ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . minEndIndex = index ; } } else {", "fixed_code": "long minEnd = getDataItem ( this . minEndIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; if ( end < minEnd ) { this . data . remove ( index ) ; this . minEndIndex = index ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return \" Node tree inequality : \" + \" \\ nTree1 : \\ n \" + toStringTree ( ) + \" \\ n \\ nTree2 : \\ n \" + node2 . toStringTree ( ) + \" \\ n \\ nSubtree1 : \" + diff . nodeA . toStringTree ( ) + \" \\ n \\ nSubtree2 : \" + diff . nodeB . toStringTree ( ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else { break ; } } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "fixed_code": "public String checkTreeEquals ( Node node2 ) { NodeMismatch diff = checkTreeEqualsImpl ( node2 ) ; if ( diff ! = null ) { return toString ( true , true , true ) ; } return null ; } Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; break ; } } else { callSiteOptimizer . optimize ( fnScope , referenced ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : return \" GT \" ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ; case NE : return \" NE \" ; case LT : return \" LT \" ; case LE : return \" LE \" ; case GT : ; case GE : return \" GE \" ; case LSH : return \" LSH \" ; case RSH : return \" RSH \" ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else if ( paramType . isFunctionType ( ) ) { FunctionType paramFunctionType = paramType . toMaybeFunctionType ( ) ; FunctionType argFunctionType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) . toMaybeFunctionType ( ) ; if ( argFunctionType ! = null & & argFunctionType . isSubtype ( paramType ) ) { maybeResolveTemplatedType ( paramFunctionType . getTypeOfThis ( ) , argFunctionType . getTypeOfThis ( ) , resolvedTypes ) ; maybeResolveTemplatedType ( paramFunctionType . getReturnType ( ) , argFunctionType . getReturnType ( ) , resolvedTypes ) ; maybeResolveTemplateTypeFromNodes ( paramFunctionType . getParameters ( ) , argFunctionType . getParameters ( ) , resolvedTypes ) ; } } else if ( paramType . isTemplatizedType ( ) ) { ObjectType referencedParamType = paramType . toMaybeTemplatizedType ( ) . getReferencedType ( ) ; JSType argObjectType = argType . restrictByNotNullOrUndefined ( ) . collapseUnion ( ) ;  if ( argObjectType . isSubtype ( referencedParamType ) ) { TemplateTypeMap paramTypeMap = paramType . getTemplateTypeMap ( ) ; TemplateTypeMap argTypeMap = argObjectType . getTemplateTypeMap ( ) ; for ( TemplateType key : paramTypeMap . getTemplateKeys ( ) ) { maybeResolveTemplatedType ( paramTypeMap . getTemplateType ( key ) , argTypeMap . getTemplateType ( key ) , resolvedTypes ) ; } } } } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; propertyType = propertyType . visit ( replacer ) ; } }", "fixed_code": "for ( JSType alernative : unionType . getAlternates ( ) ) { maybeResolveTemplatedType ( alernative , argType , resolvedTypes ) ; } } else ; } private void maybeResolveTemplateTypeFromNodes ( TemplateTypeMap typeMap = restrictedObjType . getTemplateTypeMap ( ) ; TemplateTypeMapReplacer replacer = new TemplateTypeMapReplacer ( registry , typeMap ) ; return null ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; if ( parent ! = null ) { while ( parent . isHook ( ) ) { parent = parent . getParent ( ) ; }  if ( parent . isName ( ) ) { return scopes . get ( parent ) ; }  if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }  return Collections . emptyList ( ) ; }", "fixed_code": "/ / Function expression . try to get a name from the parent var / / declaration or assignment . Node parent = function . getParent ( ) ; return Collections . emptyList ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return true ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; if ( isExpressionTreeUnsafe ( functionExpression , state . sideEffects ) & & functionExpression . getFirstChild ( ) ! = grandchild ) { Preconditions . checkState ( allowObjectCallDecomposing ( ) , \" Object method calls can not be decomposed . \" ) ; state . sideEffects = true ;  Node replacement = rewriteCallExpression ( parent , state ) ; parent = replacement ; } } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "/ / Only inline functions that return something . if ( block . getFirstChild ( ) . isReturn ( ) & & block . getFirstChild ( ) . getFirstChild ( ) ! = null ) { return false ; } } & & NodeUtil . isGet ( parent . getFirstChild ( ) ) ) { Node functionExpression = parent . getFirstChild ( ) ; decomposeSubExpressions ( functionExpression . getNext ( ) , child , state ) ; } else if ( parentType = = Token . OBJECTLIT ) { decomposeObjectLiteralKeys ( parent . getFirstChild ( ) , child , state ) ; } else { } res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_116"}
{"buggy_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { return objectType . toString ( ) + \" . \" + propName ; } } }", "fixed_code": "if ( objectType ! = null & & ( objectType . getConstructor ( ) ! = null | | objectType . isFunctionPrototypeType ( ) ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; declareVar ( var ) ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateChildCount ( n , 1 ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "fixed_code": "final Node var = n . getFirstChild ( ) ; final Node block = var . getNext ( ) ; ; scanVars ( block ) ; return ; / / only one child to scan private void validateThrow ( Node n ) { validateNodeType ( Token . THROW , n ) ; validateExpression ( n . getFirstChild ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "refMap = Maps . newHashMap ( ) ; for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { refMap . put ( var . getName ( ) , entry . getValue ( ) ) ; } } }", "fixed_code": "for ( Entry < Var , ReferenceCollection > entry : globalRefMap . entrySet ( ) ) { Var var = entry . getKey ( ) ; if ( var . isGlobal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; }", "fixed_code": "/ / Dive down the right side of the assign . parent = next ; next = leftSide . getNext ( ) ; } else { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "fixed_code": "case Token . SHEQ : if ( outcome ) { } else { return caseEquality ( condition , blindScope , SHNE ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "} } restoreLookAhead ( token ) ; return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "} } return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; if ( gramps . isCall ( ) & & parent = = gramps . getFirstChild ( ) ) { if ( n = = parent . getFirstChild ( ) & & parent . getChildCount ( ) = = 2 & & n . getNext ( ) . isName ( ) & & \" eval \" . equals ( n . getNext ( ) . getString ( ) ) ) { return ; } }  / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } }", "fixed_code": "/ / fix up the tree in more clever ways when these are removed . if ( parent . getType ( ) = = Token . COMMA ) { Node gramps = parent . getParent ( ) ; / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) ; else break ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { return false ; } } }", "fixed_code": "} } else { if ( ! propA . isSubtype ( propB ) ) { } } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; if ( i = = MAX_PRETTY_PRINTED_PROPERTIES ) { sb . append ( \" , . . . \" ) ; break ; } } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { return registry . getNativeObjectType ( JSTypeNative . OBJECT_TYPE ) ; } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return false ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } for ( String property : thatRecord . properties . keySet ( ) ) { if ( ! hasProperty ( property ) ) { builder . addProperty ( property , thatRecord . getPropertyType ( property ) , thatRecord . getPropertyNode ( property ) ) ; } }  return builder . build ( ) ; }", "fixed_code": "sb . append ( getPropertyType ( property ) . toString ( ) ) ; + i ; } sb . append ( \" } \" ) ; public JSType build ( ) { / / If we have an empty record , simply return the object type . if ( isEmpty ) { } return registry . createRecordType ( Collections . unmodifiableMap ( properties ) ) ; Set < String > keySet = properties . keySet ( ) ; Map < String , JSType > otherProps = otherRecord . properties ; if ( ! otherProps . keySet ( ) . equals ( keySet ) ) { return true ; } for ( String key : keySet ) { if ( ! otherProps . get ( key ) . isEquivalentTo ( properties . get ( key ) ) ) { getPropertyNode ( property ) ) ; } return builder . build ( ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return NodeUtil . isFunctionExpression ( n ) ; }", "fixed_code": "/ / Estimate savings int savings = 0 ; for ( Reduction reduction : reductions ) { } / / Compare estimated savings against the helper cost . Apply } private static boolean isReduceableFunctionExpression ( Node n ) { return false ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "fixed_code": "for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ; if ( canRemove ) { declaration . remove ( ) ; changed = true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ; return false ;", "fixed_code": "case EOF : / / discard any accumulated information jsdocBuilder . build ( null ) ; ; checkExtendedTypes ( extendedTypes ) ; return false ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return false ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "fixed_code": "boolean checkUnionEquivalenceHelper ( UnionType that , boolean tolerateUnknowns ) { if ( ! tolerateUnknowns & & alternates . size ( ) ! = that . alternates . size ( ) ) { return true ; } for ( JSType alternate : that . alternates ) { if ( ! hasAlternate ( alternate , tolerateUnknowns ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { appendHexJavaScriptRepresentation ( sb , c ) ; } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } out . append ( \" \\ \\ u \" ) . append ( HEX_CHARS [ ( codePoint > > > 12 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 8 ) & 0xf ] ) . append ( HEX_CHARS [ ( codePoint > > > 4 ) & 0xf ] ) . append ( HEX_CHARS [ codePoint & 0xf ] ) ; } } } try { return Double . parseDouble ( s ) ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "fixed_code": "if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { } } } appendHexJavaScriptRepresentation ( surrogates [ 1 ] , out ) ; return ; } } } } try { return null ; } catch ( NumberFormatException e ) { return Double . NaN ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "reportCodeChange ( ) ; return result ; } return n ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "reportCodeChange ( ) ; return result ; } return null ; } protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; compiler . reportCodeChange ( ) ; } } private void applyCollapses ( ) { for ( Collapse collapse : collapses ) {  Node var = new Node ( Token . VAR ) ; var . copyInformationFrom ( collapse . startNode ) ; collapse . parent . addChildBefore ( var , collapse . startNode ) ;  boolean redeclaration = false ; for ( Node n = collapse . startNode ; n ! = collapse . endNode ; ) { Node next = n . getNext ( ) ;  Preconditions . checkState ( var . getNext ( ) = = n ) ; collapse . parent . removeChildAfter ( var ) ;  if ( n . isVar ( ) ) { while ( n . hasChildren ( ) ) { var . addChildToBack ( n . removeFirstChild ( ) ) ; } } else { Node assign = n . getFirstChild ( ) ; Node lhs = assign . getFirstChild ( ) ; Preconditions . checkState ( lhs . isName ( ) ) ; Node rhs = assign . getLastChild ( ) ; lhs . addChildToBack ( rhs . detachFromParent ( ) ) ; var . addChildToBack ( lhs . detachFromParent ( ) ) ; redeclaration = true ; } n = next ; }  if ( redeclaration ) { JSDocInfo info = new JSDocInfo ( ) ; info . addSuppression ( \" duplicate \" ) ; var . setJSDocInfo ( info ) ; } } } }", "fixed_code": "if ( ! collapses . isEmpty ( ) ) { applyCollapses ( ) ; } } private void applyCollapses ( ) { } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + separator . length ( ) ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) { return EMPTY ; } StringBuilder buf = new StringBuilder ( 256 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "public EventListenerSupport ( Class < L > listenerInterface , ClassLoader classLoader ) { this ( ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . notNull ( listenerInterface , \" Listener interface cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; * @ param classLoader the class loader to be used private void createProxy ( Class < L > listenerInterface , ClassLoader classLoader ) { Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; proxy = listenerInterface . cast ( Proxy . newProxyInstance ( classLoader , new Class [ ] { listenerInterface } , createInvocationHandler ( ) ) ) ; } throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / we have more points before the sign change , drop the lowest point } else { - end ; }", "fixed_code": "/ / we have more points before the sign change , drop the lowest point + start ; } else { + + start ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "int idx = 1 ; while ( count < index ) { count + = idx ; + + idx ; } - idx ; indices [ last ] = idx ;", "fixed_code": "int idx = 1 ; while ( count < index ) { count + = idx ; while ( count < index ) { count + = idx ; + + idx ; } + + idx ; } indices [ last ] = idx ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_56"}
{"buggy_code": "stepSize = hNew ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "fixed_code": "stepSize = hNew ; lastStep = manager . stop ( ) ; final double stepEnd = stepStart + stepSize ; interpolator . setInterpolatedTime ( stepEnd ) ; System . arraycopy ( interpolator . getInterpolatedState ( ) , 0 , yTmp , 0 , y0 . length ) ; / / discrete events handling interpolatorTmp . reinitialize ( stepEnd , stepSize , correctedScaled , nordsieckTmp ) ; setMaxGrowth ( 10 . 0 ) ; interpolatorTmp . storeTime ( stepStart ) ; interpolatorTmp . shift ( ) ; interpolatorTmp . storeTime ( stepEnd ) ; if ( manager . evaluateStep ( interpolatorTmp ) ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_74"}
{"buggy_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; qMax = Math . max ( qMax , Math . max ( work [ 3 + pingPong ] , work [ 7 + pingPong ] ) ) ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType - = 12 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "work [ l - 2 * pingPong ] = Math . min ( work [ l - 2 * pingPong ] , Math . min ( work [ 6 + pingPong ] , work [ 6 + pingPong ] ) ) ; dMin = 0 . 0 ; dMin = - 0 . 0 ; } } } else { / / early failure . Divide by 4 . tau * = 0 . 25 ; tType = - 8 ; } } else if ( Double . isNaN ( dMin ) ) { tau = 0 . 0 ; / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { j - = 4 ; } return true ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} } else if ( dMin = = dN2 ) { tType = - 5 ; double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "fixed_code": "} } else if ( dMin = = dN2 ) { double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) {", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "coefficients [ i ] = 0 ; } else { basicRows . add ( basicRow ) ; for ( int artificialVar = 0 ; artificialVar < numArtificialVariables ; artificialVar + + ) { int row = getBasicRow ( getArtificialVariableOffset ( ) + artificialVar ) ; subtractRow ( 0 , row , 1 . 0 ) ; } coefficients [ i ] = ( basicRow = = null ? 0 : getEntry ( basicRow , getRhsOffset ( ) ) ) - ( restrictToNonNegative ? 0 : mostNegative ) ; } Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; break ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ;", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "public double inverseCumulativeProbability ( final double p ) throws MathException { setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; if ( p = = 0 ) { return 0d ; } if ( p = = 1 ) { double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return 0 ; }", "label": 0, "tool_name": "Arja", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "public Range ( double lower , double upper ) { if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower + \" ) < = upper ( \" + upper + \" ) . \" ; throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "public Range ( double lower , double upper ) { if ( lower > upper ) {  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = this . annotations . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = \" Too many elements \" ; Font sfont = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  }", "fixed_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( this . rangeGridlinesVisible | | b2 ) { return ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( y ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "compiler . getCodingConvention ( ) , globalName , value , v . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "fixed_code": "compiler . getCodingConvention ( ) , globalName , value , grandparent . getJSDocInfo ( ) ) . useSourceInfoIfMissingFromForTree ( n ) ; NodeUtil . setDebugInformation ( newDecl . getFirstChild ( ) . getFirstChild ( ) , n , name ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( allCatchNodes , exitType , labelName ) ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( gramps = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else assignedToUnknownValue = true ; } if ( assignedToUnknownValue & & hasPropertyAssign ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = rhsValue . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "fixed_code": "JSType valueType = getDeclaredType ( t . getSourceName ( ) , info , n , rhsValue ) ; if ( valueType = = null & & rhsValue ! = null ) { / / Determining type for # 5 valueType = ownerNode . getJSType ( ) ; } / / Function prototypes are special . / / It ' s a common JS idiom to do :", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_48"}
{"buggy_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "} @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } }", "fixed_code": "}  }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( 16 ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "fixed_code": "/ / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = searchList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } } case 4 : { char ch = str . charAt ( 0 ) ;", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & & ( str . charAt ( 2 ) = = ' S ' | | str . charAt ( 2 ) = = ' s ' ) ; } case 4 : { char ch = str . charAt ( 0 ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "fixed_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = endValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - upper ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; }", "fixed_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( f0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "fixed_code": "assignPointsToClusters ( clusters , points ) ; / / iterate through updating the centers until we ' re done final int max = ( maxIterations < = 0 ) ? Integer . MAX_VALUE : maxIterations ; for ( int count = 0 ; count < max ; count + + ) { boolean clusteringChanged = false ; List < Cluster < T > > newClusters = new ArrayList < Cluster < T > > ( ) ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r2 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "fixed_code": "/ / Inverse quadratic interpolation . double r1 = y0 / y2 ; double r2 = y1 / y2 ; p = r3 * ( dx * r1 * ( r1 - r2 ) - ( x1 - x0 ) * ( r1 - 1 . 0 ) ) ; p1 = ( r1 - 1 . 0 ) * ( r2 - 1 . 0 ) * ( r3 - 1 . 0 ) ; } if ( p > 0 . 0 ) {", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * start ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , this . epsilon , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return d ; }", "label": 0, "tool_name": "AVATAR", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "fixed_code": "int start = pos . getIndex ( ) ; char [ ] c = pattern . toCharArray ( ) ; if ( escapingOn & & c [ start ] = = QUOTE ) { getQuotedString ( pattern , pos , false ) ; return appendTo = = null ? null : appendTo . append ( QUOTE ) ; } int lastHold = start ; for ( int i = pos . getIndex ( ) ; i < pattern . length ( ) ; i + + ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 5 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( ( size ) + 4 ) ) ; ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch11", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch12", "project_name": "Lang_59"}
{"buggy_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "fixed_code": "ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; ensureCapacity ( ( ( size ) + 4 ) ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch13", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 4 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 5 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Lang_59"}
{"buggy_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { ensureCapacity ( ( ( size ) + 4 ) ) ; str . getChars ( 0 , strLen , buffer , size ) ; } else { int padLen = width - strLen ; str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; ensureCapacity ( ( ( size ) + 5 ) ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) { str . getChars ( 0 , strLen , buffer , size ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Lang_59"}
{"buggy_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "fixed_code": "* @ return this , to enable chaining public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { ensureCapacity ( ( ( size ) + 5 ) ) ; if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 5 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Lang_59"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + ( size ) + 4 ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Lang_59"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . multiply ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < pingPong ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 3 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch10", "project_name": "Math_80"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( this . add ( org . apache . commons . math3 . complex . Complex . I ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * b > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( c . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "fixed_code": "} if ( other instanceof Complex ) { Complex c = ( Complex ) other ; if ( org . apache . commons . math3 . complex . Complex . I . subtract ( this ) . isNaN ) { return isNaN ; } else { return ( real = = c . real ) & & ( imaginary = = c . imaginary ) ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = 0 . 0 | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_63"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < 2 * ( pingPong ) ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( numIterations < maximumIterations ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "CapGen", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Math_63"}
{"buggy_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ i + k ] = tmp ; } j - = 4 ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch4", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > = 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Math_63"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ j - k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch5", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Math_63"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ i + k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch6", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( x = = 0 . 0 ? 0 . 0 : x > 0 . 0 ? 1 . 0 : - 1 . 0 ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * 2 * ( pingPong ) - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch7", "project_name": "Math_80"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( org . apache . commons . math . util . MathUtils . TWO_PI ) & & Double . isNaN ( y ) ) | | x = = y ; }", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 4 * ( n - 1 ) ) + ( pingPong ) ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch8", "project_name": "Math_80"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + 1 ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ;", "label": 0, "tool_name": "CapGen", "patch_name": "patch9", "project_name": "Math_80"}
{"buggy_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "fixed_code": "contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( value - this . lowerBound ) / ( this . upperBound this . lowerBound ) * 255 . 0 ) ; return new Color ( g , g , g ) ; }", "fixed_code": "public Paint getPaint ( double value ) { double v = Math . max ( value , this . lowerBound ) ; v = Math . min ( v , this . upperBound ) ; int g = ( int ) ( ( java . lang . Math . min ( v , upperBound ) ) / ( this . upperBound return new Color ( g , g , g ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_24"}
{"buggy_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( index , shape ) ; }", "fixed_code": "* @ param shape the { @ link Shape } . public void setShape ( int index , Shape shape ) { set ( org . jfree . chart . util . AbstractObjectList . DEFAULT_INITIAL_CAPACITY , shape ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Chart_6"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( sourceExcerpt ! = null ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "@ Override public boolean equals ( Object other ) { if ( this = = other ) { return true ; } if ( other instanceof Complex ) {", "fixed_code": "@ Override public boolean equals ( Object other ) { if ( ( java . lang . Double . isNaN ( imaginary ) ) | | ( java . lang . Double . isNaN ( real ) ) ) { return true ; } if ( other instanceof Complex ) {", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_5"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , 1 ) ; } public static boolean equals ( double x , double y , double eps ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = eps ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return equalsIncludingNaN ( x , y ) | | ( FastMath . abs ( y - x ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . assert maxUlps > 0 & & maxUlps < NAN_GAP ; long xInt = Double . doubleToLongBits ( x ) ; long yInt = Double . doubleToLongBits ( y ) ; / / Make lexicographically ordered as a two ' s - complement integer . if ( xInt < 0 ) { xInt = SGN_MASK - xInt ; } if ( yInt < 0 ) { yInt = SGN_MASK - yInt ; } final boolean isEqual = FastMath . abs ( xInt - yInt ) < = maxUlps ; return isEqual & & ! Double . isNaN ( x ) & & ! Double . isNaN ( y ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | equals ( x , y , maxUlps ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( x . length ! = y . length ) { return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equalsIncludingNaN ( x [ i ] , y [ i ] ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return factorial ( n ) ; } return FastMath . floor ( FastMath . exp ( factorialLog ( n ) ) + 0 . 5 ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return FastMath . log ( factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = Integer . MIN_VALUE ) | | ( v = = Integer . MIN_VALUE ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return FastMath . abs ( u ) + FastMath . abs ( v ) ; } / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) if ( u > 0 ) { u = - u ; } / / make u negative if ( v > 0 ) { v = - v ; } / / make v negative / / B1 . [ Find power of 2 ] int k = 0 ; while ( ( u & 1 ) = = 0 & & ( v & 1 ) = = 0 & & k < 31 ) { / / while u and v are / / both even . . . u / = 2 ; v / = 2 ;", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return (    / / Check that \" maxUlps \" is non - negative and small enough so that / / NaN won ' t compare as equal to anything ( except another NaN ) . / / Make lexicographically ordered as a two ' s - complement integer . / / keep u and v negative , as negative integers range down to / / - 2 ^ 31 , while positive numbers can only be as large as 2 ^ 31 - 1 / / ( i . e . we can ' t necessarily negate a negative number without / / overflow ) / / B1 . [ Find power of 2 ] ( ( ( ( ( NAN_GAP ) & 1 ) = = 0 ) & & ( ( ( NAN_GAP ) & 1 ) = = 0 ) ) & & ( ( NAN_GAP ) < 31 ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( x = = y ) ; } public static boolean equalsIncludingNaN ( double x , double y ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) ; } public static boolean equals ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equals ( x , y , 1 ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equalsIncludingNaN ( double x , double y , double eps ) { return ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x , y ) ) | | ( ( org . apache . commons . math . util . FastMath . abs ( ( y - x ) ) ) < = eps ) ; } public static boolean equals ( double x , double y , int maxUlps ) { assert ( maxUlps > 0 ) & & ( maxUlps < ( org . apache . commons . math . util . MathUtils . NAN_GAP ) ) ; long xInt = java . lang . Double . doubleToLongBits ( x ) ; long yInt = java . lang . Double . doubleToLongBits ( y ) ; if ( xInt < 0 ) { xInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - xInt ; } if ( yInt < 0 ) { yInt = ( org . apache . commons . math . util . MathUtils . SGN_MASK ) - yInt ; } final boolean isEqual = ( org . apache . commons . math . util . FastMath . abs ( ( xInt - yInt ) ) ) < = maxUlps ; return ( isEqual & & ( ! ( java . lang . Double . isNaN ( x ) ) ) ) & & ( ! ( java . lang . Double . isNaN ( y ) ) ) ; } public static boolean equalsIncludingNaN ( double x , double y , int maxUlps ) { return ( ( java . lang . Double . isNaN ( x ) ) & & ( java . lang . Double . isNaN ( y ) ) ) | | ( org . apache . commons . math . util . MathUtils . equals ( x , y , maxUlps ) ) ; } public static boolean equals ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equals ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static boolean equalsIncludingNaN ( double [ ] x , double [ ] y ) { if ( ( x = = null ) | | ( y = = null ) ) { return ! ( ( x = = null ) ^ ( y = = null ) ) ; } if ( ( x . length ) ! = ( y . length ) ) { return false ; } for ( int i = 0 ; i < ( x . length ) ; + + i ) { if ( ! ( org . apache . commons . math . util . MathUtils . equalsIncludingNaN ( x [ i ] , y [ i ] ) ) ) { return false ; } } return true ; } public static long factorial ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n > 20 ) { throw new java . lang . ArithmeticException ( \" factorial value is too large to fit in a long \" ) ; } return org . apache . commons . math . util . MathUtils . FACTORIALS [ n ] ; } public static double factorialDouble ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . MathUtils . factorial ( n ) ; } return org . apache . commons . math . util . FastMath . floor ( ( ( org . apache . commons . math . util . FastMath . exp ( org . apache . commons . math . util . MathUtils . factorialLog ( n ) ) ) + 0 . 5 ) ) ; } public static double factorialLog ( final int n ) { if ( n < 0 ) { throw org . apache . commons . math . MathRuntimeException . createIllegalArgumentException ( org . apache . commons . math . exception . util . LocalizedFormats . FACTORIAL_NEGATIVE_PARAMETER , n ) ; } if ( n < 21 ) { return org . apache . commons . math . util . FastMath . log ( org . apache . commons . math . util . MathUtils . factorial ( n ) ) ; } double logSum = 0 ; for ( int i = 2 ; i < = n ; i + + ) { logSum + = org . apache . commons . math . util . FastMath . log ( i ) ; } return logSum ; } public static int gcd ( final int p , final int q ) { int u = p ; int v = q ; if ( ( u = = 0 ) | | ( v = = 0 ) ) { if ( ( u = = ( java . lang . Integer . MIN_VALUE ) ) | | ( v = = ( java . lang . Integer . MIN_VALUE ) ) ) { throw org . apache . commons . math . MathRuntimeException . createArithmeticException ( org . apache . commons . math . exception . util . LocalizedFormats . GCD_OVERFLOW_32_BITS , p , q ) ; } return ( org . apache . commons . math . util . FastMath . abs ( u ) ) + ( org . apache . commons . math . util . FastMath . abs ( v ) ) ; } if ( u > 0 ) { u = - u ; } if ( v > 0 ) { v = - v ; } int k = 0 ; while ( ( ( ( u & 1 ) = = 0 ) & & ( ( v & 1 ) = = 0 ) ) & & ( k < 31 ) ) {  u / = 2 ; v / = 2 ; / / both even . . . u / = 2 ; v / = 2 ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "return solve ( f , max , max ) ; }", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = getMean ( ) ; } return ret ;", "fixed_code": "if ( p < 0 . 5 ) { ret = - ( Double . MAX_VALUE ) ; } else { ret = ( ( standardDeviation ) - ( standardDeviation ) ) / ( ( mean ) * ( java . lang . Math . sqrt ( 2 . 0 ) ) ) ; } return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = p - 2 . 0 ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Cardumen", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; }", "fixed_code": "CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { if ( dataset ! = null ) { return result ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; g2 . setClip ( savedClip ) ;", "fixed_code": "if ( info ! = null ) { plotInfo = info . getPlotInfo ( ) ; } if ( false ) { this . plot . draw ( g2 , plotArea , anchor , null , plotInfo ) ; } g2 . setClip ( savedClip ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "public void removeColumn ( Comparable columnKey ) { this . data . removeColumn ( columnKey ) ; fireDatasetChanged ( ) ;", "fixed_code": "public void removeColumn ( Comparable columnKey ) { if ( false ) { this . data . removeColumn ( columnKey ) ; } fireDatasetChanged ( ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( false ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( true ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "int newdiff = startValue - endValue ; if ( false ) { end . add ( field , newdiff ) ; } return newdiff ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( x < = 1 ) | | ( y < = x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "} if ( max ( diagD ) > 1e14 * min ( diagD ) ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "fixed_code": "} if ( this . dimension = = 1 ) { double tfac = max ( diagD ) / 1e14 - min ( diagD ) ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) {", "fixed_code": "final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; }", "fixed_code": "if ( values [ 0 ] < = length ) { if ( test ( values , weights , begin , length ) ) { clear ( ) ; if ( length = = 1 ) { var = 0 . 0 ; } else if ( length > 1 ) { Mean mean = new Mean ( ) ; double m = mean . evaluate ( values , weights , begin , length ) ; var = evaluate ( values , weights , m , begin , length ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( this . DEFAULT_ZERO_TOLERANCE = = this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "} sum2 = 0 ; for ( int j = 0 ; j < solvedCols ; + + j ) {", "fixed_code": "} if ( this . costRelativeTolerance ! = this . orthoTolerance ) { sum2 = 0 ; } for ( int j = 0 ; j < solvedCols ; + + j ) {", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; }", "fixed_code": "public void setInitialStepSize ( final double initialStepSize ) { if ( false ) { if ( ( initialStepSize < minStep ) | | ( initialStepSize > maxStep ) ) { initialStep = - 1 . 0 ; } else { initialStep = initialStepSize ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "if ( false ) { for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; }", "fixed_code": "int j = 4 * n - 1 ; if ( false ) { for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ;", "fixed_code": "final double gam = dN2 ; if ( true ) { return ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( false ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; }", "fixed_code": "if ( fa * fb > = 0 . 0 ) { if ( false ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "{ if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; }", "fixed_code": "{ if ( nameKey . length ( ) ! = 0 ) { if ( fromYear < = toYear ) { OfYear ofYear = new OfYear ( mode , monthOfYear , dayOfMonth , dayOfWeek , advanceDayOfWeek , millisOfDay ) ; Recurrence recurrence = new Recurrence ( ofYear , nameKey , saveMillis ) ; Rule rule = new Rule ( recurrence , fromYear , toYear ) ; getLastRuleSet ( ) . addRule ( rule ) ; } }", "label": 0, "tool_name": "DynaMoth", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default : throw new IllegalArgumentException ( \" Node cannot be refined . \\ n \" + node . toStringTree ( ) ) ; } }", "fixed_code": "/ / \" this \" references aren ' t currently modeled in the CFG . default :  } }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Closure_19"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) { this ( 0 ) ; }", "fixed_code": "* Default constructor , uses default parameters public CMAESOptimizer ( ) {  }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ;", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true to log verbosely public static boolean verbose ( ) { return cVerbose ! = null | | cVerbose . get ( ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "FixMiner", "patch_name": "patch1", "project_name": "Time_11"}
{"buggy_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "fixed_code": "result = ( ValueAxis ) this . rangeAxes . get ( index ) ; } if ( result = = null ) { CategoryAxis xAxis = ( CategoryAxis ) this . domainAxes . get ( index ) ; Plot parent = getParent ( ) ; if ( parent instanceof CategoryPlot ) { CategoryPlot cp = ( CategoryPlot ) parent ; result = cp . getRangeAxis ( index ) ; public void setDataset ( int index , CategoryDataset dataset ) { Object result = null ; CategoryDataset existing = ( CategoryDataset ) this . datasets . get ( index ) ; if ( existing ! = null ) { existing . removeChangeListener ( this ) ; } int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { Paint outlinePaint = plot . getOutlinePaint ( ) ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # getLegend ( ) public void removeLegend ( ) { removeSubtitle ( getLegend ( ) ) ; } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; fireChartChanged ( ) ; }", "fixed_code": "* @ see # getLegend ( ) public void removeLegend ( ) { } public void removeSubtitle ( Title title ) { this . subtitles . remove ( title ) ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "fixed_code": "if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; this . topBlock = null ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; Size2D s1 = arrangeNN ( container , g2 ) ; this . rightBlock = null ; h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) ,", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; }", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { if ( item = = null ) { throw new IllegalArgumentException ( \" Null ' item ' argument . \" ) ; } item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "fixed_code": "* @ param notify notify listeners ? public void add ( TimeSeriesDataItem item , boolean notify ) { updateBoundsForRemovedItem ( item ) ; item = ( TimeSeriesDataItem ) item . clone ( ) ; Class c = item . getPeriod ( ) . getClass ( ) ; if ( this . timePeriodClass = = null ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : tryConvertToNumber ( n . getChildAtIndex ( 1 ) ) ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; replacement = performArithmeticOp ( opType , valueToCombine , right ) ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "fixed_code": "tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . HOOK : ; tryConvertToNumber ( n . getLastChild ( ) ) ; return ; case Token . NAME : Node replacement = performArithmeticOp ( opType , valueToCombine , right ) ; if ( replacement = = null ) { valueToCombine = lr ; int start = 0 ; } if ( replacement ! = null ) { / / Remove the child that has been combined", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { resolvedTemplateType ( resolvedTypes , paramType . toMaybeTemplateType ( ) , argType ) ; } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "fixed_code": "JSType argType , Map < TemplateType , JSType > resolvedTypes ) { if ( paramType . isTemplateType ( ) ) { } else if ( paramType . isUnionType ( ) ) { / / @ param { Array . < T > | NodeList | Arguments | { length : number } } UnionType unionType = paramType . toMaybeUnionType ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } } return Collections . emptyList ( ) ;", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { final String paramName = \" jscomp_throw_param \" ; newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; return scopes . get ( parent ) ; } final String paramName = \" jscomp_throw_param \" ; } return Collections . emptyList ( ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; if ( value . isQualifiedName ( ) & & nextName . equals ( value . getQualifiedName ( ) ) ) {  if ( ! isSafeReplacement ( next , assign ) ) { return false ; }  exprParent . removeChild ( expr ) ; expr . removeChild ( assign ) ; parent . replaceChild ( next , assign ) ; return true ; } } return false ;", "fixed_code": "case Token . NAME : if ( next . isQualifiedName ( ) ) { String nextName = next . getQualifiedName ( ) ; } return false ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "if ( isResultUsed ) { return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "fixed_code": "if ( isResultUsed ) { return ; } int start = 0 ; } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) { return ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;  / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "fixed_code": "Multimap < Reducer , Reduction > reductionMap = HashMultimap . create ( ) ; / / Apply reductions iff they will provide some savings . for ( Reducer reducer : reducers ) { Collection < Reduction > reductions = reductionMap . get ( reducer ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : addVerboseWarnings ( options ) ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "fixed_code": "addDefaultWarnings ( options ) ; break ; case VERBOSE : boolean valid = false ; break ; default : throw new RuntimeException ( \" Unknown warning level . \" ) ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { for ( Symbol declaration : nameInfo . getDeclarations ( ) ) { boolean canRemove = false ;  if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;  if ( specializableFunction ! = null ) { specializationState . reportRemovedFunction ( specializableFunction , null ) ; canRemove = true ; } }  if ( canRemove ) { declaration . remove ( ) ; changed = true ; } }  logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "fixed_code": "boolean changed = false ; for ( NameInfo nameInfo : allNameInfo ) { if ( ! nameInfo . isReferenced ( ) ) { logger . fine ( \" Removed unused prototype property : \" + nameInfo . name ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : return \" POS \" ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > return TernaryValue . TRUE ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; }  n . getParent ( ) . replaceChild ( n , replacement ) ; reportCodeChange ( ) ; }", "fixed_code": "case MOD : return \" MOD \" ; case NOT : return \" NOT \" ; case BITNOT : return \" BITNOT \" ; case POS : ; case NEG : return \" NEG \" ; case NEW : return \" NEW \" ; case DELPROP : return \" DELPROP \" ; static TernaryValue isStrWhiteSpaceChar ( int c ) { switch ( c ) { case ' \\ u000B ' : / / < VT > ; case ' ' : / / < SP > case ' \\ n ' : / / < LF > case ' \\ r ' : / / < CR > } else { replacement = Node . newNumber ( value ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; int start = 0 ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { Double d = createDouble ( str ) ; return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } this . membershipMatrix = null ; this . points = null ; this . clusters = null ; }", "fixed_code": "k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { } } this . membershipMatrix = null ; this . points = null ; boolean emptyCluster = false ; this . clusters = null ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ; } }", "fixed_code": "for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minRow = row ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getLocalizedMessage ( ) ; } }", "fixed_code": "public double getNumericalVariance ( ) { if ( ! numericalVarianceIsCalculated ) { final double logm = FastMath . log ( denominatorDegreesOfFreedom ) ; numericalVariance = calculateNumericalVariance ( ) ; numericalVarianceIsCalculated = true ; } return numericalVariance ; x ) ; } if ( Double . isNaN ( hN ) ) { return - 0 . 0 ; } if ( FastMath . abs ( deltaN - 1 . 0 ) < epsilon ) { @ Override public String getLocalizedMessage ( ) { return context . getMessage ( ) ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else if ( nbPoints = = x . length ) {  nbPoints - - ;  if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; }  } / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { this . allowed = allowedSolution ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "fixed_code": "System . arraycopy ( y , start , y , 0 , nbPoints ) ; signChangeIndex - = start ; } else { signChangeIndex = 2 ; if ( nbPoints = = x . length ) { nbPoints - - ; if ( signChangeIndex > = ( x . length + 1 ) / 2 ) { System . arraycopy ( x , 1 , x , 0 , nbPoints ) ; System . arraycopy ( y , 1 , y , 0 , nbPoints ) ; - - signChangeIndex ; } } } yB = nextY ; / / ( by construction , we know it lies inside the tightest bracketing interval ) System . arraycopy ( x , signChangeIndex , x , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; x [ signChangeIndex ] = nextX ; System . arraycopy ( y , signChangeIndex , y , signChangeIndex + 1 , nbPoints - signChangeIndex ) ; y [ signChangeIndex ] = nextY ; if ( agingB > = MAXIMAL_AGING ) { targetY = - REDUCTION_FACTOR * yA ; } else { targetY = 0 ; } + + nbPoints ; / / update the bracketing interval if ( nextY * yA < = 0 ) { public double solve ( int maxEval , UnivariateFunction f , double min , double max , double startValue , AllowedSolution allowedSolution ) { double x1 = getMax ( ) ; this . allowed = allowedSolution ; verifyInterval ( min , max ) ; return super . solve ( maxEval , f , min , max , startValue ) ; } } try { evaluations . incrementCount ( ) ; } catch ( MaxCountExceededException e ) { double initial = getStartValue ( ) ; throw new TooManyEvaluationsException ( e . getMax ( ) ) ; } } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; break ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ;", "fixed_code": "for ( int i = 4 * ( n0 - 2 ) ; i > = 0 ; i - = 4 ) { if ( work [ i + 2 ] < = 0 ) { i0 = 1 + i / 4 ; } if ( diagMin > = 4 * offDiagMax ) { diagMin = Math . min ( diagMin , work [ i + 4 ] ) ; work [ 4 * deflatedEnd - 3 - pingPong ] = 0 . 0 ; dMin = 0 . 0 ; updateSigma ( tau ) ; final int upperStart = 5 * main . length ; return deflatedEnd ; } else if ( dMin < 0 . 0 ) { / / tau too big . Select new tau and try again . if ( tType < - 22 ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { if ( tType < - 22 ) { tau = 0 . 0 ; } else if ( dMin1 > 0 . 0 ) { tau = ( tau + dMin ) * ( 1 . 0 - 2 . 0 * MathUtils . EPSILON ) ; tType - = 11 ; } else { tau * = 0 . 25 ; tType - = 12 ; } j - = 4 ; } return true ;", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; }  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "fixed_code": "} double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ; } else {", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "fixed_code": "do { a = Math . max ( a - 1 . 0 , lowerBound ) ; int i = 0 ; b = Math . min ( b + 1 . 0 , upperBound ) ; fa = function . value ( a ) ; fb = function . value ( b ) ; ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( p = = 0 ) { return Double . NEGATIVE_INFINITY ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "if ( x < = 0 . 0 ) { ret = 0 . 0 ; } else { setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; double n = getNumeratorDegreesOfFreedom ( ) ; double m = getDenominatorDegreesOfFreedom ( ) ; ret = Beta . regularizedBeta ( ( n * x ) / ( m + n * x ) , double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return p ; }", "label": 0, "tool_name": "GenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( null = = dataset ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "fixed_code": "insets . getRight ( ) ) ; } hotspot = null ; if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( endIndex < 0 ) { emptyRange = true ; }", "fixed_code": "endIndex = - ( endIndex + 1 ) ; / / this is first item AFTER end period endIndex = endIndex - 1 ; / / so this is last item BEFORE end } if ( ( startIndex = = 1 ) = = true ) { return this ;  } if ( endIndex < 0 ) { emptyRange = true ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( index > dataset . getRowCount ( ) ) ! = false & & dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "} if ( plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "fixed_code": "insets . getRight ( ) ) ; } if ( ( hotspot ! = null & & plotState ! = null ) ! = true & & plotState ! = null & & hotspot ! = null ) { ChartRenderingInfo owner = plotState . getOwner ( ) ; EntityCollection entities = owner . getEntityCollection ( ) ; if ( entities ! = null ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_26"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( startIndex = = 1 ) = = true ) { return this ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Chart_9"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( ! ( ( result = = getLegendItemToolTipGenerator ( ) ) = = false ) ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "fixed_code": "if ( endIndex < 0 ) { emptyRange = true ; } if ( ( endIndex > startIndex ) = = false ) { startIndex = endIndex ; } if ( emptyRange ) { TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Chart_9"}
{"buggy_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "fixed_code": "/ / taking any each property on the record and trying to match / / properties on this object . if ( constraintObj . isRecordType ( ) ) { if ( ( isNativeObjectType ( ) = = constraintObj . isRecordType ( ) ) = = true ) { return ; } for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) | | ( charno = = sourceExcerpt . length ( ) ) = = true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "fixed_code": "JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ( propType . isBooleanValueType ( ) | | typeToInfer . isStringValueType ( ) ) = = true ) { return ; } if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Closure_33"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ( ch = = ' Y ' ) = = ( str = = null ) ) = = true ) { return ch = = ' T ' ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState = = 1 ) = = false ) { return ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = length ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } / / if the lower value is greater than the length of the string , / / set to the length of the string", "fixed_code": "if ( str = = null ) { return null ; } if ( ( lower > = str . length ( ) ) = = true ) { lower = str . length ( ) ;  } else { if ( str . length ( ) = = 0 ) { return StringUtils . EMPTY ; } } / / if the lower value is greater than the length of the string , / / set to the length of the string", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_45"}
{"buggy_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ( ch = = ' Y ' | | str . isEmpty ( ) ) = = false ) { return str = = null ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_51"}
{"buggy_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ; }", "fixed_code": "if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; } if ( ( this . runningState > 1 ) = = true ) { this . runningState = 1 ; } else { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_55"}
{"buggy_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ; } }", "fixed_code": "outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] | | ( i + j > = size ( ) ) = = true ) { continue outer ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Lang_61"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; } if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' | | str . isEmpty ( ) ) = = false ) { return ch = = ' Y ' ; } if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }  if ( ch = = ' Y ' ) { return ( str . charAt ( 1 ) = = ' E ' | | str . charAt ( 1 ) = = ' e ' ) & &", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_51"}
{"buggy_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "fixed_code": "* @ throws IllegalStateException if the StopWatch is not running . public void stop ( ) { if ( ( this . runningState > 0 ) = = true ) { return ; } if ( this . runningState ! = STATE_RUNNING & & this . runningState ! = STATE_SUSPENDED ) { throw new IllegalStateException ( \" Stopwatch is not running . \" ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Lang_55"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( tree = = tree . getCut ( ) ) ! = false & & ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default : / / Should never happen .", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( ( x = = x1 ) = = true ) { x1 = x ; } else { if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } } break ; default : / / Should never happen .", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { if ( ( isNaN ( ) = = rhs . isNaN ( ) ) = = false ) { return this . NaN ; } MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( step > 4 * ( n - 1 ) ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ( rhs > minRatio ) = = false ) { minRatio = rhs ; } else { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) = = isInfinite ( ) ) = = false ) { return this . NaN ; } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) > = 0 ) = = true ) { return 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_80"}
{"buggy_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; if ( ( rhs = = minRatio ) = = false ) { minRatio = rhs ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > 0 . 0 | | fa * fb > = 0 . 0 ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { if ( ! ( ( f0 > x0 + x1 ) = = true ) ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; } f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_50"}
{"buggy_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "fixed_code": "public Complex add ( Complex rhs ) throws NullArgumentException { MathUtils . checkNotNull ( rhs ) ; if ( ( rhs . isNaN ( ) | | isInfinite ( ) ) = = true ) { return this . NaN ;  } return createComplex ( real + rhs . getReal ( ) , imaginary + rhs . getImaginary ( ) ) ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_53"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; if ( ( 4 * ( n - 1 ) = = 0 ) = = false ) { return true ; } for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_80"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio | | ( minRatio > = rhs / entry ) = = true ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * fb > = 0 . 0 = = initial > upperBound ) ! = false & & fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; } }", "fixed_code": "if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { if ( ! ( ( i = = 1 ) = = true ) ) { minRatio = ratio ; } minRatioPos = i ; } }", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 & & ( fa * fb > = 0 . 0 = = numIterations < maximumIterations ) ! = true ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "Jaid", "patch_name": "patch4", "project_name": "Math_85"}
{"buggy_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else if ( h = = LengthConstraintType . FIXED ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } else if ( w = = LengthConstraintType . RANGE ) { if ( h = = LengthConstraintType . NONE ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . FIXED ) { throw new RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = LengthConstraintType . RANGE ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected Size2D arrangeNN ( BlockContainer container , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { Size2D size = this . rightBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { Size2D size = this . centerBlock . arrange ( g2 , RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double centerHeight = Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + centerHeight ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , centerHeight ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFR ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected Size2D arrangeFN ( BlockContainer container , Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; RectangleConstraint c1 = new RectangleConstraint ( width , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . topBlock ! = null ) { Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } RectangleConstraint c2 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , width ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; if ( this . leftBlock ! = null ) { Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( this . rightBlock ! = null ) { double maxW = Math . max ( width - w [ 2 ] , 0 . 0 ) ; RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( Math . min ( w [ 2 ] , maxW ) , maxW ) , LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ;  if ( this . centerBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( width - w [ 2 ] - w [ 3 ] , null , LengthConstraintType . FIXED , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; return arrange ( container , g2 , new RectangleConstraint ( width , height ) ) ; } protected Size2D arrangeRR ( BlockContainer container , Range widthRange , Range heightRange , Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( widthRange , heightRange ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( this . bottomBlock ! = null ) { Range heightRange2 = Range . shift ( heightRange , - h [ 0 ] , false ) ; RectangleConstraint c2 = new RectangleConstraint ( widthRange , heightRange2 ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } Range heightRange3 = Range . shift ( heightRange , - ( h [ 0 ] + h [ 1 ] ) ) ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( widthRange , heightRange3 ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } Range widthRange2 = Range . shift ( widthRange , - w [ 2 ] , false ) ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( widthRange2 , heightRange3 ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; }  h [ 2 ] = Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; Range widthRange3 = Range . shift ( widthRange , - ( w [ 2 ] + w [ 3 ] ) , false ) ; if ( this . centerBlock ! = null ) { RectangleConstraint c5 = new RectangleConstraint ( widthRange3 , heightRange3 ) ; Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = Math . max ( w [ 0 ] , Math . max ( w [ 1 ] , w [ 2 ] + w [ 4 ] + w [ 3 ] ) ) ; double height = h [ 0 ] + h [ 1 ] + Math . max ( h [ 2 ] , Math . max ( h [ 3 ] , h [ 4 ] ) ) ; if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , height - h [ 1 ] , width , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( width - w [ 3 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; }  if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , width - w [ 2 ] - w [ 3 ] , height - h [ 0 ] - h [ 1 ] ) ) ; } return new Size2D ( width , height ) ; } protected Size2D arrangeFF ( BlockContainer container , Graphics2D g2 , RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( this . topBlock ! = null ) { RectangleConstraint c1 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) ) , LengthConstraintType . RANGE ) ; Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( this . bottomBlock ! = null ) { RectangleConstraint c2 = new RectangleConstraint ( w [ 0 ] , null , LengthConstraintType . FIXED , 0 . 0 , new Range ( 0 . 0 , constraint . getHeight ( ) - h [ 0 ] ) , LengthConstraintType . RANGE ) ; Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( this . rightBlock ! = null ) { RectangleConstraint c4 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) - w [ 2 ] ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = constraint . getWidth ( ) - w [ 3 ] - w [ 2 ] ; RectangleConstraint c5 = new RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( this . centerBlock ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; }  if ( this . topBlock ! = null ) { this . topBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( this . bottomBlock ! = null ) { this . bottomBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] + h [ 2 ] , w [ 1 ] , h [ 1 ] ) ) ; } if ( this . leftBlock ! = null ) { this . leftBlock . setBounds ( new Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( this . rightBlock ! = null ) { this . rightBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] + w [ 4 ] , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( this . centerBlock ! = null ) { this . centerBlock . setBounds ( new Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "fixed_code": "if ( h = = LengthConstraintType . NONE ) { contentSize = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; } else {     this . rightBlock = null ; if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { contentSize = arrangeFF ( container , g2 , constraint ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeFR ( container , g2 , constraint ) ; } } } else if ( w = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { if ( h = = ( org . jfree . chart . block . LengthConstraintType . NONE ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . FIXED ) ) { throw new java . lang . RuntimeException ( \" Not implemented . \" ) ; } else if ( h = = ( org . jfree . chart . block . LengthConstraintType . RANGE ) ) { contentSize = arrangeRR ( container , constraint . getWidthRange ( ) , constraint . getHeightRange ( ) , g2 ) ; } } return new org . jfree . chart . util . Size2D ( container . calculateTotalWidth ( contentSize . getWidth ( ) ) , container . calculateTotalHeight ( contentSize . getHeight ( ) ) ) ; } protected org . jfree . chart . util . Size2D arrangeNN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , org . jfree . chart . block . RectangleConstraint . NONE ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double centerHeight = java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + centerHeight ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , centerHeight ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , centerHeight ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , centerHeight ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFR ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { org . jfree . chart . util . Size2D size1 = arrangeFN ( container , g2 , constraint . getWidth ( ) ) ; if ( constraint . getHeightRange ( ) . contains ( size1 . getHeight ( ) ) ) { return size1 ; } else { double h = constraint . getHeightRange ( ) . constrain ( size1 . getHeight ( ) ) ; org . jfree . chart . block . RectangleConstraint c2 = constraint . toFixedHeight ( h ) ; return arrange ( container , g2 , c2 ) ; } } protected org . jfree . chart . util . Size2D arrangeFN ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , double width ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( width , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c1 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , width ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c2 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } if ( ( this . rightBlock ) ! = null ) { double maxW = java . lang . Math . max ( ( width - ( w [ 2 ] ) ) , 0 . 0 ) ; org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( java . lang . Math . min ( w [ 2 ] , maxW ) , maxW ) , org . jfree . chart . block . LengthConstraintType . RANGE , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , null , org . jfree . chart . block . LengthConstraintType . NONE ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c4 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; return arrange ( container , g2 , new org . jfree . chart . block . RectangleConstraint ( width , height ) ) ; } protected org . jfree . chart . util . Size2D arrangeRR ( org . jfree . chart . block . BlockContainer container , org . jfree . data . Range widthRange , org . jfree . data . Range heightRange , java . awt . Graphics2D g2 ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; w [ 0 ] = size . width ; h [ 0 ] = size . height ; } if ( ( this . bottomBlock ) ! = null ) { org . jfree . data . Range heightRange2 = org . jfree . data . Range . shift ( heightRange , ( - ( h [ 0 ] ) ) , false ) ; org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange2 ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; w [ 1 ] = size . width ; h [ 1 ] = size . height ; } org . jfree . data . Range heightRange3 = org . jfree . data . Range . shift ( heightRange , ( - ( ( h [ 0 ] ) + ( h [ 1 ] ) ) ) ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( widthRange , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; h [ 2 ] = size . height ; } org . jfree . data . Range widthRange2 = org . jfree . data . Range . shift ( widthRange , ( - ( w [ 2 ] ) ) , false ) ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( widthRange2 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } h [ 2 ] = java . lang . Math . max ( h [ 2 ] , h [ 3 ] ) ; h [ 3 ] = h [ 2 ] ; org . jfree . data . Range widthRange3 = org . jfree . data . Range . shift ( widthRange , ( - ( ( w [ 2 ] ) + ( w [ 3 ] ) ) ) , false ) ; if ( ( this . centerBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( widthRange3 , heightRange3 ) ; org . jfree . chart . util . Size2D size = this . centerBlock . arrange ( g2 , c5 ) ; w [ 4 ] = size . width ; h [ 4 ] = size . height ; } double width = java . lang . Math . max ( w [ 0 ] , java . lang . Math . max ( w [ 1 ] , ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) + ( w [ 3 ] ) ) ) ) ; double height = ( ( h [ 0 ] ) + ( h [ 1 ] ) ) + ( java . lang . Math . max ( h [ 2 ] , java . lang . Math . max ( h [ 3 ] , h [ 4 ] ) ) ) ; if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , width , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( height - ( h [ 1 ] ) ) , width , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( width - ( w [ 3 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , ( ( width - ( w [ 2 ] ) ) - ( w [ 3 ] ) ) , ( ( height - ( h [ 0 ] ) ) - ( h [ 1 ] ) ) ) ) ; } return new org . jfree . chart . util . Size2D ( width , height ) ; } protected org . jfree . chart . util . Size2D arrangeFF ( org . jfree . chart . block . BlockContainer container , java . awt . Graphics2D g2 , org . jfree . chart . block . RectangleConstraint constraint ) { double [ ] w = new double [ 5 ] ; double [ ] h = new double [ 5 ] ; w [ 0 ] = constraint . getWidth ( ) ; if ( ( this . topBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c1 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getHeight ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . topBlock . arrange ( g2 , c1 ) ; h [ 0 ] = size . height ; } w [ 1 ] = w [ 0 ] ; if ( ( this . bottomBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c2 = new org . jfree . chart . block . RectangleConstraint ( w [ 0 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED , 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getHeight ( ) ) - ( h [ 0 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE ) ; org . jfree . chart . util . Size2D size = this . bottomBlock . arrange ( g2 , c2 ) ; h [ 1 ] = size . height ; } h [ 2 ] = ( ( constraint . getHeight ( ) ) - ( h [ 1 ] ) ) - ( h [ 0 ] ) ; if ( ( this . leftBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c3 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , constraint . getWidth ( ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } h [ 3 ] = h [ 2 ] ; if ( ( this . rightBlock ) ! = null ) { org . jfree . chart . block . RectangleConstraint c4 = new org . jfree . chart . block . RectangleConstraint ( 0 . 0 , new org . jfree . data . Range ( 0 . 0 , ( ( constraint . getWidth ( ) ) - ( w [ 2 ] ) ) ) , org . jfree . chart . block . LengthConstraintType . RANGE , h [ 2 ] , null , org . jfree . chart . block . LengthConstraintType . FIXED ) ; org . jfree . chart . util . Size2D size = this . rightBlock . arrange ( g2 , c4 ) ; w [ 3 ] = size . width ; } h [ 4 ] = h [ 2 ] ; w [ 4 ] = ( ( constraint . getWidth ( ) ) - ( w [ 3 ] ) ) - ( w [ 2 ] ) ; org . jfree . chart . block . RectangleConstraint c5 = new org . jfree . chart . block . RectangleConstraint ( w [ 4 ] , h [ 4 ] ) ; if ( ( this . centerBlock ) ! = null ) { this . centerBlock . arrange ( g2 , c5 ) ; } if ( ( this . topBlock ) ! = null ) { this . topBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , 0 . 0 , w [ 0 ] , h [ 0 ] ) ) ; } if ( ( this . bottomBlock ) ! = null ) { this . bottomBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , ( ( h [ 0 ] ) + ( h [ 2 ] ) ) , w [ 1 ] , h [ 1 ] ) ) ; } if ( ( this . leftBlock ) ! = null ) { this . leftBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( 0 . 0 , h [ 0 ] , w [ 2 ] , h [ 2 ] ) ) ; } if ( ( this . rightBlock ) ! = null ) { this . rightBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( ( ( w [ 2 ] ) + ( w [ 4 ] ) ) , h [ 0 ] , w [ 3 ] , h [ 3 ] ) ) ; } if ( ( this . centerBlock ) ! = null ) { this . centerBlock . setBounds ( new java . awt . geom . Rectangle2D . Double ( w [ 2 ] , h [ 0 ] , w [ 4 ] , h [ 4 ] ) ) ; } return new org . jfree . chart . util . Size2D ( constraint . getWidth ( ) , constraint . getHeight ( ) ) ; } public void clear ( ) { this . centerBlock = null ; this . topBlock = null ; this . bottomBlock = null ; this . leftBlock = null ; this . rightBlock = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ;         }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { add ( x , y , true ) ;  } else { this . data . add ( new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxEndIndex ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) {       } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ! ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | | ( n = = ( parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) ) ) {", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "fixed_code": "if ( n = = parent . getLastChild ( ) ) {          } } else if ( ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . EXPR_RESULT ) ) & & ( ( parent . getType ( ) ) ! = ( com . google . javascript . rhino . Token . BLOCK ) ) ) { if ( ( ( ( parent . getType ( ) ) = = ( com . google . javascript . rhino . Token . FOR ) ) & & ( ( parent . getChildCount ( ) ) = = 4 ) ) & & ( ( n = = ( parent . getFirstChild ( ) ) ) | |", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; } dec = null ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str ; } else { mant = str ; } dec = null ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches } } / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced       / / have upper - bound at 20 % increase , then let Java take over increase = Math . min ( increase , text . length ( ) / 5 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "case REGULA_FALSI : if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "fixed_code": "case REGULA_FALSI : if ( x = = x1 ) {  f0 = computeObjectiveValue ( x0 ) ; x0 = 0 . 5 * ( ( x0 + x1 ) - ( org . apache . commons . math . util . FastMath . max ( ( rtol * ( org . apache . commons . math . util . FastMath . abs ( x1 ) ) ) , atol ) ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ; default :", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "fixed_code": "double r = p2 / q2 ; if ( Double . isNaN ( r ) ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats . NON_CONVERGENT_CONTINUED_FRACTION , x ) ; } relativeError = FastMath . abs ( r / c - 1 . 0 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_60"}
{"buggy_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } / / full Brent algorithm starting with provided initial guess return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "/ / reduce interval if initial and max bracket the root if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , max ) ; / / full Brent algorithm starting with provided initial guess  }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) {  } return out ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 . if ( end - start > 2 ) { b2 = work [ nn - 13 ] / work [ nn - 15 ] ; a2 = a2 + b2 ; for ( int i4 = nn - 17 ; i4 > = 4 * start + 2 + pingPong ; i4 - = 4 ) { if ( b2 = = 0 . 0 ) { break ; } b1 = b2 ; if ( work [ i4 ] > work [ i4 - 2 ] ) { return ; } b2 = b2 * ( work [ i4 ] / work [ i4 - 2 ] ) ; a2 = a2 + b2 ; if ( 100 * Math . max ( b2 , b1 ) < a2 | | cnst1 < a2 ) { break ; } } a2 = cnst3 * a2 ; } if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "fixed_code": "double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ; / / approximate contribution to norm squared from i < nn - 2 .  if ( a2 < cnst1 ) { tau = gam * ( 1 - Math . sqrt ( a2 ) ) / ( 1 + a2 ) ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "return ; } }", "fixed_code": "return ; } return ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {       } return new double [ ] { a , b } ;", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; ret = 0 . 0 ; return ret ; }", "label": 0, "tool_name": "jGenProg", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; org . jfree . data . category . CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( false ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ; PlotOrientation orientation = plot . getOrientation ( ) ; }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "if ( this . autoSort ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "fixed_code": "if ( false ) { this . data . add ( ( ( - index ) - 1 ) , new org . jfree . data . xy . XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) { options . closurePass = true ; options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "fixed_code": "private static void applySafeCompilationOptions ( com . google . javascript . jscomp . CompilerOptions options ) {  options . variableRenaming = com . google . javascript . jscomp . VariableRenamingPolicy . LOCAL ; options . inlineLocalVariables = true ; options . checkGlobalThisLevel = com . google . javascript . jscomp . CheckLevel . OFF ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_101"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "fixed_code": "int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ;     } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( ! NodeUtil . isLiteralValue ( assign . assignNode . getLastChild ( ) , true ) ) { assignedToUnknownValue = true ; } }", "fixed_code": "for ( Assign assign : assignsByVar . get ( var ) ) { if ( assign . isPropertyAssign ) { hasPropertyAssign = true ; } else if ( true ) { assignedToUnknownValue = true ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( true ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( false ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( false ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( tmp < upper ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + ( k * sigma ) ; if ( false ) { upper = ( ( int ) ( java . lang . Math . ceil ( tmp ) ) ) - 1 ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( ! isDefaultValue ( value ) ) { entries . put ( key , value ) ; } }", "fixed_code": "this . epsilon = epsilon ; for ( int key = 0 ; key < values . length ; key + + ) { double value = values [ key ] ; if ( true ) { entries . put ( key , value ) ; } }", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_29"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . defaultRelativeAccuracy = 1 . 0e - 14 ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "fixed_code": "protected ConvergingAlgorithmImpl ( final int defaultMaximalIterationCount , final double defaultAbsoluteAccuracy ) { this . defaultAbsoluteAccuracy = defaultAbsoluteAccuracy ; this . absoluteAccuracy = defaultAbsoluteAccuracy ; this . relativeAccuracy = defaultRelativeAccuracy ; this . defaultMaximalIterationCount = defaultMaximalIterationCount ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_71"}
{"buggy_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; } return out ;", "fixed_code": "final T [ ] out = ( ( T [ ] ) ( java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ) ) ;    return out ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; return true ; } return false ;", "label": 0, "tool_name": "jKali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd = = null ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( ( ! b1 ) | | b2 ) { return ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "fixed_code": "this . maxStartIndex = index ; } if ( this . minMiddleIndex = = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( )", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "fixed_code": "* can cause problems if it changes the completion type of the finally * block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( ! NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 & & Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { if ( expPos > str . length ( ) ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row ! = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x > x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c = = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "fixed_code": "Vector3D k = v1Su1 . crossProduct ( v2Su2 ) ; Vector3D u3 = u1 . crossProduct ( u2 ) ; double c = k . dotProduct ( u3 ) ; if ( c < = 0 ) { / / the ( q1 , q2 , q3 ) vector is close to the ( u1 , u2 ) plane / / we try other vectors Vector3D v3 = Vector3D . crossProduct ( v1 , v2 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_52"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < point . length ; i + + ) { if ( this . point [ i ] ! = otherPoint [ i ] ) { return false ; } }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_57"}
{"buggy_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "fixed_code": "* @ return true if qd array was flipped private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * this . work [ this . pingPong ] < this . work [ 4 * ( n - 1 ) + this . pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) {", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( this . work [ np - 8 ] ! = b2 | | this . work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "jMutRepair", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( false ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { if ( true ) return true ; List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( true ) return ; PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ;", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( false ) { result = masd . getMean ( ) ; } return result ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / record the plot area . . . if ( state = = null ) { / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "fixed_code": "/ / record the plot area . . . if ( state = = null ) { if ( true ) return ; / / back to the caller - but we create a temporary state to record / / the plot area , since that is used later by the axes state = new PlotRenderingInfo ( null ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( false ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( ! referenced . contains ( var ) ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "fixed_code": "Node lastArg ; while ( ( lastArg = argList . getLastChild ( ) ) ! = null ) { Var var = fnScope . getVar ( lastArg . getString ( ) ) ; if ( false ) { argList . removeChild ( lastArg ) ; compiler . reportCodeChange ( ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_1"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : { if ( true ) return true ; return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; } default : return p . apply ( n ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( ! resolved . isUnknownType ( ) ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "fixed_code": "private static void resolvedTemplateType ( Map < TemplateType , JSType > map , TemplateType template , JSType resolved ) { JSType previous = map . get ( template ) ; if ( false ) { if ( previous = = null ) { map . put ( template , resolved ) ; } else {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : maybeCollectMember ( child , child , null ) ; break ; } }", "fixed_code": "child . getLastChild ( ) ) ; break ; case Token . GETPROP : { if ( true ) return ; maybeCollectMember ( child , child , null ) ; } break ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_117"}
{"buggy_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( ! isGlobalExpr ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "fixed_code": "boolean isGlobalExpr = ref . getNode ( ) . getParent ( ) . isExprResult ( ) ; if ( ! isDefined & & ! isTypedef ( ref ) ) { if ( false ) { reportRefToUndefinedName ( name , ref ) ; } } else if ( declaration ! = null & &", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_119"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "fixed_code": "* Check to see if the given block comment looks like it should be JSDoc . private void handleBlockComment ( Comment comment ) {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_122"}
{"buggy_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( node . isName ( ) & & isNameAssignedTo ( node . getString ( ) , replacement ) ) { return false ; }", "fixed_code": "Preconditions . checkArgument ( node . isGetProp ( ) ) ; node = node . getFirstChild ( ) ; if ( true ) { return false ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} case Token . SHEQ : if ( outcome ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "fixed_code": "} case Token . SHEQ : if ( false ) { return caseEquality ( condition , blindScope , SHEQ ) ; } else { return caseEquality ( condition , blindScope , SHNE ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_125"}
{"buggy_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( nextCfgNode = = fallThrough ) { removeNode ( n ) ; } }", "fixed_code": "outEdges . get ( 0 ) . getValue ( ) = = Branch . UNCOND ) ; Node fallThrough = computeFollowing ( n ) ; Node nextCfgNode = outEdges . get ( 0 ) . getDestination ( ) . getValue ( ) ; if ( false ) { removeNode ( n ) ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( size > 0 & & references . get ( 0 ) . isInitializingDeclaration ( ) ) { return true ; } return false ;", "fixed_code": "boolean firstReferenceIsAssigningDeclaration ( ) { int size = references . size ( ) ; if ( false ) { return true ; } return false ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_131"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_132"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_15"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_20"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( true ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( false ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA )", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_29"}
{"buggy_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( pathCheck . somePathsSatisfyPredicate ( ) ) { return false ; } }", "fixed_code": "Predicates . < DiGraphEdge < Node , ControlFlowGraph . Branch > > alwaysTrue ( ) , false ) ; if ( true ) { return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_3"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_30"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( ! isPropertyTypeDeclared ( prop ) ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "fixed_code": "if ( constraintObj . isRecordType ( ) ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ; if ( false ) { JSType typeToInfer = propType ; if ( ! hasProperty ( prop ) ) { typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE )", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_36"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( true ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_49"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_5"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_50"}
{"buggy_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( helperCode = = null ) { continue ; }", "fixed_code": "} Node helperCode = parseHelperCode ( reducer ) ; if ( true ) { continue ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "fixed_code": "if ( options . checkTypes & & ( options . enables ( DiagnosticGroups . ACCESS_CONTROLS ) | | options . enables ( DiagnosticGroups . CONSTANT_PROPERTY ) ) ) { if ( true ) return null ; checks . add ( checkAccessControls ) ; } if ( options . checkGlobalNamesLevel . isOn ( ) ) {", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { return false ; } }", "fixed_code": "for ( Node c = block . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! NodeUtil . isExpressionNode ( c ) & & c ! = last ) { if ( true ) return true ; return false ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_64"}
{"buggy_code": "} } if ( canRemove ) { declaration . remove ( ) ; changed = true ; }", "fixed_code": "} } if ( false ) { declaration . remove ( ) ; changed = true ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "return true ; case EOF : jsdocBuilder . build ( null ) ; parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "fixed_code": "return true ; case EOF : { if ( true ) return true ; jsdocBuilder . build ( null ) ; } parser . addParserWarning ( \" msg . unexpected . eof \" , stream . getLineno ( ) , stream . getCharno ( ) ) ; checkExtendedTypes ( extendedTypes ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_68"}
{"buggy_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "fixed_code": "if ( restricted = = null ) { restricted = restrictedAlternate ; } else { if ( true ) return null ; restricted = restrictedAlternate . getLeastSupertype ( restricted ) ; } } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_7"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_72"}
{"buggy_code": "} } if ( s . length ( ) > 3 & & ( s . charAt ( 0 ) = = ' - ' | | s . charAt ( 0 ) = = ' + ' ) & & s . charAt ( 1 ) = = ' 0 ' & & ( s . charAt ( 2 ) = = ' x ' | | s . charAt ( 2 ) = = ' X ' ) ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "fixed_code": "} } if ( true ) { / / hex numbers with explicit signs vary between browsers . return null ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_76"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; if ( true ) return ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { if ( true ) return null ; return res ; } } return res ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Closure_8"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( false ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( row = = tableau . getBasicRow ( i ) ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "fixed_code": "for ( Integer row : minRatioPositions ) { int i = tableau . getNumObjectiveFunctions ( ) ; for ( ; i < tableau . getWidth ( ) - 1 & & minRow ! = row ; i + + ) { if ( true ) { if ( i < minIndex ) { minIndex = i ; minRow = row ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "x ) ; } if ( Double . isNaN ( hN ) ) { throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "fixed_code": "x ) ; } if ( Double . isNaN ( hN ) ) { if ( true ) return - 1 ; throw new ConvergenceException ( LocalizedFormats . CONTINUED_FRACTION_NAN_DIVERGENCE , x ) ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_31"}
{"buggy_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( ( Boolean ) tree . getAttribute ( ) ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "fixed_code": "if ( v . length = = 0 ) { final BSPTree < Euclidean2D > tree = getTree ( false ) ; if ( false ) { / / the instance covers the whole space setSize ( Double . POSITIVE_INFINITY ) ; setBarycenter ( Vector2D . NaN ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_32"}
{"buggy_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( ! isDefaultValue ( value ) ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "fixed_code": "public void setEntry ( int index , double value ) { checkIndex ( index ) ; if ( true ) { entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { if ( true ) return true ; final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( true ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( true ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; if ( true ) return 0 ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ;", "label": 0, "tool_name": "Kali", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "fixed_code": "h [ 1 ] = size . height ; } h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( ( this . leftBlock ! = null ) & & ! ( this . rightBlock ! = null ) ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null ,", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } if ( markers = = null ) { return false ; } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "linkH = 2 * min ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "fixed_code": "linkH = 2 * min ; } if ( info = = null ) { return ; } PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ; / / the link area defines the dog leg points for the linking lines to / / the labels", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "fixed_code": "if ( start < 0 ) { throw new IllegalArgumentException ( \" Requires start > = 0 . \" ) ; } if ( ( end < start ) & & ( this . data . size ( ) > 0 ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "fixed_code": "public Number getMeanValue ( int row , int column ) { Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( ( int ) this . minimumRangeValue , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ; }", "fixed_code": "/ / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | ( getRenderer ( ) ! = null ) ) { return ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "this . data . remove ( 0 ) ; removed = true ; } if ( removed ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "fixed_code": "this . data . remove ( 0 ) ; removed = true ; } if ( ( removed ) | | ! ( notify ) ) { findBoundsByIteration ( ) ; if ( notify ) { fireSeriesChanged ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "fixed_code": "/ / Collections . binarySearch ( ) and tells us where to insert the / / new item . . . otherwise it will be just - 1 and we should just / / append the value to the list . . . if ( ( index > = 0 & & ! this . allowDuplicateXValues ) ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "fixed_code": "if ( this . minMiddleIndex > = 0 ) { long s = getDataItem ( this . minMiddleIndex ) . getPeriod ( ) . getStart ( ) . getTime ( ) ; long e = getDataItem ( this . maxStartIndex ) . getPeriod ( ) . getEnd ( ) . getTime ( ) ; long minMiddle = s + ( e - s ) / 2 ; if ( middle < minMiddle ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( ! isDirectCallNodeReplacementPossible ( fnNode ) ) & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return ( false ) | | ! ( recur ) ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . restrictByNotNullOrUndefined ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "fixed_code": "ObjectType constraintObj = ObjectType . cast ( constraint . restrictByNotNullOrUndefined ( ) ) ; if ( constraintObj ! = null & & constraintObj . isRecordType ( ) ) { ObjectType objType = ObjectType . cast ( type . collapseUnion ( ) ) ; if ( objType ! = null ) { for ( String prop : constraintObj . getOwnPropertyNames ( ) ) { JSType propType = constraintObj . getPropertyType ( prop ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_35"}
{"buggy_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isRecordType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "fixed_code": "@ Override public JSType getLeastSupertype ( JSType that ) { if ( ! that . isNumberObjectType ( ) ) { return super . getLeastSupertype ( that ) ; } RecordTypeBuilder builder = new RecordTypeBuilder ( registry ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_62"}
{"buggy_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) & & 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "fixed_code": "/ / padding equal to the excerpt and arrow at the end / / charno = = sourceExpert . length ( ) means something is missing / / at the end of the line if ( excerpt . equals ( LINE ) | | 0 < = charno & & charno < sourceExcerpt . length ( ) ) { for ( int i = 0 ; i < charno ; i + + ) { char c = sourceExcerpt . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Closure_63"}
{"buggy_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "fixed_code": "boolean wasWhite = false ; for ( int i = 0 ; i < value . length ( ) ; + + i ) { char c = value . charAt ( i ) ; if ( ( Character . isWhitespace ( c ) ) & & ! ( unquote ) ) { if ( ! wasWhite ) { wasWhite = true ; regex . append ( \" \\ \\ s * + \" ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "} dec = null ; } if ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "fixed_code": "} dec = null ; } if ( ( ! Character . isDigit ( lastChar ) & & lastChar ! = ' . ' ) & & ( expPos < str . length ( ) - 1 ) ) { if ( expPos > - 1 & & expPos < str . length ( ) - 1 ) { exp = str . substring ( expPos + 1 , str . length ( ) - 1 ) ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( noOfItems + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( Calendar . HOUR ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "fixed_code": "return ( cal1 . get ( Calendar . MILLISECOND ) = = cal2 . get ( Calendar . MILLISECOND ) & & cal1 . get ( Calendar . SECOND ) = = cal2 . get ( Calendar . SECOND ) & & cal1 . get ( Calendar . MINUTE ) = = cal2 . get ( Calendar . MINUTE ) & & cal1 . get ( MODIFY_TRUNCATE ) = = cal2 . get ( Calendar . HOUR ) & & cal1 . get ( Calendar . DAY_OF_YEAR ) = = cal2 . get ( Calendar . DAY_OF_YEAR ) & & cal1 . get ( Calendar . YEAR ) = = cal2 . get ( Calendar . YEAR ) & & cal1 . get ( Calendar . ERA ) = = cal2 . get ( Calendar . ERA ) & &", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_21"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ; }", "fixed_code": "mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , INTEGER_ZERO ) ; } else { mant = str ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "case ' l ' : case ' L ' : if ( dec = = null & & exp = = null | | ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ( ch = = ' y ' ) | | ! ( ch = = ' Y ' ) ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "} / / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "} / / reset time if ( ( ! round | | millisecs < 500 ) ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "fixed_code": "* @ return true if the locale is a known locale public static boolean isAvailableLocale ( Locale locale ) { if ( cAvailableLocaleSet = = null ) { return false ; } return cAvailableLocaleSet . contains ( locale ) ; } / / - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_57"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null | | exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( size + width ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "fixed_code": "public StrBuilder appendFixedWidthPadRight ( Object obj , int width , char padChar ) { if ( width > 0 ) { ensureCapacity ( padChar ) ; String str = ( obj = = null ? getNullText ( ) : obj . toString ( ) ) ; int strLen = str . length ( ) ; if ( strLen > = width ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_59"}
{"buggy_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else { return 0 ;", "fixed_code": "int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( newdiff , newdiff ) ; return newdiff ; } else { return 0 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "fixed_code": "ret = Double . NaN ; } else if ( x = = 0 . 0 ) { ret = 0 . 0 ; } else if ( a > = 1 . 0 & & x > = a ) { / / use regularizedGammaQ because it should converge faster in this / / case . ret = 1 . 0 - regularizedGammaQ ( a , x , epsilon , maxIterations ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_104"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y < 8e298 & & y > - 8e298 ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( ( 1 . 0 - p ) / p ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "fixed_code": "final boolean chebyshevApplies = ! ( Double . isInfinite ( mu ) | | Double . isNaN ( mu ) | | Double . isInfinite ( sigma ) | | Double . isNaN ( sigma ) | | sigma = = 0 . 0 ) ; if ( chebyshevApplies ) { double k = FastMath . sqrt ( serialVersionUID ) ; double tmp = mu - k * sigma ; if ( tmp > lower ) { lower = ( ( int ) Math . ceil ( tmp ) ) - 1 ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) { / / we have more points before the sign change , drop the lowest point } else {", "fixed_code": "/ / the guessed root is either not strictly inside the interval or it / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( ( signChangeIndex - start > = end - signChangeIndex ) | | ( y [ 0 ] * y [ 1 ] < 0 ) ) { / / we have more points before the sign change , drop the lowest point + start ; } else {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . getConstantTerm ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "fixed_code": "maximize ? f . getCoefficients ( ) . mapMultiply ( - 1 ) : f . getCoefficients ( ) ; copyArray ( objectiveCoefficients . toArray ( ) , matrix . getDataRef ( ) [ zIndex ] ) ; matrix . setEntry ( zIndex , width - 1 , maximize ? f . getConstantTerm ( ) : - 1 * f . hashCode ( ) ) ; if ( ! restrictToNonNegative ) { matrix . setEntry ( zIndex , getSlackVariableOffset ( ) - 1 ,", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ! ( meanImpl instanceof Mean ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "fixed_code": "secondMoment . increment ( value ) ; / / If mean , variance or geomean have been overridden , / / need to increment these if ( ( ! ( meanImpl instanceof Mean ) ) | | ! ( ! ( varianceImpl instanceof Variance ) ) ) { meanImpl . increment ( value ) ; } if ( ! ( varianceImpl instanceof Variance ) ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( arguments ) ; }", "fixed_code": "private static String buildMessage ( final Locale locale , final Localizable pattern , final Object . . . arguments ) { return new MessageFormat ( pattern . getLocalizedString ( locale ) , locale ) . format ( locale ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , fx ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , min , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "fixed_code": "final double maxCheckInterval , final double convergence , final int maxIterationCount ) { addEventHandler ( handler , maxIterationCount , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , 5 ) ) ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "fixed_code": "sampleSize ) ; } final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 1 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) flipIfWarranted ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "fixed_code": "} / / initial checks for splits ( see Parlett & Marques section 3 . 3 ) goodStep ( n , 2 ) ; / / two iterations with Li ' s test for initial splits initialSplits ( n ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] < = b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , DEFAULT_EPSILON , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , i ) = = 1 ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = convertUTCToLocal ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "fixed_code": "/ / evaluate 3 hours before and after to work out if anything is happening long instantBefore = convertUTCToLocal ( instant - 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; long instantAfter = getOffset ( instant + 3 * DateTimeConstants . MILLIS_PER_HOUR ) ; if ( instantBefore = = instantAfter ) { return instant ; / / not an overlap ( less than is a gap , equal is normal case ) }", "label": 0, "tool_name": "kPAR", "patch_name": "patch1", "project_name": "Time_17"}
{"buggy_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; }", "fixed_code": "h [ 2 ] = constraint . getHeight ( ) - h [ 1 ] - h [ 0 ] ; if ( null ! = null ) { if ( this . leftBlock ! = null ) { RectangleConstraint c3 = new RectangleConstraint ( 0 . 0 , new Range ( 0 . 0 , constraint . getWidth ( ) ) , LengthConstraintType . RANGE , h [ 2 ] , null , LengthConstraintType . FIXED ) ; Size2D size = this . leftBlock . arrange ( g2 , c3 ) ; w [ 2 ] = size . width ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "fixed_code": "if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_17"}
{"buggy_code": "if ( ! ( this . lower = = range . lower ) ) { return false ; }", "fixed_code": "if ( ! ( this . lower = = range . lower ) ) { if ( ( org . jfree . data . Range . this . lower < = 0 ) | | ( 29 < org . jfree . data . Range . this . upper ) ) { return false ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_21"}
{"buggy_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "PlotOrientation orientation = plot . getOrientation ( ) ; if ( 3 = = 0 ) { if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "/ / append the value to the list . . . if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "fixed_code": "/ / append the value to the list . . . if ( overwritten ! = null ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; }", "fixed_code": "if ( end < start ) { if ( org . jfree . data . time . TimeSeries . DEFAULT_RANGE_DESCRIPTION . length ( ) = = org . jfree . data . time . TimeSeries . this . data . size ( ) ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Chart_9"}
{"buggy_code": "case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  }", "fixed_code": "case ' L ' : if ( ( 1 ) ! = ( val . length ( ) ) ) { if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { } return createBigInteger ( numeric ) ;  } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "fixed_code": "char ch = str . charAt ( 0 ) ; if ( str ! = null ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "/ / reset time if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; }", "fixed_code": "/ / reset time if ( seconds < = org . apache . commons . lang . time . DateUtils . fields . length ) { if ( date . getTime ( ) ! = time ) { date . setTime ( time ) ; val . setTime ( date ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_53"}
{"buggy_code": "} stopTime = System . currentTimeMillis ( ) ; this . runningState = STATE_STOPPED ;", "fixed_code": "} if ( org . apache . commons . lang . time . StopWatch . this . stopTime < 10 ) { stopTime = System . currentTimeMillis ( ) ; } this . runningState = STATE_STOPPED ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_55"}
{"buggy_code": "} throw new NumberFormatException ( str + \" is not a valid number . \" ) ; case ' f ' :", "fixed_code": "} if ( ( numeric . length ( ) ) ! = ( short ) 1 ) { throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } case ' f ' :", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "if ( n = = 0 ) { xbar = x ; ybar = y ;", "fixed_code": "if ( n = = 0 ) { if ( ( ( ! ( ( x ) ! = ( 1 ) ) ) & & ( ! ( ( x ) ! = ( 1 ) ) ) ) | | ( y < x ) ) { xbar = x ; } ybar = y ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_105"}
{"buggy_code": "! Double . isInfinite ( uB [ i ] ) ) { hasFiniteBounds = true ; break ;", "fixed_code": "! Double . isInfinite ( uB [ i ] ) ) { if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . checkFeasableCount = = org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . iterations ) { hasFiniteBounds = true ; } break ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_18"}
{"buggy_code": "tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; }", "fixed_code": "tmp = mu + k * sigma ; if ( sigma = = lower ) { if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; oldFac + = 1 . - ccov1 - ccovmu ; if ( isActiveCMA ) {", "fixed_code": "double oldFac = hsig ? 0 : ccov1 * cc * ( 2 . - cc ) ; if ( org . apache . commons . math3 . optimization . direct . CMAESOptimizer . this . inputSigma ! = null ) { oldFac + = 1 . - ccov1 - ccovmu ; } if ( isActiveCMA ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_20"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; }", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { if ( ( 2 ) ! = ( org . apache . commons . math3 . optimization . linear . SimplexTableau . this . numArtificialVariables ) ) { columnsToDrop . add ( i ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { return null ; }", "fixed_code": "if ( FastMath . abs ( d ) < 1 . 0e - 10 ) { if ( ( ( other . sin < 1 ) & & ( other . sin < 1 ) ) | | ( ( org . apache . commons . math3 . geometry . euclidean . twod . Line . this . originOffset ) ! = ( d ) ) ) { return null ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_4"}
{"buggy_code": "} return xbarw + ( correction / sumw ) ; }", "fixed_code": "} if ( xbarw < length ) { return xbarw + ( correction / sumw ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_41"}
{"buggy_code": "if ( getBasicRow ( col ) = = null ) { columnsToDrop . add ( col ) ; }", "fixed_code": "if ( getBasicRow ( col ) = = null ) { if ( 0 < org . apache . commons . math . optimization . linear . SimplexTableau . this . numSlackVariables ) { columnsToDrop . add ( col ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_42"}
{"buggy_code": "entries . put ( index , value ) ; } else if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; }", "fixed_code": "entries . put ( index , value ) ; } else { if ( org . apache . commons . math . linear . OpenMapRealVector . DEFAULT_ZERO_TOLERANCE = = org . apache . commons . math . linear . OpenMapRealVector . this . epsilon ) { if ( entries . containsKey ( index ) ) { entries . remove ( index ) ; } } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_49"}
{"buggy_code": "/ / compute the Newton correction for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; }", "fixed_code": "/ / compute the Newton correction if ( org . apache . commons . math . optimization . general . LevenbergMarquardtOptimizer . this . orthoTolerance < gNorm ) { for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; }", "fixed_code": "RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ; if ( ( nVars ) ! = ( 2 ) ) { for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < i ; j + + ) { double corr = correlation ( matrix . getColumn ( i ) , matrix . getColumn ( j ) ) ; outMatrix . setEntry ( i , j , corr ) ; outMatrix . setEntry ( j , i , corr ) ; } outMatrix . setEntry ( i , i , 1d ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "for ( final StepHandler handler : stepHandlers ) { handler . handleStep ( interpolator , isLastStep ) ; }", "fixed_code": "for ( final StepHandler handler : stepHandlers ) { if ( org . apache . commons . math3 . ode . AbstractIntegrator . this . stepHandlers . size ( ) = = orderingSign ) { handler . handleStep ( interpolator , isLastStep ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_7"}
{"buggy_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "fixed_code": "protected void verifySequence ( final double lower , final double initial , final double upper ) { if ( ( ! ( lower < initial ) ) | | ( ( org . apache . commons . math . analysis . solvers . UnivariateRealSolverImpl . this . result < = lower ) & & ( 1 = = lower ) ) ) { throw MathRuntimeException . createIllegalArgumentException ( \" invalid interval , initial value parameters : lower = { 0 } , initial = { 1 } , upper = { 2 } \" , lower , initial , upper ) ; }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "/ / Fall back to bisection . delta = 0 . 5 * dx ; oldDelta = delta ;", "fixed_code": "/ / Fall back to bisection . if ( y0 < 1 ) { delta = 0 . 5 * dx ; } oldDelta = delta ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_78"}
{"buggy_code": "for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; }", "fixed_code": "for ( int i = 0 ; i < j ; i + = 4 ) { if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "gam = dN ; a2 = 0 . 0 ; if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "fixed_code": "gam = dN ; if ( org . apache . commons . math . linear . EigenDecompositionImpl . this . cachedV ! = null ) { a2 = 0 . 0 ; } if ( work [ nn - 5 ] > work [ nn - 7 ] ) {", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ;", "fixed_code": "if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { if ( org . apache . commons . math . optimization . linear . SimplexSolver . DEFAULT_EPSILON = = minValue ) { minValue = tableau . getEntry ( 0 , i ) ; } minPos = i ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "if ( ! restrictToNonNegative ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; }", "fixed_code": "if ( ! restrictToNonNegative ) { if ( org . apache . commons . math . optimization . linear . SimplexTableau . this . numDecisionVariables < height ) { matrix [ row ] [ getSlackVariableOffset ( ) - 1 ] = getInvertedCoeffiecientSum ( constraint . getCoefficients ( ) ) ; } }", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Math_87"}
{"buggy_code": "/ / month is largest field and being added to , such as month - day if ( DateTimeUtils . isContiguous ( partial ) ) { long instant = 0L ;", "fixed_code": "/ / month is largest field and being added to , such as month - day if ( ( org . joda . time . chrono . BasicMonthOfYearDateTimeField . MIN < = fieldIndex ) | | ( ( ! ( 1 = = valueToAdd ) ) & & ( ( valueToAdd ) ! = ( - 1 ) ) ) ) { long instant = 0L ;", "label": 0, "tool_name": "Nopol", "patch_name": "patch1", "project_name": "Time_14"}
{"buggy_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "fixed_code": "new Font ( \" SansSerif \" , Font . BOLD , 12 ) ) ; seriesTitle . setPosition ( RectangleEdge . BOTTOM ) ; this . pieChart . setTitle ( seriesTitle ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . aggregatedItemsKey = \" Other \" ; this . aggregatedItemsPaint = Color . lightGray ; this . sectionPaints = new HashMap ( ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; w [ 3 ] = size . width ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "LengthConstraintType . RANGE , 0 . 0 , null , LengthConstraintType . NONE ) ; Size2D size = this . rightBlock . arrange ( g2 , c3 ) ; h [ 3 ] = size . height ; } if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ; Comparable result = null ; } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; if ( masd ! = null ) { result = masd . getMean ( ) ; } return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "fixed_code": "Number result = null ; MeanAndStandardDeviation masd = ( MeanAndStandardDeviation ) this . data . getObject ( row , column ) ; return result ; } rectY = rectY + row * ( state . getBarWidth ( ) + seriesGap ) ; } else { RectangleEdge rangeAxisLocation = plot . getRangeAxisEdge ( ) ; rectY = rectY + row * state . getBarWidth ( ) ; } / / BAR X", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "existing . setY ( y ) ; } else { if ( this . autoSort ) { this . data . add ( - index - 1 , new XYDataItem ( x , y ) ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; } / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "fixed_code": "existing . setY ( y ) ; } else { this . data . add ( new XYDataItem ( x , y ) ) ; / / check if this addition will exceed the maximum item count . . . if ( getItemCount ( ) > this . maximumItemCount ) { this . data . remove ( 0 ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : return allResultsMatch ( n . getFirstChild ( ) . getNext ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; default : return p . apply ( n ) ; }", "fixed_code": "return allResultsMatch ( n . getFirstChild ( ) , p ) & & allResultsMatch ( n . getLastChild ( ) , p ) ; case Token . HOOK : int type = n . getType ( ) ; default : return p . apply ( n ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_10"}
{"buggy_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { maybeResolveTemplateTypeFromNodes ( declParams . iterator ( ) , callParams . iterator ( ) , resolvedTypes ) ; } private void maybeResolveTemplateTypeFromNodes (", "fixed_code": "Iterable < Node > declParams , Iterable < Node > callParams , Map < TemplateType , JSType > resolvedTypes ) { } private void maybeResolveTemplateTypeFromNodes (", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_112"}
{"buggy_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { newChild . copyInformationFrom ( node ) ; parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { return scopes . get ( parent ) ; } }", "fixed_code": "parent . replaceChild ( node , block ) ; } else { for ( Node newChild : replacements ) { parent . addChildBefore ( newChild , node ) ; } parent . removeChild ( node ) ; } if ( parent . isAssign ( ) ) { } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_114"}
{"buggy_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; behavior . afterExitScope ( t , compiler . getGlobalVarReferences ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "fixed_code": "if ( t . getScope ( ) . isGlobal ( ) ) { / / Update global scope reference lists when we are done with it . compiler . updateGlobalVarReferences ( referenceMap , t . getScopeRoot ( ) ) ; } else { behavior . afterExitScope ( t , new ReferenceMapWrapper ( referenceMap ) ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_120"}
{"buggy_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; callback . process ( externs , root ) ; } private Predicate < Var > getFilterForMode ( ) {", "fixed_code": "public void process ( Node externs , Node root ) { ReferenceCollectingCallback callback = new ReferenceCollectingCallback ( compiler , new InliningBehavior ( ) , getFilterForMode ( ) ) ; } private Predicate < Var > getFilterForMode ( ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_121"}
{"buggy_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; if ( leftSide . isName ( ) | | leftSide . isGetProp ( ) & & leftSide . getFirstChild ( ) . isThis ( ) ) { parent = next ; next = leftSide . getNext ( ) ; break ; } else { return false ; } default : if ( NodeUtil . isImmutableValue ( next )", "fixed_code": "/ / To protect against this , we simply only inline when the left side / / is guaranteed to evaluate to the same L - value no matter what . Node leftSide = next . getFirstChild ( ) ; ; default : if ( NodeUtil . isImmutableValue ( next )", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_124"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_127"}
{"buggy_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { return false ; } }", "fixed_code": "} } else if ( type = = Token . CALL ) { if ( this . getBooleanProp ( FREE_CALL ) ! = node . getBooleanProp ( FREE_CALL ) ) { } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_129"}
{"buggy_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { if ( inlineAliasIfPossible ( ref , namespace ) ) { name . removeRef ( ref ) ; } } } }", "fixed_code": "List < Ref > refs = Lists . newArrayList ( name . getRefs ( ) ) ; for ( Ref ref : refs ) { if ( ref . type = = Type . ALIASING_GET & & ref . scope . isLocal ( ) ) { } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_130"}
{"buggy_code": "return ; } if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "fixed_code": "return ; } if ( n = = parent . getLastChild ( ) ) { int index = - 1 ; } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( ! ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | | n = = parent . getFirstChild ( ) . getNext ( ) . getNext ( ) ) ) ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; } } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "fixed_code": "/ / This no - op statement was there so that JSDoc information could / / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { } } else if ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) { if ( parent . getType ( ) = = Token . FOR & & parent . getChildCount ( ) = = 4 & & ( n = = parent . getFirstChild ( ) | |", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_31"}
{"buggy_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } defineInferredProperty ( prop , typeToInfer , null ) ; } } }", "fixed_code": "typeToInfer = getNativeType ( JSTypeNative . VOID_TYPE ) . getLeastSupertype ( propType ) ; } } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_33"}
{"buggy_code": "return false ; } } return true ; case Token . REGEXP : / / Return true only if all children are const .", "fixed_code": "return false ; } } return false ; case Token . REGEXP : / / Return true only if all children are const .", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_45"}
{"buggy_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; }  if ( savings > ( helperCodeCost + SAVINGS_THRESHOLD ) ) { for ( Reduction reduction : reductions ) { reduction . apply ( ) ; }  Node addingRoot = compiler . getNodeForCodeInsertion ( null ) ; addingRoot . addChildrenToFront ( helperCode ) ; compiler . reportCodeChange ( ) ; } } }", "fixed_code": "for ( Reduction reduction : reductions ) { savings + = reduction . estimateSavings ( ) ; } } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_55"}
{"buggy_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkGlobalThisLevel = CheckLevel . WARNING ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "fixed_code": "/ / checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run . options . checkSuspiciousCode = true ; options . checkSymbols = true ; options . checkMissingReturn = CheckLevel . WARNING ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_59"}
{"buggy_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return res ; } } return res ;", "fixed_code": "} res = n . checkTreeEqualsImpl ( n2 ) ; if ( res ! = null ) { return null ; } } return res ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_61"}
{"buggy_code": "boolean canRemove = false ; if ( specializationState = = null ) { canRemove = true ; } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "fixed_code": "boolean canRemove = false ; if ( specializationState = = null ) { } else { Node specializableFunction = getSpecializableFunctionFromSymbol ( declaration ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_67"}
{"buggy_code": "break ; case Token . STRING : return getStringNumberValue ( n . getString ( ) ) ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "fixed_code": "break ; case Token . STRING : break ; case Token . ARRAYLIT : case Token . OBJECTLIT :", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_75"}
{"buggy_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; currentTraversal . getCompiler ( ) . report ( error ) ; }", "fixed_code": "protected void error ( DiagnosticType diagnostic , Node n ) { JSError error = currentTraversal . makeError ( n , diagnostic , n . toString ( ) ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Closure_78"}
{"buggy_code": "return readObject ; } catch ( ClassNotFoundException ex ) { throw new SerializationException ( \" ClassNotFoundException while reading cloned object data \" , ex ) ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "fixed_code": "return readObject ; } catch ( ClassNotFoundException ex ) { return object ; } catch ( IOException ex ) { throw new SerializationException ( \" IOException while reading cloned object data \" , ex ) ; } finally {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "} / / $ FALL - THROUGH $ default : throw new NumberFormatException ( str + \" is not a valid number . \" ) ; } } else {", "fixed_code": "} / / $ FALL - THROUGH $ default : return createInteger ( str ) ; } } else {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "fixed_code": "throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; } if ( str . startsWith ( \" - - \" ) ) { return Short . parseShort ( str ) ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) | | str . startsWith ( \" 0X \" ) | | str . startsWith ( \" - 0X \" ) ) { int hexDigits = str . length ( ) - 2 ; / / drop 0x", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Lang_7"}
{"buggy_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { throw new MaxIterationsExceededException ( maxIterations ) ; } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "fixed_code": "/ / calculate series double n = 0 . 0 ; / / current element index double an = 1 . 0 / a ; / / n - th element in the series if ( Double . isNaN ( x ) | | ( x < = 0 . 0 ) ) { ret = Double . NaN ; } else { double g = 607 . 0 / 128 . 0 ; double sum = 0 . 0 ; for ( int i = lanczos . length - 1 ; i > 0 ; - - i ) { sum = sum + ( lanczos [ i ] / ( x + i ) ) ; } sum = sum + lanczos [ 0 ] ; double tmp = x + g + . 5 ; ret = ( ( x + . 5 ) * Math . log ( tmp ) ) - tmp + HALF_LOG_2_PI + Math . log ( sum / x ) ; } double sum = an ; / / partial sum while ( Math . abs ( an ) > epsilon & & n < maxIterations ) { / / compute next element in the series n = n + 1 . 0 ; sum = sum + an ; } if ( n > = maxIterations ) { } else { ret = Math . exp ( - x + ( a * Math . log ( x ) ) - logGamma ( a ) ) * sum ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_103"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; } return solveInverseCumulativeProbability ( p , lower , upper ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} } } return minRow ; } return minRatioPositions . get ( 0 ) ; }", "fixed_code": "} } } } return minRatioPositions . get ( 0 ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_28"}
{"buggy_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { columnsToDrop . add ( i ) ; } } / / non - basic artificial variables", "fixed_code": "/ / positive cost non - artificial variables for ( int i = getNumObjectiveFunctions ( ) ; i < getArtificialVariableOffset ( ) ; i + + ) { final double entry = tableau . getEntry ( 0 , i ) ; } / / non - basic artificial variables", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "fixed_code": "if ( ! ( ( nextX > xA ) & & ( nextX < xB ) ) ) { / / the guessed root is not strictly inside of the tightest bracketing interval signChangeIndex = 2 ; / / is a NaN ( which occurs when some sampling points share the same y ) / / we try again with a lower interpolation order if ( signChangeIndex - start > = end - signChangeIndex ) {", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_40"}
{"buggy_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] = work3 [ pj ] * diag [ pj ] / dxNorm ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "fixed_code": "return ; } for ( int j = 0 ; j < solvedCols ; + + j ) { int pj = permutation [ j ] ; work1 [ pj ] / = work2 [ j ] ; / / depending on the sign of the function , update parl or paru . if ( fp > 0 ) { parl = FastMath . max ( parl , lmPar ) ; } else { for ( int j = rank ; j < cols ; + + j ) { lmDir [ permutation [ j ] ] = 0 ; } if ( fp < 0 ) { paru = FastMath . min ( paru , lmPar ) ; } } / / compute an improved estimate for lmPar lmPar = FastMath . max ( parl , lmPar + correction ) ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_58"}
{"buggy_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ; } j - = 4 ; } return true ; } return false ;", "fixed_code": "if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; int mBlockIndex = 0 ; return true ; } return false ;", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "fixed_code": "final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; b2 = work [ nn - 5 ] / work [ nn - 7 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; } }", "fixed_code": "Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minPos = i ; } }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "while ( true ) { incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; } }", "fixed_code": "while ( true ) { final double [ ] xSmallest = simplex [ 0 ] . getPointRef ( ) ; incrementIterationsCounter ( ) ; / / save the original vertex final RealPointValuePair [ ] original = simplex ; / / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; return ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } if ( Math . abs ( rootFindingFunction . value ( upperBound ) ) < 1E - 6 ) { return upperBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { } return new double [ ] { a , b } ; if ( Math . abs ( rootFindingFunction . value ( lowerBound ) ) < 1E - 6 ) { return lowerBound ; } / / Failed bracket convergence was not because of corner solution throw new MathException ( ex ) ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "protected double getInitialDomain ( double p ) { double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; ret = 1 . 0 ; return ret ; }", "label": 0, "tool_name": "RSRepair", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index ! = 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( ! ( dataset . equals ( dataset ) ) ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Chart_1"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( ( dataset ! = null ) & & ( index > 0 ) ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Chart_1"}
{"buggy_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; Context rhsContext = Context . OTHER ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "fixed_code": "case Token . HOOK : { Preconditions . checkState ( childCount = = 3 ) ; int p = NodeUtil . precedence ( type ) ; CodeGenerator . Context rhsContext = CodeGenerator . Context . IN_FOR_INIT_CLAUSE ; addExpr ( first , p + 1 , context ) ; cc . addOp ( \" ? \" , true ) ; addExpr ( first . getNext ( ) , 1 , rhsContext ) ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_123"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( options . dependencyOptions . needsManagement ( ) ) | | ( options . closurePass ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_18"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( c > 0x1f & & c < = 0x7f ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "fixed_code": "/ / No charsetEncoder provided - pass straight latin characters / / through , and escape the rest . Doing the explicit character / / check is measurably faster than using the CharsetEncoder . if ( ( c > = 31 ) & & ( c < 127 ) ) { sb . append ( c ) ; } else { / / Other characters can be misinterpreted by some js parsers ,", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_73"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( namespace , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Closure_93"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev ! = 0 ) & & ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_38"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isImmutableValue ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NULL_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_18"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( ( prev < 0 ) | | ( prev = = ' - ' ) ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_38"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return locals . apply ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_INVALID_ARGUMENT_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options . dependencyOptions ) ! = null ) & & ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_18"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . isToStringMethodCall ( value ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Closure_93"}
{"buggy_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( options . dependencyOptions . needsManagement ( ) & & options . closurePass ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "fixed_code": "/ / Check if the sources need to be re - ordered . boolean staleInputs = false ; if ( ( ( options ) = = null ) | | ( options . dependencyOptions . needsManagement ( ) ) ) { for ( CompilerInput input : inputs ) { / / Forward - declare all the provided types , so that they / / are not flagged even if they are dropped from the process .", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_18"}
{"buggy_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return true ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "fixed_code": "/ / TODO ( nicksantos ) : This needs to be changed so that it / / returns true iff we ' re sure the value was never aliased from inside / / the constructor ( similar to callHasLocalResult ) return NodeUtil . evaluatesToLocalValue ( value . getFirstChild ( ) ) ; case Token . FUNCTION : case Token . REGEXP : case Token . ARRAYLIT :", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_86"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_DUPLICATE_NAMESPACE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch6", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_TOO_MANY_ARGUMENTS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch6", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_LATE_PROVIDE_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch7", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( 0 , ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Closure_93"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_92"}
{"buggy_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( ' . ' ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "fixed_code": "} else { / / In this case , the name was implicitly provided by two independent / / modules . We need to move this code up to a common module . int indexOfDot = namespace . indexOf ( \" JSC_BASE_CLASS_ERROR \" ) ; if ( indexOfDot = = - 1 ) { / / Any old place is fine . compiler . getNodeForCodeInsertion ( minimumModule )", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Closure_93"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , 0 ) ) ; } } }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return ( a < = b ) ? b : ( Float . isNaN ( a + b ) ? Float . NaN : b ) ; }", "fixed_code": "* @ return b if a is lesser or equal to b , a otherwise public static float max ( final float a , final float b ) { return a < = b ? b : Float . isNaN ( ( a + b ) ) ? Float . NaN : a ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_59"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return x = = y ; }", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = ( 3 - n ) * 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > fb ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch10", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( fa ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch11", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch12", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( fa > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch13", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . max ( ( fa * 0 . 0 ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch14", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( Math . min ( ( fa * fb ) , 0 . 0 ) ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch15", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa ) = = 0 . 0 ) | | ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch16", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( ( fa * fb ) > 0 . 0 ) & & ( ( initial ) ! = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch17", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * 0 . 0 ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch2", "project_name": "Math_85"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( ( MathUtils . compareTo ( entry , epsilon , epsilon ) ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Math_82"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch3", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ) > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch4", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa * maximumIterations ) > 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch5", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch6", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch7", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa ! = fb ) & & ( ( fa ) > = 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch8", "project_name": "Math_85"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( ( fa > 0 . 0 ) & & ( ( fa * fb ) > 0 . 0 ) ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" +", "label": 0, "tool_name": "SequenceR", "patch_name": "patch9", "project_name": "Math_85"}
{"buggy_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "fixed_code": "public MultiplePiePlot ( CategoryDataset dataset ) { super ( ) ; if ( dataset ! = null ) { dataset . addChangeListener ( this ) ; } this . dataset = dataset ; PiePlot piePlot = new PiePlot ( null ) ; this . pieChart = new JFreeChart ( piePlot ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "fixed_code": "public void removeValue ( int index ) { this . keys . remove ( index ) ; this . values . remove ( index ) ; if ( index < = this . keys . size ( ) ) { rebuildIndex ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_18"}
{"buggy_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; removeRow ( index ) ; }", "fixed_code": "public void removeRow ( Comparable rowKey ) { int index = getRowIndex ( rowKey ) ; if ( index < 0 ) { throw new UnknownKeyException ( \" The key ( \" + rowKey . toString ( ) ) ; } removeRow ( index ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_22"}
{"buggy_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "fixed_code": "drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } if ( orientation = = PlotOrientation . HORIZONTAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "fixed_code": "if ( end < start ) { throw new IllegalArgumentException ( \" Requires start < = end . \" ) ; } this . maxY = 1 . 0 ; TimeSeries copy = ( TimeSeries ) super . clone ( ) ; copy . data = new java . util . ArrayList ( ) ; if ( this . data . size ( ) > 0 ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_106"}
{"buggy_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( CompilationLevel . ADVANCED_OPTIMIZATIONS = = level ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "fixed_code": "} catch ( IOException e ) { throw new RuntimeException ( \" Reading XTB file \" , e ) ; } } else if ( options . messageBundle ! = null ) { options . messageBundle = new EmptyMessageBundle ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; }  return this ; }", "fixed_code": "child ! = null ; child = child . getNext ( ) ) { child . useSourceInfoIfMissingFromForTree ( other ) ; } this . propListHead = other . propListHead ; return this ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_108"}
{"buggy_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token ! = JsDocToken . STRING ) { return reportGenericTypeSyntaxWarning ( ) ; }", "fixed_code": "* TypeApplication : = ' . < ' TypeExpressionList ' > ' private Node parseTypeName ( JsDocToken token ) { if ( token = = null ) { return reportGenericTypeSyntaxWarning ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "* block . See ECMA 262 Sections 8 . 9 & 12 . 14 if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getFirstChild ( ) . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . UNCOND , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "fixed_code": "} else if ( parent . getLastChild ( ) = = node ) { if ( cfa ! = null ) { for ( Node finallyNode : cfa . finallyMap . get ( parent ) ) { cfa . createEdge ( fromNode , Branch . ON_EX , finallyNode ) ; } } return computeFollowNode ( fromNode , parent , cfa ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_14"}
{"buggy_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "fixed_code": "} if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "fixed_code": "/ / be attached to the name . This check should not complain about it . if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = parent . getParent ( ) . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK )", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "fixed_code": "Node newRight ; if ( areNodesEqualForInlining ( left , right . getFirstChild ( ) ) ) { n . removeChild ( right ) ; newRight = right . getLastChild ( ) ; } else if ( NodeUtil . isCommutative ( right . getType ( ) ) & & areNodesEqualForInlining ( left , right . getLastChild ( ) ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_26"}
{"buggy_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( x < 0 & & prev = = ' - ' ) { add ( \" \" ) ; }", "fixed_code": "/ / x - - 4 ( which is a syntax error ) . char prev = getLastChar ( ) ; boolean negativeZero = isNegativeZero ( x ) ; if ( prev = = ' - ' ) { add ( \" \" ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_38"}
{"buggy_code": "getPropertyNode ( property ) ) ; } } return builder . build ( ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "fixed_code": "getPropertyNode ( property ) ) ; } } return getLeastSupertype ( this , that ) ; } JSType getGreatestSubtypeHelper ( JSType that ) { if ( that . isRecordType ( ) ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_46"}
{"buggy_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null ) { className = target . getString ( ) ; } }", "fixed_code": "String qualifiedName = callee . getQualifiedName ( ) ; if ( functionName . equals ( qualifiedName ) ) { Node target = callee . getNext ( ) ; if ( target ! = null & & target . getType ( ) = = Token . STRING ) { className = target . getString ( ) ; } }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Closure_57"}
{"buggy_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { / / too many for Long return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "fixed_code": "} if ( pfxLen > 0 ) { / / we have a hex number final int hexDigits = str . length ( ) - pfxLen ; if ( hexDigits > 16 ) { try { return createLong ( str ) ; } catch ( final NumberFormatException nfe ) { } return createBigInteger ( str ) ; } if ( hexDigits > 8 ) { / / too many for an int", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_1"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_10"}
{"buggy_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( start = = 0 & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "fixed_code": "throw new IllegalArgumentException ( \" Requested random string length \" + count + \" is less than 0 . \" ) ; } if ( chars = = null & & end = = 0 ) { if ( ! letters & & ! numbers ) { end = Integer . MAX_VALUE ; } else {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_12"}
{"buggy_code": "if ( str = = null ) { return null ; } if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "fixed_code": "if ( str = = null ) { return null ; } str = str . toLowerCase ( ) ; if ( StringUtils . isBlank ( str ) ) { throw new NumberFormatException ( \" A blank string is not a valid number \" ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_16"}
{"buggy_code": "/ / a wrong value . return null ; } if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "fixed_code": "/ / a wrong value . return null ; } str = str . toLowerCase ( ) ; if ( str . startsWith ( \" 0x \" ) | | str . startsWith ( \" - 0x \" ) ) { return createInteger ( str ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortClassName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getShortCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( lower + ( upper - 3 ) ) < lower ) { upper = lower ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "locale = Locale . getDefault ( ) ; } try { SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "fixed_code": "locale = Locale . getDefault ( ) ; } try { if ( locale ! = null ) { key = new Pair ( key , locale ) ; } SimpleDateFormat formatter = ( SimpleDateFormat ) DateFormat . getDateTimeInstance ( dateStyle , timeStyle , locale ) ; String pattern = formatter . toPattern ( ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_50"}
{"buggy_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < len ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "fixed_code": "char [ ] thisBuf = buffer ; int len = thisBuf . length - strLen ; outer : for ( int i = startIndex ; i < size ; i + + ) { for ( int j = 0 ; j < strLen ; j + + ) { if ( str . charAt ( j ) ! = thisBuf [ i + j ] ) { continue outer ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_61"}
{"buggy_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "fixed_code": "end . add ( field , - 1 * difference ) ; int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < field ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "fixed_code": "Validate . notNull ( classLoader , \" ClassLoader cannot be null . \" ) ; Validate . isTrue ( listenerInterface . isInterface ( ) , \" Class { 0 } is not an interface \" , listenerInterface . getName ( ) ) ; this . prototypeArray = ( L [ ] ) Array . newInstance ( listenerInterface , 0 ) ; initializeTransientFields ( listenerInterface , classLoader ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Lang_9"}
{"buggy_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) | | ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "fixed_code": "final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( n < maxIterations ) & & ( FastMath . abs ( value - value ) > epsilon ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_1"}
{"buggy_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "fixed_code": "* @ since 1 . 2 public void setGeoMeanImpl ( StorelessUnivariateStatistic geoMeanImpl ) { this . sumImpl = geoMeanImpl ; checkEmpty ( ) ; this . geoMeanImpl = geoMeanImpl ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_43"}
{"buggy_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "fixed_code": "throws ConvergenceException { forward = interpolator . isForward ( ) ; t0 = interpolator . getPreviousTime ( ) ; final double t1 = interpolator . getCurrentTime ( ) ; final double dt = t1 - t0 ; if ( FastMath . abs ( dt ) < convergence ) {", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_44"}
{"buggy_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "fixed_code": "break ; case REGULA_FALSI : / / Nothing . if ( x = = x0 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return evaluations . getCount ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return ( Double . isNaN ( x ) & & Double . isNaN ( y ) ) | | x = = y ; }", "fixed_code": "* @ return { @ code true } if the values are equal . public static boolean equals ( double x , double y ) { return equals ( x , y , 1 ) | | FastMath . abs ( y - x ) < = SAFE_MIN ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j ) { out [ i ] [ j ] = 0d ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "fixed_code": "double [ ] [ ] out = new double [ nVars ] [ nVars ] ; for ( int i = 0 ; i < nVars ; i + + ) { for ( int j = 0 ; j < nVars ; j + + ) { if ( i = = j & & i < nVars ) { out [ i ] [ j ] = 0 . 0 ; } else { double r = correlationMatrix . getEntry ( i , j ) ; double t = Math . abs ( r * Math . sqrt ( ( nObs - 2 ) / ( 1 - r * r ) ) ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_69"}
{"buggy_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; }   return solve ( f , min , yMin , max , yMax , initial , yInitial ) ; }", "fixed_code": "if ( yInitial * yMax < 0 ) { return solve ( f , initial , yInitial , max , yMax , initial , yInitial ) ; } return solve ( f , min , initial ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_73"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = sampleSize ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "fixed_code": "/ / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 0 ; k + = step ) { final double tmp = work [ i + k ] ; work [ i + k ] = work [ j - k ] ; work [ j - k ] = tmp ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( work [ np - 8 ] > b2 | | work [ np - 4 ] > b1 ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "fixed_code": "double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ; if ( b2 > 0 . 0 & & b2 > b2 * b1 / ( 1 + b2 * b2 ) ) { return ; } double a2 = ( work [ np - 8 ] / b2 ) * ( 1 + work [ np - 4 ] / b1 ) ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) {  return ; }", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < = 0 ) { return ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "} while ( ( fa * fb > 0 . 0 ) & & ( numIterations < maximumIterations ) & & ( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * upperBound > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; if ( MathUtils . compareTo ( tableau . getEntry ( i , col ) , 0 , epsilon ) > = 0 ) { double ratio = rhs / tableau . getEntry ( i , col ) ; if ( ratio < = minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SimFix", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "fixed_code": "} int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null & & baseToolTipGenerator ! = legendItemToolTipGenerator ) { return result ; } int seriesCount = dataset . getRowCount ( ) ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Chart_1"}
{"buggy_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { return result ; } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "fixed_code": "int index = this . plot . getIndexOf ( this ) ; CategoryDataset dataset = this . plot . getDataset ( index ) ; if ( dataset ! = null ) { if ( false ) { return result ; } } int seriesCount = dataset . getRowCount ( ) ; if ( plot . getRowRenderingOrder ( ) . equals ( SortOrder . ASCENDING ) ) { for ( int i = 0 ; i < seriesCount ; i + + ) {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Chart_1"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , true ) ) ; } } }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Lang_6"}
{"buggy_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , pos ) ) ; } } }", "fixed_code": "/ / / / contract with translators is that they have to understand codepoints / / / / and they just took care of a surrogate pair for ( int pt = 0 ; pt < consumed ; pt + + ) { pos + = Character . charCount ( Character . codePointAt ( input , writer ! = null ) ) ; } } }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Lang_6"}
{"buggy_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "fixed_code": "if ( Precision . compareTo ( entry , 0d , maxUlps ) > 0 ) { final double ratio = rhs / entry ; final int cmp = Precision . compareTo ( ratio , minRatio , maxUlps ) ; if ( rhs ! = minRatio ) { if ( cmp = = 0 ) { minRatioPositions . add ( i ) ; } else if ( cmp < 0 ) { } } } } if ( minRatioPositions . size ( ) = = 0 ) { return null ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_33"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | i < 0 ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_70"}
{"buggy_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "fixed_code": "for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getHeight ( ) ; i + + ) { final double rhs = tableau . getEntry ( i , tableau . getWidth ( ) - 1 ) ; final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , entry ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ;", "label": 0, "tool_name": "SketchFix", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 ) { / / max and m bracket the root . min = m ; } else {", "fixed_code": "public double solve ( final UnivariateRealFunction f , double min , double max , double initial ) throws MaxIterationsExceededException , FunctionEvaluationException { return solve ( f , min , max ) ; } fmin = f . value ( min ) ; fm = f . value ( m ) ; if ( fm * fmin > 0 . 0 | | fmin = = fm ) { / / max and m bracket the root . min = m ; } else {", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Math_70"}
{"buggy_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio ) { minRatio = ratio ; minRatioPos = i ; }", "fixed_code": "final double entry = tableau . getEntry ( i , col ) ; if ( MathUtils . compareTo ( entry , 0 , epsilon ) > = 0 ) { final double ratio = rhs / entry ; if ( ratio < minRatio & & ratio > = 0 ) { minRatio = ratio ; minRatioPos = i ; }", "label": 0, "tool_name": "SketchFix", "patch_name": "patch2", "project_name": "Math_82"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > = upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp < upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "fixed_code": "} k = 1 . 0 / k ; tmp = mu + k * sigma ; if ( tmp > upper ) { upper = ( ( int ) Math . ceil ( tmp ) ) - 1 ; } }", "label": 0, "tool_name": "SOFix", "patch_name": "patch2", "project_name": "Math_2"}
{"buggy_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list ! = null | | list . contains ( listener ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower throw new IllegalArgumentException ( msg ) ; } this . lower = lower ; this . upper = upper ;", "fixed_code": "if ( lower > upper ) { String msg = \" Range ( double , double ) : require lower ( \" + lower \" ) < = upper ( \" + upper + \" ) . \" ;  } this . lower = lower ; this . upper = upper ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_13"}
{"buggy_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = markers . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "fixed_code": "markers = ( ArrayList ) this . backgroundDomainMarkers . get ( new Integer ( } boolean removed = getAnnotations ( ) . remove ( marker ) ; if ( removed & & notify ) { fireChangeEvent ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_14"}
{"buggy_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } public void draw ( Graphics2D g2 , Rectangle2D plotArea , Point2D anchor , PlotState parentState , PlotRenderingInfo info ) {  RectangleInsets insets = getInsets ( ) ; insets . trim ( plotArea ) ;  Rectangle2D originalPlotArea = ( Rectangle2D ) plotArea . clone ( ) ; if ( info ! = null ) { info . setPlotArea ( plotArea ) ; info . setDataArea ( plotArea ) ; }  drawBackground ( g2 , plotArea ) ;  Shape savedClip = g2 . getClip ( ) ; g2 . clip ( plotArea ) ;  double gapPercent = getInteriorGap ( ) ; double labelPercent = 0 . 0 ; if ( getLabelGenerator ( ) ! = null ) { labelPercent = getLabelGap ( ) + getMaximumLabelWidth ( ) ; } double gapHorizontal = plotArea . getWidth ( ) * ( gapPercent + labelPercent ) * 2 . 0 ; double gapVertical = plotArea . getHeight ( ) * gapPercent * 2 . 0 ;  if ( DEBUG_DRAW_INTERIOR ) { double hGap = plotArea . getWidth ( ) * getInteriorGap ( ) ; double vGap = plotArea . getHeight ( ) * getInteriorGap ( ) ; double igx1 = plotArea . getX ( ) + hGap ; double igx2 = plotArea . getMaxX ( ) - hGap ; double igy1 = plotArea . getY ( ) + vGap ; double igy2 = plotArea . getMaxY ( ) - vGap ; g2 . setPaint ( Color . lightGray ) ; g2 . draw ( new Rectangle2D . Double ( igx1 , igy1 , igx2 - igx1 , igy2 - igy1 ) ) ; }  double linkX = plotArea . getX ( ) + gapHorizontal / 2 ; double linkY = plotArea . getY ( ) + gapVertical / 2 ; double linkW = plotArea . getWidth ( ) - gapHorizontal ; double linkH = plotArea . getHeight ( ) - gapVertical ;  if ( isCircular ( ) ) { / / is circular ? double min = Math . min ( linkW , linkH ) / 2 ; linkX = ( linkX + linkX + linkW ) / 2 - min ; linkY = ( linkY + linkY + linkH ) / 2 - min ; linkW = 2 * min ; linkH = 2 * min ; }  PiePlotState state = initialise ( g2 , plotArea , this , null , info ) ;  Rectangle2D linkAreaXX = new Rectangle2D . Double ( linkX , linkY , linkW , linkH * ( 1 - this . depthFactor ) ) ; state . setLinkArea ( linkAreaXX ) ;  if ( DEBUG_DRAW_LINK_AREA ) { g2 . setPaint ( Color . blue ) ; g2 . draw ( linkAreaXX ) ; g2 . setPaint ( Color . yellow ) ; g2 . draw ( new Ellipse2D . Double ( linkAreaXX . getX ( ) , linkAreaXX . getY ( ) , linkAreaXX . getWidth ( ) , linkAreaXX . getHeight ( ) ) ) ; }  double hh = linkW * getLabelLinkMargin ( ) ; double vv = linkH * getLabelLinkMargin ( ) ; Rectangle2D explodeArea = new Rectangle2D . Double ( linkX + hh / 2 . 0 , linkY + vv / 2 . 0 , linkW - hh , linkH - vv ) ;  state . setExplodedPieArea ( explodeArea ) ;  double maximumExplodePercent = getMaximumExplodePercent ( ) ; double percent = maximumExplodePercent / ( 1 . 0 + maximumExplodePercent ) ;  double h1 = explodeArea . getWidth ( ) * percent ; double v1 = explodeArea . getHeight ( ) * percent ; Rectangle2D pieArea = new Rectangle2D . Double ( explodeArea . getX ( ) + h1 / 2 . 0 , explodeArea . getY ( ) + v1 / 2 . 0 , explodeArea . getWidth ( ) - h1 , explodeArea . getHeight ( ) - v1 ) ;  int depth = ( int ) ( pieArea . getHeight ( ) * this . depthFactor ) ; Rectangle2D linkArea = new Rectangle2D . Double ( linkX , linkY , linkW , linkH - depth ) ; state . setLinkArea ( linkArea ) ;  state . setPieArea ( pieArea ) ; state . setPieCenterX ( pieArea . getCenterX ( ) ) ; state . setPieCenterY ( pieArea . getCenterY ( ) - depth / 2 . 0 ) ; state . setPieWRadius ( pieArea . getWidth ( ) / 2 . 0 ) ; state . setPieHRadius ( ( pieArea . getHeight ( ) - depth ) / 2 . 0 ) ;  PieDataset dataset = getDataset ( ) ; if ( DatasetUtilities . isEmptyOrNull ( getDataset ( ) ) ) { drawNoDataMessage ( g2 , plotArea ) ; g2 . setClip ( savedClip ) ; drawOutline ( g2 , plotArea ) ; return ; }  if ( dataset . getKeys ( ) . size ( ) > plotArea . getWidth ( ) ) { String text = \" Too many elements \" ; Font sfont = new Font ( \" dialog \" , Font . BOLD , 10 ) ; g2 . setFont ( sfont ) ; FontMetrics fm = g2 . getFontMetrics ( sfont ) ; int stringWidth = fm . stringWidth ( text ) ;  g2 . drawString ( text , ( int ) ( plotArea . getX ( ) + ( plotArea . getWidth ( ) - stringWidth ) / 2 ) , ( int ) ( plotArea . getY ( ) + ( plotArea . getHeight ( ) / 2 ) ) ) ; return ; } if ( isCircular ( ) ) { double min = Math . min ( plotArea . getWidth ( ) , plotArea . getHeight ( ) ) / 2 ; plotArea = new Rectangle2D . Double ( plotArea . getCenterX ( ) - min , plotArea . getCenterY ( ) - min , 2 * min , 2 * min ) ; } List sectionKeys = dataset . getKeys ( ) ;  if ( sectionKeys . size ( ) = = 0 ) { return ; }  double arcX = pieArea . getX ( ) ; double arcY = pieArea . getY ( ) ;  Composite originalComposite = g2 . getComposite ( ) ; g2 . setComposite ( AlphaComposite . getInstance ( AlphaComposite . SRC_OVER , getForegroundAlpha ( ) ) ) ;  double totalValue = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ; double runningTotal = 0 ; if ( depth < 0 ) { return ; / / if depth is negative don ' t draw anything }  ArrayList arcList = new ArrayList ( ) ; Arc2D . Double arc ; Paint paint ; Paint outlinePaint ; Stroke outlineStroke ;  Iterator iterator = sectionKeys . iterator ( ) ; while ( iterator . hasNext ( ) ) {  Comparable currentKey = ( Comparable ) iterator . next ( ) ; Number dataValue = dataset . getValue ( currentKey ) ; if ( dataValue = = null ) { arcList . add ( null ) ; continue ; } double value = dataValue . doubleValue ( ) ; if ( value < = 0 ) { arcList . add ( null ) ; continue ; } double startAngle = getStartAngle ( ) ; double direction = getDirection ( ) . getFactor ( ) ; double angle1 = startAngle + ( direction * ( runningTotal * 360 ) ) / totalValue ; double angle2 = startAngle + ( direction * ( runningTotal + value ) * 360 ) / totalValue ; if ( Math . abs ( angle2 - angle1 ) > getMinimumArcAngleToDraw ( ) ) { arcList . add ( new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , angle1 , angle2 - angle1 , Arc2D . PIE ) ) ; } else { arcList . add ( null ) ; } runningTotal + = value ; }  Shape oldClip = g2 . getClip ( ) ;  Ellipse2D top = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Ellipse2D bottom = new Ellipse2D . Double ( pieArea . getX ( ) , pieArea . getY ( ) + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth ) ;  Rectangle2D lower = new Rectangle2D . Double ( top . getX ( ) , top . getCenterY ( ) , pieArea . getWidth ( ) , bottom . getMaxY ( ) - top . getCenterY ( ) ) ;  Rectangle2D upper = new Rectangle2D . Double ( pieArea . getX ( ) , top . getY ( ) , pieArea . getWidth ( ) , bottom . getCenterY ( ) - top . getY ( ) ) ;  Area a = new Area ( top ) ; a . add ( new Area ( lower ) ) ; Area b = new Area ( bottom ) ; b . add ( new Area ( upper ) ) ; Area pie = new Area ( a ) ; pie . intersect ( b ) ;  Area front = new Area ( pie ) ; front . subtract ( new Area ( top ) ) ;  Area back = new Area ( pie ) ; back . subtract ( new Area ( bottom ) ) ;  int [ ] xs ; int [ ] ys ; arc = new Arc2D . Double ( arcX , arcY + depth , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , 0 , 360 , Arc2D . PIE ) ;  int categoryCount = arcList . size ( ) ; for ( int categoryIndex = 0 ; categoryIndex < categoryCount ; categoryIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( categoryIndex ) ; if ( arc = = null ) { continue ; } Comparable key = getSectionKey ( categoryIndex ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; g2 . setPaint ( paint ) ; g2 . fill ( arc ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( arc ) ; g2 . setPaint ( paint ) ;  Point2D p1 = arc . getStartPoint ( ) ;  xs = new int [ ] { ( int ) arc . getCenterX ( ) , ( int ) arc . getCenterX ( ) , ( int ) p1 . getX ( ) , ( int ) p1 . getX ( ) } ; ys = new int [ ] { ( int ) arc . getCenterY ( ) , ( int ) arc . getCenterY ( ) - depth , ( int ) p1 . getY ( ) - depth , ( int ) p1 . getY ( ) } ; Polygon polygon = new Polygon ( xs , ys , 4 ) ; g2 . setPaint ( java . awt . Color . lightGray ) ; g2 . fill ( polygon ) ; g2 . setPaint ( outlinePaint ) ; g2 . setStroke ( outlineStroke ) ; g2 . draw ( polygon ) ; g2 . setPaint ( paint ) ;  }  g2 . setPaint ( Color . gray ) ; g2 . fill ( back ) ; g2 . fill ( front ) ;  int cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key , true ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , false , true ) ; } cat + + ; }  cat = 0 ; iterator = arcList . iterator ( ) ; while ( iterator . hasNext ( ) ) { Arc2D segment = ( Arc2D ) iterator . next ( ) ; if ( segment ! = null ) { Comparable key = getSectionKey ( cat ) ; paint = lookupSectionPaint ( key ) ; outlinePaint = lookupSectionOutlinePaint ( key ) ; outlineStroke = lookupSectionOutlineStroke ( key ) ; drawSide ( g2 , pieArea , segment , front , back , paint , outlinePaint , outlineStroke , true , false ) ; } cat + + ; }  g2 . setClip ( oldClip ) ;  Arc2D upperArc ; for ( int sectionIndex = 0 ; sectionIndex < categoryCount ; sectionIndex + + ) { arc = ( Arc2D . Double ) arcList . get ( sectionIndex ) ; if ( arc = = null ) { continue ; } upperArc = new Arc2D . Double ( arcX , arcY , pieArea . getWidth ( ) , pieArea . getHeight ( ) - depth , arc . getAngleStart ( ) , arc . getAngleExtent ( ) , Arc2D . PIE ) ;  Comparable currentKey = ( Comparable ) sectionKeys . get ( sectionIndex ) ; paint = lookupSectionPaint ( currentKey , true ) ; outlinePaint = lookupSectionOutlinePaint ( currentKey ) ; outlineStroke = lookupSectionOutlineStroke ( currentKey ) ; g2 . setPaint ( paint ) ; g2 . fill ( upperArc ) ; g2 . setStroke ( outlineStroke ) ; g2 . setPaint ( outlinePaint ) ; g2 . draw ( upperArc ) ;  if ( info ! = null ) { EntityCollection entities = info . getOwner ( ) . getEntityCollection ( ) ; if ( entities ! = null ) { String tip = null ; PieToolTipGenerator tipster = getToolTipGenerator ( ) ; if ( tipster ! = null ) { tip = tipster . generateToolTip ( dataset , currentKey ) ; } String url = null ; if ( getURLGenerator ( ) ! = null ) { url = getURLGenerator ( ) . generateURL ( dataset , currentKey , getPieIndex ( ) ) ; } PieSectionEntity entity = new PieSectionEntity ( upperArc , dataset , getPieIndex ( ) , sectionIndex , currentKey , tip , url ) ; entities . add ( entity ) ; } } List keys = dataset . getKeys ( ) ; Rectangle2D adjustedPlotArea = new Rectangle2D . Double ( originalPlotArea . getX ( ) , originalPlotArea . getY ( ) , originalPlotArea . getWidth ( ) , originalPlotArea . getHeight ( ) - depth ) ; if ( getSimpleLabels ( ) ) { drawSimpleLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } else { drawLabels ( g2 , keys , totalValue , adjustedPlotArea , linkArea , state ) ; } }  g2 . setClip ( savedClip ) ; g2 . setComposite ( originalComposite ) ; drawOutline ( g2 , originalPlotArea ) ;  }", "fixed_code": "notifyListeners ( new PlotChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_15"}
{"buggy_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } public void drawItem ( Graphics2D g2 , CategoryItemRendererState state , Rectangle2D dataArea , CategoryPlot plot , CategoryAxis domainAxis , ValueAxis rangeAxis , CategoryDataset data , int row , int column , int pass ) {  if ( ! ( data instanceof StatisticalCategoryDataset ) ) { throw new IllegalArgumentException ( \" Requires StatisticalCategoryDataset . \" ) ; } StatisticalCategoryDataset statData = ( StatisticalCategoryDataset ) data ;  PlotOrientation orientation = plot . getOrientation ( ) ; if ( orientation = = PlotOrientation . HORIZONTAL ) { drawHorizontalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } else if ( orientation = = PlotOrientation . VERTICAL ) { drawVerticalItem ( g2 , state , dataArea , plot , domainAxis , rangeAxis , statData , row , column ) ; } }", "fixed_code": "notifyListeners ( new RendererChangeEvent ( this ) ) ; } ", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_25"}
{"buggy_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) < = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "fixed_code": "PlotRenderingInfo state ) { / / if the plot area is too small , just return . . . boolean b1 = ( area . getWidth ( ) ! = MINIMUM_WIDTH_TO_DRAW ) ; boolean b2 = ( area . getHeight ( ) < = MINIMUM_HEIGHT_TO_DRAW ) ; if ( b1 | | b2 ) { return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_26"}
{"buggy_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { add ( item , true ) ; }", "fixed_code": "* permitted ) . public void add ( TimeSeriesDataItem item ) { updateBoundsForRemovedItem ( item ) ; add ( item , true ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_3"}
{"buggy_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( x ) , new Double ( y ) ) ; }", "fixed_code": "* @ since 1 . 0 . 10 public XYDataItem addOrUpdate ( double x , double y ) { return addOrUpdate ( new Double ( getItemCount ( ) ) , new Double ( y ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_5"}
{"buggy_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxMiddleIndex ; }", "fixed_code": "* @ return The index . public int getMaxMiddleIndex ( ) { return this . maxStartIndex ;  }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Chart_7"}
{"buggy_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n . options . messageBundle = new EmptyMessageBundle ( ) ; } return options ;", "fixed_code": "/ / In ADVANCED mode , goog . getMsg is going to be renamed anyway , / / so we might as well inline it . But shut off the i18n warnings , / / because the user didn ' t really ask for i18n .  } return options ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_107"}
{"buggy_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseTypeName ( token ) ; }", "fixed_code": "* For expressions on the right hand side of a this : or new : private Node parseContextTypeExpression ( JsDocToken token ) { return parseAndRecordTypeNode ( token ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_109"}
{"buggy_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "fixed_code": "/ / For each named parameter check if a mutable argument use more than one . if ( fnParam ! = null ) { if ( cArg ! = null ) { if ( ( hasSideEffects & & NodeUtil . canBeSideEffected ( cArg ) ) & & ( NodeUtil . mayHaveSideEffects ( cArg , compiler ) ) ) { return CanInlineResult . NO ; } / / Check for arguments that are evaluated more than once .", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_115"}
{"buggy_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( ! ControlFlowGraph . isEnteringNewCfgNode ( c ) & & apply ( c ) ) { return true ; } }", "fixed_code": "} for ( Node c = n . getFirstChild ( ) ; c ! = null ; c = c . getNext ( ) ) { if ( apply ( c ) ) { return true ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_12"}
{"buggy_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; tryMinimizeExits ( finallyBlock , exitType , labelName ) ; } }", "fixed_code": "if ( NodeUtil . hasFinally ( n ) ) { Node finallyBlock = n . getLastChild ( ) ; matchingExitNode ( finallyBlock , exitType , labelName ) ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_126"}
{"buggy_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( token ) ; String returnDescription = returnDescriptionInfo . string ;", "fixed_code": "/ / Find the return ' s description ( if applicable ) . if ( jsdocBuilder . shouldParseDocumentation ( ) ) { ExtractionInfo returnDescriptionInfo = extractMultilineTextualBlock ( current ( ) ) ; String returnDescription = returnDescriptionInfo . string ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_133"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ( ancestorType = = Token . COMMA ) | | ( parent . getType ( ) ! = Token . EXPR_RESULT & & parent . getType ( ) ! = Token . BLOCK ) ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ; else break ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_21"}
{"buggy_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType = = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "fixed_code": "if ( n = = parent . getLastChild ( ) ) { for ( Node an : parent . getAncestors ( ) ) { int ancestorType = an . getType ( ) ; if ( ancestorType > = Token . COMMA ) continue ; if ( ancestorType ! = Token . EXPR_RESULT & & ancestorType ! = Token . BLOCK ) return ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_22"}
{"buggy_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = nullCount + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "fixed_code": "* @ return a number between 0 . 0 and 100 . 0 double getTypedPercent ( ) { int total = this . noTypeCheckSection + unknownCount + typedCount ; if ( total = = 0 ) { return 0 . 0 ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Closure_66"}
{"buggy_code": "} @ Override protected Class < ? > resolveClass ( ObjectStreamClass desc ) throws IOException , ClassNotFoundException { String name = desc . getName ( ) ; try { return Class . forName ( name , false , classLoader ) ; } catch ( ClassNotFoundException ex ) { return Class . forName ( name , false , Thread . currentThread ( ) . getContextClassLoader ( ) ) ; } } }", "fixed_code": "}  }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_13"}
{"buggy_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( tokenLen > = 4 ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "fixed_code": "rule = new TextField ( Calendar . ERA , ERAs ) ; break ; case ' y ' : / / year ( number ) if ( ( tokenLen > = 4 ) | | ! ( tokenLen = = 2 ) ) { rule = selectNumberRule ( Calendar . YEAR , tokenLen ) ; } else { rule = TwoDigitYearField . INSTANCE ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_18"}
{"buggy_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ( array [ startIndex ] = = null ? 16 : array [ startIndex ] . toString ( ) . length ( ) ) + 1 ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "fixed_code": "return EMPTY ; } StringBuilder buf = new StringBuilder ( ) ; for ( int i = startIndex ; i < endIndex ; i + + ) { if ( i > startIndex ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_20"}
{"buggy_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) < = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "fixed_code": "private static int greatestCommonDivisor ( int u , int v ) { / / From Commons Math : / / if either operand is abs 1 , return 1 : if ( Math . abs ( u ) = = 1 | | Math . abs ( v ) < = 1 ) { return 1 ; } / / keep u and v negative , as negative integers range down to", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_22"}
{"buggy_code": "/ / can ' t have an E at the last byte return false ; } if ( chars [ i ] = = ' . ' ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "fixed_code": "/ / can ' t have an E at the last byte return false ; } if ( ( chars [ i ] = = ' . ' ) | | ( chars [ i ] = = ' l ' | | chars [ i ] = = ' L ' ) ) { if ( hasDecPoint | | hasExp ) { / / two decimal points or dec in exponent return false ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_24"}
{"buggy_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos > - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "fixed_code": "} mant = str . substring ( 0 , decPos ) ; } else { if ( expPos < - 1 ) { mant = str . substring ( 0 , expPos ) ; } else { mant = str ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_27"}
{"buggy_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i < searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "fixed_code": "int increase = 0 ; / / count the replacement text elements that are larger than their corresponding text being replaced for ( int i = 0 ; i = = searchList . length ; i + + ) { int greater = replacementList [ i ] . length ( ) - searchList [ i ] . length ( ) ; if ( greater > 0 ) { increase + = 3 * greater ; / / assume 3 matches", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_39"}
{"buggy_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageName ( cls . getName ( ) ) ; }", "fixed_code": "if ( cls = = null ) { return StringUtils . EMPTY ; } return getPackageCanonicalName ( cls . getName ( ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_41"}
{"buggy_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , true ) ; break ; case START_FE : fmtCount + + ;", "fixed_code": "while ( pos . getIndex ( ) < pattern . length ( ) ) { switch ( c [ pos . getIndex ( ) ] ) { case QUOTE : appendQuotedString ( pattern , pos , stripCustom , false ) ; break ; case START_FE : fmtCount + + ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_43"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & ( numeric . charAt ( 0 ) = = ' - ' & & isDigits ( numeric . substring ( 1 ) ) | | isDigits ( numeric ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_44"}
{"buggy_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( upper < lower ) { upper = lower ; }", "fixed_code": "upper = str . length ( ) ; } / / if upper is less than lower , raise it to lower if ( ( upper < lower ) & & ( upper ! = str . length ( ) ) ) { upper = lower ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_45"}
{"buggy_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch = = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "fixed_code": "} case 3 : { char ch = str . charAt ( 0 ) ; if ( ch < = ' y ' ) { return ( str . charAt ( 1 ) = = ' e ' | | str . charAt ( 1 ) = = ' E ' ) & & ( str . charAt ( 2 ) = = ' s ' | | str . charAt ( 2 ) = = ' S ' ) ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_51"}
{"buggy_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "fixed_code": "switch ( lastChar ) { case ' l ' : case ' L ' : if ( dec ! = numeric | | ( dec = = null & & exp = = null & & isDigits ( numeric . substring ( 1 ) ) & & ( numeric . charAt ( 0 ) = = ' - ' | | Character . isDigit ( numeric . charAt ( 0 ) ) ) ) ) { try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_58"}
{"buggy_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size - = len ; }", "fixed_code": "* @ throws IndexOutOfBoundsException if any index is invalid private void deleteImpl ( int startIndex , int endIndex , int len ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , capacity ( ) - endIndex ) ; size - = len ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_60"}
{"buggy_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = startValue - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "fixed_code": "int endValue = end . get ( field ) ; int startValue = start . get ( field ) ; if ( endValue < startValue ) { int newdiff = difference - endValue ; end . add ( field , newdiff ) ; return newdiff ; } else {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Lang_63"}
{"buggy_code": "if ( x < 0 ) { / / y is an even integer in this case if ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) { return pow ( - x , y ) ; }", "fixed_code": "if ( x < 0 ) { / / y is an even integer in this case if ( ( y > = TWO_POWER_52 | | y < = - TWO_POWER_52 ) & & ! ( y = = ( long ) y ) ) { return pow ( - x , y ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_15"}
{"buggy_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final double m = getNumberOfSuccesses ( ) ; final double n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "fixed_code": "protected double calculateNumericalVariance ( ) { final double N = getPopulationSize ( ) ; final int m = getNumberOfSuccesses ( ) ; final int n = getSampleSize ( ) ; return ( n * m * ( N - n ) * ( N - m ) ) / ( N * N * ( N - 1 ) ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_2"}
{"buggy_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "fixed_code": "case REGULA_FALSI : / / Nothing . if ( x = = x1 ) { x0 + = 0 . 5 * ( x0 + x1 - FastMath . max ( rtol * FastMath . abs ( x1 ) , atol ) ) ; f0 = computeObjectiveValue ( x0 ) ; } break ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_50"}
{"buggy_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return iterations . getCount ( ) ; }", "fixed_code": "* @ return the number of evaluations of the objective function . public int getIterations ( ) { return this . evaluations . getCount ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_6"}
{"buggy_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( bound1 , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "fixed_code": "try { final double bound1 = ( i = = 0 ) ? min : min + generator . nextDouble ( ) * ( max - min ) ; final double bound2 = ( i = = 0 ) ? max : min + generator . nextDouble ( ) * ( max - min ) ; optima [ i ] = optimizer . optimize ( f , goal , FastMath . min ( min , bound2 ) , FastMath . max ( bound1 , bound2 ) ) ; } catch ( FunctionEvaluationException fee ) { optima [ i ] = null ; } catch ( ConvergenceException ce ) {", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_62"}
{"buggy_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] ) ) { return false ; } }", "fixed_code": "return false ; } for ( int i = 0 ; i < x . length ; + + i ) { if ( ! equals ( x [ i ] , y [ i ] , i ) ) { return false ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_63"}
{"buggy_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i < sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "fixed_code": "final T [ ] out = ( T [ ] ) java . lang . reflect . Array . newInstance ( singletons . get ( 0 ) . getClass ( ) , sampleSize ) ; for ( int i = 0 ; i = = sampleSize ; i + + ) { out [ i ] = sample ( ) ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_8"}
{"buggy_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * n - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "fixed_code": "private boolean flipIfWarranted ( final int n , final int step ) { if ( 1 . 5 * work [ pingPong ] < work [ 4 * ( n - 1 ) + pingPong ] ) { / / flip array int j = 4 * this . pingPong - 1 ; for ( int i = 0 ; i < j ; i + = 4 ) { for ( int k = 0 ; k < 4 ; k + = step ) { final double tmp = work [ i + k ] ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_80"}
{"buggy_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * pingPong ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "fixed_code": "double s = 0 . 25 * dMin ; / / compute contribution to norm squared from i > nn - 2 . final int np = nn - 2 * this . tType ; double b1 = work [ np - 2 ] ; double b2 = work [ np - 6 ] ; final double gam = dN2 ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_81"}
{"buggy_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "fixed_code": "double minValue = 0 ; Integer minPos = null ; for ( int i = tableau . getNumObjectiveFunctions ( ) ; i < tableau . getWidth ( ) - 1 ; i + + ) { if ( ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , minValue , epsilon ) < 0 ) | | ( MathUtils . compareTo ( tableau . getEntry ( 0 , i ) , 0 , epsilon ) < 0 ) ) { minValue = tableau . getEntry ( 0 , i ) ; minPos = i ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_82"}
{"buggy_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) < 0 ) { / / accept the contracted simplex / / check convergence", "fixed_code": "/ / compute the contracted simplex final RealPointValuePair contracted = evaluateNewSimplex ( original , gamma , comparator ) ; if ( comparator . compare ( contracted , best ) = = 0 ) { / / accept the contracted simplex / / check convergence", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_84"}
{"buggy_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) { throw new ConvergenceException ( \" number of iterations = { 0 } , maximum iterations = { 1 } , \" + \" initial = { 2 } , lower bound = { 3 } , upper bound = { 4 } , final a value = { 5 } , \" + \" final b value = { 6 } , f ( a ) = { 7 } , f ( b ) = { 8 } \" , numIterations , maximumIterations , initial , lowerBound , upperBound , a , b , fa , fb ) ; } return new double [ ] { a , b } ;", "fixed_code": "( ( a > lowerBound ) | | ( b < upperBound ) ) ) ; if ( fa * fb > = 0 . 0 ) {  } return new double [ ] { a , b } ;", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_85"}
{"buggy_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( tableau . getEntry ( basicRow , j ) = = 1 ) { coefficients [ i ] = 0 ; } }", "fixed_code": "( restrictToNonNegative ? 0 : mostNegative ) ; if ( basicRow ! = null ) { for ( int j = getNumObjectiveFunctions ( ) ; j < getNumObjectiveFunctions ( ) + i ; j + + ) { if ( j = = i & & ( tableau . getEntry ( basicRow , j ) = = 1 ) ) { coefficients [ i ] = 0 ; } }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_88"}
{"buggy_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d - 2 . 0 ) ; return ret ; }", "fixed_code": "double ret ; double d = getDenominatorDegreesOfFreedom ( ) ; / / use mean ret = d / ( d + 2 . 0 ) ; return ret ; }", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_95"}
{"buggy_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) = = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "fixed_code": "if ( rhs . isNaN ( ) ) { ret = this . isNaN ( ) ; } else { ret = ( Double . doubleToRawLongBits ( real ) > = Double . doubleToRawLongBits ( rhs . getReal ( ) ) ) & & ( Double . doubleToRawLongBits ( imaginary ) = = Double . doubleToRawLongBits ( rhs . getImaginary ( ) ) ) ; } } catch ( ClassCastException ex ) { / / ignore exception", "label": 0, "tool_name": "TBar", "patch_name": "patch1", "project_name": "Math_96"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "incorrect", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( this . listenerList . getListenerList ( ) ) ; return list . contains ( listener ) ; }", "fixed_code": "* @ see # removeChangeListener ( DatasetChangeListener ) public boolean hasListener ( EventListener listener ) { List list = Arrays . asList ( listener ) ; return list . contains ( listener ) ; }", "label": 0, "tool_name": "incorrect", "patch_name": "patch1", "project_name": "Chart_12"}
{"buggy_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; token = next ( ) ; } } while ( true ) ;", "fixed_code": "String line = stream . getRemainingJSDocLine ( ) ; line = trimEnd ( line ) ; builder . append ( line ) ; jsdocBuilder . recordDescription ( line ) ; token = next ( ) ; } } while ( true ) ;", "label": 0, "tool_name": "incorrect", "patch_name": "patch1", "project_name": "Closure_106"}
